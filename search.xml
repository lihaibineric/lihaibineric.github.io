<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【多智能体强化学习】基于自动分组的价值函数分解</title>
    <url>/2023/11/22/MARL_%E8%87%AA%E5%8A%A8%E5%88%86%E7%BB%84/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>
<h2 id="automatic-grouping-for-marl">Automatic Grouping for MARL</h2>
<p>论文标题：</p>
<p><strong>《Vast: Value function factorization with variable agent
sub-teams》</strong></p>
<p><strong>《Automatic Grouping for Efficient Cooperative Multi-Agent
Reinforcement Learning》</strong></p>
<p>论文代码：<a
href="https://github.com/zyfsjycc/GoMARL">https://github.com/zyfsjycc/GoMARL</a></p>
<h2 id="价值函数分解">价值函数分解</h2>
<p>价值函数的提出是为了缓解在传统的中心化训练和去中心化执行中的Critic网络出现的难以训练的问题，同时传统的合作型多智能体强化学习的方法难以解决信用分配的问题，即如何确定某个智能体<strong>对于全局任务而言的贡献程度</strong>。</p>
<h4 id="主体研究框架">主体研究框架：</h4>
<p><span class="math display">\[
Q_{tot} (τ,a)≈Ψ([Q_i (τ_i,a_i)]_{i=1}^N)
\]</span></p>
<p>目的就是学习到这样一个分解算子 <span
class="math inline">\(Ψ\)</span>，能够将局部的价值函数 <span
class="math inline">\(Q_i\)</span> 拟合成全局的价值函数 <span
class="math inline">\(Q_{tot}\)</span>，而这样的拟合过程学习到的分解算子<span
class="math inline">\(Ψ\)</span>应当满足以下的约束条件： <span
class="math display">\[
\underset{\boldsymbol{a}}{\arg \max } Q_{\text {tot
}}(\boldsymbol{\tau}, \boldsymbol{a})=\left(\begin{array}{c}
\operatorname{argmax}_{a_1} Q_1\left(\tau_1, a_1\right) \\
\vdots \\
\operatorname{argmax}_{a_N} Q_N\left(\tau_N, a_N\right)
\end{array}\right)
\]</span>
这个公式的本质是希望分解之后的局部和全局的最优动作能够最优一致，才能保证这样的算子分解方法是有效果的。</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122215614627.png"
alt="价值函数分解的基本思想" />
<figcaption aria-hidden="true">价值函数分解的基本思想</figcaption>
</figure>
<h2 id="可变子团队的价值函数分解">可变子团队的价值函数分解</h2>
<h4 id="研究动机">研究动机：</h4>
<ol type="1">
<li><strong>大部分</strong>价值函数方法对<strong>少量智能体</strong>的任务效果好</li>
<li><strong>VFF</strong>方法过于扁平，存在性能瓶颈，没有考虑群组之间的一个关系，比较朴素且直接</li>
<li>忽略智能体之间关系导致智能体训练信息不足</li>
</ol>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122202659835.png" alt="朴素的价值函数分解方法" style="zoom:60%;" /><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122202712624.png" alt="自动分组之后的价值函数分解方法" style="zoom:60%;" /></p>
<p>因此，为了能够缓解朴素的价值函数分解方法中的<strong>缺乏群组信息的缺陷</strong>，文中提出能够分组处理多智能体系统的工作VAST，能够动态处理群组划分的算子来给出基于分组的智能体价值函数方法。</p>
<h4 id="主要贡献">主要贡献：</h4>
<ol type="1">
<li>基于 <span class="math inline">\(K ≤ N = |D|\)</span>
的分解子团队值<span
class="math inline">\(Q_{t,k}^G\)</span>，线性分解每个子团队成员$jG_{t,k}⊆D
$ 局部值<span class="math inline">\(Q_j\)</span></li>
<li>提出了一种分解方式动态并随时间变化，同时保持VFF方法的去中心性执行的特点</li>
<li>提供了<strong>元梯度</strong>方法来优化子团队分组策略</li>
</ol>
<h4 id="实现方法">实现方法：</h4>
<h5 id="子团队分组策略">子团队分组策略：</h5>
<p>分组策略的本质是学习一个<strong>概率分布</strong><span
class="math inline">\(\mathcal{X}(k∣i,τ_(t,i),s_t
)\)</span>，概率分布的本质思想是能够通过每个智能体的状态以及历史数据信息给出智能体
<span class="math inline">\(i\)</span> 所在的组别 <span
class="math inline">\(k\)</span></p>
<h5 id="元梯度的更新方式">元梯度的更新方式：</h5>
<p><span class="math display">\[
𝑔=𝐴 ̂(𝑘,𝑖,𝜏_{𝑡,𝑖},𝑠_𝑡 ) ∇_𝜃 log⁡𝒳_{MetaGrad}  (𝑘∣𝑖,𝜏_{𝑡,𝑖},𝑠_𝑡 )
\]</span></p>
<ul>
<li>参考借鉴了强化学习的策略梯度更新的方式</li>
<li>在多智能体强化学习中利用<strong>强化学习</strong>的方法学习一个组别的分组器</li>
</ul>
<p><span class="math display">\[
𝐴 ̂(𝑘,𝑖,𝜏_{𝑡,𝑖},𝑠_𝑡 )=𝑄 ̂(𝑘,𝑖,𝜏_{𝑡,𝑖},𝑠_𝑡 )−𝑉 ̂(𝑖,𝜏_{𝑡,𝑖},𝑠_𝑡 )
\]</span></p>
<p><span class="math display">\[
𝑉 ̂(𝑖,𝜏_{𝑡,𝑖},𝑠_𝑡 )=∑_(𝑎_{𝑡,𝑖}∈𝒜_𝑖) 𝜋_𝑖 (𝑎_{𝑡,𝑖}∣𝜏_{𝑡,𝑖} ) 𝑄_𝑖
(𝜏_{𝑡,𝑖},𝑎_{𝑡,𝑖} )
\]</span></p>
<ul>
<li>策略梯度更新的方式是基于优势函数的方法进行更新分组器</li>
</ul>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122220849824.png"
alt="不同分类器的对比" />
<figcaption aria-hidden="true">不同分类器的对比</figcaption>
</figure>
<p>这里还采用了不同的分组器方法加入实验的对比</p>
<h5 id="算法思路">算法思路</h5>
<ul>
<li><p>将D 分成<span class="math inline">\(K= ⌈ηN⌉≤ N =
|D|\)</span>个子团队<span class="math inline">\(G_{t,k}\)</span>
其中比例<span class="math inline">\(η ∈ [
1⁄N,1]\)</span>，所有的团队集合 <span
class="math inline">\(G_t=⟨G_{t,1},…,G_{t,K} ⟩\)</span>，</p></li>
<li><p>分组：<span class="math inline">\(G_{t,k}⊆D,G_{t,k}∩G_{t,k′}=∅
;D=U_{k=1}^K  G_{t,k}\)</span></p></li>
<li><p>组内联合动作：<span class="math inline">\(a_{t,k}^G=a{t,j}
_j∈G_{t,k}\)</span></p></li>
<li><p>选择<span
class="math inline">\(Ψ_{VDN}\)</span>算子分解(满足IGM)：</p>
<p><span class="math display">\[
Q_{t,k}^G (τ_{t,k}^G,a_{t,k}^G )=Ψ_{VDN} (⋅)=∑_{j∈G_{t,k}} Q_j
(τ_{t,j},a_{t,j})
\]</span></p></li>
<li><p>最终的全局联合价值函数近似：</p></li>
</ul>
<p><span class="math display">\[
Q_{tot} (τ_t,a_t )=Ψ(Q_{t,1}^G (τ_{t,1}^G,a_{t,1}^G ),…,Q_{t,K}^G
(τ_{t,K}^G,a_{t,K}^G ))
\]</span>
<img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122221728761.png" alt="可变子团队的伪代码" style="zoom:67%;" /></p>
<h5 id="igm条件保持">IGM条件保持</h5>
<p>如果以群组为单位的价值函数分解的方式能够保证IGM条件： <span
class="math display">\[
argmax_(𝑎_{𝑡,𝑘}^𝐺∈𝒜)⁡〖𝑄_{tot}(𝜏_𝑡,𝑎_𝑡)〗=
⟨argmax_(⟨𝐚_{𝐭,𝐤}^𝐆 ⟩_(𝐺_{𝑡,𝑘}∈𝒢_𝑡 ))⁡𝑄_{𝑡,𝑘}^𝐺 (𝜏_{𝑡,𝑘}^𝐺,𝑎_{𝑡,𝑘}^𝐺
)⟩_(𝐺_{𝑡,𝑘}∈𝒢_𝑡)
\]</span> 希望能够满足对于局部智能体到全局价值函数的IGM条件的保持 <span
class="math display">\[
argmax_(𝑎_𝑡∈𝒜)⁡𝑄_{tot}(𝜏_𝑡,𝑎_𝑡 )=
⟨argmax_(𝑎_{𝑡,𝑖}∈𝒜_𝑖 )⁡𝑄_𝑖 (𝜏_{𝑡,𝑖},𝑎_{𝑡,𝑖})⟩_(𝑖∈𝒟)
\]</span> 推导过程如下： <span class="math display">\[
\begin{aligned}
&amp; Q_{t, k}^G\left(\tau_{t, k}^G, a_{t, k}^G\right)=\sum_{j \in G_{t,
k}} Q_j\left(\tau_{t, j}, a_{t, j}\right) ; \operatorname{argmax}_{a_t
\in G_{t, k}} Q_{t, k}^G\left(\tau_{t, k}^G, a_{t,
k}^G\right)=\left\langle\operatorname{argmax}_{a_{t, i} \in
\mathcal{A}_i} Q_i\left(\tau_{t, i}, a_{t, i}\right)\right\rangle_{i \in
G_{t, k}} \\
&amp; a_t \stackrel{\Psi}{=}\left\langle a_{t, k}^G\right\rangle_{G_{t,
k} \in \mathcal{G}_t} \stackrel{\Psi_{V D
N}}{=}\left\langle\left\langle\bar{a}_{t, i}\right\rangle_{i \in G_{t,
k}}\right\rangle_{G_{t, k} \in \mathcal{G}_t}
\stackrel{\mathcal{D}=G_{t, 1} \cup \cdots \cup G_{t,
K}}{=}\left\langle\bar{a}_{t, i}\right\rangle_{i \in \mathcal{D}}
\end{aligned}
\]</span></p>
<h2 id="自适应分组的marl">自适应分组的MARL</h2>
<h4 id="研究动机-1">研究动机</h4>
<ul>
<li>通过任务分配实现隐式分组的方法仅解决结构清晰的任务，并且需要领域知识或先验设置</li>
<li>VAST 研究子团队对价值分解的影响，但需要先验的组数，ROMA
的学习依赖于智能体观察的动态角色</li>
</ul>
<h4 id="gomarl算法的优势">GoMARL算法的优势</h4>
<ul>
<li>算法不依赖先验领域知识</li>
<li>动态调整：在分组学习过程中根据智能体的表现<strong>逐步调整</strong>分组划分。利用<strong>群体信息</strong>来促进策略专业化和高效的团队合作</li>
</ul>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122222736852.png" alt="引入群组划分板块的分解方法" style="zoom:67%;" /></p>
<h4 id="个体与群组关系假设">个体与群组关系假设</h4>
<ul>
<li><strong>所有智能体集合：</strong><span
class="math inline">\(A={a_1,…,a_n }\)</span></li>
<li><strong>分组集合</strong>: <span class="math inline">\(G={g_1,…,g_m
}，1≤m≤n\)</span></li>
<li>每个<span
class="math inline">\(g_i\)</span><strong>包含</strong><span
class="math inline">\(n_j
(1≤n_j≤n)\)</span><strong>个不同的智能体，有</strong><span
class="math inline">\(g_i={a_(j_1 ),…,a_(j_(n_j )
)}\)</span>，<strong>且有</strong><span
class="math inline">\(g_j∩g_k=∅\)</span>，<strong>且有</strong><span
class="math inline">\(⋃_jg_j =A，j,k∈{1,2,…,m}\)</span></li>
</ul>
<h4 id="自动分组实现方法">自动分组实现方法</h4>
<p>自动分组的基本逻辑是学习<span
class="math inline">\(f_g:A↦G\)</span>，这样的算子的目标是能够学习到系数权重
<span class="math display">\[
Q_G^{tot} (s_t,u_t )=E_(s_{t+1:∞},u_{t+1:∞} ) [∑_(k=0)^∞ γ^k
r_{t+k}∣s_t,u_t;G]
\]</span> 让总体的联合动作价值函数的值最大，分组的价值函数为： <span
class="math display">\[
𝑄^{𝑔_𝑗}=𝑓(𝑄^{𝑗_1} (𝜏^{𝑗_1},𝑢^{𝑗_1}),⋯,𝑄^{𝑗_{𝑛_𝑗}} (𝜏^{𝑗_(𝑛_𝑗
)},𝑢^{𝑗_{𝑛_𝑗}};𝑤_1^{𝑔_𝑗})
\]</span> 学习到的贡献程度为：<span
class="math inline">\(𝑤_1^{𝑔_𝑗}\)</span>，训练的目标函数为： <span
class="math display">\[
ℒ_𝑔 (𝜃_{w_1})=𝔼_((𝐳,𝐮,𝑟,𝐳′)∼ℬ∑_𝑖(∥𝑓_(w_1)^𝑖 (𝜏^𝑖 (𝑧^𝑖,𝑢^𝑖 );𝜃_(w_1)^𝑖
)∥_{𝑙_1})
\]</span>
根据每次在分组中的贡献权重来依次调整智能体的分组，当贡献的权重过小的话，就认为智能体不属于分组中，进入下一轮的分组调整中。</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122223325635.png"
alt="自动分组的逻辑图" />
<figcaption aria-hidden="true">自动分组的逻辑图</figcaption>
</figure>
<h4 id="section"></h4>
<h4 id="agent-network的优化">Agent Network的优化</h4>
<ul>
<li><p>智能体内嵌信息网络获取的群组相关信息<span
class="math inline">\(e_i\)</span></p></li>
<li><p><strong>Similarity-Diversity
objective</strong>：来自同一组的智能体的信息是相似的，来自不同群体的智能体信息之间保持多样性：
<span class="math display">\[
\begin{gathered}
\mathcal{L}_{S
D}\left(\theta_e\right)=\mathbb{E}_{\mathcal{B}}\left(\sum_{i \neq j}
I(i, j) \cdot \operatorname{cosine}\left(f_e\left(h^i ; \theta_e\right),
f_e\left(h^j ; \theta_e\right)\right)\right) \\
\text { where } I(i, j)=\left\{\begin{array}{cc}
-1, &amp; a^i, a^j \in g^k \\
1, &amp; a^i \in g^k, a^j \in g^l, k \neq l
\end{array}\right.
\end{gathered}
\]</span>
很直观的理解，对于合作型的强化学习任务而言，我们希望能够在同一个任务域内强化策略的合作，而不同的任务域内的策略应当保持多样性，能够让多智能体系统探索更多的可能性，防止陷入局部最优的情况。</p></li>
<li><p><strong>Agent Network特点</strong>：</p>
<ul>
<li>多样化的策略，部分共享参数的策略去中心化</li>
<li>超网络<span
class="math inline">\(f_d\)</span>将提取的智能体信息e集成到策略梯度中</li>
</ul></li>
<li><p>合理性表示： <span class="math display">\[
𝜕𝑄^{𝑡𝑜𝑡}/(𝜕𝜃_ℎ )=(𝜕𝑄^{𝑡𝑜𝑡})/(𝜕𝑄^𝑎 )  (𝜕𝑄^𝑎)/(𝜕𝜃_ℎ )=(𝜕𝑄^{𝑡𝑜𝑡})/(𝜕𝑄^𝑎
)  (𝜕𝑄^𝑎)/(𝜕𝑣_ℎ^𝑎 )  (𝜕𝑣_ℎ^𝑎)/(𝜕𝜃_ℎ )=𝑓_𝑑 (𝑒^𝑎 )⋅(𝜕𝑄^{𝑡𝑜𝑡})/(𝜕𝑄^𝑎
)  (𝜕𝑣_ℎ^𝑎)/(𝜕𝜃_ℎ )
\]</span></p></li>
</ul>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122225119182.png" alt="Agent Network优化方式" style="zoom:67%;" /></p>
<h4 id="整体的训练框架">整体的训练框架</h4>
<h6 id="双层混合网络">双层混合网络</h6>
<ul>
<li><p>群体状态下的群体行动价值信息，将全局的状态分解成局部的状态信息用于训练，这部分的局部状态信息是基于群组划分之后的状态信息</p></li>
<li><p><span class="math inline">\(s^{g_j}\)</span> 是分组后<span
class="math inline">\(e_t^i (a_i∈g_j
)\)</span>按组别融合，建立分组器映射</p>
<p><span class="math display">\[
f_{w_2}(s^g )：s^g→w_2^g
\]</span></p></li>
<li><p>集中到策略梯度中，内嵌群组状态信息潜在促进组内合作： <span
class="math display">\[
𝜕𝑄^{𝑡𝑜𝑡}/(𝜕𝜃_ℎ )=(𝜕𝑄^{𝑡𝑜𝑡})/(𝜕𝑄^𝑎 )  (𝜕𝑄^𝑎)/(𝜕𝜃_ℎ )=(𝜕𝑄^{𝑡𝑜𝑡})/(𝜕𝑄^𝑎
)  (𝜕𝑄^𝑎)/(𝜕𝑣_ℎ^𝑎 )  (𝜕𝑣_ℎ^𝑎)/(𝜕𝜃_ℎ )=𝑓_𝑑 (𝑒^𝑎 )⋅(𝜕𝑄^{𝑡𝑜𝑡})/(𝜕𝑄^𝑎
)  (𝜕𝑣_ℎ^𝑎)/(𝜕𝜃_ℎ )
\]</span></p></li>
<li><p>按照全文的总共方法的总述可以得到全局分解目标： <span
class="math display">\[
ℒ(𝜃)=ℒ_𝑇𝐷 (𝜃)+𝜆_𝑔 ℒ_𝑔 (𝜃_(w_1 ) )+𝜆_𝑆𝐷 ℒ_𝑆𝐷 (𝜃_𝑒 )
\]</span></p></li>
</ul>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122225354328.png"
alt="总体训练框架" />
<figcaption aria-hidden="true">总体训练框架</figcaption>
</figure>
<h4 id="实验结果">实验结果</h4>
<p>在星际争霸的环境中的训练结果</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122225759954.png"
alt="SMAC训练结果" />
<figcaption aria-hidden="true">SMAC训练结果</figcaption>
</figure>
<p>消融实验</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122225941711.png"
alt="消融实验对比" />
<figcaption aria-hidden="true">消融实验对比</figcaption>
</figure>
<p>谷歌足球的训练结果</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122225826734.png"
alt="GRF的训练结果与可视化" />
<figcaption aria-hidden="true">GRF的训练结果与可视化</figcaption>
</figure>
]]></content>
      <categories>
        <category>强化学习</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>深度学习</tag>
        <tag>强化学习</tag>
      </tags>
  </entry>
  <entry>
    <title>【自动驾驶】RSS Model for Autonomous Driving</title>
    <url>/2023/10/21/RSS-Model/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>
<h2 id="rss-model-for-autonomous-driving"><strong>RSS Model for
Autonomous Driving</strong></h2>
<h4
id="论文on-a-formal-model-of-safe-and-scalable-self-driving-cars">论文：《On
a Formal Model of Safe and Scalable Self-driving Cars》</h4>
<h4 id="contribution"><strong>Contribution：</strong></h4>
<ul>
<li>Safety (RSS model) Reasonable care, Responsibility, agile driving
policy</li>
<li>Semantic (Semantic language) :Defined Q function over the Semantic
space</li>
<li>PAC sensing model：Safety and Comfort of driving ；tied to the Q
function;</li>
</ul>
<h4 id="safety-concept"><strong>1. Safety Concept</strong></h4>
<p>Functional versus nominal safety 功能安全与名义安全</p>
<p>Functional Safety，FuSa 是指电子电路中操作的完整性</p>
<p>名义安全是在假设HW和SW系统运行无差错(即在功能上是安全的)的情况下，AV是否正在做出安全的逻辑决策。</p>
<p>Sense，Plan，Act 感知 计划 行动</p>
<h4 id="现有的自动驾驶汽车的决策方案"><strong>2.
现有的自动驾驶汽车的决策方案</strong></h4>
<ul>
<li>Miles driven ：基于统计的论点，同时需要较大的统计量数据</li>
<li>disengagements（脱离）：被定义为人类安全驾驶人因为做出不安全的决定而不得不干预AV的运行，从而导致事故的情况。</li>
<li>simulation：建立虚拟世界模拟器，模拟器和显示世界的差距，无法建模全部的策略</li>
<li>scenario based testing
：枚举现实世界的驾驶场景，过度拟合和泛化的问题</li>
<li>proprietary approaches</li>
</ul>
<h4
id="rssresponsibility-sensitive-safety-model-for-multi-agent-safety"><strong>3.
RSS(Responsibility-Sensitive-Safety) Model for Multi-agent
Safety</strong></h4>
<ul>
<li><p>目标：</p>
<ul>
<li>做不到绝对安全，需要有Reasonable的响应</li>
<li>遵循RSS能做到乌托邦Utopia</li>
<li>敏捷而非防御，不应当过于谨慎而影响其他驾驶</li>
<li>法律解释的意义</li>
</ul></li>
<li><p>形式化的规则：</p>
<ol type="1">
<li>Do not hit someone from behind.</li>
<li>Do not cut-in recklessly.</li>
<li><strong>Right-of-way is given, not taken.</strong>
道路通行权是给予的而不是占用的</li>
<li>Be careful of areas with limited visibility
小心有限可视化的范围</li>
<li>If you can avoid an accident without causing another one, you must
do it.</li>
</ol></li>
</ul>
<h5 id="single-land-road-单向道路的情况"><strong>3.1 Single Land Road
单向道路的情况</strong></h5>
<ul>
<li><p>不考虑前车倒退的情况，后车撞上前车那么后车负责，后车有责任和前车保持距离</p></li>
<li><p><span class="math inline">\(c_r\)</span>表示前车，<span
class="math inline">\(c_f\)</span>表示后车，<span
class="math inline">\(\rho\)</span>表示的是前车的反应时间，<span
class="math inline">\(a_{max,break}\)</span>表示的是前车的最大加速度，<span
class="math inline">\(a_{max,accel}\)</span>表示的是最多的加速制动，<span
class="math inline">\(a_{min,break}\)</span>表示的是后车的最小制动加速度来保证不会撞到前车</p></li>
<li><p><strong>同方向行驶</strong>的安全距离</p>
<p>给出最小的安全纵向距离： <span class="math display">\[
d_{min}=max\{v_r\rho+1/2a_{max,accel}\rho^2+((v_r+\rho
a_{max,accel})^2)/2a_{min,break}-v_f^2/2a_{max,break},0\}
\]</span></p></li>
<li><figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915172320331.png"
alt="Definition 1" />
<figcaption aria-hidden="true">Definition 1</figcaption>
</figure></li>
<li><p><span class="math inline">\(t_b\)</span> dangerous time；<span
class="math inline">\([t_b,t_b+\rho]\)</span> 表示一定的反应时间
在这个范围之内在给定的加速度范围之内 执行proper response</p></li>
<li><p>Proper Response
：表示我们允许执行的最大加速度的限制，并取最小值约束保证满足所有的约束</p></li>
<li><p>安全纵向距离和Proper Response取决于参数：<span
class="math inline">\(\rho,a_{max,sccel},a_{min,brake},a_{max,brake}\)</span>
参数保证了对智能体行为的假设，选择适当的参数</p></li>
<li><p>Utopia is possible
如果所有智能体车辆都能够遵循合理的响应，那么能归纳证明可以规避事故的发生</p></li>
</ul>
<h5 id="a-lane-based-coordinate-system-基于车道的坐标系"><strong>3.2 A
Lane-Based Coordinate System 基于车道的坐标系</strong></h5>
<ul>
<li><p>车道中心是平面上一条平滑有向的曲线 <span
class="math inline">\(r\)</span> ,其中所有部分可以表示为 <span
class="math inline">\(r^{(1)},...,r^{(k)}\)</span>
即可以是线性的，也可以是弧形的</p></li>
<li><p>构造 <span class="math inline">\(R-&gt;R^2\)</span>的变换为 <span
class="math inline">\(\phi\)</span>
就是横纵坐标，从而来保证在逻辑上的前后车辆的关系</p></li>
<li><p>具体的映射的方式可以表示为如下：</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915172406204.png"
alt="道路映射的方式" />
<figcaption aria-hidden="true">道路映射的方式</figcaption>
</figure></li>
<li><p>横纵速度/加速度
的计算就可以通过这样的坐标系定义之下得到的一阶/二阶的导数计算得到</p></li>
</ul>
<h5
id="longitudinal-safe-distance-and-proper-response-纵向约束"><strong>3.3
Longitudinal Safe Distance and Proper Response 纵向约束</strong></h5>
<ul>
<li><p>给出安全距离的定义：</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915172437378.png"
alt="Definition 2" />
<figcaption aria-hidden="true">Definition 2</figcaption>
</figure>
<p>安全距离定义的想法是，如果两辆车都能对违反安全距离的行为做出“适当”反应，那么就不会发生碰撞。如果其中一个没有“正确”反应，那么它就应对事故负责。</p></li>
<li><p>那么我们需要知道危险发生的时间，定义这样一个时刻<strong>Dangerous
Longitudinal Situation and Danger Threshold</strong></p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915172501683-20231022115917321.png"
alt="真正的危险时间" />
<figcaption aria-hidden="true">真正的危险时间</figcaption>
</figure>
<p>给定一个纵向的危险发生的时间段</p></li>
<li><p><strong>longitudinal proper response 纵向的适当响应</strong></p>
<p>blame time
责任时间表示的是这个时间能够将驾驶的责任从自动驾驶汽车转移到驾驶员身上，如果接管了那么后续的责任将由驾驶员负责，否则由汽车负责</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915172514045-20231022115917843.png"
alt="Definition 4" />
<figcaption aria-hidden="true">Definition 4</figcaption>
</figure>
<p>给出了对于纵向单向行驶而言的速度和加速的要求，需要在危险到来之前做出合理的响应</p></li>
</ul>
<h5
id="lateral-safe-distance-and-proper-response-横向的约束"><strong>3.4
Lateral Safe Distance and Proper Response 横向的约束</strong></h5>
<ul>
<li><p>稳健侧向速度 <span
class="math inline">\(\mu\)</span>：汽车总是存在横向的一个微小摆动:
<span class="math display">\[
\mu-lateral-v=(l_{out}-l)/(t_{out}-t)
\]</span></p></li>
<li><p>横向安全距离：</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915172633796.png"
alt="Definition 6" />
<figcaption aria-hidden="true">Definition 6</figcaption>
</figure>
<p>对于双方而言都有一个加速度，同时有一个最小的制动加速度</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915172648760.png"
alt="Lemma 4" />
<figcaption aria-hidden="true">Lemma 4</figcaption>
</figure></li>
<li><p>同样定义横向的危险时间和危险区间时间：</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173056976-20231022115918644.png"
alt="Definition 7" />
<figcaption aria-hidden="true">Definition 7</figcaption>
</figure></li>
<li><p><strong>Lateral Proper response 给出横向的适当反应</strong></p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173119252.png"
alt="Definition 8" />
<figcaption aria-hidden="true">Definition 8</figcaption>
</figure>
<p>首先如果在适当的响应时间范围之内，那么只需要限制两车的加速度在一定的范围之内</p>
<p>如果超出了适当响应时间，那么对于两车的加速度限制需要更改</p></li>
</ul>
<h5
id="combining-longitudinal-and-lateral-proper-responses-横向和纵向相结合"><strong>3.5
Combining Longitudinal and Lateral Proper Responses
横向和纵向相结合</strong></h5>
<ul>
<li><p>对于横向和纵向结合的车道，定义危险时间和危险情况</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173150615.png"
alt="Defintion 9" />
<figcaption aria-hidden="true">Defintion 9</figcaption>
</figure></li>
<li><p>危险阈值时间定义为横向和纵向的危险阈值时间的最大值，同样定义了危险时间t</p></li>
<li><p><strong>Basic Proper response to dangerous situations
对于危险情况的正确反应处理</strong></p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173218415.png"
alt="Definition 10" />
<figcaption aria-hidden="true">Definition 10</figcaption>
</figure>
<p>对于危险的阈值速度进行分析，如果分别为纵向的阈值速度和横向的阈值速度，那么分别根据前面所述的Definition
4和Definition 8 进行速度的限制</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173251798-20231022115919728.png" alt="横向纵向情况" style="zoom:50%;" /></p>
<p>上面的这张图可以说明问题，当横纵的任意一个方向到达危险的阈值情况，分别作出Proper
Response，那么就可以按照合理的方式来规避风险</p></li>
<li><p><strong>Lemma5 Utopia is possible</strong></p>
<p>Consider a multi-lane road where all lanes share the same geometry.
Suppose that at all times, all cars on the road comply with the basic
proper response as given in Definition 10. Then, there will be
<strong>no collisions</strong></p>
<p>归纳证明说明如果在合适的范围之内作出合理的响应，那么能规避碰撞</p></li>
</ul>
<h5
id="compensating-for-improper-behavior-of-others-他人的不正当行为"><strong>3.6
Compensating for improper behavior of others
他人的不正当行为</strong></h5>
<ul>
<li><p>如果对方没做出合理反应，那么自己应当作出合适反应避免发生事故，同时不引起下一个事故</p></li>
<li><p>Naive Prediction：根据速度和加速度线性外推</p></li>
<li><p>Evasive
Manoeuvre：给出两个函数来尽量规避出现车祸，就是根据时间来给速度和加速度的变化规划</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173348421.png"
alt="Definition 12" />
<figcaption aria-hidden="true">Definition 12</figcaption>
</figure>
<p>相当于给出两个函数来知道汽车应当在某个时间范围内到达什么样的位置是安全的，那么要达到这样的位置汽车要采取什么样的速度和加速度来实现</p>
<p><strong>if you can avoid an accident without causing another
accident, you must do it</strong></p></li>
</ul>
<h5
id="proper-response-with-extra-evasive-effort-制动规避的适当反应"><strong>Proper
Response with Extra Evasive Effort 制动规避的适当反应</strong></h5>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173422047-20231022115920481.png"
alt="Definition 13" />
<figcaption aria-hidden="true">Definition 13</figcaption>
</figure>
<h5
id="multiple-geometry-and-right-of-way-rules处理几何图形区域的车辆优先权问题"><strong>3.7
Multiple Geometry and Right-of-Way
Rules处理几何图形区域的车辆优先权问题</strong></h5>
<ul>
<li><p>如果有存在不同的几何形状的情形会导致响应的冲突</p></li>
<li><p>定义横向的安全距离对于<strong>不同的几何路径</strong>对于相同的几何路径仍然成立</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173615571.png"
alt="Definition14" />
<figcaption aria-hidden="true">Definition14</figcaption>
</figure>
<p>向位置范围为[x_i,min,
x_i,max]，按照不同的加速度行驶，且不能超过指定的加速度制动那么，则c_1和c_2之间的横向安全距离需要满足：<strong>两车之间横向距离的最小值应大于Definition7中定义的横向安全距离</strong></p></li>
<li><p>那么如何作出适当的反应 Proper response，给出合适的速度约束</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173634068-20231022115921111.png"
alt="横向的合适响应" />
<figcaption aria-hidden="true">横向的合适响应</figcaption>
</figure>
<p>在反应时间之内可以按照加速度范围内进行移动，但是当超过反应时间之后就要对侧向的速度进行制动</p></li>
<li><p>定义不同几何路况的纵向的顺序</p>
<ul>
<li><figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173650265-20231022115921291.png"
alt="路况优先权问题" />
<figcaption aria-hidden="true">路况优先权问题</figcaption>
</figure>
<p>如果在同一条路上那么直接有先后顺序</p>
<p>如果不在同一条路上，那么根据车辆距离两条道路的相交的位置来定</p>
<p>当存在纵向的安全距离才会用到这个定义，同时应当是明显的前后顺序</p></li>
</ul></li>
<li><p>纵向的安全距离（不同的几何路径）</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173703808-20231022115921710.png"
alt="Definition 17" />
<figcaption aria-hidden="true">Definition 17</figcaption>
</figure>
<ol type="1">
<li>如果c_i没有路径的优先级，那么将在路口汇入的位置执行加速到减速的过程停在路口</li>
<li>如果c_1在c_2前面，c_1执行任意动作（最大刹车加速度的意思是保证这个动作的距离下限），c_2执行最大加速-最小减速过程。当两车速度都为0时，c_1仍然在c_2前面（即后车要刹得住，当前车停下时，纵向顺序关系依然能保持）</li>
<li>如果没有优先级和前后关系，则考虑两车到达路口的时间范围，如果两者时间范围相交，则有碰撞风险，都需要刹车，反之就正常走。</li>
</ol>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173722252.png"
alt="示意图" />
<figcaption aria-hidden="true">示意图</figcaption>
</figure></li>
<li><p>纵向的安全响应（Proper response）</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173840619.png"
alt="Definition18" />
<figcaption aria-hidden="true">Definition18</figcaption>
</figure>
<ol type="1">
<li>longitudinal proper response取决于Danger Threshold
Time前的situation：</li>
<li>如果17.1满足，则优先车辆正常开，另外一个则需要在反应时间后刹车。</li>
<li>如果17.2满足，则前面车辆正常开，候车需要在反应时间后刹车。</li>
<li>如果17.3满足，两车都需要在横向和纵向上刹车（这里又提到了横向，是纵向已经不能完全规避碰撞风险，所以需要引入横向动作）。</li>
</ol></li>
<li><p>Traffic Lights</p>
<ol type="1">
<li>不能简单通过红绿灯的情况来将责任分配给不同的车辆，对于例外的路口的车辆</li>
<li>绿灯的有优先权 但不是有优先权的就对于规则而言没有责任</li>
<li>The above discussion is a formalism of the common sense rule of
<strong>right of way is given, not taken.</strong></li>
</ol></li>
</ul>
<h5 id="unstructured-road-非结构化的道路"><strong>3.8 Unstructured Road
非结构化的道路</strong></h5>
<ol type="1">
<li><figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173851532-20231022115922491.png"
alt="Definition 19" />
<figcaption aria-hidden="true">Definition 19</figcaption>
</figure>
<p>轨迹这个表示了根据时间而改变的位置状态，ts的定义就表示车辆第一次完全停止的时间</p>
<p><strong>未来某部分时刻汽车的位置、某个时间车辆的角度</strong></p></li>
<li><figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173902698-20231022115922745.png"
alt="Definition20" />
<figcaption aria-hidden="true">Definition20</figcaption>
</figure>
<p>当两车的轨迹不满足以下条件时，则称会发生碰撞：</p>
<p>（1）对于两车均停止之前的任意时刻，两车之间距离均大于epsilon。</p>
<p>（2）在某车停车之前，两车之前距离均大于epsilon，且此时第二辆车的速度矢量指向第一辆车。即当前车停车，后车依然往前车方向开，后车需要与前车保持距离。</p></li>
<li><figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173913570.png"
alt="Definition 21" />
<figcaption aria-hidden="true">Definition 21</figcaption>
</figure>
<p>定义Constrains（C）下的轨迹T(C,
c)，刹车/正常向前行驶的轨迹分别表示为T(Cb, c)和T(Cf,c).</p></li>
<li><figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173936523.png"
alt="Definition 22" />
<figcaption aria-hidden="true">Definition 22</figcaption>
</figure>
<ol type="1">
<li>其中一辆车的刹车轨迹和另一辆车的前进轨迹不相交，那么安全（注意保持先后关系对两辆车都适用）</li>
<li>两辆车都刹车，轨迹没有相交</li>
</ol></li>
<li><p>如果不满足安全的要求，那么应当选择Proper Response：</p>
<ol type="1">
<li>如果两辆车都停着，那么其中一辆车应当远离另一辆车选择用Definition
20的方法远离</li>
<li>否则，如果根据safe
distance(1)的定义是安全的，一辆车执行刹车，另一辆车在停下来之前就要按照Cf的轨迹正常开，都停下来之后就回到了（1）</li>
<li>同时选择刹车</li>
</ol></li>
</ol>
<h5 id="pedestrians-行人"><strong>3.9 Pedestrians 行人</strong></h5>
<ul>
<li><p>安全距离和合理反应；和汽车相比调整参数且增加非结构化的假设</p></li>
<li><p>在斑马线或者是人行道上规定行人的行为，行人的合理活动范围是一个以他为圆心的圆</p></li>
<li><p>遵循互不干扰否则有责任的准则，当汽车进入行人的可能出事的范围那么
汽车有责，否则行人有责任</p></li>
</ul>
<h5 id="cautiousness-with-respect-to-occlusion-遮挡问题"><strong>3.10
Cautiousness with respect to Occlusion 遮挡问题</strong></h5>
<ul>
<li><p>Exposure Time 曝光时间：第一次看到这个物体的时间</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173954765-20231022115923512.png"
alt="Definition23" />
<figcaption aria-hidden="true">Definition23</figcaption>
</figure></li>
<li><p><strong>速度不合理导致的不合理情况</strong>：</p>
<p>相当于速度的范围不在给定的合理的区间。
上述提到的参数和地图上的每个汽车的位置、优先级规则和其他的场景结构等条件相关联</p>
<ol type="1">
<li><p>具有道路优先级的汽车的最大速度优先级较高</p></li>
<li><p>速度的阈值范围根据具体的道路结构</p></li>
</ol>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915174217869.png"
alt="遮挡示意图" />
<figcaption aria-hidden="true">遮挡示意图</figcaption>
</figure></li>
</ul>
<p>相当于对于遮挡问题需要对双方的车辆有速度限制才能保证危险的发生</p>
<h5 id="不当行为造成的不合理的情况"><strong>3.11
不当行为造成的不合理的情况</strong></h5>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915174242726.png"
alt="Definition 25" />
<figcaption aria-hidden="true">Definition 25</figcaption>
</figure>
<p>对于出现遮挡的参与者都要保持合理的行为才能规避事故</p>
<p><strong>对于有遮挡的正确响应方法</strong>：规避不合理的情况，包括但不限于24-25的</p>
<h5 id="responsibility"><strong>3.12 Responsibility</strong></h5>
<ul>
<li>明确智能体责任</li>
<li>发生碰撞那么有可能是其中一个智能体没有遵守适当的响应约束，那么需要对事故负责</li>
</ul>
<h5 id="utopia">3.13 Utopia</h5>
<ul>
<li>Lemma 5证明如果所有汽车都遵循基本的响应规则，那么不会发生碰撞</li>
<li>Lemma
6证明如果对于遮挡的问题都能做出合理的响应规则，那么就不会发生事故（反证法）</li>
</ul>
<h4 id="driving-policy-rl"><strong>4. Driving Policy
（RL）</strong></h4>
<ul>
<li><p>驾驶策略的定义：驾驶策略是从感知状态到驾驶命令的映射</p></li>
<li><p>构建高效的驾驶策略，拓展到百万级别的策略</p></li>
<li><p>描述驾驶策略的语言：(利用强化学习的描述方法)</p>
<ol type="1">
<li><p><span class="math inline">\(s_t\)</span>表示某一时刻的状态，<span
class="math inline">\(\pi\)</span>表示的是策略函数，<span
class="math inline">\(a_t\)</span>表示的是汽车能够选择的动作，根据策略函数来确定，得到一块序列
<span class="math inline">\(&lt;s_t,a_t&gt;\)</span></p></li>
<li><p><span class="math inline">\(P_{\pi}\)</span>表示的是根据 <span
class="math inline">\(\pi\)</span> 选择产生的后面不同序列<span
class="math inline">\(&lt;s_t,a_t&gt;\)</span>的概率</p></li>
<li><p><span class="math inline">\(E_{s~P_\pi}[\rho(s)]\)</span>
用于衡量当前策略的好坏程度，相当于对当下这个策略可能产生的不同奖励值选择期望，同时
<span
class="math inline">\(\rho(s)\)</span>表示的是当前状态下的奖励</p></li>
<li><p>在实际的实现过程中，<span
class="math inline">\(a_t\)</span>表示的是本车与其他道路使用者的位置、速度和加速度等问题，<span
class="math inline">\(s_{t+1}\)</span>表示的是下一时刻的状态，同时取决于当前时刻的动作以及其他智能体的行为，奖励函数<span
class="math inline">\(\rho(s)\)</span>
取决于当前环境中的其他智能体的相对位置速度等信息。</p></li>
<li><p>价值函数 <span
class="math inline">\(Q\)</span>表示的是当前智能体执行某一个动作所能造成的长期回报
,由此来选择最好的策略函数来保证<span class="math inline">\(\pi(s)=argmax
Q(s,a)\)</span></p></li>
<li><p><span class="math display">\[
Q(s, a)=\max _{(a_t, \ldots, a_{t+T})} \sum_{\tau=t}^T \rho(s_\tau,
a_\tau )  \quad  {  s.t. } \quad s_t=s, a_t=a, \forall \tau,
s_{\tau+1}=f(s_\tau, a_\tau)
\]</span></p>
<p>定义价值函数的计算方式，根据每个时刻汇总得到的奖励值进行求和得到的总的价值</p></li>
<li><p>参数 <span class="math inline">\(T\)</span>
表示的是“规划时间范围” 控制计算时间和评估质量之间的自然权衡，如果 <span
class="math inline">\(T\)</span>越大那么说明当前的动作评估效果越好</p></li>
</ol></li>
<li><p>计算价值函数挑战：</p>
<ol type="1">
<li>如果将动作空间进行离散，那么需要较大的计算空间，依赖于巨大的计算能力</li>
<li>采用离线计算，离散化动作域和状态域，然后采用离线的计算方式评估每个
<span class="math inline">\(（s,a）\)</span> 的价值</li>
<li>采用动态规划，计算每个 <span
class="math inline">\(（s,a）\)</span>的价值函数值 <span
class="math inline">\(Q（s,a）\)</span> 仍然面临计算空间较大的问题</li>
<li>利用有限类函数来近似价值函数，但是无法做出良好的近似，同时对于这样的神经网络比较难以学习</li>
<li>当更新时间较小存在一定的信噪比，导致学习速度及其缓慢，逼近类方法固有的问题</li>
<li>总结：<strong>资源计算量巨大的方法</strong>和
<strong>粗糙近似逼近</strong>会带来不同程度的问题</li>
</ol></li>
<li><p><strong>Semantics</strong> to the rescue重新定义自动驾驶语义</p>
<ul>
<li><p>在语义动作空间上定义价值函数Q：语义空间较小无语大量计算资源，能够对价值函数Q进行准确的估计</p></li>
<li><p>语义动作空间：</p>
<ol type="1">
<li><p>主要思想：纵向目标；横向目标；实现目标的积极性程度</p>
<p>横向：Lateral goals are desired positions in lane coordinate system
(e.g., “my goal is to be in the center of lane number 2”).</p>
<p>纵向： Longitudinal goals are of three types. The first is relative
position and speed w.r.t. other vehicles (e.g., “my goal is to be behind
car number 3, at its same speed, and at a distance of 2 seconds from
it”).</p>
<p>速度目标：speed target (e.g., “drive at the allowed speed for this
road times 110%”).</p>
<p>速度限制：speed constraint at a certain position (e.g., when
approaching a junction, “speed of 0 at the stop line”, or when passing a
sharp curve, “speed of at most 60kmh at a certain position on the
curve”).<strong>速度曲线</strong></p></li>
<li><p>确定横向目标和纵向目标之间的组合，利用运动学公式来实现目标</p></li>
<li><p>语义动作空间产生了所有可能的几何曲线的子集，除了特殊的情况</p></li>
</ol></li>
</ul></li>
<li><p><strong>Constructing an evaluation function for semantic
actions</strong> 构建<strong>语义动作的评估</strong>函数</p>
<ul>
<li>定义语义动作 <span
class="math inline">\(A^s\)</span>空间，通过当前的状态 <span
class="math inline">\(s\)</span>,选择最好的动作 <span
class="math inline">\(a^s\in A^s\)</span>, 根据一些列的几何轨迹 <span
class="math inline">\((s_1,a_1),...,(s_T,a_T)\)</span>，同时认为新的下一时刻的状态有一个新的函数给出
<span class="math inline">\(s_{t+1}=f(s_t,a_t)\)</span>
同时继续根据奖励函数的值来评估执行的语义动作的好坏程度 <span
class="math inline">\(\frac{1}{T}
\sum_{t=1}^T\rho(s_t,a_t)\)</span></li>
<li>利用语义动作来评估能规避信噪比低等问题</li>
<li>利用机器学习来泛化，在不同类型的道路上进行训练，推广到不同的道路</li>
<li>语义动作空间：<strong>资源高效利用同时很准确地进行评估</strong></li>
</ul></li>
<li><p><strong>The dynamics of the other agents
其他智能体的动态</strong></p>
<ul>
<li><span class="math inline">\(s_{t+1}=f(s_t,a_t)\)</span>
这样的确定性函数与现实不符合，多个智能体之间会相互影响</li>
<li>通过高频次地重新应用决策，不断调整策略来适应新的环境</li>
</ul></li>
</ul>
<h4 id="sensing-传感"><strong>Sensing 传感</strong></h4>
<h5 id="传感研究的内容">传感研究的内容：</h5>
<p>静态对象：(a fence that occludes relevant part of a merging
road).；</p>
<p>动态对象：车辆（边界框、速度、加速度）、行人（边界框、速度、加速度）、交通灯、动态道路分隔线（例如建筑区域的锥体）、临时交通标志和警察活动以及道路上的其他障碍物。</p>
<h5 id="sensing-system"><strong>Sensing system</strong></h5>
<ol type="1">
<li>Let <span class="math inline">\(S\)</span> denote the domain of
sensing state and let X be the domain of raw sensor and mapping data. A
传感系统表示的是一个函数 <span class="math inline">\(\hat{s}\)</span> :
<span class="math inline">\(X → S.\)</span></li>
<li>什么时候传感器的值 <span class="math inline">\(\hat{s}\)</span>
能够和状态 <span class="math inline">\(s\)</span>
近似？<strong>通过近似之后对驾驶策略的总体表现：安全性和舒适性</strong></li>
<li>传感器系统可能会犯的<strong>错误类型</strong>：
<ul>
<li>False negative: the sensing system misses an object
误报：传感器错过了一个物体</li>
<li>False positive: the sensing system indicates a “ghost” object
错误：传感器系统提示存在幽灵物体</li>
<li>Inaccurate measurements: the sensing system correctly detects an
object but incorrectly estimates its position or speed
测量不准确：传感系统正确检测到物体但是错误估计位置和速度</li>
<li>Inaccurate semantic: the sensing system correctly detects an object
but misinterpret its semantic meaning, for example, the color of a
traffic light
语义信息不准确：传感系统正确检测物体，但误解了语义信息，比如交通灯的颜色</li>
</ul></li>
</ol>
<h5 id="comfort"><strong>Comfort</strong></h5>
<ul>
<li>相当于利用传感器函数来近似估计 <span
class="math inline">\(s\)</span> ,如果 <span
class="math inline">\(\pi(\hat{s}(x))=\pi(s)\)</span> 也就是说<span
class="math inline">\(\pi(\hat{s}(x))=argmaxQ(\hat{s}(x),a)\)</span>，那么就说明当前这个传感器是可以的，同时允许有一定的误差范围：
<span class="math inline">\(Q(\hat{s}(x),a)\ge
Q(s,\pi(s))-\epsilon\)</span>，这个时候可以说是 <span
class="math inline">\(\epsilon
-\)</span>准确的，同时也允许传感器有小概率发生故障 <span
class="math inline">\(\delta\)</span></li>
<li>For example, we can choose three thresholds, $$1 &lt; $<span
class="math inline">\(2 &lt;\)</span>$3 to represent mild, medium, and
gross mistakes，表示传感器的错误程度，轻中重</li>
</ul>
<h5 id="pac-sensing-system"><strong>PAC sensing system</strong></h5>
<ol type="1">
<li><figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915174341417.png"
alt="Definition 28" />
<figcaption aria-hidden="true">Definition 28</figcaption>
</figure>
<p><strong>Probably-Approximately-Correct (PAC)</strong>
X表示的是原始的数据与映射的数据域，从期望的角度给出误差率的平均值：
<span class="math display">\[
\mathbb{P}_{(x, s) \sim D}\left[Q(s, \pi(\hat{s}(x))) \geq Q(s,
\pi(s))-\epsilon_i\right] \geq 1-\delta_i
\]</span></p></li>
<li><p>通过记录许多人类驾驶员的数据来构建此分布，而不是遵循自动驾驶车辆的特定策略（不切实际），由于任何合理策略对
D
的影响都很小，通过应用简单的数据增强技术，我们可以构建适当的分布，然后在传感系统的每次重大更新后执行离线验证。</p></li>
<li><p>重点关注经常发生的“测量不准确”类型的错误</p></li>
<li><p>let <span class="math inline">\(p(o)\)</span>，<span
class="math inline">\(\hat{p}(o)\)</span> be the positions of o in the
coordinate system of the host vehicle according to <span
class="math inline">\(s(x)\)</span>, <span
class="math inline">\(\hat{s}(x)\)</span>
respectively.分别表示某个对象的<strong>真实的位置信息</strong>和<strong>传感器的位置信息</strong>。</p>
<p>目标到主车辆的距离为：<span class="math inline">\(\|p\|\)</span>
，加性误差：<span
class="math inline">\(\|p(o)-\hat{p}(o)\|\)</span>，相对误差为 <span
class="math inline">\(\frac{\|p(o)-\hat{p}(o)\|}{\|p(o)\|}\)</span></p></li>
<li><p>对于positions a set of objects <span
class="math inline">\(O\)</span>表示的是一堆对象，要求 <span
class="math inline">\(p(o)\)</span> 和 <span
class="math inline">\(\hat{p}(o)\)</span>之间的相对误差小于一个精确度不妨计作
$$ ,但是<span class="math inline">\(\epsilon-ego-accurate\)</span>
的传感状态不能保证PAC传感系统能够满足每个合理的价值函数：当相对误差很小的时候，尽管认为合理了，但是对于实际的情况而言会出现不同的价值函数结果。选择制动or继续前进，<strong>横向不能用相对距离</strong></p></li>
<li><p>表明<span class="math inline">\(\epsilon-ego-accurate\)</span>
并不能保证我们的传感系统是PAC。是否还有其他属性足以满足 PAC
传感系统的要求</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915174411587-20231022115924657.png"
alt="Definition 29" />
<figcaption aria-hidden="true">Definition 29</figcaption>
</figure></li>
<li><figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915174449633.png"
alt="Definition 31" />
<figcaption aria-hidden="true">Definition 31</figcaption>
</figure>
<p>给出价值函数合理的L-语义-<span
class="math inline">\(Lipschitz\)</span>条件</p></li>
<li><figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915174520766.png"
alt="Lemma 7" />
<figcaption aria-hidden="true">Lemma 7</figcaption>
</figure>
<p>判定为PAC传感系统的终极判定</p></li>
</ol>
<h5 id="safety"><strong>Safety</strong></h5>
<ul>
<li><p>目标是减少事故发生的概率，存在两类安全情况：</p>
<ol type="1">
<li>传感系统认为危险情况是不危险的；</li>
<li>传感器系统认为不危险情况是危险的：当安全的时候突然出现紧急刹车会导致危险</li>
</ol></li>
<li><p>解决的是如何确保和验证safety-critic sensing
mistake足够小，采用的方法是融合多个工程和技术都独立的子系统。多数子系统认为安全才算安全：</p></li>
<li><p><strong>单侧c-近似独立</strong>的多个子系统</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915174623604-20231022115925281.png"
alt="Definition 32" />
<figcaption aria-hidden="true">Definition 32</figcaption>
</figure></li>
<li><p>对于服从单侧-c近似独立的子系统，能够推出：</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915174653068.png"
alt="Corollary 3" />
<figcaption aria-hidden="true">Corollary 3</figcaption>
</figure>
<p>基于多子系统方案和Corollary 3，为了达到10^-9
失效率，对sensing系统的验证不再需要10^9
小时的数据，而是分别对每个子系统验证10^5小时就可以了</p></li>
<li><p>独立假设背后的合理性留给我们去推理。有些传感器对会产生完全不相关的误差；单侧-c近似独立是否成立</p></li>
<li><p>对于安全幽灵而言，当出现至少有两个传感器认为的情况是危险的，才能认为是危险的</p></li>
<li><p><strong>Building a scalable sensing
system可扩展的传感器系统</strong></p>
<ol type="1">
<li>Cameras</li>
<li>Road Experience Management (REM)，不使用点云，而是一种基于语义的方法
approach，利用大量的车端detects semantically meaningful objects in the
scene (lane marks, curbs, poles, traffic lights,
etc.)，并可以对云端进行更新。以可扩展的方式非常频繁地更新地图。此外，自动驾驶车辆可以通过现有的通信平台（蜂窝网络）接收小型地图数据</li>
<li>A complementary radar and lidar
system，能够产生极高的精度；直接测量速度和距离，这进一步提高了乘坐的舒适度</li>
</ol></li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>智能安全</tag>
      </tags>
  </entry>
  <entry>
    <title>【基础工具】Anaconda命令集</title>
    <url>/2023/10/22/conda_list/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>
<h2 id="conda-常用命令">Conda 常用命令</h2>
<h3 id="查看conda版本">查看conda版本</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">conda --version/ conda -V<br></code></pre></td></tr></table></figure>
<h3 id="查看已有环境">查看已有环境</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">conda info --envs<br>conda env <span class="hljs-built_in">list</span><br>conda info -e<br></code></pre></td></tr></table></figure>
<h3 id="进退环境">进退环境</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">conda activate  [name]<span class="hljs-comment"># 重新进入虚拟环境</span><br>conda deactivate  <span class="hljs-comment"># 退出虚拟环境</span><br></code></pre></td></tr></table></figure>
<h3 id="创建新的环境">创建新的环境</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">conda create -n *** python=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<h3 id="删除环境">删除环境</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">conda remove -n old_name --<span class="hljs-built_in">all</span> <span class="hljs-comment"># 删除环境old_name</span><br></code></pre></td></tr></table></figure>
<h3 id="激活环境">激活环境</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">conda activate xxxx <span class="hljs-comment"># 激活xxxx环境</span><br></code></pre></td></tr></table></figure>
<h3 id="关闭环境">关闭环境</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">conda deactivate <span class="hljs-comment"># 关闭环境</span><br></code></pre></td></tr></table></figure>
<h3 id="克隆环境">克隆环境</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">conda create -n [new_name] --clone [old_name]<br></code></pre></td></tr></table></figure>
<h3 id="升级版本">升级版本</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">conda update -n base conda <span class="hljs-comment">#update最新版本的conda；</span><br>conda update --<span class="hljs-built_in">all</span> <span class="hljs-comment">#更新所有包</span><br></code></pre></td></tr></table></figure>
<h3 id="pip管理的常用包">Pip管理的常用包</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">pip search package_name <br>pip show package_name <br>pip uninstall｜｜package_name<br>pip <span class="hljs-built_in">list</span><br></code></pre></td></tr></table></figure>
<h3 id="删除环境中的包">删除环境中的包</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">conda remove package <span class="hljs-comment">#删除当前环境中的包</span><br>conda remove -- name env_name package <span class="hljs-comment">#删除指定环境中的包</span><br></code></pre></td></tr></table></figure>
<h3 id="指定环境中安装包">指定环境中安装包</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">conda install --name env_name package_name <br></code></pre></td></tr></table></figure>
<h3 id="conda环境的python版本非指定">Conda环境的python版本非指定</h3>
<p>指定虚拟环境x的python版本是3.8，base环境是3.11；conda
activate激活x之后python版本仍为3.11。</p>
<p><strong>原因：</strong>在base环境中修改了.zshrc文件中的python只定路径，让每次虚拟环境中的python找到的python都只能按照指定的python路径进行寻找，从而导致conda环境中的python版本不能制定。</p>
<p><strong>修改方式：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">vim .zshrc<br></code></pre></td></tr></table></figure>
<p>进入
.zshrc环境中进行修改，如果发现一类诸如其他python版本指定的路径的话，需要进行删除，只需要保留最原始的关于anaconda的命令初始化，完成之后输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.zshrc<br></code></pre></td></tr></table></figure>
<p>解决问题</p>
<h3 id="镜像源安装">镜像源安装</h3>
<p>在conda环境中改变默认的下载镜像源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pip config <span class="hljs-built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple <br></code></pre></td></tr></table></figure>
<p>加上这句话之后就会出现以下的写文件</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino">Writing to /home/user/.config/pip/pip.conf<br></code></pre></td></tr></table></figure>
<p><strong>下载使用清华源加上： -i
https://pypi.tuna.tsinghua.edu.cn/simple</strong></p>
<blockquote>
<p><strong>清华：<code>https://pypi.tuna.tsinghua.edu.cn/simple/</code></strong></p>
<p><strong>阿里云：<code>http://mirrors.aliyun.com/pypi/simple/</code></strong></p>
<p><strong>中国科技大学
：<code>https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/</code></strong></p>
<p><strong>豆瓣：<code>http://pypi.doubanio.com/simple/</code></strong></p>
</blockquote>
<p>如果是给conda添加镜像：清华源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">conda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/win-64/<br></code></pre></td></tr></table></figure>
<p>添加阿里源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">conda config --add channels https://mirrors.aliyun.com/pypi/simple/<br></code></pre></td></tr></table></figure>
<p>查看已经添加的镜像源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">conda config --show channels<br></code></pre></td></tr></table></figure>
<p>移除其中的指定的镜像源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">conda config --remove channels + 镜像的名称<br></code></pre></td></tr></table></figure>
<h3 id="conda无法自动更新">Conda无法自动更新</h3>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231206113335958.png"
alt="image-20231206113335958" />
<figcaption aria-hidden="true">image-20231206113335958</figcaption>
</figure>
<p>原因：<a
href="https://so.csdn.net/so/search?q=conda&amp;spm=1001.2101.3001.7020">conda</a>和pip等相关包的版本太低，自动更新不能用，解决方案：在命令行中输入以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">conda clean --all<br>conda update --all<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>基础工具</category>
      </categories>
      <tags>
        <tag>基础工具</tag>
      </tags>
  </entry>
  <entry>
    <title>【后端开发】Golang基础</title>
    <url>/2023/11/27/go-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>
<hr />
<h1 id="golang基础">Golang基础</h1>
<p>参考学习资料：</p>
<ul>
<li><a
href="https://www.bilibili.com/video/BV1gf4y1r79E/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click">8小时转职Golang工程师</a></li>
<li><a href="https://gfw.go101.org/">Go语言101</a></li>
<li><a
href="https://golang.design/go-questions/">Go程序员面试笔试宝典</a></li>
</ul>
<h2 id="golang简介">Golang简介</h2>
<h3 id="go语言的优势">go语言的优势</h3>
<ol type="1">
<li><strong>部署简单</strong>
<ul>
<li>可以直接编译成机器码可执行</li>
<li>不依赖其他库</li>
<li>直接运行即可部署</li>
</ul></li>
<li><strong>静态类型语言</strong>
<ul>
<li>编译的时候就能查出来大多数的问题</li>
</ul></li>
<li><strong>语言层面的并发</strong>
<ul>
<li>能够成分利用多核</li>
</ul></li>
<li><strong>强大的标准库</strong>
<ul>
<li>runtime系统调度机制</li>
<li>丰富的标准库</li>
</ul></li>
<li><strong>简单易学</strong>
<ul>
<li>25个关键字，内嵌C语法支持</li>
<li>面向对象的特征，能够跨平台</li>
<li>go语言<strong>没有异常</strong>，全部都用ERROR来表示</li>
</ul></li>
</ol>
<h3 id="go应用方向">go应用方向</h3>
<ol type="1">
<li><strong>云计算基础设施建设</strong>
<ul>
<li>Docker, kubernetes</li>
<li>Consul, cloudflare CDN</li>
</ul></li>
<li><strong>基础后端软件</strong>：tide, influxdb, cockroachdb</li>
<li><strong>微服务</strong>：go-kit, micro</li>
<li><strong>互联网基础设施</strong>： 以太坊，hyperledger</li>
</ol>
<hr />
<h2 id="go的环境安装">Go的环境安装</h2>
<h3 id="下载官网">下载官网</h3>
<p>go的官网下载网站，选择合适的系统版本进行安装<a
href="https://go.dev/dl/">https://go.dev/dl/</a></p>
<h3 id="安装步骤">安装步骤</h3>
<ol type="1">
<li><p>下载安装包并按照安装包的指引下载相关的内容</p></li>
<li><p>对于Mac系统会直接配置好环境变量，根据官网的安装手册进行安装 <a
href="https://go.dev/doc/install">https://go.dev/doc/install</a></p></li>
<li><p>测试GO的版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">go version<br></code></pre></td></tr></table></figure>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231127204733470.png" alt="go version" style="zoom: 67%;" /></p></li>
<li><p>测试GO的环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">go <span class="hljs-built_in">env</span><br></code></pre></td></tr></table></figure>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231127204804150.png" alt="go env" style="zoom: 50%;" /></p></li>
</ol>
<h2 id="go环境变量">GO环境变量</h2>
<h3 id="goroot路径">GOROOT路径</h3>
<p>GOROOT 表示的是安装包所在的位置，一般不需要修改</p>
<h3 id="gopath路径">GOPATH路径</h3>
<p>GOPATH表示的是运行文件所在的位置，表示的是workspace的文件位置，GOPATH是我们的工作空间，保存go项目代码和第三方依赖包<strong>GOPATH</strong>可以设置多个，其中，第一个将会是默认的包目录，使用
go get 下载的包都会在第一个path中的src目录下，使用 go
install时，在哪个GOPATH中找到了这个包，就会在哪个GOPATH下的bin目录生成可执行文件</p>
<p>修改GOPATH的路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> GOPATH=<span class="hljs-string">&quot;/Users/lihaibin/workspace/golang&quot;</span><br></code></pre></td></tr></table></figure>
<p>将文件查找的路径设置为GOROOT和GOPATH的并集合</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$GOROOT</span>/bin:<span class="hljs-variable">$GOPATH</span>/bin<br></code></pre></td></tr></table></figure>
<p>将两个部分并在一起之后，就能从两个地方开始寻找定义的包</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203140236053.png"
alt="查找文件的路径顺序" />
<figcaption aria-hidden="true">查找文件的路径顺序</figcaption>
</figure>
<p>首先会从GOROOT进行搜索，接着从GOPATH进行搜索。</p>
<p>GOPATH是开发时的工作目录。用于：</p>
<ol type="1">
<li>保存编译后的二进制文件。</li>
<li><code>go get</code>和<code>go install</code>命令会下载go代码到GOPATH。</li>
<li>import包时的搜索路径</li>
</ol>
<p>使用GOPATH时，GO会在以下目录中搜索包：</p>
<ol type="1">
<li><code>GOROOT/src</code>：该目录保存了Go标准库代码。</li>
<li><code>GOPATH/src</code>：该目录保存了应用自身的代码和第三方依赖的代码。</li>
</ol>
<p><strong>GOPATH的弊端</strong></p>
<p>在 GOPATH 的 <code>$GOPATH/src</code> 下进行 <code>.go</code>
文件或源代码的存储，我们可以称其为 GOPATH
的模式，这个模式拥有一些弊端.</p>
<ul>
<li><p><strong>无版本控制概念.</strong>
在执行<code>go get</code>的时候，你无法传达任何的版本信息的期望，也就是说你也无法知道自己当前更新的是哪一个版本，也无法通过指定来拉取自己所期望的具体版本。</p></li>
<li><p><strong>无法同步一致第三方版本号.</strong> 在运行 Go
应用程序的时候，你无法保证其它人与你所期望依赖的第三方库是相同的版本，也就是说在项目依赖库的管理上，你无法保证所有人的依赖版本都一致。</p></li>
<li><p><strong>无法指定当前项目引用的第三方版本号.</strong> 你没办法处理
v1、v2、v3 等等不同版本的引用问题，因为 GOPATH
模式下的导入路径都是一样的，都是<code>github.com/foo/bar</code>。</p></li>
</ul>
<h3 id="goproxy设置">GOPROXY设置</h3>
<p>这个环境变量主要是用于设置 <strong>Go 模块代理（Go module
proxy）,其作用是用于使 Go
在后续拉取模块版本时直接通过镜像站点来快速拉取</strong>。</p>
<p>GOPROXY
的默认值是：<code>https://proxy.golang.org,direct</code>，<code>proxy.golang.org</code>国内访问不了,需要设置国内的代理</p>
<ul>
<li>阿里云 https://mirrors.aliyun.com/goproxy/</li>
<li>七牛云 https://goproxy.cn,direct</li>
</ul>
<p>并通过以下的命令进行设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">go <span class="hljs-built_in">env</span> -w GOPROXY=https://goproxy.cn,direct<br></code></pre></td></tr></table></figure>
<p>GOPROXY 的值是一个以英文逗号 “,” 分割的 Go
模块代理列表，允许设置多个模块代理，假设你不想使用，也可以将其设置为
“off” ，这将会禁止 Go 在后续操作中使用任何 Go 模块代理。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">go <span class="hljs-built_in">env</span> -w GOPROXY=https://goproxy.cn,https://mirrors.aliyun.com/goproxy/,direct<br></code></pre></td></tr></table></figure>
<h3 id="go111module">GO111MODULE</h3>
<p>GO111MODULE 有三个值：off, on和auto（默认值）。</p>
<ul>
<li>GO111MODULE=off，go命令行将不会支持module功能，寻找依赖包的方式将会沿用旧版本那种通过vendor目录或者GOPATH模式来查找。</li>
<li>GO111MODULE=on，go命令行会使用modules，而一点也不会去GOPATH目录下查找。</li>
<li>GO111MODULE=auto，默认值，go命令行将会根据当前目录来决定是否启用module功能。这种情况下可以分为两种情形：
当前目录在GOPATH/src之外且该目录包含go.mod文件
当前文件在包含go.mod文件的目录下面。</li>
</ul>
<p>执行以下命令开启go mod管理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">go <span class="hljs-built_in">env</span> -w GO111MODULE=on<br></code></pre></td></tr></table></figure>
<h2 id="go基本语法">Go基本语法</h2>
<h3 id="如何编译并运行一个go文件">如何编译并运行一个Go文件</h3>
<p>对于已经写好的go文件，这里以hello.go作为例子，直接使用以下语句进行编译并运行</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> run hello.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure>
<p>或者将编译和运行两个过程分开，先编译后运行：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> build hello.<span class="hljs-keyword">go</span><br>./ hello<br></code></pre></td></tr></table></figure>
<h3 id="写一个hello.go">写一个hello.go</h3>
<p>首先给出基本框架</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span>(<br>	<span class="hljs-string">&quot;fmt&quot;</span>,<br>  <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  fmt.Println(<span class="hljs-string">&quot;hello world!&quot;</span>)<br>  time.Sleep(<span class="hljs-number">1</span>*time.Second)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>程序的第一行声明了名为main的package。<strong>一个package会包含一个或多个.go源代码文件。每一个源文件都是以package开头。</strong>比如我们的例子里是package
main。这行声明语句表示该文件是属于哪一个package。</p>
<ul>
<li>第一行代码<strong>package
main</strong>定义了包名。你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package
main。package main表示一个可独立执行的程序，每个 Go
应用程序都包含一个名为 main 的包。</li>
<li>下一行<strong>import "fmt"</strong>告诉 Go 编译器这个程序需要使用
fmt 包（的函数，或其他元素），fmt 包实现了格式化
IO（输入/输出）的函数。</li>
<li>下一行func main()是程序开始执行的函数。main
函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有
init() 函数则会先执行该函数）。</li>
</ul>
<blockquote>
<p>一个程序的<code>main</code>入口函数必须不带任何输入参数和返回结果。而且go语言的语法，定义函数的时候，<strong>‘{’
必须和函数名在同一行，不能另起一行</strong></p>
</blockquote>
<h3 id="变量的声明">变量的声明</h3>
<p>声明变量的一般形式是使用 var 关键字</p>
<h4 id="第一种声明">第一种声明：</h4>
<p>指定变量类型，声明后若不赋值，使用<strong>默认值0</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> v_name v_type<br>v_name = value<br><span class="hljs-keyword">package</span> main<br><br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">var</span> a <span class="hljs-type">int</span><br>        fmt.Printf(<span class="hljs-string">&quot; = %d\n&quot;</span>, a)<br>&#125;<br><br><br>$<span class="hljs-keyword">go</span> run test.<span class="hljs-keyword">go</span><br>a = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<h4 id="第二种声明">第二种声明：</h4>
<p>根据值自行判定变量类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> v_name = value<br></code></pre></td></tr></table></figure>
<h4 id="第三种声明">第三种声明：</h4>
<p>省略var, 注意
:=左侧的变量不应该是已经声明过的，就是:=只能用于没有被声明的变量赋值上，否则会编译错误</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">v_name := value<br><br><br><span class="hljs-comment">// 例如</span><br><span class="hljs-keyword">var</span> a <span class="hljs-type">int</span> = <span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-number">10</span><br>c : = <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure>
<p>几种声明类型的对比</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">//第一种 使用默认值</span><br>        <span class="hljs-keyword">var</span> a <span class="hljs-type">int</span><br>        fmt.Printf(<span class="hljs-string">&quot;a = %d\n&quot;</span>, a)<br><br><br>        <span class="hljs-comment">//第二种</span><br>        <span class="hljs-keyword">var</span> b <span class="hljs-type">int</span> = <span class="hljs-number">10</span><br>        fmt.Printf(<span class="hljs-string">&quot;b = %d\n&quot;</span>, b)<br><br><br>        <span class="hljs-comment">//第三种 省略后面的数据类型,自动匹配类型</span><br>        <span class="hljs-keyword">var</span> c = <span class="hljs-number">20</span><br>        fmt.Printf(<span class="hljs-string">&quot;c = %d\n&quot;</span>, c)<br><br><br>        <span class="hljs-comment">//第四种 省略var关键字</span><br>        d := <span class="hljs-number">3.14</span><br>        fmt.Printf(<span class="hljs-string">&quot;d = %f\n&quot;</span>, d)<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="全局变量声明">全局变量声明</h4>
<p>和一般的定义变量的方式一样</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x, y <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> c, d <span class="hljs-type">int</span> = <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">var</span> e, f = <span class="hljs-number">123</span>, <span class="hljs-string">&quot;lihaibin&quot;</span><br></code></pre></td></tr></table></figure>
<p>特殊的定义全局变量的方式，而且<strong>:=的定义方式不能够用于定义全局变量</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">var</span> ( <span class="hljs-comment">//这种分解的写法,一般用于声明全局变量</span><br>        a <span class="hljs-type">int</span><br>        b <span class="hljs-type">bool</span><br>)<br><br><span class="hljs-comment">//这种不带声明格式的只能在函数体内声明</span><br><span class="hljs-comment">//g, h := 123, &quot;需要在func函数体内实现&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;&#125;<br></code></pre></td></tr></table></figure>
<h4 id="多变量声明">多变量声明</h4>
<p>:=不能用于已经被初始化之后的变量的赋值，如果对于_的情况是不具备可读性，相当于忽略</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        g, h := <span class="hljs-number">123</span>, <span class="hljs-string">&quot;需要在func函数体内实现&quot;</span><br>        fmt.Println(x, y, a, b, c, d, e, f, g, h)<br><br>        <span class="hljs-comment">//不能对g变量再次做初始化声明</span><br>        <span class="hljs-comment">//g := 400</span><br><br>        _, value := <span class="hljs-number">7</span>, <span class="hljs-number">5</span>  <span class="hljs-comment">//实际上7的赋值被废弃，变量 _  不具备读特性</span><br>        <span class="hljs-comment">//fmt.Println(_) //_变量的是读不出来的</span><br>        fmt.Println(value) <span class="hljs-comment">//5</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="常量">常量</h3>
<h4 id="常量的声明方式">常量的声明方式</h4>
<p>常量是一个简单值的标识符，在程序运行时，<strong>不会被修改的量</strong>。常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。</p>
<p>常量的定义格式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> identifier [<span class="hljs-keyword">type</span>] = value<br><span class="hljs-keyword">const</span> b <span class="hljs-type">string</span> = <span class="hljs-string">&quot;abc&quot;</span><br></code></pre></td></tr></table></figure>
<p>隐式定义类型方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> b = <span class="hljs-string">&quot;abc&quot;</span><br></code></pre></td></tr></table></figure>
<p>多重赋值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> a, b, c = <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;str&quot;</span> <span class="hljs-comment">//多重赋值</span><br></code></pre></td></tr></table></figure>
<p>枚举类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    Unknown = <span class="hljs-number">0</span><br>    Female = <span class="hljs-number">1</span><br>    Male = <span class="hljs-number">2</span><br>)<br></code></pre></td></tr></table></figure>
<p>常量可以用len(), cap(),
unsafe.Sizeof()常量计算表达式的值。常量表达式中，函数必须是内置函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;unsafe&quot;</span><br><span class="hljs-keyword">const</span> (<br>    a = <span class="hljs-string">&quot;abc&quot;</span><br>    b = <span class="hljs-built_in">len</span>(a)<br>    c = unsafe.Sizeof(a)<br>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">println</span>(a, b, c)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果为：abc, 3, 16</p>
<blockquote>
<p>unsafe.Sizeof(a) = 16</p>
<p>字符串类型在 go 里是个结构,
包含指向底层数组的指针和长度,这两部分每部分都是 8
个字节，所以字符串类型大小为 16 个字节。</p>
</blockquote>
<h4 id="常量中的iota标识符">常量中的iota标识符</h4>
<p>在 golang
中，一个方便的习惯就是使用<code>iota</code>标示符，简化了常量用于增长数字的定义。</p>
<p>下面的代码中，当第一行赋值了iota之后，那么相当于初始化位置是0，后面的依次增加是1，2</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    CategoryBooks = <span class="hljs-literal">iota</span> <span class="hljs-comment">// 0</span><br>    CategoryHealth       <span class="hljs-comment">// 1</span><br>    CategoryClothing     <span class="hljs-comment">// 2</span><br>)<br></code></pre></td></tr></table></figure>
<p>如果对<code>iota</code>进行运算，其实相当于是选择当前的行作为iota的取值进行运算，如果中间不对运算加以改变，那么会一直持续按照当前的运算规则执行下去</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>	<span class="hljs-comment">//关键字 iota</span><br>	<span class="hljs-comment">/* BEIJING=0</span><br><span class="hljs-comment">	SHANGHAI=1</span><br><span class="hljs-comment">	SHENGZHENG=2 */</span><br>	BEIJING = <span class="hljs-number">10</span> * <span class="hljs-literal">iota</span> <span class="hljs-comment">// 默认为0 输出0</span><br>	SHANGHAI  <span class="hljs-comment">//输出10</span><br>	HANGZHOU <span class="hljs-comment">//输出20</span><br>)<br></code></pre></td></tr></table></figure>
<p>同样的在同一个const中去定义不同的
<code>iota</code>的计算方式也可以，<code>iota</code>的取值就是选择当前的行，从哪个地方开始改变，那么就改成不同的计算方式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>	<span class="hljs-comment">//这个iota的值表示的是和行数有关的数值，因此计算的时候用行来表示</span><br>	a, b = <span class="hljs-literal">iota</span> + <span class="hljs-number">1</span>, <span class="hljs-literal">iota</span> + <span class="hljs-number">2</span> <span class="hljs-comment">//每次新开一个关于iota的计算 那么后续全部会跟着这个计算方式下去</span><br>	c, d<br>	e, f<br>	g, h = <span class="hljs-literal">iota</span> * <span class="hljs-number">2</span>, <span class="hljs-literal">iota</span> * <span class="hljs-number">3</span><br>	<span class="hljs-comment">//iota只能在const之中使用</span><br>	i, k<br>)<br></code></pre></td></tr></table></figure>
<p>以下是输出的内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">a= 1 b= 2 c= 2 d= 3 e= 3 f= 4 g= 6 h= 9 i= 8 k= 12<br></code></pre></td></tr></table></figure>
<h3 id="函数">函数</h3>
<h4 id="基本函数的定义">基本函数的定义</h4>
<p>多个返回值初始化设置了函数的形参之后，初始值是0</p>
<p>go每次设置一个变量值之后都有初始值，如果是数据就是0，如果是字符串那么就是空，防止出现一些野指针的情况</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(x, y <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">string</span>) &#123;<br>   <span class="hljs-keyword">return</span> y, x<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   a, b := swap(<span class="hljs-string">&quot;Mahesh&quot;</span>, <span class="hljs-string">&quot;Kumar&quot;</span>)<br>   fmt.Println(a, b)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出的结果是</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">Kumar Mahesh<br></code></pre></td></tr></table></figure>
<h4 id="import和init">import和init</h4>
<p>所有被导入的包都加载完毕了，就会开始对main包中的包级常量和变量进行初始化，执行main包中的init函数，最后执行main函数。下图详细地解释了整个执行过程：</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231202121630297.png"
alt="init的调用顺序" />
<figcaption aria-hidden="true">init的调用顺序</figcaption>
</figure>
<p>分别建不同的文件夹对应的就是package的名字，相应的在.go文件内部声明package的名字</p>
<p>main 函数只能在package main中</p>
<p><strong>注意：</strong>
在包中设置接口的时候，函数名称<strong>必须第一个字母是大写，如果是小写的话将无法识别</strong></p>
<ul>
<li>如果函数名第一个是大写就是对外开放的函数，认为是public</li>
<li>如果函数名第一个是小写的话就认为是私有的函数，认为是private</li>
</ul>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203140110880.png" alt="接口函数大小写的区别" style="zoom:67%;" /></p>
<p>init函数的调用过程，首先会对包中的init进行初始化再进行调用接口</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203140412429.png" alt="init()调用顺序和过程" style="zoom:67%;" /></p>
<p>如果你导入了包比如lib1，但是没有使用这个包里面的接口函数，仍然会报错</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203141038750.png" alt="导入包但是没有使用接口函数" style="zoom:67%;" /></p>
<p>以下是一个import包的例子，首先定义两个不同包以及对应的接口函数和初始化函数的实现</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> InitLib1<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;lib1&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> InitLib2<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;lib2&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;GolangTraining/InitLib1&quot;</span><br>    <span class="hljs-string">&quot;GolangTraining/InitLib2&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;libmain init&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;libmian main&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>"GolangTraining/InitLib1""GolangTraining/InitLib2"</code>是两个包的地址，go会默认从GOROOT和GOPATH两个默认的位置进行寻找，首先要保证地址的正确性</p>
<p>代码的输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">lib1<br>lib2<br>libmain init<br>libmian main<br></code></pre></td></tr></table></figure>
<h4 id="匿名导包方式">匿名导包方式</h4>
<p>如果我不想调用lib1的函数接口，但是想使用lib1的init()函数怎么办呢，如果这个时候直接导入了包但是不调用接口，就会出现上述的错误</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203141038750.png" alt="导入包但是没有使用接口函数" style="zoom:70%;" /></p>
<p>在导入的包前面加上下划线来认为这个包是匿名的，这样就能知进行init操作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span>(<br>			<span class="hljs-string">&quot;fmt&quot;</span><br>			_<span class="hljs-string">&quot;lib2&quot;</span><br>)<br></code></pre></td></tr></table></figure>
<p>那么这个时候就只会调用<code>init()</code>函数同时不会出错</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203141336299.png"
alt="只调用init()函数" />
<figcaption aria-hidden="true">只调用init()函数</figcaption>
</figure>
<p>除了能够匿名导包之外，还能给新导入的包起个别的名字，比如叫mylib作为新的别名</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203141500041.png" alt="给导入的包换个名字" style="zoom:67%;" /></p>
<p>或者直接使用<code>·</code>来进行调用</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203141620428.png" alt="换别名进行导包" style="zoom:67%;" /></p>
<p>最好别使用这种，如果两个包的函数名称一样那么可能会导致<strong>出现歧义的情况</strong></p>
<h4 id="函数值传递">函数值传递</h4>
<p>函数如果使用参数，该变量可称为函数的形参。</p>
<p><strong>形参</strong>就像定义在函数体内的<strong>局部变量</strong>。调用函数，可以通过两种方式来传递参数：<strong>值传递和指针传递</strong></p>
<p>值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。<strong>默认情况下，Go
语言使用的是值传递</strong>，即在调用过程中不会影响到实际参数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* 定义相互交换值的函数 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>   <span class="hljs-keyword">var</span> temp <span class="hljs-type">int</span><br><br><br>   temp = x <span class="hljs-comment">/* 保存 x 的值 */</span><br>   x = y    <span class="hljs-comment">/* 将 y 值赋给 x */</span><br>   y = temp <span class="hljs-comment">/* 将 temp 值赋给 y*/</span><br><br><br>   <span class="hljs-keyword">return</span> temp;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>接下来，让我们使用值传递来调用 swap() 函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">/* 定义局部变量 */</span><br>   <span class="hljs-keyword">var</span> a <span class="hljs-type">int</span> = <span class="hljs-number">100</span><br>   <span class="hljs-keyword">var</span> b <span class="hljs-type">int</span> = <span class="hljs-number">200</span><br><br><br>   fmt.Printf(<span class="hljs-string">&quot;交换前 a 的值为 : %d\n&quot;</span>, a )<br>   fmt.Printf(<span class="hljs-string">&quot;交换前 b 的值为 : %d\n&quot;</span>, b )<br><br><br>   <span class="hljs-comment">/* 通过调用函数来交换值 */</span><br>   swap(a, b)<br><br><br>   fmt.Printf(<span class="hljs-string">&quot;交换后 a 的值 : %d\n&quot;</span>, a )<br>   fmt.Printf(<span class="hljs-string">&quot;交换后 b 的值 : %d\n&quot;</span>, b )<br>&#125;<br><br><br><span class="hljs-comment">/* 定义相互交换值的函数 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>   <span class="hljs-keyword">var</span> temp <span class="hljs-type">int</span><br><br><br>   temp = x <span class="hljs-comment">/* 保存 x 的值 */</span><br>   x = y    <span class="hljs-comment">/* 将 y 值赋给 x */</span><br>   y = temp <span class="hljs-comment">/* 将 temp 值赋给 y*/</span><br><br><br>   <span class="hljs-keyword">return</span> temp;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行的结果为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">交换前 a 的值为 : 100<br>交换前 b 的值为 : 200<br>交换后 a 的值 : 100<br>交换后 b 的值 : 200<br></code></pre></td></tr></table></figure>
<h3 id="go指针">GO指针</h3>
<p>和C++以及C中的是一样的，对go中的指针定义的时候 *int
传递变量的地址&amp;</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203171319969.png" alt="指针和引用的传递例子" style="zoom:67%;" /></p>
<p>在对一个指针赋值的时候，传递的是某一个变量的地址，就是传递这个变量的引用，引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p>
<h3 id="defer">defer</h3>
<p>defer语句被用于预定对一个函数的调用。可以把这类被defer语句调用的函数称为<strong>延迟函数</strong>，主要作用：</p>
<ul>
<li>释放占用的资源</li>
<li>捕捉处理异常</li>
<li>输出日志</li>
</ul>
<p>如果一个函数中有多个defer语句，它们会以<strong>LIFO（后进先出）</strong>的顺序执行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Demo</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;1&quot;</span>)<br>	<span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;2&quot;</span>)<br>	<span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;3&quot;</span>)<br>	<span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;4&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	Demo()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出的内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">4<br>3<br>2<br>1<br></code></pre></td></tr></table></figure>
<h3 id="数组与切片">数组与切片</h3>
<p>Go 语言切片 <code>slice</code> 是对数组的抽象</p>
<h4 id="静态数组">静态数组</h4>
<p>通过这种方式进行初始化数组以及进行切片操作，通过range关键字进行遍历数组，并给出index和value进行给出不同的下标和数值</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203174817927.png" alt="初始化数组并进行切片操作" style="zoom:67%;" /></p>
<p>固定数组传递的是一个值拷贝</p>
<h4 id="动态数组-slice"><strong>动态数组 slice</strong></h4>
<p>切片不需要说明长度</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment">		声明切片之后的长度是3，同时初始化的值是1，2，3</span><br><span class="hljs-comment">	*/</span><br>slice1 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>s := arr[:]<br><span class="hljs-comment">//但是这个时候就只会重新赋予空间并复制0</span><br>slice1 = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">4</span>)<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">		声明slice是切片,但是没有分配空间</span><br><span class="hljs-comment">	*/</span><br><span class="hljs-keyword">var</span> slice2 []<span class="hljs-type">int</span><br></code></pre></td></tr></table></figure>
<p>也可以指定容量，其中<code>capacity</code>为可选参数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">make</span>([]T, length, capacity)<br></code></pre></td></tr></table></figure>
<p>将arr中从下标startIndex到<strong>endIndex-1</strong>
下的元素创建为一个新的切片</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">s := arr[startIndex:endIndex]<br></code></pre></td></tr></table></figure>
<p>缺省endIndex时将表示一直到arr的最后一个元素，缺省startIndex时将表示从arr的第一个元素开始</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">s := arr[startIndex:]<br>s := arr[:endIndex]<br></code></pre></td></tr></table></figure>
<p>通过切片s初始化切片s1</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">s1 := s[startIndex:endIndex]<br></code></pre></td></tr></table></figure>
<p>通过内置函数 <code>make()</code>初始化切片s,<code>[]int</code>
标识为其元素类型为int的切片</p>
<p>同时动态数组传递的过程中的参数形式是一致的，能够适配所有的slice参数类型，但是对于</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203205827787.png" alt="动态数组传递引用同时不会因为长度不一样而改变形参" style="zoom:67%;" /></p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203205839072.png" alt="动态数组的初始化和打印" style="zoom:67%;" /></p>
<p>这里面的下划线表示的是<strong>不需要考虑</strong>的index的数值，可以忽略，这里是关于切片slice的声明和打印</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">	<span class="hljs-comment">//声明切片之后的长度是3，同时初始化的值是1，2，3</span><br>	slice1 :=[]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br>	<span class="hljs-comment">//%v表示的是打印出全部的表示信息</span><br>	fmt.Printf(<span class="hljs-string">&quot;len = %d, slice =%v\n&quot;</span>, <span class="hljs-built_in">len</span>(slice1),slice1)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>打印的结果是</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203210558440.png" alt="输出的结果" style="zoom:67%;" /></p>
<p>声明slice但是不一定声明了空间，因此需要注意的是声明的同时并给出空间大小，同时没办法中途增加空间</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span>  <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-comment">/* </span><br><span class="hljs-comment">	声明切片之后的长度是3，同时初始化的值是1，2，3</span><br><span class="hljs-comment">	 */</span><br>	slice1 :=[]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br>	<span class="hljs-comment">//%v表示的是打印出全部的表示信息</span><br>	fmt.Printf(<span class="hljs-string">&quot;len = %d, slice =%v\n&quot;</span>, <span class="hljs-built_in">len</span>(slice1),slice1)<br>	<span class="hljs-comment">//直接对没有赋予空间的位置修改会出现位置越界</span><br>	<span class="hljs-comment">//slice1[3]=999</span><br>	slice1 = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">4</span>)<br>	<span class="hljs-comment">//但是这个时候就只会重新赋予空间并复制0</span><br>	fmt.Printf(<span class="hljs-string">&quot;len = %d, slice =%v\n&quot;</span>, <span class="hljs-built_in">len</span>(slice1),slice1)<br>	<span class="hljs-comment">/* </span><br><span class="hljs-comment">	声明slice是切片,但是没有分配空间</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">var</span> slice2 []<span class="hljs-type">int</span><br>	fmt.Printf(<span class="hljs-string">&quot;len = %d, slice =%v\n&quot;</span>, <span class="hljs-built_in">len</span>(slice2),slice2)<br>	<span class="hljs-comment">//slice2[0]=2 //直接赋予数值会出现错误，越界</span><br>	slice2 = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">3</span>)<br>	<span class="hljs-comment">//开辟空间，但是默认值都是0</span><br>	fmt.Printf(<span class="hljs-string">&quot;len = %d, slice =%v\n&quot;</span>, <span class="hljs-built_in">len</span>(slice2),slice2)<br>	slice2[<span class="hljs-number">0</span>]=<span class="hljs-number">1000</span><br>	fmt.Printf(<span class="hljs-string">&quot;len = %d, slice =%v\n&quot;</span>, <span class="hljs-built_in">len</span>(slice2),slice2)<br>	<span class="hljs-comment">//此时就修改成功</span><br>	<span class="hljs-comment">/*  </span><br><span class="hljs-comment">	声明slice类型，同时分配空间</span><br><span class="hljs-comment">	*/</span><br>	<span class="hljs-keyword">var</span> slice3 =<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">5</span>)<br>	fmt.Printf(<span class="hljs-string">&quot;len = %d, slice =%v\n&quot;</span>, <span class="hljs-built_in">len</span>(slice3),slice3)<br><br><br></code></pre></td></tr></table></figure>
<p>判断一个切片是不是空的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">	<span class="hljs-comment">/* </span><br><span class="hljs-comment">	判断一个slice切片是不是为0</span><br><span class="hljs-comment">	*/</span><br>	<span class="hljs-keyword">if</span> slice1 == <span class="hljs-literal">nil</span>&#123;<br>		fmt.Println(<span class="hljs-string">&quot;slice1 is null&quot;</span>)<br>	&#125;<span class="hljs-keyword">else</span>&#123;<br>		fmt.Println(<span class="hljs-string">&quot;slice1 is not null&quot;</span>)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意if-else的格式有要求，<code>&#123;</code>必须是出现在else和if紧接着的位置，不能换行写</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203211744713.png" alt="判断当前的动态数组是不是空的" style="zoom:67%;" /></p>
<h4 id="append和copy">append()和copy()</h4>
<p>如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203213134825.png" alt="追加元素的操作显示" style="zoom:67%;" /></p>
<p><strong>注意，如果append超过了当前的空间，那么slice就会继续增加空间，增加的大小是cap的大小增加</strong></p>
<p>拷贝copy()操作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* 创建切片 numbers1 是之前切片的两倍容量*/</span><br>   numbers1 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(numbers), (<span class="hljs-built_in">cap</span>(numbers))*<span class="hljs-number">2</span>)<br><br><br>   <span class="hljs-comment">/* 拷贝 numbers 的内容到 numbers1 */</span><br>   <span class="hljs-built_in">copy</span>(numbers1,numbers)<br>   printSlice(numbers1)  <br></code></pre></td></tr></table></figure>
<p>关于切片的截取操作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* </span><br><span class="hljs-comment">	切片的截取 </span><br><span class="hljs-comment">	*/</span><br>	<span class="hljs-keyword">var</span> slice6 = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">3</span>)<br>	slice6[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span><br>	slice6[<span class="hljs-number">2</span>]=<span class="hljs-number">33</span><br>	fmt.Printf(<span class="hljs-string">&quot;len = %d, cap = %d, slice =%v\n&quot;</span>, <span class="hljs-built_in">len</span>(slice6), <span class="hljs-built_in">cap</span>(slice6), slice6)<br>	<span class="hljs-comment">//截取的过程中是左闭右开</span><br>	s1:=slice6[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]<br>	<span class="hljs-comment">// s1:=slice6[:]//表示截取全部</span><br>	fmt.Println(s1)<br>	<span class="hljs-comment">//注意此时的s1的地址和slice6的位置一样了</span><br><br>	<span class="hljs-comment">//copy</span><br>	<span class="hljs-keyword">var</span> s2 = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">3</span>)<br>	<span class="hljs-built_in">copy</span>(s2,slice6)<br>	fmt.Println(s2)<span class="hljs-comment">// 只会从头开始截取s2长度的，如果长了那么就是0，</span><br>	<span class="hljs-comment">//否则就是选择slice6中相同长度的元素，从左到右边</span><br></code></pre></td></tr></table></figure>
<h3 id="map">map</h3>
<p>map和slice类似，只不过是数据结构不同，下面是map的一些声明方式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//第一种声明</span><br>    <span class="hljs-keyword">var</span> test1 <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span><br>    <span class="hljs-comment">//在使用map前，需要先make，make的作用就是给map分配数据空间</span><br>    test1 = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>, <span class="hljs-number">10</span>) <br>    test1[<span class="hljs-string">&quot;one&quot;</span>] = <span class="hljs-string">&quot;php&quot;</span><br>    test1[<span class="hljs-string">&quot;two&quot;</span>] = <span class="hljs-string">&quot;golang&quot;</span><br>    test1[<span class="hljs-string">&quot;three&quot;</span>] = <span class="hljs-string">&quot;java&quot;</span><br>    fmt.Println(test1) <span class="hljs-comment">//map[two:golang three:java one:php]</span><br><br><br>    <span class="hljs-comment">//第二种声明</span><br>    test2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)<br>    test2[<span class="hljs-string">&quot;one&quot;</span>] = <span class="hljs-string">&quot;php&quot;</span><br>    test2[<span class="hljs-string">&quot;two&quot;</span>] = <span class="hljs-string">&quot;golang&quot;</span><br>    test2[<span class="hljs-string">&quot;three&quot;</span>] = <span class="hljs-string">&quot;java&quot;</span><br>    fmt.Println(test2) <span class="hljs-comment">//map[one:php two:golang three:java]</span><br><br>    <span class="hljs-comment">//第三种声明</span><br>    test3 := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<br>        <span class="hljs-string">&quot;one&quot;</span> : <span class="hljs-string">&quot;php&quot;</span>,<br>        <span class="hljs-string">&quot;two&quot;</span> : <span class="hljs-string">&quot;golang&quot;</span>,<br>        <span class="hljs-string">&quot;three&quot;</span> : <span class="hljs-string">&quot;java&quot;</span>,<br>    &#125;<br>    fmt.Println(test3) <span class="hljs-comment">//map[one:php two:golang three:java]</span><br><br><br>    <br>    language := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)<br>    language[<span class="hljs-string">&quot;php&quot;</span>] = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>, <span class="hljs-number">2</span>)<br>    language[<span class="hljs-string">&quot;php&quot;</span>][<span class="hljs-string">&quot;id&quot;</span>] = <span class="hljs-string">&quot;1&quot;</span><br>    language[<span class="hljs-string">&quot;php&quot;</span>][<span class="hljs-string">&quot;desc&quot;</span>] = <span class="hljs-string">&quot;php是世界上最美的语言&quot;</span><br>    language[<span class="hljs-string">&quot;golang&quot;</span>] = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>, <span class="hljs-number">2</span>)<br>    language[<span class="hljs-string">&quot;golang&quot;</span>][<span class="hljs-string">&quot;id&quot;</span>] = <span class="hljs-string">&quot;2&quot;</span><br>    language[<span class="hljs-string">&quot;golang&quot;</span>][<span class="hljs-string">&quot;desc&quot;</span>] = <span class="hljs-string">&quot;golang抗并发非常good&quot;</span><br>    <br>    fmt.Println(language) <span class="hljs-comment">//map[php:map[id:1 desc:php是世界上最美的语言] golang:map[id:2 desc:golang抗并发非常good]]</span><br><br><br>    <span class="hljs-comment">//增删改查</span><br>    <span class="hljs-comment">// val, key := language[&quot;php&quot;]  //查找是否有php这个子元素</span><br>    <span class="hljs-comment">// if key &#123;</span><br>    <span class="hljs-comment">//     fmt.Printf(&quot;%v&quot;, val)</span><br>    <span class="hljs-comment">// &#125; else &#123;</span><br>    <span class="hljs-comment">//     fmt.Printf(&quot;no&quot;);</span><br>    <span class="hljs-comment">// &#125;</span><br><br>    <span class="hljs-comment">//language[&quot;php&quot;][&quot;id&quot;] = &quot;3&quot; //修改了php子元素的id值</span><br>    <span class="hljs-comment">//language[&quot;php&quot;][&quot;nickname&quot;] = &quot;啪啪啪&quot; //增加php元素里的nickname值</span><br>    <span class="hljs-comment">//delete(language, &quot;php&quot;)  //删除了php子元素</span><br>    fmt.Println(language)<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="面向对象结构体">面向对象结构体</h3>
<h4 id="定义一个结构体">定义一个结构体</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//定义一个结构体</span><br><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>    name <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>分别定义不同的拷贝和引用的函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t T)</span></span> method1() &#123;<br>    t.name = <span class="hljs-string">&quot;new name1&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span></span> method2() &#123;<br>    t.name = <span class="hljs-string">&quot;new name2&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>结果是使用值拷贝的输出的name没有改变，只有使用引用的才发生了改变</p>
<p>关于结构体定义的细节，内部的成员变量和结构体本身的大小写就是蕴含了是不是私有和公有的关系，大写标识公有，小写表示私有</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 如果这个类如果是大写，那么其他的Package也能够访问</span><br><span class="hljs-keyword">type</span> Human <span class="hljs-keyword">struct</span> &#123;<br>	Name <span class="hljs-type">string</span> <span class="hljs-comment">//其中变量名称表示大写说明是能够对外界可见的public</span><br>	Age  <span class="hljs-type">int</span><br>	<span class="hljs-comment">//如果是小写那么就是private的属性</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>对于结构体内部的成员函数，必须是传递了引用的地址才能够修改，否则就是默认的值传递</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Human)</span></span> GetName() &#123;<br>	fmt.Println(this.Name)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Human)</span></span> SetName(newname <span class="hljs-type">string</span>) &#123;<br>	<span class="hljs-comment">//只有是引用地址的传递的时候才是能够修改的</span><br>	this.Name = newname<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this Human)</span></span> SetName1(newname <span class="hljs-type">string</span>) &#123;<br>	<span class="hljs-comment">//默认是值传递</span><br>	this.Name = newname<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="类的继承性">类的继承性</h4>
<p>如果新定义的类继承了某个类，那么只需要在内部写上所继承的类的名称，同时这里没有C++中的公有保护等其他类型的继承，公有私有的设定保持一致</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Superman <span class="hljs-keyword">struct</span> &#123;<br>	Human <span class="hljs-comment">//表示Superman继承了Human，同时这里没有C++中的公有保护等其他类型的继承</span><br>	<span class="hljs-comment">//在子类中重新增加变量</span><br>	Level <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>对继承类中的方法重写，同样传递的还是引用和指针</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 对于父类方法进行重写</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Superman)</span></span> GetName() &#123;<br>	fmt.Println(this.Name)<br>	fmt.Println(this.Level)<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>重新定义新的方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 子类中的新方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Superman)</span></span> LevelUp() &#123;<br>	fmt.Println(<span class="hljs-string">&quot;level up&quot;</span>)<br>	this.Level = this.Level + <span class="hljs-number">1</span><br>	fmt.Println(this)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>关于主函数中的调用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	human := Human&#123;Name: <span class="hljs-string">&quot;zhang&quot;</span>, Age: <span class="hljs-number">99</span>&#125;<br>	human.SetName1(<span class="hljs-string">&quot;li&quot;</span>)<br>	fmt.Println(human) <span class="hljs-comment">//&#123;zhang 99&#125;</span><br>	human.SetName(<span class="hljs-string">&quot;li&quot;</span>)<br>	fmt.Println(human) <span class="hljs-comment">//&#123;li 99&#125;</span><br>	human.GetName()<br>	fmt.Println(<span class="hljs-string">&quot;-------------&quot;</span>)<br>	superman := Superman&#123;Human&#123;<span class="hljs-string">&quot;li4&quot;</span>, <span class="hljs-number">18</span>&#125;, <span class="hljs-number">99</span>&#125;<br>	<span class="hljs-comment">//父类方法的重写</span><br>	superman.GetName()<br>	<span class="hljs-comment">//子类新方法</span><br>	superman.LevelUp()<br>	<span class="hljs-comment">/* level up</span><br><span class="hljs-comment">	&amp;&#123;&#123;li4 18&#125; 100&#125;	 */</span><br>	<span class="hljs-comment">//父类方法原封不动</span><br>	superman.SetName(<span class="hljs-string">&quot;wang5&quot;</span>)<br>	fmt.Println(superman) <span class="hljs-comment">//&#123;&#123;wang5 18&#125; 100&#125;</span><br><br>	fmt.Println(<span class="hljs-string">&quot;+++++++++++++&quot;</span>)<br>	<span class="hljs-comment">//第二种继承类对象的声明</span><br>	<span class="hljs-keyword">var</span> super Superman<br>	super.Name = <span class="hljs-string">&quot;zhangmazi&quot;</span><br>	super.Level = <span class="hljs-number">100</span><br>	super.Age = <span class="hljs-number">19</span><br>	fmt.Println(super)<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="interface与类型断言">Interface与类型断言</h3>
<p>在继承和多态上，一系列家族定义的接口，<strong>每个子类能够重写方法</strong>，实现同一个方法有多个接口表现形式</p>
<h4 id="类的多态性">类的多态性</h4>
<p>本质上利用interface来实现类的多态性</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 本质是一个指针多态</span><br><span class="hljs-keyword">type</span> Animal <span class="hljs-keyword">interface</span> &#123;<br>	<span class="hljs-comment">//给出接口包含的多态的函数</span><br>	Sleep()<br>	GetColor() <span class="hljs-type">string</span><br>	GetType() <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">// 定义一个具体的类</span><br><span class="hljs-keyword">type</span> Cat <span class="hljs-keyword">struct</span> &#123;<br>	<span class="hljs-comment">/*如果继承一个接口interface 那么就不需要直接写出来继承，</span><br><span class="hljs-comment">	只需要进行实现就可以认为继承了这个接口inerface</span><br><span class="hljs-comment">	*/</span><br>	color <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">// 第二个多态的类</span><br><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span> &#123;<br>	<span class="hljs-comment">//同样需要进行继承这个interface</span><br>	color <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>那怎么认为这个cat继承了这个animal类呢？只需要对animal中的所有函数重写即可认为是继承了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* 必须要完全重写所有的接口才能认为是多态满足 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Cat)</span></span> Sleep() &#123;<br>	fmt.Println(<span class="hljs-string">&quot;cat sleep...&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Cat)</span></span> GetColor() <span class="hljs-type">string</span> &#123;<br>	fmt.Printf(<span class="hljs-string">&quot;the cat color is %v\n&quot;</span>, this.color)<br>	<span class="hljs-keyword">return</span> this.color<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Cat)</span></span> GetType() <span class="hljs-type">string</span> &#123;<br>	fmt.Printf(<span class="hljs-string">&quot;the type is cat\n&quot;</span>)<br>	<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Cat&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>同理对于dog也是一样</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Dog)</span></span> Sleep() &#123;<br>	fmt.Println(<span class="hljs-string">&quot;dog sleep...&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Dog)</span></span> GetColor() <span class="hljs-type">string</span> &#123;<br>	fmt.Printf(<span class="hljs-string">&quot;the dog color is %v\n&quot;</span>, this.color)<br>	<span class="hljs-keyword">return</span> this.color<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Dog)</span></span> GetType() <span class="hljs-type">string</span> &#123;<br>	fmt.Printf(<span class="hljs-string">&quot;the type is dog\n&quot;</span>)<br>	<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Dog&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>主函数中如何实现不同的多态调用呢？注意哦，这个地方传递的是继承类的引用进去来实现多态</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">showanimal</span><span class="hljs-params">(animal Animal)</span></span> &#123;<br>	animal.Sleep()<br>	<span class="hljs-comment">// fmt.Println(&quot;color = &quot;,animal.GetColor())</span><br>	<span class="hljs-comment">// fmt.Println(&quot;type = &quot;,animal.GetType())</span><br>	animal.GetType()<br>	animal.GetColor()<br>&#125;<br><br><br>	cat := Cat&#123;<span class="hljs-string">&quot;Green&quot;</span>&#125;<br>	dog := Dog&#123;<span class="hljs-string">&quot;Yellow&quot;</span>&#125;<br><br>	<span class="hljs-comment">//通过传递指针和引用来实现多态性</span><br>	showanimal(&amp;cat)<br>	showanimal(&amp;dog)<br></code></pre></td></tr></table></figure>
<h4 id="万能类型interface">万能类型interface</h4>
<p>golang中的所有程序都实现了interface{}的接口，这意味着，所有的类型如string,int,int64甚至是自定义的struct类型都就此拥有了<code>interface&#123;&#125;</code>的接口，这种做法和java中的Object类型比较类似。那么在一个数据通过<code>func funcName(interface&#123;&#125;)</code>的方式传进来的时候，也就意味着这个参数被自动的转为<code>interface&#123;&#125;</code>的类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">funcName</span><span class="hljs-params">(a <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">string</span> &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(a)<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>interface&#123;&#125;</code>相当于是一个万能的数据类型，适用于对任何的函数的参数传递中的使用</p>
<ul>
<li>直接断言使用</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-keyword">interface</span>&#123;&#125;<br>fmt.Println(<span class="hljs-string">&quot;Where are you,Jonny?&quot;</span>, a.(<span class="hljs-type">string</span>))<br></code></pre></td></tr></table></figure>
<p>如果断言失败一般会导致panic的发生。所以为了防止panic的发生，我们需要在断言前进行一定的判断</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">value, ok := a.(<span class="hljs-type">string</span>)<br></code></pre></td></tr></table></figure>
<p>如果断言失败，<strong>那么ok的值将会是false,但是如果断言成功ok的值将会是true</strong>，同时value将会得到所期待的正确的值。</p>
<h5 id="interface的例子">interface{}的例子</h5>
<p>定义一个断言类型的函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunc</span><span class="hljs-params">(arg <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>	fmt.Println(<span class="hljs-string">&quot;myfunc is called...&quot;</span>)<br>	fmt.Println(arg)<br><br>	<span class="hljs-comment">//interface&#123;&#125;如何确定类型是什么呢？</span><br><br>	<span class="hljs-comment">//类型断言机制 用于判断是什么类型</span><br>	value, ok := arg.(<span class="hljs-type">string</span>)<br>	<span class="hljs-keyword">if</span> !ok &#123;<br>		fmt.Println(<span class="hljs-string">&quot;arg is not a string&quot;</span>)<br>		fmt.Printf(<span class="hljs-string">&quot;the value is %T\n&quot;</span>, arg) <span class="hljs-comment">//the value is main.Book</span><br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		fmt.Println(<span class="hljs-string">&quot;arg is string type,is = &quot;</span>, value)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>主函数的调用关系如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Book <span class="hljs-keyword">struct</span> &#123;<br>	auth <span class="hljs-type">string</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	book := Book&#123;<span class="hljs-string">&quot;golang&quot;</span>&#125;<br>	myFunc(book) <span class="hljs-comment">//&#123;golang&#125;</span><br>	myFunc(<span class="hljs-number">100</span>)  <span class="hljs-comment">//100</span><br>	myFunc(<span class="hljs-string">&quot;goland&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>输出的内容是：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#输出的值</span><br>myfunc is called...<br>&#123;golang&#125;<br>arg is not a string<br>the value is main.Book<br>myfunc is called...<br>100<br>arg is not a string<br>the value is int<br>myfunc is called...<br>goland<br></code></pre></td></tr></table></figure>
<h3 id="reflect反射">Reflect反射</h3>
<p>在讲反射之前，先来看看Golang关于类型设计的一些原则</p>
<ul>
<li>变量包括（type, value）两部分</li>
<li>type 包括 <code>static type</code>和<code>concrete type</code>.
简单来说
<code>static type</code>是你在编码是看见的类型(如int、string)，<code>concrete type</code>是<code>runtime</code>系统看见的类型</li>
<li>类型断言能否成功，取决于变量的<code>concrete type</code>，而不是<code>static type</code>.
因此，一个
<code>reader</code>变量如果它的<code>concrete type</code>也实现了<code>write</code>方法的话，它也可以被类型断言为<code>writer</code>.</li>
</ul>
<p><code>反射</code>，就是建立在类型之上的，Golang的指定类型的变量的类型是静态的（也就是指定int、string这些的变量，它的type是static
type），在创建变量的时候就已经确定，<strong>反射主要与Golang的interface类型相关</strong>（它的type是concrete
type），<strong>只有interface类型才有反射一说</strong></p>
<p>在Golang的实现中，每个<code>interface</code>变量都有一个对应<code>pair</code>，pair中记录了实际变量的值和类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">(value, <span class="hljs-keyword">type</span>)<br></code></pre></td></tr></table></figure>
<p>value是实际变量值，type是实际变量的类型。一个<code>interface&#123;&#125;</code>类型的变量包含了2个指针，一个指针指向值的<strong>类型<code>concrete type</code></strong>，另外一个指针指向<strong>实际的值对应<code>value</code></strong></p>
<h4 id="reflect的基本功能">reflect的基本功能</h4>
<p><strong>reflect的反射类型对象：TypeOf和ValueOf</strong></p>
<p>那么在Golang的reflect反射包中有什么样的方式可以让我们直接获取到变量内部的信息呢？
它提供了两种类型（或者说两个方法）让我们可以很容易的访问接口变量内容，分别是<code>reflect.ValueOf()</code>
和 <code>reflect.TypeOf()</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// ValueOf returns a new Value initialized to the concrete value</span><br><span class="hljs-comment">// stored in the interface i.  ValueOf(nil) returns the zero </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ValueOf</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> Value &#123;...&#125;<br><br><span class="hljs-comment">//ValueOf用来获取输入参数接口中的数据的值，如果接口为空则返回0</span><br><br><br><span class="hljs-comment">// TypeOf returns the reflection Type that represents the dynamic type of i.</span><br><span class="hljs-comment">// If i is a nil interface value, TypeOf returns nil.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TypeOf</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> Type &#123;...&#125;<br><br><span class="hljs-comment">//TypeOf用来动态获取输入参数接口中的值的类型，如果接口为空则返回nil</span><br></code></pre></td></tr></table></figure>
<p><code>reflect.TypeOf()</code>是获取pair中的type，<code>reflect.ValueOf()</code>获取pair中的value，示例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> num <span class="hljs-type">float64</span> = <span class="hljs-number">1.2345</span><br><br>    fmt.Println(<span class="hljs-string">&quot;type: &quot;</span>, reflect.TypeOf(num))<br>    fmt.Println(<span class="hljs-string">&quot;value: &quot;</span>, reflect.ValueOf(num))<br>&#125;<br><br>运行结果:<br><span class="hljs-keyword">type</span>:  <span class="hljs-type">float64</span><br>value:  <span class="hljs-number">1.2345</span><br></code></pre></td></tr></table></figure>
<p>说明：</p>
<ol type="1">
<li><strong>reflect.TypeOf：</strong>
直接给到了我们想要的type类型，如float64、int、各种pointer、struct
等等真实的类型</li>
<li><strong>reflect.ValueOf：</strong>直接给到了我们想要的具体的值，如1.2345这个具体数值，或者类似&amp;{1
"Allen.Wu" 25} 这样的结构体struct的值</li>
<li>反射可以将“接口类型变量”转换为“反射类型对象”，反射类型指的是<code>reflect.Type</code>和<code>reflect.Value这</code>两种</li>
</ol>
<h4 id="reflet例子1">reflet例子1:</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reflectNum</span><span class="hljs-params">(arg <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>	fmt.Println(<span class="hljs-string">&quot;type:&quot;</span>, reflect.TypeOf(arg))<br>	fmt.Println(<span class="hljs-string">&quot;value:&quot;</span>, reflect.ValueOf(arg))<br>&#125;<br></code></pre></td></tr></table></figure>
<p>主函数的调用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">var</span> num <span class="hljs-type">float64</span> = <span class="hljs-number">1.2345</span><br>	reflectNum(num)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意，在使用反射之前需要引入<strong>reflect的包</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;reflect&quot;</span><br>)<br></code></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> num <span class="hljs-type">float64</span> = <span class="hljs-number">1.2345</span><br><br>    pointer := reflect.ValueOf(&amp;num)<br>    value := reflect.ValueOf(num)<br><br>    <span class="hljs-comment">// 可以理解为“强制转换”，但是需要注意的时候，转换的时候，如果转换的类型不完全符合，则直接panic</span><br>    <span class="hljs-comment">// Golang 对类型要求非常严格，类型一定要完全符合</span><br>    <span class="hljs-comment">// 如下两个，一个是*float64，一个是float64，如果弄混，则会panic</span><br>    convertPointer := pointer.Interface().(*<span class="hljs-type">float64</span>)<br>    convertValue := value.Interface().(<span class="hljs-type">float64</span>)<br><br>    fmt.Println(convertPointer)<br>    fmt.Println(convertValue)<br>&#125;<br><br>运行结果：<br><span class="hljs-number">0xc42000e238</span><br><span class="hljs-number">1.2345</span><br></code></pre></td></tr></table></figure>
<h4 id="reflet例子2">reflet例子2:</h4>
<ul>
<li><p>首先定义一个类以及关于这个类的方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>	Id   <span class="hljs-type">int</span><br>	Name <span class="hljs-type">string</span><br>	Age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this User)</span></span> Call() &#123; <span class="hljs-comment">//为什么这个地方返回类型不是*</span><br>	fmt.Println(<span class="hljs-string">&quot;user is called ..&quot;</span>)<br>	fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, this)<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>再定义一个利用反射选择类中值和方法的函数</p></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DoFiledAndMethod</span><span class="hljs-params">(input <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>	<span class="hljs-comment">//获取输入的类型type</span><br>	inputType := reflect.TypeOf(input)<br>	fmt.Println(<span class="hljs-string">&quot;input type is: &quot;</span>, inputType.Name())<br>	<span class="hljs-comment">//output: input type is:  User</span><br><br>	<span class="hljs-comment">//获取input的value</span><br>	inputValue := reflect.ValueOf(input)<br>	fmt.Println(<span class="hljs-string">&quot;input value is: &quot;</span>, inputValue)<br>	<span class="hljs-comment">//output: input value is:  &#123;1 eric 19&#125;</span><br><br>	<span class="hljs-comment">//通过type获取其中的字段</span><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">		1、获取interface中的reflect的type, 通过type得到numfield，进行遍历</span><br><span class="hljs-comment">		2、得到每个filed，就是数据类型</span><br><span class="hljs-comment">		3、通过filed中有一个interface()方法得到对应的value</span><br><span class="hljs-comment">	*/</span><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; inputType.NumField(); i++ &#123;<br>		field := inputType.Field(i)<br>		<span class="hljs-comment">// value:=inputType.Field&#123;i&#125;.interface()</span><br>		value := inputValue.Field(i).Interface()<br>		<span class="hljs-comment">// fmt.Println(field) //&#123;Id  int  0 [0] false&#125;、&#123;Name  string  8 [1] false&#125;</span><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">			每个field表示的就是一行的元素内容，其中Name表示了这一行的变量名， Type表示的是这一行的类型</span><br><span class="hljs-comment">			通过value单独存在field里面，根据索引值寻找通过Interface()调用</span><br><span class="hljs-comment">		*/</span><br>		fmt.Printf(<span class="hljs-string">&quot;%s: %v = %v\n&quot;</span>, field.Name, field.Type, value)<br><br>	&#125;<br><br>	<span class="hljs-comment">/* 如何遍历选择方法呢</span><br><span class="hljs-comment">	也是根据inputType来进行划分</span><br><span class="hljs-comment">	*/</span><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; inputType.NumMethod(); i++ &#123;<br>		m := inputType.Method(i)<br>		fmt.Printf(<span class="hljs-string">&quot;%s: %v\n&quot;</span>, m.Name, m.Type)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意点：</p>
<ol type="1">
<li><strong>reflect.TypeOf</strong>(input)得到类型</li>
<li><strong>reflect.ValueOf</strong>(input)得到对应的值</li>
<li><strong>reflect.TypeOf</strong>(input).<strong>NumField()</strong>的方法是获得interface()中的所有的字段</li>
<li>如果选择字段中的类型： <strong>inputType.Field(i) =
reflect.TypeOf(input).Field(i)</strong></li>
<li>如果选择字段中的值：<strong>inputType.Field(i) =
reflect.TypeOf(input).Field(i).Interface()</strong></li>
<li>如果想便利interface中的方法：<strong>reflect.TypeOf</strong>(input).<strong>NumMethod()</strong>，其中具体的方法是：<strong>reflect.TypeOf(input).Method(i)</strong></li>
</ol>
<p>通过运行结果可以得知获取未知类型的interface的所属方法（函数）的步骤为：</p>
<ol type="1">
<li>先获取interface的reflect.Type，然后通过NumMethod进行遍历</li>
<li>再分别通过reflect.Type的Method获取对应的真实的方法（函数）</li>
<li>最后对结果取其Name和Type得知具体的方法名</li>
<li>也就是说反射可以将“反射类型对象”再重新转换为“接口类型变量”</li>
<li>struct 或者 struct 的嵌套都是一样的判断处理方式</li>
</ol>
<h4
id="通过reflect.value设置实际变量的值">通过reflect.Value设置实际变量的值</h4>
<p>reflect.Value是通过reflect.ValueOf(X)获得的，只有当X是指针的时候，才可以通过reflec.Value修改实际变量X的值，即：要修改反射类型的对象就一定要保证其值是“addressable”的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-keyword">var</span> num <span class="hljs-type">float64</span> = <span class="hljs-number">1.2345</span><br>    fmt.Println(<span class="hljs-string">&quot;old value of pointer:&quot;</span>, num)<br><br>    <span class="hljs-comment">// 通过reflect.ValueOf获取num中的reflect.Value，注意，参数必须是指针才能修改其值</span><br>    pointer := reflect.ValueOf(&amp;num)<br>    newValue := pointer.Elem()<br><br>    fmt.Println(<span class="hljs-string">&quot;type of pointer:&quot;</span>, newValue.Type())<br>    fmt.Println(<span class="hljs-string">&quot;settability of pointer:&quot;</span>, newValue.CanSet())<br><br>    <span class="hljs-comment">// 重新赋值</span><br>    newValue.SetFloat(<span class="hljs-number">77</span>)<br>    fmt.Println(<span class="hljs-string">&quot;new value of pointer:&quot;</span>, num)<br><br>    <span class="hljs-comment">////////////////////</span><br>    <span class="hljs-comment">// 如果reflect.ValueOf的参数不是指针，会如何？</span><br>    pointer = reflect.ValueOf(num)<br>    <span class="hljs-comment">//newValue = pointer.Elem() // 如果非指针，这里直接panic，“panic: reflect: call of reflect.Value.Elem on float64 Value”</span><br>&#125;<br><br>运行结果：<br>old value of pointer: <span class="hljs-number">1.2345</span><br><span class="hljs-keyword">type</span> of pointer: <span class="hljs-type">float64</span><br>settability of pointer: <span class="hljs-literal">true</span><br><span class="hljs-built_in">new</span> value of pointer: <span class="hljs-number">77</span><br></code></pre></td></tr></table></figure>
<ol type="1">
<li>需要传入的参数是*
float64这个指针，然后可以通过pointer.Elem()去获取所指向的Value，<strong>注意一定要是指针</strong>。</li>
<li>如果传入的参数不是指针，而是变量，那么</li>
</ol>
<ul>
<li><ul>
<li>通过Elem获取原始值对应的对象则直接panic</li>
<li>通过CanSet方法查询是否可以设置返回false</li>
</ul></li>
</ul>
<ol type="1">
<li>newValue.CantSet()表示是否可以重新设置其值，如果输出的是true则可修改，否则不能修改，修改完之后再进行打印发现真的已经修改了。</li>
<li>reflect.Value.Elem()
表示获取原始值对应的反射对象，只有原始对象才能修改，当前反射对象是不能修改的，是指只能修改原是对象的<strong>值的大小，不能修改地址</strong></li>
<li>newValue.SetFloat(77)重新设置值的操作，传递引用来修改interface中的值</li>
</ol>
<h4 id="反射的基本原理">反射的基本原理</h4>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231219205804430.png"
alt="反射基本原理总结" />
<figcaption aria-hidden="true">反射基本原理总结</figcaption>
</figure>
<h3 id="section"></h3>
<h3 id="结构体标签">结构体标签</h3>
<p>本质上还是利用了反射，通过以下形式给结构体中的变量添加标签作用：
其他包在调用这个当前包的时候对于某个属性的一个说明，指示某个包在具体使用中的作用。</p>
<p><strong>作用：能够将结构体转化为json格式</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;reflect&quot;</span><br>)<br><span class="hljs-keyword">type</span> resume <span class="hljs-keyword">struct</span>&#123;<br>	<span class="hljs-comment">/*  </span><br><span class="hljs-comment">	通过以下形式给结构体中的变量添加标签</span><br><span class="hljs-comment">	作用： 其他包在调用这个当前包的时候对于某个属性的一个说明，指示某个包在具体使用中的作用</span><br><span class="hljs-comment">	*/</span><br>	Name <span class="hljs-type">string</span> <span class="hljs-string">`info:&quot;name&quot; doc:&quot;我的名字&quot;`</span> <br>	Sex <span class="hljs-type">string</span> <span class="hljs-string">`info:&quot;sex&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findtag</span><span class="hljs-params">(str <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span>&#123;<br>	t :=reflect.TypeOf(str).Elem()<br><br>	<span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;t.NumField();i++&#123;<br>		tagstring:=t.Field(i).Tag.Get(<span class="hljs-string">&quot;info&quot;</span>)<br>		tagdoc:=t.Field(i).Tag.Get(<span class="hljs-string">&quot;doc&quot;</span>)<br>		fmt.Println(<span class="hljs-string">&quot;info:&quot;</span>,tagstring,<span class="hljs-string">&quot;doc&quot;</span>,tagdoc)<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">var</span> re resume<br>	findtag(&amp;re) <span class="hljs-comment">//注意这里传递的是引用</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231207215501791.png" alt="go printf的占位符格式" style="zoom:67%;" /></p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231207215514980.png" alt="go printf的占位符表示" style="zoom:67%;" /></p>
<p>输出之后在json格式转换中可以看到如下，注意可以看到的是输出的内容是根据给定的tag来进行标题的命名的</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231207215859488.png" alt="转化为json格式的例子" style="zoom:67%;" /></p>
<p>利用反射取出元素查询</p>
<p>利用编码和解码对struct 和json之间的转化</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;encoding/json&quot;</span><br>)<br><br><span class="hljs-comment">//如何将结构体转化成json</span><br><span class="hljs-keyword">type</span> Movie <span class="hljs-keyword">struct</span>&#123;<br>	Title <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;title&quot;`</span>  <span class="hljs-comment">//就是告诉json库对应的变量的标签名字是这个</span><br>	Year <span class="hljs-type">int</span> <span class="hljs-string">`json:&quot;year&quot;`</span><br>	Price <span class="hljs-type">int</span> <span class="hljs-string">`json:&quot;rmb&quot;`</span><br>	Actors []<span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;actors&quot;`</span> <span class="hljs-comment">//slice `json:&quot;actors&quot;`</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	movie :=Movie&#123;<span class="hljs-string">&quot;喜剧之王&quot;</span>,<span class="hljs-number">2000</span>,<span class="hljs-number">10</span>,[]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;zhouxingchi&quot;</span>,<span class="hljs-string">&quot;zhangbozhi&quot;</span>&#125;&#125;<br><br>	<span class="hljs-comment">//编码的过程就是将 struct--&gt;json</span><br><br>	jsonStr,err:=json.Marshal(movie)<br><br>	<span class="hljs-comment">//返回两个字段</span><br><br>	<span class="hljs-keyword">if</span> err!=<span class="hljs-literal">nil</span>&#123;<br>		fmt.Println(<span class="hljs-string">&quot;json marshal error&quot;</span>,err)<br>		<span class="hljs-keyword">return</span><br>	&#125;<br>	fmt.Printf(<span class="hljs-string">&quot;jsonStr=%s\n&quot;</span>,jsonStr )<br>	<span class="hljs-comment">/* jsonStr=&#123;&quot;title&quot;:&quot;喜剧之王&quot;,&quot;year&quot;:2000,&quot;rmb&quot;:10,&quot;Actors&quot;:[&quot;zhouxingchi&quot;,&quot;zhangbozhi&quot;]&#125; */</span><br><br>	<span class="hljs-comment">//解码过程：json--&gt;struct</span><br>	<span class="hljs-comment">//jsonStr=&#123;&quot;title&quot;:&quot;喜剧之王&quot;,&quot;year&quot;:2000,&quot;rmb&quot;:10,&quot;actors&quot;:[&quot;zhouxingchi&quot;,&quot;zhangbozhi&quot;]&#125;</span><br><br>	myMovie:=Movie&#123;&#125;<br>	<span class="hljs-comment">//注意这个地方传递的参量是引用</span><br>	err=json.Unmarshal(jsonStr,&amp;myMovie)<br>	<span class="hljs-keyword">if</span> err!=<span class="hljs-literal">nil</span>&#123;<br>		fmt.Println(<span class="hljs-string">&quot;json unmashal error&quot;</span>,err)<br>		<span class="hljs-keyword">return</span> <br>	&#125;<br>	fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>,myMovie)<br>	<span class="hljs-comment">//返回结构体</span><br>	<span class="hljs-comment">//&#123;喜剧之王 2000 10 [zhouxingchi zhangbozhi]&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>【基础工具】Linux指令集</title>
    <url>/2023/11/25/linux/</url>
    <content><![CDATA[<h2 id="linux命令集">Linux命令集</h2>
<h4 id="查看当前路径的位置-pwd">查看当前路径的位置 pwd</h4>
<h4 id="查看命令历史">查看命令历史</h4>
<p>终端中输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">history</span><br></code></pre></td></tr></table></figure>
<h4 id="指定查找关键字">指定查找关键字</h4>
<p>通过增加grep来增加关键字的筛选</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">| grep GOPROXY<br></code></pre></td></tr></table></figure>
<h4 id="当前目录下的文件">当前目录下的文件</h4>
<ul>
<li>当前目录下的文件 ls</li>
<li>ls -l；ls-h；都是用来显示文件的详细信息</li>
<li>ls -a 来显示所有的文件（包含隐藏文件）</li>
<li>组合使用 ls -lha 显示所有并包含的隐藏文件且显示详细信息</li>
<li>使用dir显示当前文件夹下的文件名*</li>
</ul>
<h4 id="切换文件夹">切换文件夹</h4>
<ul>
<li><p>cd .. <em>#返回父级目录</em></p></li>
<li><table>
<thead>
<tr class="header">
<th style="text-align: center;">cd</th>
<th>切换到当前用户的主目录(/home/用户目录)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">cd ~</td>
<td>切换到当前用户的主目录(/home/用户目录)</td>
</tr>
<tr class="even">
<td style="text-align: center;">cd .</td>
<td>保持在当前目录不变</td>
</tr>
<tr class="odd">
<td style="text-align: center;">cd …</td>
<td>切换到上级目录</td>
</tr>
<tr class="even">
<td style="text-align: center;">cd -</td>
<td>可以在最近两次工作目录之间来回切换</td>
</tr>
</tbody>
</table></li>
<li><p>相对路径 在输入路径时，最前面不是 / 或者 ~，表示相对 当前目录
所在的目录位置 绝对路径 在输入路径时，最前面是 / 或者 ~，表示从
<strong>根目录/家目录</strong> 开始的具体目录位置</p></li>
</ul>
<h4 id="移动文件到指定位置-mv">移动文件到指定位置 mv</h4>
<ul>
<li><p>mv <u>文件名</u> <u>指定的路径位置</u> -i 用于提示</p></li>
<li><p>修改文件夹名称：mv 原来的文件夹名称 后来的文件夹名称</p></li>
<li><h6 id="拷贝某个文件夹到指定路径">拷贝某个文件夹到指定路径</h6>
<ul>
<li><p>cp <u>当前文件夹下某个文件名</u>（带后缀） <u>目标路径</u> -i
用于提示</p>
<table>

<thead>
<tr class="header">
<th>命令</th>
<th>对应英文</th>
<th>作用</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>01</td>
<td>tree [目录名]</td>
<td>tree</td>
<td>以树状图列出文件目录结构</td>
</tr>
<tr class="even">
<td>02</td>
<td>cp 源文件目标文件</td>
<td>copy</td>
<td>复制文件或者目录</td>
</tr>
<tr class="odd">
<td>03</td>
<td>mv 源文件 目标文件</td>
<td>move</td>
<td>移动文件或者目录／文件或者目录重命名</td>
</tr>
</tbody>
</table></li>
</ul></li>
</ul>
<h4 id="创建文件夹">创建文件夹</h4>
<ul>
<li>进入路径的位置 mkdir <u>需要创建的文件夹的名称</u></li>
<li>递归创建文件夹 mkdir -p 123/456
<u>在123文件夹下递归创建文件夹456</u></li>
</ul>
<h4 id="新建某个文件">新建某个文件</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> 123.txt<br></code></pre></td></tr></table></figure>
<h4 id="删除文件夹">删除文件夹</h4>
<ul>
<li>rmdir+ 需要删除的文件名</li>
</ul>
<h4 id="删除某个文件">删除某个文件</h4>
<ul>
<li><p>使用rm来对文件进行删除 -i 进行删除前的查询</p></li>
<li><table>
<thead>
<tr class="header">
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-f</td>
<td>强制删除，忽略不存在的文件，无需提示</td>
</tr>
<tr class="even">
<td>-r</td>
<td>递归地删除目录下的内容，<strong>删除文件夹
时必须加此参数</strong></td>
</tr>
</tbody>
</table></li>
</ul>
<h4 id="解压缩文件的指令">解压缩文件的指令</h4>
<ul>
<li><h5 id="对于zip文件的操作">对于ZIP文件的操作</h5>
<ul>
<li>解压操作：进入需要解压的文件的位置：<strong>unzip
filename.zip</strong></li>
<li>压缩文件：同理进入需要解压的文件夹的上一级 zip filename.zip</li>
</ul></li>
</ul>
<h4 id="linux中查看系统使用情况">Linux中查看系统使用情况</h4>
<ul>
<li><p>Top 来显示CPU的占用情况：</p>
<blockquote>
<table>

<thead>
<tr class="header">
<th>PID</th>
<th>进程的ID</th>
<th>USER</th>
<th>进程所有者</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>PR</strong></td>
<td>进程的优先级别，越小越优先被执行</td>
<td><strong>NInice</strong></td>
<td>值</td>
</tr>
<tr class="even">
<td><strong>VIRT</strong></td>
<td>进程占用的虚拟内存</td>
<td><strong>RES</strong></td>
<td>进程占用的物理内存</td>
</tr>
<tr class="odd">
<td><strong>SHR</strong></td>
<td>进程使用的共享内存</td>
<td>S</td>
<td>进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数</td>
</tr>
<tr class="even">
<td><strong>%CPU</strong></td>
<td>进程占用CPU的使用率</td>
<td><strong>%MEM</strong></td>
<td>进程使用的物理内存和总内存的百分比</td>
</tr>
<tr class="odd">
<td><strong>TIME+</strong></td>
<td>该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值</td>
<td><strong>COMMAND</strong></td>
<td>进程启动命令名称</td>
</tr>
</tbody>
</table>
</blockquote></li>
<li><p><strong>top</strong>退出方式是==用q进行退出==</p></li>
<li><p><strong>free</strong>查看内存的使用情况</p>
<blockquote>
<table>

<thead>
<tr class="header">
<th>total</th>
<th>总计物理内存的大小</th>
<th>used</th>
<th>已使用多大</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>free</strong></td>
<td>可用有多少</td>
<td><strong>Shared</strong></td>
<td>多个进程共享的内存总额</td>
</tr>
<tr class="even">
<td><strong>Buffers/cached</strong></td>
<td>磁盘缓存的大小</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</blockquote></li>
<li><p><strong>vmstat</strong>指令也是用于查看内存的使用</p>
<blockquote>
<ul>
<li><p><strong>Procs(进程)</strong>： r:
运行队列中进程数量，这个值也可以判断是否需要增加CPU。(长期大于1) b:
等待IO的进程数量</p></li>
<li><p><strong>Memory(内存)</strong>：swpd: 使用虚拟内存大小；free:
空闲物理内存大小；buff: 用作缓冲的内存大小；cache:
用作缓存的内存大小</p></li>
<li><p><strong>Swap</strong>： si:
每秒从交换区写到内存的大小，由磁盘调入内存；so:
每秒写入交换区的内存大小，由内存调入磁盘</p></li>
<li><p><strong>IO</strong>：bi: 每秒读取的块数，bo:
每秒写入的块数</p></li>
<li><p><strong>系统</strong>： in: 每秒中断数，包括时钟中断。 cs:
每秒上下文切换数。</p></li>
<li><p><strong>CPU(以百分比表示)</strong>：us:
用户进程执行时间百分比(user time) sy: 内核系统进程执行时间百分比(system
time) ；wa: IO等待时间百分比； id: 空闲时间百分比</p></li>
</ul>
</blockquote></li>
</ul>
<h4 id="查看系统的gpu">查看系统的GPU</h4>
<p>实时查看GPU使用情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">watch -n 1 nvidia-smi <br></code></pre></td></tr></table></figure>
<p>行代码的意思是只选择指定标号GPU进行使用，执行完该行代码之后python环境无法检测到指定GPU之外的其他</p>
<h4 id="系统环境变量">系统环境变量</h4>
<p>对于MACOS，用VIM进入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">vim ～/.zshrc<br></code></pre></td></tr></table></figure>
<p>添加环境变量的语句是，这里以增加路径为例子</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> GOPATH=<span class="hljs-string">&quot;user/workspace/golang&quot;</span><br></code></pre></td></tr></table></figure>
<p>添加完环境变量之后，激活一下设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.zshrc<br></code></pre></td></tr></table></figure>
<p>同样对于Linux系统而言也是相同的步骤</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">vim ~/.bashrc<br></code></pre></td></tr></table></figure>
<p>添加完成之后最后激活一下设定</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure>
<p>如果想直接查看当前某个环境变量的设置的值可以用以下的命令进行查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$GOPARH</span><br></code></pre></td></tr></table></figure>
<p>输出的值是当前的这个环境变量设置的值，比如会输出：user/workspace/golang</p>
<h4 id="显示linux系统的其他信息">显示Linux系统的其他信息</h4>
<h5 id="时间和日期">时间和日期</h5>
<table>
<thead>
<tr class="header">
<th>序号</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>01</td>
<td>date</td>
<td>查看系统时间</td>
</tr>
<tr class="even">
<td>02</td>
<td>cal</td>
<td>calendar 查看日历， -y 选项可以查看一年的日历</td>
</tr>
</tbody>
</table>
<h5 id="磁盘信息">磁盘信息</h5>
<table>
<thead>
<tr class="header">
<th>序号</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>01</td>
<td>df -h</td>
<td>disk free 显示磁盘剩余空间</td>
</tr>
<tr class="even">
<td>02</td>
<td>du -h [目录名]</td>
<td>disk usage 显示目录下的文件大小</td>
</tr>
</tbody>
</table>
<h5 id="进程信息">进程信息</h5>
<p>​ 所谓<strong>进程</strong>，通俗地说就是
<strong>当前正在执行的一个程序</strong></p>
<table>
<thead>
<tr class="header">
<th>序号</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>01</td>
<td>ps aux</td>
<td>process status 查看进程的详细状况</td>
</tr>
<tr class="even">
<td>02</td>
<td>top</td>
<td>动态显示运行中的进程并且排序</td>
</tr>
<tr class="odd">
<td>03</td>
<td>kill [-9] 进程代号</td>
<td>终止指定代号的进程， -9 表示强行终止</td>
</tr>
</tbody>
</table>
<h4 id="网络测试">网络测试</h4>
<p>​ ping 一般用于检测当前计算机到目标计算机之间的网络
<strong>是否通畅，数值越大，速度越慢</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-meta"># 检测到目标主机是否连接正常</span><br>$ ping IP地址 www.baidu.com<br><span class="hljs-meta"># 检测本地网卡工作正常</span><br>$ ping <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br></code></pre></td></tr></table></figure>
<h4 id="gpu运行指定">GPU运行指定</h4>
<ol type="1">
<li><p>首先先查看对应的GPU内存：<strong>nvidia-smi</strong></p></li>
<li><p>然后在终端输出代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">CUDA_VISIBLE_DEVICES=<span class="hljs-number">1</span> python your_model.py <br></code></pre></td></tr></table></figure>
<p>再或者使用
<code>**torch.cuda.set_device()**函数</code>指定gpu使用编号：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br>torch.cuda.set_device(<span class="hljs-number">2</span>) <span class="hljs-comment"># 使用2号GPU</span><br></code></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>基础工具</category>
      </categories>
      <tags>
        <tag>基础工具</tag>
        <tag>后端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>【基础工具】Git命令集</title>
    <url>/2023/10/23/git/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>
<p>Git
是一个版本控制系统，是任何软件开发项目中的主要内容。通常有两个主要用途：代码备份和代码版本控制。使用Git可以逐步处理代码，在需要回滚到备份副本的过程中保存每一步的进度。</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231206220759363.png"
alt="Git与GitHub" />
<figcaption aria-hidden="true">Git与GitHub</figcaption>
</figure>
<h2 id="git的安装与配置">Git的安装与配置</h2>
<h4 id="安装git">安装Git</h4>
<p>直接上官网下载安装</p>
<p><a
href="https://link.zhihu.com/?target=https%3A//git-scm.com/download">https://link.zhihu.com/?target=https%3A//git-scm.com/download</a></p>
<p><a href="https://git-scm.com/">https://git-scm.com/</a></p>
<p>或者MAC使用brew对git进行安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">brew install git<br></code></pre></td></tr></table></figure>
<h4 id="查看git中的配置">查看Git中的配置</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git config --list<br>git config --global user.email <span class="hljs-built_in">test</span>@163.com<br>git config --global user.name <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure>
<h4 id="检查是否安装成功">检查是否安装成功</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git version<br></code></pre></td></tr></table></figure>
<h2 id="git的基本控制">Git的基本控制</h2>
<h3 id="初始化git仓库">初始化Git仓库</h3>
<p>当完成上述的配置之后，就能开始初始化Git仓库，进入需要创建<strong>工作区</strong>workspace的文件夹输出git初始化的操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> workspace<br>git init<br></code></pre></td></tr></table></figure>
<p>创建一个名为 .git
的新子目录（该目录为隐藏的），其中包含所有必需的存储库文件（Git
存储库框架）；注意区分<strong>工作区</strong>和<strong>暂存区</strong>，在没有add之前我们都是在<strong>工作区</strong></p>
<p>【Vscode】考虑<strong>Git
graph插件</strong>来可视化git分支目录的全貌</p>
<ul>
<li><h5 id="在github端新建仓库">在Github端新建仓库</h5>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231206215455986.png"
alt="Github端新建仓库" />
<figcaption aria-hidden="true">Github端新建仓库</figcaption>
</figure>
<p>根据需要可以设置为公有的或者是私有的，最好不要设置README.md，因为初始化的国过程可能会出现冲突，设置也没关系</p></li>
<li><h5
id="本地的git和远端github的连接">本地的Git和远端github的连接</h5>
<p>获取本地的SSH公钥匙，打开终端并输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;youremail@example.com&quot;</span><br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231206221011696.png"
alt="产生公钥的位置" />
<figcaption aria-hidden="true">产生公钥的位置</figcaption>
</figure>
<p>进入.ssh中复制id_rsa.pub中的内容，并在Github中的如下位置复制改内容添加SSH🔗</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231206221215856.png"
alt="SSH链接" />
<figcaption aria-hidden="true">SSH链接</figcaption>
</figure>
<p>完成连接之后再配置git的相关内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git config --global user.email <span class="hljs-built_in">test</span>@163.com<br>git config --global user.name <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure></li>
<li><h5 id="本地工作区的设置">本地工作区的设置</h5>
<p>首先进行初始化设置，使当前文件夹能够使用git</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git init<br></code></pre></td></tr></table></figure>
<p>如果一开始没有设置README.md文件那么执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git add README.md<br>git commit -m <span class="hljs-string">&quot;first commit&quot;</span><br>git branch -M master<br>git remote add origin git@github.com.....git<br>git push -u origin master<br></code></pre></td></tr></table></figure>
<p>以上这些步骤，就能将本地的git和远端的仓库进行关联</p></li>
<li><h5 id="本地和远端关联失败">本地和远端关联失败</h5>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231206220359185.png"
alt="推送出现错误" />
<figcaption aria-hidden="true">推送出现错误</figcaption>
</figure>
<p>当然会出现本地和远端关联失败的情况，产生的原因可能如下：</p>
<ol type="1">
<li><p>在默认情况下，<code>git push</code>时一般会上传到<code>origin</code>下的<code>master</code>分支上，当<em>repository</em>和<em>branch</em>过多，又没有设置关联时，git就会产生疑问</p>
<p>通过以下命令查看<strong>远端</strong>和<strong>本地</strong>的分支，并<strong>选择合适的</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git branch //本地<br>git branch -a //远端<br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231206220538190.png"
alt="远端和本地的不同分支" />
<figcaption aria-hidden="true">远端和本地的不同分支</figcaption>
</figure></li>
<li><p>如果本地初始化的内容和远端的内容不一样，那么无法判断本地和远端的内容差异，因此需要选择如下之一</p></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git reset --hard origin/master<br></code></pre></td></tr></table></figure>
<p>直接将远端的内容覆盖到本地</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git push -f -u origin master<br></code></pre></td></tr></table></figure>
<p>强行将本地的内容覆盖到远端，那么就能形成统一，从而完成链接。</p></li>
</ul>
<h3 id="添加文件和备注">添加文件和备注</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git add . <br>git add &lt;file&gt;<br></code></pre></td></tr></table></figure>
<p>执行上述命令之后将会将当前的file或者是工作区中的所有文件都上传到暂存区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git commit -m<span class="hljs-string">&quot;【test】XXX更改信息提示&quot;</span><br><span class="hljs-comment">#如果多次提交想覆盖到同一个提交的备注上执行下面</span><br>git commit --amend<br></code></pre></td></tr></table></figure>
<p>上述的命令是将本次的提交添加描述，分布式协作的时候能看清</p>
<h3 id="状态与日志">状态与日志</h3>
<p>查看默认配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git config --list<br></code></pre></td></tr></table></figure>
<p>查看当前所在的分支位置信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git status<br></code></pre></td></tr></table></figure>
<p>查看当前分支下的更改日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure>
<h3 id="推送与拉取">推送与拉取</h3>
<p>将本地暂存区中的更改内容推送到远端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git push<br>git push -f <span class="hljs-comment">#强行推出</span><br></code></pre></td></tr></table></figure>
<p>将远端所在的分支内容拉到本地</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git pull<br></code></pre></td></tr></table></figure>
<p>更新所在分支的最新内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git fetch --all <br></code></pre></td></tr></table></figure>
<h3 id="复制分支">复制分支</h3>
<p>获取git连接git@ XXX.git之后执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git@ XXX.git<br></code></pre></td></tr></table></figure>
<p>如果觉得git的内容太大，可以选择内部的分支进行下载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> -b feature/xxx git@ XXX.git<br></code></pre></td></tr></table></figure>
<p>feature/xxx为具体的分支内容</p>
<h3 id="分支操作">分支操作</h3>
<p>查看分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git branch -a <span class="hljs-comment">#查看所有的分支</span><br>git branch -r <span class="hljs-comment">#查看远端的分支</span><br></code></pre></td></tr></table></figure>
<p>切换不同的分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git checkout [branch] <span class="hljs-comment">#切换到分支</span><br></code></pre></td></tr></table></figure>
<p>创建新的分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git branch [branch] <span class="hljs-comment">#创建新的分支</span><br></code></pre></td></tr></table></figure>
<p>创建新的分支并切换到上面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git checkout -b [branch] <span class="hljs-comment">#创建并切换新的分支</span><br></code></pre></td></tr></table></figure>
<h3 id="分支冲突">分支冲突</h3>
<p><strong>问题描述：</strong>如果当前修改的版本基于旧版，但是远端已经是新版origin/master，<strong>此时修改基于的内容和远端不同不能强行推</strong>。</p>
<p><strong>解决方法1：</strong>通过换基的方法解决，通过将当前的修改的旧版换到最新的基上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#先将文件提交到暂存区</span><br>git add . <span class="hljs-comment">#保存在暂存区</span><br>git commit -m <span class="hljs-string">&quot;XXX&quot;</span><br><span class="hljs-comment">#进行换基操作</span><br>git rebase -i origin/master<br><span class="hljs-comment">#再次提交</span><br>git add .<br><span class="hljs-comment">#继续换基</span><br>git rebase --<span class="hljs-built_in">continue</span><br><span class="hljs-comment">#换基成功后,只需要一次备注（覆盖）</span><br>git commit --amend<br><span class="hljs-comment">#最后退出</span><br>git push<br>git push -f <span class="hljs-comment">#或者强行推出</span><br></code></pre></td></tr></table></figure>
<p><strong>解决方法2：</strong> 暴力覆盖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git fetch --all <span class="hljs-comment">#获取远端的全部内容</span><br>git reset --hard origin/master <span class="hljs-comment">#强行将远端的内容覆盖到本地的文件中</span><br>git commit --amend <br>git push -f <span class="hljs-comment">#强行推出</span><br><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>基础工具</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>【后端开发】Golang协程与Channel</title>
    <url>/2023/12/19/goroutine/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>
<h1 id="golang进阶">Golang进阶</h1>
<p>这一部分主要介绍golang中的并发，并发是 golang 的优势之一，使用关键字
go 可以很方便的开启一个<strong>协程</strong>. go 语言中，常常用
<strong>go</strong>、<strong>chan</strong>、<strong>select</strong> 及
<strong>sync
库</strong>完成并发操作，处理<strong>同步</strong>、<strong>异步</strong>、<strong>阻塞</strong>、<strong>非阻塞</strong>任务</p>
<p>go 语言的并发编程，以下是需要了解的基础知识点</p>
<ul>
<li><strong>阻塞</strong>:
阻塞是进程(也可以是线程、协程)的状态之一（新建、就绪、运行、阻塞、终止).
指的是当数据未准备就绪，这个进程(线程、协程)一直等待，这就是阻塞.</li>
<li><strong>非阻塞</strong>:
当数据为准备就绪，该进程(线程、协程)不等待可以继续执行，这就是非阻塞.</li>
<li><strong>同步</strong>:
在发起一个调用时，在没有得到结果之前，这个调用就不返回，这个调用过程一直在等待.
这是同步.</li>
<li><strong>异步</strong>:
在发起调用后，就立刻返回了，这次调用过程就结束了.
等到有结果了被调用方主动通知调用者结果. 这是异步</li>
<li><strong>goroutine</strong>: 通过关键字 go 即可创建一个协程.</li>
<li><strong>chan :</strong> golang
中用于并发的通道，用于协程的通信.</li>
</ul>
<h2 id="goroutine协程">Goroutine协程</h2>
<p>协程并发，coroutine，也叫轻量级线程。</p>
<p>与传统的系统级线程和进程相比，协程最大的优势在于“轻量级”。可以轻松创建上万个而不会导致系统资源衰竭。</p>
<p>一个线程中可以有任意多个协程，但某一时刻只能有一个协程在运行，<strong>多个协程分享该线程分配到的计算机资源</strong>。</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231207223749991-20231219211513985.png" alt="传统的线程调度方式" style="zoom:80%;" /></p>
<p>存在切换成本，存储当前的线程的状态</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231207223845618.png"
alt="CPU切换造成的时间消耗" />
<figcaption aria-hidden="true">CPU切换造成的时间消耗</figcaption>
</figure>
<p>在协程中，调用一个任务就像调用一个函数一样，消耗的系统资源最少！但能达到进程、线程并发相同的效果。</p>
<p>在一次并发任务中，进程、线程、协程均可以实现。从系统资源消耗的角度出发来看，进程相当多，线程次之，协程最少</p>
<h3 id="goroutine基本模型">Goroutine基本模型</h3>
<p>线程数量越多会导致切换成本越大越容易造成浪费</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231210220547247.png" alt="CPU管理协程的具体细节" style="zoom:67%;" /></p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231210220633895.png" alt="早期调度器的方式" style="zoom:67%;" /></p>
<p>老式调度器的缺点：</p>
<ul>
<li>创建、销毁、调度G都需要每个M获取锁，这就形成了<strong>激烈的锁竞争</strong></li>
<li>M转移G会造成<strong>延迟和额外的系统负载</strong></li>
<li>系统调用(CPU在M之间的切换)
导致频繁的线程阻塞和取消阻塞操作<strong>增加了系统开销</strong></li>
</ul>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231210221404383.png" alt="调度器设计的准则" style="zoom:67%;" /></p>
<h3 id="goroutine的定义">Goroutine的定义</h3>
<p>goroutine是Go语言并行设计的核心，有人称之为go程。
Goroutine从量级上看很像协程，它比线程更小，十几个goroutine可能体现在底层就是五六个线程，Go语言内部帮你实现了这些goroutine之间的内存共享。执行goroutine只需极少的栈内存(大概是4~5KB)，当然会根据相应的数据伸缩。也正因为如此，可同时运行成千上万个并发任务。goroutine比thread更易用、更高效、更轻便。</p>
<p>一般情况下，一个普通计算机跑几十个线程就有点负载过大了，但是同样的机器却可以轻松地让成百上千个goroutine进行资源竞争。</p>
<h3 id="创建goroutine">创建Goroutine</h3>
<p>只需在函数调⽤语句前添加 <strong>go</strong>
关键字，就可创建并发执⾏单元。在并发编程中，我们通常想将一个过程切分成几块，然后让每个goroutine各自负责一块工作，当一个程序启动时，主函数在一个单独的goroutine中运行，我们叫它main
goroutine。</p>
<p>示例代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newTask</span><span class="hljs-params">()</span></span> &#123;<br>    i := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        i++<br>        fmt.Printf(<span class="hljs-string">&quot;new goroutine: i = %d\n&quot;</span>, i)<br>        time.Sleep(<span class="hljs-number">1</span>*time.Second) <span class="hljs-comment">//延时1s</span><br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//创建一个 goroutine，启动另外一个任务</span><br>    <span class="hljs-keyword">go</span> newTask()<br>    i := <span class="hljs-number">0</span><br>    <span class="hljs-comment">//main goroutine 循环打印</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        i++<br>        fmt.Printf(<span class="hljs-string">&quot;main goroutine: i = %d\n&quot;</span>, i)<br>        time.Sleep(<span class="hljs-number">1</span> * time.Second) <span class="hljs-comment">//延时1s</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">main Goroutine: i=1<br>new Goroutine: i =2<br>new Goroutine: i =3<br>main Goroutine: i=2<br>main Goroutine: i=3<br>new Goroutine: i =4<br>new Goroutine: i =5<br></code></pre></td></tr></table></figure>
<h3 id="goroutine特性">Goroutine特性</h3>
<p><strong>主goroutine退出后，其它的工作goroutine也会自动退出：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newTask</span><span class="hljs-params">()</span></span> &#123;<br>    i := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        i++<br>        fmt.Printf(<span class="hljs-string">&quot;new goroutine: i = %d\n&quot;</span>, i)<br>        time.Sleep(<span class="hljs-number">1</span> * time.Second) <span class="hljs-comment">//延时1s</span><br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//创建一个 goroutine，启动另外一个任务</span><br>    <span class="hljs-keyword">go</span> newTask()<br> <br>    fmt.Println(<span class="hljs-string">&quot;main goroutine exit&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231219213501210.png" alt="主进程结束那么其余的goroutine结束" style="zoom:67%;" /></p>
<h3 id="goexit函数">Goexit函数</h3>
<p>调用 runtime.Goexit() 将立即终止当前 goroutine
执⾏，调度器确保所有已注册 defer 延迟调用被执行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;runtime&quot;</span><br>)<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;A.defer&quot;</span>)<br> <br>        <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;B.defer&quot;</span>)<br>            runtime.Goexit() <span class="hljs-comment">// 终止当前 goroutine, import &quot;runtime&quot;</span><br>            fmt.Println(<span class="hljs-string">&quot;B&quot;</span>) <span class="hljs-comment">// 不会执行</span><br>        &#125;()<br> <br>        fmt.Println(<span class="hljs-string">&quot;A&quot;</span>) <span class="hljs-comment">// 不会执行</span><br>    &#125;()       <span class="hljs-comment">//不要忘记()</span><br> <br>    <span class="hljs-comment">//死循环，目的不让主goroutine结束</span><br>    <span class="hljs-keyword">for</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231219214022511.png" alt="image-20231219214022511" style="zoom:67%;" /></p>
<p>对于goroutine的形式没办法拿到协程返回的值
，从而阻塞了两个协程之间的通信，因此有必要研究如何让两个协程进行通信的机制因此这个地方引入了</p>
<h2 id="channel管道">Channel管道</h2>
<p>channel是Go语言中的一个<strong>核心类型</strong>，可以把它看成管道。并发核心单元通过它就可以发送或者接收数据进行通讯</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231213150125899.png" alt="go语言之间的goroutine通信机制" style="zoom:80%;" /></p>
<p>channel是一个数据类型，主要用来解决go程的同步问题以及go程之间数据共享（数据传递）的问题。引⽤类型
channel可用于<strong>多个 goroutine
通讯。其内部实现了同步，确保并发安全</strong>。</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231213150927632.png"
alt="基于channel的同步并发安全" />
<figcaption aria-hidden="true">基于channel的同步并发安全</figcaption>
</figure>
<p>这个channel在这个位置就已经隐含表示了先后执行的关系</p>
<ul>
<li>如果main.go在运行的时候如果找不到
channel返回的值，那么就会channel让main.go产生阻塞，</li>
<li>同理对于另一边的sub.go也是一样，如果没有另一个goroutine来接受发出的channel数据，那么就会一直处于等待接受的状态产生阻塞，</li>
<li><strong>相当于首先得握上手才能继续执行进程</strong></li>
</ul>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231213151022873.png" alt="主goroutine发生阻塞" style="zoom:67%;" /></p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231213151129109.png" alt="子进程发生阻塞" style="zoom:67%;" /></p>
<h3 id="定义channel基本语法">定义channel基本语法</h3>
<p>定义一个channel时，也需要定义发送到channel的值的类型。channel可以使用内置的<strong>make()函数</strong>来创建：</p>
<p><strong>chan</strong>是创建channel所需使用的关键字。Type
代表指定channel收发数据的类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Type)  <span class="hljs-comment">//等价于make(chan Type, 0)</span><br><span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Type, capacity)<br></code></pre></td></tr></table></figure>
<p>当 参数<code>capacity= 0</code> 时，channel
是<strong>无缓冲阻塞</strong>读写的；当<code>capacity &gt; 0</code>
时，channel <strong>有缓冲非阻塞的</strong>，直到写满
capacity个元素才阻塞写入。</p>
<p>channel非常像生活中的管道，一边可以存放东西，另一边可以取出东西。channel通过操作符
<code>&lt;-</code>
来接收和发送数据，<strong>发送和接收</strong>数据语法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">channel &lt;- value      <span class="hljs-comment">//发送value到channel</span><br>&lt;-channel             <span class="hljs-comment">//接收并将其丢弃</span><br>x := &lt;-channel        <span class="hljs-comment">//从channel中接收数据，并赋值给x</span><br>x, ok := &lt;-channel    <span class="hljs-comment">//功能同上，同时检查通道是否已关闭或者是否为空</span><br></code></pre></td></tr></table></figure>
<p>默认情况下，channel接收和发送数据都是阻塞的，除非另一端已经准备好，这样就使得goroutine同步变的更加的简单，而<strong>不需要显式的lock。</strong></p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br> <br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;子go程结束&quot;</span>)<br> <br>        fmt.Println(<span class="hljs-string">&quot;子go程正在运行……&quot;</span>)<br> <br>        c &lt;- <span class="hljs-number">666</span> <span class="hljs-comment">//666发送到c</span><br>    &#125;()<br> <br>    num := &lt;-c <span class="hljs-comment">//从c中接收数据，并赋值给num</span><br> <br>    fmt.Println(<span class="hljs-string">&quot;num = &quot;</span>, num)<br>    fmt.Println(<span class="hljs-string">&quot;main go程结束&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">goroutine 正在运行...<br>goroutine结束<br>num =  666<br>main goroutine 结束...<br></code></pre></td></tr></table></figure>
<p>分析：</p>
<ul>
<li>首先第一步会需要子进程将666放进channel中才不会发生阻塞，同时主进程会在
<code>num := &lt;-c</code>的位置进行等待channel中传入数据</li>
<li>当channel中出现了数据之后，那么下一步就是从中选择数据并进行赋值</li>
<li>最后结束</li>
</ul>
<h3 id="channel的无缓冲阻塞">channel的无缓冲阻塞</h3>
<p>无缓冲的通道（unbuffered
channel）是指在接收前没有能力保存任何数据值的通道。</p>
<p>这种类型的通道要求发送goroutine和接收goroutine同时准备好，才能完成发送和接收操作。否则，通道会导致先执行发送或接收操作的
goroutine 阻塞等待。</p>
<p><strong>阻塞：</strong>由于某种原因数据没有到达，当前go程（线程）持续处于等待状态，直到条件满足，才解除阻塞。</p>
<p><strong>同步：</strong>在两个或多个go程（线程）间，保持数据内容一致性的机制。</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231213151511356.png"
alt="无缓冲的channel同步" />
<figcaption aria-hidden="true">无缓冲的channel同步</figcaption>
</figure>
<p>如果两个goroutine存在利用channel通信的情况，两个goroutine之间存在相互的消息传递，那么在无缓冲的情况下，存在隐含的先后同步关系，必须接收方到达了channel之后消息发送方才会持续发送消息并往下运行</p>
<ul>
<li>在第 1 步，两个 goroutine
都到达通道，但哪个都没有开始执行发送或者接收。</li>
<li>在第 2 步，左侧的 goroutine
将它的手伸进了通道，这模拟了向通道发送数据的行为。这时，这个 goroutine
会在通道中被锁住，直到交换完成。</li>
<li>在第 3 步，右侧的 goroutine
将它的手放入通道，这模拟了从通道里接收数据。这个 goroutine
一样也会在通道中被锁住，直到交换完成。</li>
<li>在第 4 步和第 5 步，进行交换，并最终，在第 6 步，两个 goroutine
都将它们的手从通道里拿出来，这模拟了被锁住的 goroutine 得到释放。两个
goroutine 现在都可以去做其他事情了。</li>
</ul>
<p>无缓冲的channel创建格式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Type)   <span class="hljs-comment">//等价于make(chan Type, 0)</span><br></code></pre></td></tr></table></figure>
<p>如果<strong>没有指定缓冲区容量</strong>，那么该通道就是同步的，因此会阻塞到发送者准备好发送和接收者准备好接收。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">//创建无缓冲的通道 c </span><br> <br>    <span class="hljs-comment">//内置函数 len 返回未被读取的缓冲元素数量，cap 返回缓冲区大小</span><br>    fmt.Printf(<span class="hljs-string">&quot;len(c)=%d, cap(c)=%d\n&quot;</span>, <span class="hljs-built_in">len</span>(c), <span class="hljs-built_in">cap</span>(c))<br> <br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;子go程结束&quot;</span>)<br> <br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br>            c &lt;- i<br>            fmt.Printf(<span class="hljs-string">&quot;子go程正在运行[%d]: len(c)=%d, cap(c)=%d\n&quot;</span>, i, <span class="hljs-built_in">len</span>(c), <span class="hljs-built_in">cap</span>(c))<br>        &#125;<br>    &#125;()<br> <br>    time.Sleep(<span class="hljs-number">2</span> * time.Second) <span class="hljs-comment">//延时2s</span><br> <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br>        num := &lt;-c <span class="hljs-comment">//从c中接收数据，并赋值给num</span><br>        fmt.Println(<span class="hljs-string">&quot;num = &quot;</span>, num)<br>    &#125;<br> <br>    fmt.Println(<span class="hljs-string">&quot;main进程结束&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>那么运行的结果是：</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231219220132461.png" alt="无缓冲channel的运行结果" style="zoom:67%;" /></p>
<p>分析：</p>
<ul>
<li>本质上会出现阻塞，如果没有及时把数据拿出</li>
<li>因此必须是其中一个放进去数据，另一个拿出数据才能能让进程执行下去，本质上保证了同步的进行</li>
</ul>
<h3 id="channel的有缓冲阻塞">channel的有缓冲阻塞</h3>
<blockquote>
<p><strong>本质上是生产者消费者模型 消息队列模型</strong></p>
</blockquote>
<p>这种类型的通道并不强制要求 goroutine
之间必须同时完成发送和接收。通道会阻塞发送和接收动作的条件也不同。</p>
<p>只有通道中没有要接收的值时，接收动作才会阻塞。只有通道没有可用缓冲区容纳被发送的值时，发送动作才会阻塞。</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231219220401111.png"
alt="有缓冲的通道在channe之间同步数据" />
<figcaption
aria-hidden="true">有缓冲的通道在channe之间同步数据</figcaption>
</figure>
<ul>
<li>在第 1 步，右侧的 goroutine 正在从通道接收一个值。</li>
<li>在第 2 步，右侧的这个 goroutine独立完成了接收值的动作，而左侧的
goroutine 正在发送一个新值到通道里。</li>
<li>在第 3 步，左侧的goroutine 还在向通道发送新值，而右侧的 goroutine
正在从通道接收另外一个值。这个步骤里的两个操作<strong>既不是同步的，也不会互相阻塞</strong>。</li>
<li>最后，在第 4
步，所有的发送和接收都完成，而通道里还有几个值，也有一些空间可以存更多的值。</li>
</ul>
<p><strong>有缓冲的channel创建格式：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Type, capacity)<br></code></pre></td></tr></table></figure>
<p>如果给定了一个缓冲区容量，通道就是异步的。只要缓冲区有未使用空间用于发送数据，或还包含可以接收的数据，那么其通信就会无阻塞地进行。</p>
<p><strong>函数 len(ch)求取缓冲区中剩余元素个数， cap(ch)
求取缓冲区元素容量大小</strong></p>
<p>示例代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span>  <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> ,<span class="hljs-number">3</span>) <span class="hljs-comment">//带有缓冲的channel</span><br><br>	<span class="hljs-comment">//查看当前的channel中的缓冲的容量大小</span><br>	<span class="hljs-comment">//len表示的是元素数量 cap表示的是缓冲的容量大小</span><br>	fmt.Println(<span class="hljs-string">&quot;len(c) = &quot;</span>, <span class="hljs-built_in">len</span>(c), <span class="hljs-string">&quot;, cap(c)&quot;</span>, <span class="hljs-built_in">cap</span>(c))<br><br>	<span class="hljs-comment">//定义一个子goroutine</span><br>	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>		<span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;sub goroutine结束&quot;</span>)<br>		<br>		<span class="hljs-comment">// for i := 0; i&lt;3; i++&#123;</span><br>		<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">4</span>; i++&#123;<span class="hljs-comment">// 这种情况就会出现阻塞，因为超过了缓冲的容量</span><br>			c &lt;- i<br>			fmt.Println(<span class="hljs-string">&quot;sub goroutine 正在运行: len(c) = &quot;</span>, <span class="hljs-built_in">len</span>(c), <span class="hljs-string">&quot;, cap(c) =  &quot;</span>, <span class="hljs-built_in">cap</span>(c),<span class="hljs-string">&quot; 发送的元素是= &quot;</span>,i)<br>		&#125;<br>	&#125;()<br><br>	time.Sleep(<span class="hljs-number">1</span>*time.Second)<br><br>	<span class="hljs-comment">//有缓存的话就不会出现阻塞的情况</span><br><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">3</span>;i++&#123;<br>		num := &lt;-c <span class="hljs-comment">//从c中接受数据并赋值给num</span><br>		fmt.Println(<span class="hljs-string">&quot;num = &quot;</span>, num)<br>	&#125;<br>	fmt.Println(<span class="hljs-string">&quot;main 结束&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231219220650672.png"
alt="有缓冲通道的运行结果" />
<figcaption aria-hidden="true">有缓冲通道的运行结果</figcaption>
</figure>
<h3 id="关闭channel">关闭Channel</h3>
<p>没有更多的值需要发送到channel的话，那么让接收者也能及时知道没有多余的值可接收将是有用的，因为接收者可以停止不必要的接收等待。这可以通过内置的<code>close</code>函数来关闭channel实现。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>) <span class="hljs-comment">//channel要通过make来触发，如果是nil channel 会发生阻塞</span><br><br>	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>		<span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;sub finished ...&quot;</span>)<br>		<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++&#123;<br>			c &lt;- i<br>			<span class="hljs-comment">// close(c)</span><br>			<span class="hljs-comment">//如果向已经关闭的channel发送数据就会出现panic的错误</span><br>		&#125;<br>		<span class="hljs-comment">// close 关闭一个channel</span><br>		<span class="hljs-built_in">close</span>(c)<br>		<span class="hljs-comment">//如果去掉关闭channel这个开关，那么会出现死锁的情况，就是main的进程数据都在等待塞数据</span><br>	&#125;()<br><br>	<span class="hljs-keyword">for</span>&#123;<br>		<span class="hljs-comment">//如果ok为ture 那么channel没有关闭, 如果为false 那么已经被关闭</span><br>		<span class="hljs-keyword">if</span> data, ok := &lt;-c; ok&#123;<br>			fmt.Println(data)<br>		&#125;<span class="hljs-keyword">else</span>&#123;<br>			<span class="hljs-keyword">break</span><br>		&#125;<br>	&#125;<br><br>	fmt.Println(<span class="hljs-string">&quot;Main finished ...&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出的结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">/* 输出的值go run channel4.go<br>0<br>1<br>2<br>3<br>4<br>Main finished ...<br>sub finished ... */<br></code></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>channel不像文件一样需要经常去关闭，只有当你确实没有任何发送数据了，或者你想显式的结束range循环之类的，才去关闭channel；</li>
<li>如果向已经关闭的channel发送数据就会出现panic的错误</li>
<li>关闭channel后，可以继续从channel接收数据；</li>
<li>如果ok为ture 那么channel没有关闭, 如果为false 那么已经被关闭</li>
<li>对于nil channel，无论收发都会被阻塞。</li>
</ul>
<h3 id="range操作channel">Range操作channel</h3>
<p>可以使用 <strong>range</strong> 来迭代不断操作channel：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br> <br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>            c &lt;- i<br>        &#125;<br>        <span class="hljs-built_in">close</span>(c)<br>    &#125;()<br> <br>    <span class="hljs-keyword">for</span> data := <span class="hljs-keyword">range</span> c &#123;<br>        fmt.Println(data)<br>    &#125;<br>    fmt.Println(<span class="hljs-string">&quot;Finished&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li><p>利用range进行简写</p></li>
<li><p>利用range不断迭代从channel中操作数据</p></li>
</ul>
<h3 id="单向channel">单向Channel</h3>
<p>默认情况下，通道channel是双向的，也就是，既可以往里面发送数据也可以同里面接收数据。</p>
<p>但是，我们经常见一个通道作为参数进行传递而只希望对方是单向使用的，要么只让它发送数据，要么只让它接收数据，这时候我们可以指定通道的方向。</p>
<p>单向channel的定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ch1 <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>       <span class="hljs-comment">// ch1是一个正常的channel，是双向的</span><br><span class="hljs-keyword">var</span> ch2 <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">float64</span> <span class="hljs-comment">// ch2是单向channel，只用于写float64数据</span><br><span class="hljs-keyword">var</span> ch3 &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>     <span class="hljs-comment">// ch3是单向channel，只用于读int数据</span><br></code></pre></td></tr></table></figure>
<p>可以将 channel 隐式转换为单向队列，只收或只发，不能将单向 channel
转换为普通 channel：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">3</span>)<br><span class="hljs-keyword">var</span> send <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span> = c <span class="hljs-comment">// send-only</span><br><span class="hljs-keyword">var</span> recv &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> = c <span class="hljs-comment">// receive-only</span><br>send &lt;- <span class="hljs-number">1</span><br><span class="hljs-comment">//&lt;-send //invalid operation: &lt;-send (receive from send-only type chan&lt;- int)</span><br>&lt;-recv<br><span class="hljs-comment">//recv &lt;- 2 //invalid operation: recv &lt;- 2 (send to receive-only type &lt;-chan int)</span><br> <br><span class="hljs-comment">//不能将单向 channel 转换为普通 channel</span><br>d1 := (<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)(send) <span class="hljs-comment">//cannot convert send (type chan&lt;- int) to type chan int</span><br>d2 := (<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)(recv) <span class="hljs-comment">//cannot convert recv (type &lt;-chan int) to type chan int</span><br></code></pre></td></tr></table></figure>
<p>单向channel的示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//   chan&lt;- //只写</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">counter</span><span class="hljs-params">(out <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(out)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>        out &lt;- i <span class="hljs-comment">//如果对方不读 会阻塞</span><br>    &#125;<br>&#125;<br> <br><span class="hljs-comment">//   &lt;-chan //只读</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printer</span><span class="hljs-params">(in &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> num := <span class="hljs-keyword">range</span> in &#123;<br>        fmt.Println(num)<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>) <span class="hljs-comment">//   chan   //读写</span><br> <br>    <span class="hljs-keyword">go</span> counter(c) <span class="hljs-comment">//生产者</span><br>    printer(c)    <span class="hljs-comment">//消费者</span><br> <br>    fmt.Println(<span class="hljs-string">&quot;done&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="channel的select">Channel的Select</h2>
<h3 id="select基本定义">Select基本定义</h3>
<p>Go里面提供了一个关键字select，通过select可以监听channel上的数据流动。每个case表示监控不同的条件.
通过select来进行控制。</p>
<p>select有比较多的限制，其中最大的一条限制就是每个<strong>case语句里必须是一个IO操作</strong>，大致的结构如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;- chan1:<br>    <span class="hljs-comment">// 如果chan1成功读到数据，则进行该case处理语句</span><br><span class="hljs-keyword">case</span> chan2 &lt;- <span class="hljs-number">1</span>:<br>    <span class="hljs-comment">// 如果成功向chan2写入数据，则进行该case处理语句</span><br><span class="hljs-keyword">default</span>:<br>    <span class="hljs-comment">// 如果上面都没有成功，则进入default处理流程</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>在一个select语句中，Go语言会按顺序<strong>从头至尾</strong>评估每一个发送和接收的语句。如果其中的<strong>任意一语句可以继续执行</strong>(即没有被阻塞)，那么就从那些可以执行的语句中任意选择一条来使用。</p>
<p>如果<strong>没有任意一条语句可以执行</strong>(即所有的通道都被阻塞)，那么有两种可能的情况：</p>
<ol type="1">
<li>如果给出了default语句，那么就会执行default语句，同时程序的执行会从select语句后的语句中恢复</li>
<li>如果没有default语句，那么select语句将被阻塞，直到至少有一个通信可以进行下去</li>
</ol>
<p>下面是<strong>示例代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">(c, quit <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>    x, y := <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> c &lt;- x:<br>            x, y = y, x+y<br>        <span class="hljs-keyword">case</span> &lt;-quit:<br>            fmt.Println(<span class="hljs-string">&quot;quit&quot;</span>)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    quit := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br> <br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++ &#123;<br>            fmt.Println(&lt;-c)<br>        &#125;<br>        quit &lt;- <span class="hljs-number">0</span><br>    &#125;()<br> <br>    fibonacci(c, quit)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行的结果：</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231220211918321.png" alt="执行的结果" style="zoom:70%;" /></p>
<h3 id="交替打印数字字母">交替打印数字字母</h3>
<p>需求：反复打印数字1字母a-&gt;1a2b3c4d5e...依次类推</p>
<p>思路：选择两个goroutine来实现这部分的内容，产生阻塞的条件是一个进程需要取数，一个goroutine需要存数来进行阻塞</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><br>	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">26</span>; i++ &#123;<br>			&lt;-c<br>			fmt.Println(<span class="hljs-type">string</span>(<span class="hljs-number">96</span> + i))<br>			c &lt;- <span class="hljs-number">0</span><br>		&#125;<br>	&#125;()<br><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">26</span>; i++ &#123;<br>			fmt.Println(i)<br>			c &lt;- <span class="hljs-number">0</span><br>			&lt;-c<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>打印的结果是：</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231220214320935.png" alt="数字字母交替打印" style="zoom:70%;" /></p>
]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>【深度学习】PyTorch使用手册</title>
    <url>/2023/10/22/pytorch/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>
<p>本文主要介绍pytorch中的基本使用，包括如何导入数据集，如何搭建并训练网络以及可视化的内容，基本涵盖了深度学习中经典算法的使用以及相关的例子</p>
<h2 id="basics">Basics</h2>
<h3 id="计算梯度例子">计算梯度例子</h3>
<p>引入基本需要用到的包，深度学习中torch处理大部分张量的运算，而torch.nn则是对torch的网络中的一些运算，这些都是必须用到的包。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch <br><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> torchvision.transforms <span class="hljs-keyword">as</span> transforms<br></code></pre></td></tr></table></figure>
<p>在深度学习中，一般使用张量进行运算，此时会涉及到计算张量的梯度等问题，我们这里给出一个例子来展示如何使用张量来进行梯度计算：</p>
<p>初始化定义张量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">x = torch.tensor(<span class="hljs-number">1.</span>, requires_grad=<span class="hljs-literal">True</span>)<br>w = torch.tensor(<span class="hljs-number">2.</span>, requires_grad=<span class="hljs-literal">True</span>)<br>b = torch.tensor(<span class="hljs-number">3.</span>, requires_grad=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure>
<p>建立<strong>计算图 computational graph</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">y = w * x + b    <span class="hljs-comment"># y = 2 * x + 3</span><br></code></pre></td></tr></table></figure>
<p>计算梯度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">y.backward()<br><span class="hljs-built_in">print</span>(x.grad)    <span class="hljs-comment"># x.grad = 2 </span><br><span class="hljs-built_in">print</span>(w.grad)    <span class="hljs-comment"># w.grad = 1 </span><br><span class="hljs-built_in">print</span>(b.grad)    <span class="hljs-comment"># b.grad = 1 </span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>【多智能体强化学习】Pymarl环境配置</title>
    <url>/2023/10/22/pymarl%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>
<p>SMAC是基于暴雪星际争霸II
RTS游戏的协作多智能体强化学习领域的研究环境。SMAC利用星际争霸2机器学习API和DeepMind的PySC2为自主代理提供了一个方便的接口。</p>
<p>本文主要介绍在多智能体强化学习中的验证平台SAMC和Pymarl的配置和安装过程</p>
<p>环境地址：<a
href="https://github.com/oxwhirl/pymarl">https://github.com/oxwhirl/pymarl</a></p>
<p>依赖环境：<a
href="https://github.com/oxwhirl/smac">https://github.com/oxwhirl/smac</a></p>
<p>主要针对Ubuntu下的Pymarl环境的配置（MAC和Windows类似）</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231022145734342.png"
alt="SMAC" />
<figcaption aria-hidden="true">SMAC</figcaption>
</figure>
<h2 id="安装starcraftii">安装StarCraftII</h2>
<h3 id="windowsmac">Windows/Mac</h3>
<p>直接在官网下载安装最新版，需要加速器或者更换亚服：<a
href="https://sc2.blizzard.cn/landing">https://sc2.blizzard.cn/landing</a></p>
<p>安装地图：<a
href="https://link.zhihu.com/?target=https%3A//github.com/oxwhirl/smac/releases/download/v0.1-beta1/SMAC_Maps.zip">https://link.zhihu.com/?target=https%3A//github.com/oxwhirl/smac/releases/download/v0.1-beta1/SMAC_Maps.zip</a></p>
<p>将地图放在Maps文件夹下</p>
<h3 id="ubuntu">Ubuntu</h3>
<p>在Ubuntu系统中，安装需要版本的SCII即可<a
href="https://github.com/Blizzard/s2client-proto#downloads">https://github.com/Blizzard/s2client-proto#downloads</a></p>
<p>下载压缩包之后安装并解压放到用户名文件夹下：～/StarCraftII/</p>
<p>如果没有把SCII安装到用户名之下，这个地方的路径可以根据放置的位置来进行更改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">vim ~/.bashrc<br></code></pre></td></tr></table></figure>
<p>在最后一行增加环境变量，这里可以更改星际争霸的位置索引到任何想要放置的位置</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">SC2PATH</span>=~/StarCraftII/<br></code></pre></td></tr></table></figure>
<p>添加完之后更新环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure>
<p>添加SAMC的地图：Linux系统在下载SCII的时候就自带了地图</p>
<h2 id="安装smac">安装SMAC</h2>
<p>创建虚拟环境并安装pytorch</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">conda create -n pymarl python=<span class="hljs-number">3.8</span> -y<br>conda activate pymarl   <br><span class="hljs-comment"># CUDA 10.2 例子具体的的CUDA版本根据自己的服务器来定</span><br>conda install pytorch==<span class="hljs-number">1.10</span><span class="hljs-number">.0</span> torchvision==<span class="hljs-number">0.11</span><span class="hljs-number">.0</span> torchaudio==<span class="hljs-number">0.10</span><span class="hljs-number">.0</span> cudatoolkit=<span class="hljs-number">10.2</span> -c pytorch<br></code></pre></td></tr></table></figure>
<p>直接利用虚拟环境中的pip来安装</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">pip install git+https://github.com/oxwhirl/smac.git<br></code></pre></td></tr></table></figure>
<p>或者可以利用git进行安装，先git
clone下载下来然后进入文件夹中进行安装</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">git clone https://github.com/oxwhirl/smac.git<br>pip install -e smac/<br></code></pre></td></tr></table></figure>
<p>如果pip install安装失败可以考虑升级pip：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">pip install --upgrade pip<br></code></pre></td></tr></table></figure>
<p>如果安装的内容失败了可以手动安装，比如pymarl运行所依赖的包有以下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">pip install sacred numpy scipy matplotlib seaborn pyyaml pygame pytest probscale imageio snakeviz tensorboard-logger<br><br></code></pre></td></tr></table></figure>
<p>或者根据<a
href="https://github.com/oxwhirl/pymarl/tree/master/docker">https://github.com/oxwhirl/pymarl/tree/master/docker</a>中的bash脚本中Dockerfile依赖内容进行安装</p>
<h2 id="pymarl与scii">Pymarl与SCII</h2>
<h3 id="采用上述安装步骤">采用上述安装步骤</h3>
<p>对于上述的操作完成操作之后，下载pymarl的环境包并进入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">git clone git@github.com:oxwhirl/pymarl.git<br>cd pymarl<br></code></pre></td></tr></table></figure>
<p>将上述安装的SCII文件夹复制到pymarl的src的3dparty之下</p>
<h3 id="如果利用docker安装">如果利用Docker安装</h3>
<p>或者根据pymarl中的内容对上述环境进行自动配置（需要Docker）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> docker<br>bash build.sh<br></code></pre></td></tr></table></figure>
<p>同时安装SCII和SMAC</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">bash install_sc2.sh<br></code></pre></td></tr></table></figure>
<h2 id="测试环境">测试环境</h2>
<h3 id="测试地图信息">测试地图信息</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">python -m smac.<span class="hljs-built_in">bin</span>.map_list <br></code></pre></td></tr></table></figure>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231022153907123.png" alt="Maps show" style="zoom:67%;" /></p>
<h3 id="测试环境信息">测试环境信息</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">python -m smac.examples.random_agents<br></code></pre></td></tr></table></figure>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231022153709693.png" alt="test agents" style="zoom: 50%;" /></p>
<h3 id="测试pymarl环境">测试Pymarl环境</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">python src/main.py --config=qmix --env-config=sc2 <span class="hljs-keyword">with</span> env_args.map_name=2s3z<br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231022153651418.png"
alt="test pymarl" />
<figcaption aria-hidden="true">test pymarl</figcaption>
</figure>
<h2 id="依赖包的版本问题">依赖包的版本问题</h2>
<p>当运行pymarl的时候容易因为依赖包产生问题</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240104210308852.png"
alt="image-20240104210308852" />
<figcaption aria-hidden="true">image-20240104210308852</figcaption>
</figure>
<p>原因是
<code>sacred</code>版本不对劲，只需要将版本降低到0.7.5这个问题就能解决</p>
<h2 id="额外设置">额外设置</h2>
<p>在利用pymarl进行实验的过程中可能会出现</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231022154059365.png"
alt="some bug" />
<figcaption aria-hidden="true">some bug</figcaption>
</figure>
<p>需要进行设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">vim torch/_tensor.py<br></code></pre></td></tr></table></figure>
<p>将757行的内容进行修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">-: self.numpy()<br>+: self.cpu().numpy()<br></code></pre></td></tr></table></figure>
<h2 id="谷歌足球环境">谷歌足球环境</h2>
<p>Google Research
Football：https://github.com/google-research/football</p>
<h4 id="安装linux依赖环境">安装Linux依赖环境</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo apt-get install git cmake build-essential libgl1-mesa-dev libsdl2-dev \<br>libsdl2-image-dev libsdl2-ttf-dev libsdl2-gfx-dev libboost-all-dev \<br>libdirectfb-dev libst-dev mesa-utils xvfb x11vnc python3-pip<br><br>python3 -m pip install --upgrade pip setuptools psutil wheel<br></code></pre></td></tr></table></figure>
<p>这一步非常重要，必须合理安装相应的包。</p>
<h4 id="安装gfootball">安装GFootball</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">python3 -m pip install gfootball<br></code></pre></td></tr></table></figure>
<p>或者用github的仓库来进行安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/google-research/football.git<br><span class="hljs-built_in">cd</span> football<br></code></pre></td></tr></table></figure>
<p>可以选择使用虚拟环境:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">python3 -m venv football-env<br><span class="hljs-built_in">source</span> football-env/bin/activate<br></code></pre></td></tr></table></figure>
<p>安装依赖包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">python3 -m pip install .<br></code></pre></td></tr></table></figure>
<h4 id="运行结果展示">运行结果展示：</h4>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240106145437351.png" alt="谷歌足球结果展示" style="zoom:50%;" /></p>
<h4 id="遇到的问题">遇到的问题</h4>
<p>编译错误，缺少boost的包：</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240106145036965.png"
alt="编译错误" />
<figcaption aria-hidden="true">编译错误</figcaption>
</figure>
<p>选择安装如下包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">conda install anaconda::py-boost<br></code></pre></td></tr></table></figure>
<p>第二个错误：</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240106145218372.png" alt="错误二" style="zoom:67%;" /></p>
<p>解决方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libffi.so.7<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>强化学习</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>深度学习</tag>
        <tag>强化学习</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法题】LeetCode算法汇总</title>
    <url>/2024/01/01/leetcode/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>
<h1 id="语言细节">语言细节</h1>
<p>vector的长度：</p>
<ul>
<li>C++：nums.size()</li>
<li>Python：len(nums)</li>
<li>GO：len(nums)</li>
</ul>
<p>构造vector:</p>
<ul>
<li>C++：vector result(长度，元素)</li>
<li>Python：res = [float('inf')] * len(nums)</li>
<li>GO：:=make([]int，n)</li>
</ul>
<p>for循环：</p>
<ul>
<li>C++：条件小括号+循环体中括号</li>
<li>Python：冒号且不需要小括号包条件</li>
<li>GO：循环体中括号，条件按照C++写但是不需要小括号</li>
</ul>
<h1 id="数组">数组</h1>
<h3 id="二分查找">二分查找</h3>
<h4 id="题目描述">题目描述</h4>
<p>链接：https://leetcode.cn/problems/binary-search/description/</p>
<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target
，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回
-1。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="hljs-section">输出: 4</span><br><span class="hljs-section">解释: 9 出现在 nums 中并且下标为 4</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="hljs-section">输出: -1</span><br><span class="hljs-section">解释: 2 不存在 nums 中因此返回 -1</span><br></code></pre></td></tr></table></figure>
<h4 id="思路">思路</h4>
<p>题目表示的是有序数组，而且题目没有重复元素。在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是<strong>循环不变量</strong>规则</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>  <span class="hljs-comment"># 定义target在左闭右闭的区间里，[left, right]</span><br><br>        <span class="hljs-keyword">while</span> left &lt;= right:<br>            middle = left + (right - left) // <span class="hljs-number">2</span><br>            <br>            <span class="hljs-keyword">if</span> nums[middle] &gt; target:<br>                right = middle - <span class="hljs-number">1</span>  <span class="hljs-comment"># target在左区间，所以[left, middle - 1]</span><br>            <span class="hljs-keyword">elif</span> nums[middle] &lt; target:<br>                left = middle + <span class="hljs-number">1</span>  <span class="hljs-comment"># target在右区间，所以[middle + 1, right]</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> middle  <span class="hljs-comment"># 数组中找到目标值，直接返回下标</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>  <span class="hljs-comment"># 未找到目标值</span><br></code></pre></td></tr></table></figure>
<p>注意这里给出的题解法：当
<code>left &lt;= right</code>的时候，以下的条件中全部都不取到等号
<code>nums[middle] &gt; target nums[middle] &lt; target</code></p>
<p>需要注意的是：<code>right=nums.size()-1</code></p>
<p>C++版本</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)<br>        &#123;<br>            <span class="hljs-comment">// int middle = (left+right)/2; 这样写会溢出</span><br>            <span class="hljs-type">int</span> middle = left + ((right - left) / <span class="hljs-number">2</span>);<br>            <span class="hljs-keyword">if</span>(nums[middle]&gt;target)<br>            &#123;<br>                right = middle<span class="hljs-number">-1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[middle]&lt;target)<br>            &#123;<br>                left = middle+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> middle;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>Go版本</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    right:=<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span><br>    left:=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> left&lt;=right&#123;<br>        middle:= left+(right-left)/<span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[middle]&lt;target&#123;<br>            left = middle+<span class="hljs-number">1</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[middle]&gt;target&#123;<br>            right = middle<span class="hljs-number">-1</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> middle<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="移除元素">移除元素</h3>
<p>https://leetcode.cn/problems/remove-element/description/</p>
<h4 id="题目描述-1">题目描述</h4>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,2,3]</span>, val = 3<br>输出：2, nums = <span class="hljs-comment">[2,2]</span><br>解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = <span class="hljs-comment">[2,2,3,3]</span> 或 nums = <span class="hljs-comment">[2,2,0,0]</span>，也会被视作正确答案。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">0,1,2,2</span>,<span class="hljs-number">3,0,4,2</span>], val = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">5</span>, nums = [<span class="hljs-number">0,1,3,0</span>,<span class="hljs-number">4</span>]<br>解释：函数应该返回新的长度 <span class="hljs-number">5</span>, 并且 nums 中的前五个元素为 <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。<br></code></pre></td></tr></table></figure>
<h4 id="思路-1">思路</h4>
<p>双指针法（快慢指针法）：
<strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p>
<p>定义快慢指针</p>
<ul>
<li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li>
<li>慢指针：指向更新 新数组下标的位置</li>
</ul>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240111141316267.png" alt="双指针题解" style="zoom:67%;" /></p>
<p>C++版本</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-type">int</span> slowindex=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fastindex = <span class="hljs-number">0</span>; fastindex&lt;nums.<span class="hljs-built_in">size</span>();fastindex++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(val!=nums[fastindex])&#123;<br>                nums[slowindex] = nums[fastindex];<br>                slowindex++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slowindex;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>python版本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeElement</span>(<span class="hljs-params">self, nums, val</span>):<br>        slowindex=<span class="hljs-number">0</span><br>        fastindex=<span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> fastindex&lt;<span class="hljs-built_in">len</span>(nums):<br>            <span class="hljs-keyword">if</span> val!=nums[fastindex]:<br>                nums[slowindex]=nums[fastindex]<br>                slowindex = slowindex+<span class="hljs-number">1</span><br>            fastindex+=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> slowindex        <br></code></pre></td></tr></table></figure>
<p>GO版本：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, val <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    slow:=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;<br>        <span class="hljs-keyword">if</span> nums[i]!=val&#123;<br>            nums[slow]=nums[i]<br>            slow++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="有序数组的平方">有序数组的平方</h3>
<p>https://leetcode.cn/problems/squares-of-a-sorted-array/</p>
<h4 id="题目描述-2">题目描述</h4>
<p><strong>示例 1：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><code class="hljs dns">输入：nums = [-<span class="hljs-number">4</span>,-<span class="hljs-number">1,0,3,10</span>]<br>输出：[<span class="hljs-number">0,1,9,16</span>,<span class="hljs-number">100</span>]<br>解释：平方后，数组变为 [<span class="hljs-number">16,1,0,9</span>,<span class="hljs-number">100</span>]<br>排序后，数组变为 [<span class="hljs-number">0,1,9,16</span>,<span class="hljs-number">100</span>]<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><code class="hljs dns">输入：nums = [-<span class="hljs-number">7</span>,-<span class="hljs-number">3,2,3,11</span>]<br>输出：[<span class="hljs-number">4,9,9,49</span>,<span class="hljs-number">121</span>]<br></code></pre></td></tr></table></figure>
<h4 id="思路-2">思路</h4>
<p>双指针法，首尾遍历比较并存储</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240111144022821.png"
alt="双指针遍历存储" />
<figcaption aria-hidden="true">双指针遍历存储</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(nums.size(),<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> j = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> k =j;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ;i&lt;=j;)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i]*nums[i]&gt;nums[j]*nums[j])&#123;<br>                result[k--]= nums[i]*nums[i];<br>                i++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                result[k--]= nums[j]*nums[j];<br>                j--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>Python:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sortedSquares</span>(<span class="hljs-params">self, nums</span>):<br>        l, r, i = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span><br>        res = [<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)] * <span class="hljs-built_in">len</span>(nums) <span class="hljs-comment"># 需要提前定义列表，存放结果</span><br>        <span class="hljs-keyword">while</span> l&lt;=r :<br>            <span class="hljs-keyword">if</span> nums[l]*nums[l] &lt; nums[r]*nums[r] :<br>                res[i--]=nums[r]*nums[r]<br>                r--<br>            <span class="hljs-keyword">else</span>:<br>                res[i--]=nums[l]*nums[l]<br>                l++<br>        <span class="hljs-keyword">return</span> <br></code></pre></td></tr></table></figure>
<p>GO:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortedSquares</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>	n := <span class="hljs-built_in">len</span>(nums)<br>	i, j, k := <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>, n<span class="hljs-number">-1</span><br>	ans := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>	<span class="hljs-keyword">for</span> i &lt;= j &#123;<br>		lm, rm := nums[i]*nums[i], nums[j]*nums[j]<br>		<span class="hljs-keyword">if</span> lm &gt; rm &#123;<br>			ans[k] = lm<br>			i++<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			ans[k] = rm<br>			j--<br>		&#125;<br>		k--<br>	&#125;<br>	<span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="长度最小的子数组">长度最小的子数组</h3>
<p>https://leetcode.cn/problems/minimum-size-subarray-sum/description/</p>
<h4 id="题目描述-3">题目描述</h4>
<p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数
<code>target</code> <strong>。</strong></p>
<p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的
<strong>连续子数组</strong>
<code>[numsl, numsl+1, ..., numsr-1, numsr]</code>
，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回
<code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">输入：target = 7, nums = <span class="hljs-comment">[2,3,1,2,4,3]</span><br>输出：2<br>解释：子数组 <span class="hljs-comment">[4,3]</span> 是该条件下的长度最小的子数组。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj">输入：<span class="hljs-keyword">target</span> = <span class="hljs-number">4</span>, nums = [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><code class="hljs dns">输入：target = <span class="hljs-number">11</span>, nums = [<span class="hljs-number">1,1,1,1</span>,<span class="hljs-number">1,1,1,1</span>]<br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<h4 id="思路-3">思路</h4>
<p>滑动窗口法</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240111153940915.png" alt="滑动窗口法" style="zoom:67%;" /></p>
<p>滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动本题中实现滑动窗口，主要确定如下三点：</p>
<ul>
<li>窗口内是什么？</li>
<li>如何移动窗口的起始位置？</li>
<li>如何移动窗口的结束位置？</li>
</ul>
<p>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> s, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = INT32_MAX;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口数值之和</span><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口起始位置</span><br>        <span class="hljs-type">int</span> subLength = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口的长度</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j++) &#123;<br>            sum += nums[j];<br>            <span class="hljs-comment">// 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件</span><br>            <span class="hljs-keyword">while</span> (sum &gt;= s) &#123;<br>                subLength = (j - i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 取子序列的长度</span><br>                result = result &lt; subLength ? result : subLength;<br>                sum -= nums[i++]; <span class="hljs-comment">// 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span><br>        <span class="hljs-keyword">return</span> result == INT32_MAX ? <span class="hljs-number">0</span> : result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="螺旋矩阵">螺旋矩阵</h3>
<p>https://leetcode.cn/problems/spiral-matrix-ii/</p>
<h4 id="题目描述-4">题目描述：</h4>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240111155904466.png" alt="螺旋矩阵" style="zoom:67%;" /></p>
<p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到
<code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的
<code>n x n</code> 正方形矩阵 <code>matrix</code></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">[[1,2,3],[8,9,4],[7,6,5]]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure>
<h4 id="思路-4">思路：</h4>
<p>大模拟循环遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generateMatrix</span>(<span class="hljs-type">int</span> n) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">result</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>));<br>        <span class="hljs-type">int</span> is=<span class="hljs-number">0</span>,ie=n<span class="hljs-number">-1</span>,js=<span class="hljs-number">0</span>,je=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(is&lt;=ie&amp;&amp;js&lt;=je)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=js;j&lt;=je;j++)<br>            &#123;<br>                result[is][j] = k++;<br>            &#125;<br>            is++;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =is;i&lt;=ie;i++)<br>            &#123;<br>                result[i][je] = k++;<br>            &#125;<br>            je--;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=je;j&gt;=js;j--)<br>            &#123;<br>                result[ie][j] = k++;<br>            &#125;<br>            ie--;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=ie;i&gt;=is;i--)<br>            &#123;<br>                result[i][js] = k++;<br>            &#125;<br>            js++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="哈希表">哈希表</h1>
<h1 id="链表">链表</h1>
<h1 id="二叉树">二叉树</h1>
<h1 id="回溯算法">回溯算法</h1>
<h1 id="贪心算法">贪心算法</h1>
<h1 id="动态规划">动态规划</h1>
]]></content>
      <categories>
        <category>LeetCode算法</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>【深度学习】推荐系统算法</title>
    <url>/2024/01/02/rec/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>
<h1 id="推荐系统">推荐系统</h1>
<p>深度推荐系统 王喆</p>
<p>https://zhuanlan.zhihu.com/p/407871839</p>
<p>搜索引擎需要用户主动输入自己的意图，有些需求、意愿，是用户自己都意识不到的。将自己拥有的、用户可能喜欢的内容主动展示给用户，从而留住用户花费更多的时间与金钱。这就是<strong>推荐系统</strong>。</p>
<p>关键词：</p>
<ol type="1">
<li>记忆与扩展</li>
<li>特征的Embedding</li>
<li>高维稀疏的类别特征</li>
<li>特征交叉结构</li>
</ol>
<h2 id="推广搜">推广搜</h2>
<p>推荐、广告、搜索</p>
<p><strong>用户需求表达方式：推荐、搜索</strong></p>
<p><strong>信息服务对象：推搜、广告</strong></p>
<p>相同点：</p>
<ul>
<li>功能架构相同：先召回在精排</li>
<li>数据架构相同：Lambda</li>
<li>技术栈相同，面向的功能相同，都需要高度个性化设计</li>
</ul>
<p><strong>推荐&amp;搜索</strong> <span class="math display">\[
F_{search}(t|q,u)\\
F_{recommend}(t|u)
\]</span>
q表示物料对用户查询的匹配程度，搜索有显式的匹配程度，但是推荐没有</p>
<p>搜索：查询语句与物料信息交叉</p>
<p>推荐：用户信息与物料信息交叉</p>
<p><strong>推搜&amp;广告</strong></p>
<p>最终目标性：（优化指标）</p>
<ul>
<li>推搜是为了制造流量，给予用户最佳的使用体验</li>
<li>广告是为了变现流</li>
</ul>
<p>实现流程：</p>
<ul>
<li>推搜目标即刻完成，比如点击和播放</li>
<li>广告是深层次的转化，需要用户选择并下载APP，存在较大的延时反馈问题</li>
</ul>
<h2 id="推荐系统简介">推荐系统简介</h2>
<p>召回：根据喜好标签进行选择</p>
<p>排序：根据召回的视频进行排序</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240109104447989.png"
alt="image-20240109104447989" />
<figcaption aria-hidden="true">image-20240109104447989</figcaption>
</figure>
<p>根据用户行为进行同步更新</p>
<ul>
<li>更新用户的喜好权重</li>
<li>更新某个视频的质量权重</li>
</ul>
<p>推荐系统功能</p>
<ol type="1">
<li>学习模型，并输入用户u和物料t，输入模型中返回score</li>
<li>返回最匹配的score最高的物料t</li>
</ol>
<p><strong>存在的问题是数据量太大且时间开销太大无法满足实时要求</strong></p>
<h2 id="rs功能架构">RS功能架构</h2>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240109105250694.png"
alt="image-20240109105250694" />
<figcaption aria-hidden="true">image-20240109105250694</figcaption>
</figure>
<p>召回</p>
<ul>
<li>离线计算+在线缓存（缺少用户信息和物料信息的交叉）</li>
<li>多路召回弥补精度的不足</li>
<li>召回和排序存在很大的差别</li>
</ul>
<p>精排</p>
<ul>
<li>提升预测精度</li>
<li>让物料信息和用户信息充分交叉，使用复杂的交叉结构和特征来提升精度</li>
</ul>
<p>粗排</p>
<ul>
<li>不用物料信息和用户信息充分交叉</li>
<li>仍然依赖离线计算+在线缓存</li>
</ul>
<p>重排</p>
<ul>
<li>调整精排的结果顺序，将相似内容打散，保证看到的推荐结果更加丰富多样</li>
</ul>
<h2 id="rs数据架构">RS数据架构</h2>
<p>存在的问题：</p>
<ol type="1">
<li>统计窗口长导致涉及的计算量会比较大，线上预测时间紧张</li>
<li>回溯历史存在Hadoop分布式文件系统(HDFS)中存的是冷数据，但是仍然有一批热数据没有落HDFS中，从而导致数据没办法全面接收</li>
</ol>
<p><strong>Lambda架构</strong></p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240109110837295.png"
alt="image-20240109110837295" />
<figcaption aria-hidden="true">image-20240109110837295</figcaption>
</figure>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240109110904180.png" alt="image-20240109110904180" style="zoom:50%;" /></p>
<p>离线层</p>
<ul>
<li>冷数据请求的计算</li>
<li>启动小时级的定时任务，每个小时都向前回溯一周的用户行为日志，统计时间窗口中每个视频的曝光数和点击数</li>
</ul>
<p>近线层</p>
<ul>
<li>KV数据库存储，缓存加速访问</li>
<li>提高查询速度</li>
</ul>
<p>在线层</p>
<ul>
<li>流式计算框架，对接用户的行为数据存储在Redis数据库汇总快速查询</li>
</ul>
<h2 id="rs特征工程">RS特征工程</h2>
<p>必要性：</p>
<ul>
<li>DNN万能函数模拟器并不可靠，输入数据未经处理会影响DNN性能的发挥</li>
<li>DNN的自动化特征工程对于大量的数据存在耗时等问题</li>
</ul>
<h3 id="特征提取">特征提取</h3>
<p>物料特征</p>
<ul>
<li>物料自身属性信息，Item ID</li>
<li>物料的类别与标签，通过DL的方式学习到物料的静态画像，可以是List等概率存储</li>
<li>内容的Embedding，中间层输出作为输入以丰富物料特征</li>
<li>物料的动态画像，如过去6小时的CTR、过去1天的平均播放时长</li>
<li><strong>反向打标签，选择物料-&gt;用户标签-&gt;丰富物料标签</strong></li>
</ul>
<p>用户特征</p>
<ul>
<li>用户的静态画像：个人信息User ID</li>
<li>用户的动态画像：历史行为中提取出兴趣爱好，反映用户的兴趣迁移</li>
</ul>
<p>交叉特征</p>
<ul>
<li>笛卡尔积，交叉后的特征喂入模型</li>
</ul>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240109144352476.png" alt="image-20240109144352476" style="zoom:67%;" /></p>
<ul>
<li>内积交叉：某个维度上的讨论（用户在维度上的兴趣和物料在维度上的属性向量之间的相似性）</li>
</ul>
<p>偏差特征</p>
<ul>
<li><p>无法做到绝对公平，没点击不代表不喜欢，点击的未必喜欢，偏差Bias</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240109145001311.png"
alt="image-20240109145001311" />
<figcaption aria-hidden="true">image-20240109145001311</figcaption>
</figure></li>
<li><p>Above
Click：只有在点击物料上方的未点击的物料才被当作负样本，没被点击的且不在点击上方的就不放进训练的集合中</p></li>
</ul>
<h3 id="数据特征处理">数据特征处理</h3>
<p>处理缺失值</p>
<ul>
<li>训练模型来预测缺失值</li>
</ul>
<p>标准化数据</p>
<ul>
<li>目的：将不同量纲、不同取值范围的数值压缩到一个数值范围内</li>
<li>标准化z-score方法：<span
class="math inline">\(x^*=(x-\mu)/(\sigma)\)</span>
分别是均值和标准差</li>
</ul>
<p>数据平滑与消偏</p>
<ul>
<li><p>目标：克服小样本的负面影响，提高计算结果的置信区间</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240109145827875.png"
alt="image-20240109145827875" />
<figcaption aria-hidden="true">image-20240109145827875</figcaption>
</figure></li>
</ul>
<p>分桶离散化</p>
<h3 id="类别特征处理">类别特征处理</h3>
<p><strong>推荐系统的特征空间：高维、稀疏</strong></p>
<p>增强类别特征表达</p>
<ul>
<li>Embedding自动学习并拓展内涵，学习<strong>隐语义</strong>拓展单个特征的内涵</li>
<li>多特征交叉，选择用户多个不同的<strong>特征</strong>进行交叉一次来增强特征的表达能力</li>
</ul>
<p>类别特征的高维性</p>
<ul>
<li>Parameter Server架构</li>
<li>分散了参数存储检索的压力，降低了带宽资源与时间开销</li>
</ul>
<p>类别特征的稀疏</p>
<ul>
<li>自适应调整学习率，自适应调整正则系数</li>
</ul>
<p>特征如何<strong>表征</strong></p>
<ul>
<li><p>建立字符串到数字的映射表，缺点在于需要更新维护且对于大规模而言比较难以负担</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240109151109287.png"
alt="image-20240109151109287" />
<figcaption aria-hidden="true">image-20240109151109287</figcaption>
</figure></li>
<li><p>采用特征哈希Feature Hashing</p></li>
</ul>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240109151313025.png"
alt="image-20240109151313025" />
<figcaption aria-hidden="true">image-20240109151313025</figcaption>
</figure>
<h2 id="rs的embedding">RS的Embedding</h2>
<h3 id="为什么要embedding">为什么要Embedding</h3>
<p>对于推荐系统而言：<strong>记忆+拓展</strong></p>
<p><strong>记忆</strong>能够处理80%的需求，但是个性化太弱（评分）</p>
<p><strong>拓展</strong>将细粒度变成粗粒度，借助深度学习的Embedding</p>
<h3 id="共享独占embedding">共享&amp;独占Embedding</h3>
<p>共享Embedding</p>
<ul>
<li>指需要喂入模型的多个地方</li>
<li>有利于缓解特征稀疏、数据不足所导致的问题</li>
<li>无法很好满足推荐系统的多目标性</li>
</ul>
<p>独占Embedding</p>
<ul>
<li><p>不同的任务使用不同的Embedding的方法</p></li>
<li><p>如果在特征交叉的时候使用的是共享Embedding，会产生相互干扰的情况（不同需求要求不同Embedding）</p></li>
<li><p>FFM：每个特征在与不同特征交叉的时候，根据对方特征所属的Field要使用不同的Embedding</p></li>
<li><p>CAN：既要使用不同的Embedding进行特征交叉，但是又不想要太多的参数导致训练的难度增加</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240109153140728.png"
alt="image-20240109153140728" />
<figcaption aria-hidden="true">image-20240109153140728</figcaption>
</figure></li>
</ul>
<h3 id="parameter-server加速器">Parameter Server加速器</h3>
<p>传统利用Hadoop/Spark的分布式训练方法忽略了<strong>高维稀疏特征空间</strong>
直接让master处理会参数量很大</p>
<p>使用PS架构的好处：</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240109153552264.png"
alt="image-20240109153552264" />
<figcaption aria-hidden="true">image-20240109153552264</figcaption>
</figure>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240109153727333.png"
alt="image-20240109153727333" />
<figcaption aria-hidden="true">image-20240109153727333</figcaption>
</figure>
<p>一个Server只负责处理海量参数中的一部分</p>
<h3 id="ps中的并发策略">PS中的并发策略</h3>
<p><strong>同步并发</strong></p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240109154105460.png"
alt="image-20240109154105460" />
<figcaption aria-hidden="true">image-20240109154105460</figcaption>
</figure>
<p><strong>异步并发</strong></p>
<p>无须等待，不存在短板效应，有明显的速度优势</p>
<p><strong>梯度失效</strong>的问题： <img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240109154409333.png"
alt="image-20240109154409333" /></p>
<p><strong>半同步半异步</strong></p>
<p>允许Worker节点在一定迭代轮数中保持异步，但是如果最快节点和最慢节点的迭代步数之差已经超过了允许的最大值，那么所有的参数都需要停下来进行一次参数的同步</p>
<h2 id="精排">精排</h2>
<h3 id="特征交叉方法">特征交叉方法</h3>
<p>传统方法：FTRL</p>
<p>FM：引入了二阶特征交叉（手动二阶特征交叉）</p>
<p>Wide&amp;Deep：兼顾记忆与扩展</p>
<p>DeepFM ：融合二阶交叉（实现了自动二阶特征交叉）</p>
<p>DCN：能够指定任意显式交叉</p>
<p>Autolnt：基于Transformer作特征交叉</p>
<h3 id="用户行为序列建模">用户行为序列建模</h3>
<p>本质：将用户行为序列提炼并压缩成用户兴趣的Embedding</p>
<p>DIN：利用Attention，将当前的物料t作为用户历史序列的Query</p>
<p>双层Attention行为序列：第一层Attention历史行为序列内部的依赖关系；第二层是当前物料和历史行为序列</p>
<p>SIM：将“软过滤”变成“硬过滤”，相当于从长序列选择短序列进行DIN</p>
<h2 id="召回">召回</h2>
<h3 id="向量化召回统一建模框架">向量化召回统一建模框架</h3>
<p>定义：将召回问题建模成向量空间中的近邻搜索问题</p>
<p>分类：两类实体QT，可以是物料-用户、用户-用户、物料-物料</p>
<p>方法流程：</p>
<ol type="1">
<li>训练一个模型，并将QT映射到同一个向量空间</li>
<li>构建起索引向量数据库</li>
<li>对于传入的Q实例先进行Embedding 再进行近邻搜索</li>
</ol>
<p>建模方法：</p>
<ul>
<li>如何定义正样本</li>
<li>如何定义负样本</li>
<li>如何将q和t映射成Embedding</li>
<li>如何定义优化目标和损失函数</li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>推荐系统</tag>
      </tags>
  </entry>
</search>
