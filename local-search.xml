<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【多智能体强化学习】Pymarl环境配置</title>
    <link href="/2023/10/22/pymarl%E7%8E%AF%E5%A2%83/"/>
    <url>/2023/10/22/pymarl%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>SMAC是WhiRL在基于暴雪星际争霸IIRTS游戏的协作多智能体强化学习(MARL)领域的研究环境。SMAC利用暴雪的《星际争霸2》机器学习API和DeepMind的PySC2为自主代理提供了一个方便的接口，让它们与《星际争霸2》互动，获得观察结果并执行动作。</p><p>主要介绍在多智能体强化学习中的验证平台SAMC和Pymarl的配置和安装过程</p><p>环境地址：<ahref="https://github.com/oxwhirl/pymarl">https://github.com/oxwhirl/pymarl</a></p><p>依赖环境：<ahref="https://github.com/oxwhirl/smac">https://github.com/oxwhirl/smac</a></p><p>主要针对Ubuntu下的Pymarl环境的配置（MAC和Windows类似）</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231022145734342.png"alt="SMAC" /><figcaption aria-hidden="true">SMAC</figcaption></figure><h2 id="安装starcraftii">安装StarCraftII</h2><h3 id="windowsmac">Windows/Mac</h3><p>直接在官网下载安装最新版，需要加速器或者更换亚服：https://sc2.blizzard.cn/landing</p><p>安装地图：https://link.zhihu.com/?target=https%3A//github.com/oxwhirl/smac/releases/download/v0.1-beta1/SMAC_Maps.zip</p><p>将地图放在Maps文件夹下</p><h3 id="ubuntu">Ubuntu</h3><p>在Ubuntu系统中，安装需要版本的SCII即可https://github.com/Blizzard/s2client-proto#downloads</p><p>下载压缩包之后安装并解压放到用户名文件夹下：～/StarCraftII/</p><p>如果没有把SCII安装到用户名之下，这个地方的路径可以根据放置的位置来进行更改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim ~/.bashrc<br></code></pre></td></tr></table></figure><p>在最后一行增加环境变量，这里可以更改星际争霸的位置索引到任何想要放置的位置</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">SC2PATH</span>=~/StarCraftII/<br></code></pre></td></tr></table></figure><p>添加完之后更新环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure><p>添加SAMC的地图：Linux系统在下载SCII的时候就自带了地图</p><h2 id="安装smac">安装SMAC</h2><p>创建虚拟环境并安装pytorch</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">conda create -n pymarl python=<span class="hljs-number">3.8</span> -y<br>conda activate pymarl   <br><span class="hljs-comment"># CUDA 10.2 例子具体的的CUDA版本根据自己的服务器来定</span><br>conda install pytorch==<span class="hljs-number">1.10</span><span class="hljs-number">.0</span> torchvision==<span class="hljs-number">0.11</span><span class="hljs-number">.0</span> torchaudio==<span class="hljs-number">0.10</span><span class="hljs-number">.0</span> cudatoolkit=<span class="hljs-number">10.2</span> -c pytorch<br></code></pre></td></tr></table></figure><p>直接利用虚拟环境中的pip来安装</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install git+https://github.com/oxwhirl/smac.git<br></code></pre></td></tr></table></figure><p>或者可以利用git进行安装，先gitclone下载下来然后进入文件夹中进行安装</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">git clone https://github.com/oxwhirl/smac.git<br>pip install -e smac/<br></code></pre></td></tr></table></figure><p>如果pip install安装失败可以考虑升级pip：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install --upgrade pip<br></code></pre></td></tr></table></figure><p>如果安装的内容失败了可以手动安装，比如pymarl运行所依赖的包有以下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install sacred numpy scipy matplotlib seaborn pyyaml pygame pytest probscale imageio snakeviz tensorboard-logger<br><br></code></pre></td></tr></table></figure><p>或者根据<ahref="https://github.com/oxwhirl/pymarl/tree/master/docker">https://github.com/oxwhirl/pymarl/tree/master/docker</a>中的bash脚本中Dockerfile依赖内容进行安装</p><h2 id="pymarl与scii">Pymarl与SCII</h2><h3 id="采用上述安装步骤">采用上述安装步骤</h3><p>对于上述的操作完成操作之后，下载pymarl的环境包并进入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">git clone git@github.com:oxwhirl/pymarl.git<br>cd pymarl<br></code></pre></td></tr></table></figure><p>将上述安装的SCII文件夹复制到pymarl的src的3dparty之下</p><h3 id="如果利用docker安装">如果利用Docker安装</h3><p>或者根据pymarl中的内容对上述环境进行自动配置（需要Docker）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> docker<br>bash build.sh<br></code></pre></td></tr></table></figure><p>同时安装SCII和SMAC</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bash install_sc2.sh<br></code></pre></td></tr></table></figure><h2 id="测试环境">测试环境</h2><h3 id="测试地图信息">测试地图信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">python -m smac.<span class="hljs-built_in">bin</span>.map_list <br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231022153907123.png" alt="Maps show" style="zoom:67%;" /></p><h3 id="测试环境信息">测试环境信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">python -m smac.examples.random_agents<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231022153709693.png" alt="test agents" style="zoom: 50%;" /></p><h3 id="测试pymarl环境">测试Pymarl环境</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">python src/main.py --config=qmix --env-config=sc2 <span class="hljs-keyword">with</span> env_args.map_name=2s3z<br></code></pre></td></tr></table></figure><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231022153651418.png"alt="test pymarl" /><figcaption aria-hidden="true">test pymarl</figcaption></figure><h2 id="额外设置">额外设置</h2><p>在利用pymarl进行实验的过程中可能会出现</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231022154059365.png"alt="some bug" /><figcaption aria-hidden="true">some bug</figcaption></figure><p>需要进行设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim torch/_tensor.py<br></code></pre></td></tr></table></figure><p>将757行的内容进行修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">-: self.numpy()<br>+: self.cpu().numpy()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
      <category>强化学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>深度学习</tag>
      
      <tag>强化学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【自动驾驶】RSS Model for Autonomous Driving</title>
    <link href="/2023/10/21/RSS-Model/"/>
    <url>/2023/10/21/RSS-Model/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="rss-model-for-autonomous-driving"><strong>RSS Model forAutonomous Driving</strong></h2><h4id="论文on-a-formal-model-of-safe-and-scalable-self-driving-cars">论文：《Ona Formal Model of Safe and Scalable Self-driving Cars》</h4><h4 id="contribution"><strong>Contribution：</strong></h4><ul><li>Safety (RSS model) Reasonable care, Responsibility, agile drivingpolicy</li><li>Semantic (Semantic language) :Defined Q function over the Semanticspace</li><li>PAC sensing model：Safety and Comfort of driving ；tied to the Qfunction;</li></ul><h4 id="safety-concept"><strong>1. Safety Concept</strong></h4><p>Functional versus nominal safety 功能安全与名义安全</p><p>Functional Safety，FuSa 是指电子电路中操作的完整性</p><p>名义安全是在假设HW和SW系统运行无差错(即在功能上是安全的)的情况下，AV是否正在做出安全的逻辑决策。</p><p>Sense，Plan，Act 感知 计划 行动</p><h4 id="现有的自动驾驶汽车的决策方案"><strong>2.现有的自动驾驶汽车的决策方案</strong></h4><ul><li>Miles driven ：基于统计的论点，同时需要较大的统计量数据</li><li>disengagements（脱离）：被定义为人类安全驾驶人因为做出不安全的决定而不得不干预AV的运行，从而导致事故的情况。</li><li>simulation：建立虚拟世界模拟器，模拟器和显示世界的差距，无法建模全部的策略</li><li>scenario based testing：枚举现实世界的驾驶场景，过度拟合和泛化的问题</li><li>proprietary approaches</li></ul><h4id="rssresponsibility-sensitive-safety-model-for-multi-agent-safety"><strong>3.RSS(Responsibility-Sensitive-Safety) Model for Multi-agentSafety</strong></h4><ul><li><p>目标：</p><ul><li>做不到绝对安全，需要有Reasonable的响应</li><li>遵循RSS能做到乌托邦Utopia</li><li>敏捷而非防御，不应当过于谨慎而影响其他驾驶</li><li>法律解释的意义</li></ul></li><li><p>形式化的规则：</p><ol type="1"><li>Do not hit someone from behind.</li><li>Do not cut-in recklessly.</li><li><strong>Right-of-way is given, not taken.</strong>道路通行权是给予的而不是占用的</li><li>Be careful of areas with limited visibility小心有限可视化的范围</li><li>If you can avoid an accident without causing another one, you mustdo it.</li></ol></li></ul><h5 id="single-land-road-单向道路的情况"><strong>3.1 Single Land Road单向道路的情况</strong></h5><ul><li><p>不考虑前车倒退的情况，后车撞上前车那么后车负责，后车有责任和前车保持距离</p></li><li><p><span class="math inline">\(c_r\)</span>表示前车，<spanclass="math inline">\(c_f\)</span>表示后车，<spanclass="math inline">\(\rho\)</span>表示的是前车的反应时间，<spanclass="math inline">\(a_{max,break}\)</span>表示的是前车的最大加速度，<spanclass="math inline">\(a_{max,accel}\)</span>表示的是最多的加速制动，<spanclass="math inline">\(a_{min,break}\)</span>表示的是后车的最小制动加速度来保证不会撞到前车</p></li><li><p><strong>同方向行驶</strong>的安全距离</p><p>给出最小的安全纵向距离： <span class="math display">\[d_{min}=max\{v_r\rho+1/2a_{max,accel}\rho^2+((v_r+\rhoa_{max,accel})^2)/2a_{min,break}-v_f^2/2a_{max,break},0\}\]</span></p></li><li><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915172320331.png"alt="Definition 1" /><figcaption aria-hidden="true">Definition 1</figcaption></figure></li><li><p><span class="math inline">\(t_b\)</span> dangerous time；<spanclass="math inline">\([t_b,t_b+\rho]\)</span> 表示一定的反应时间在这个范围之内在给定的加速度范围之内 执行proper response</p></li><li><p>Proper Response：表示我们允许执行的最大加速度的限制，并取最小值约束保证满足所有的约束</p></li><li><p>安全纵向距离和Proper Response取决于参数：<spanclass="math inline">\(\rho,a_{max,sccel},a_{min,brake},a_{max,brake}\)</span>参数保证了对智能体行为的假设，选择适当的参数</p></li><li><p>Utopia is possible如果所有智能体车辆都能够遵循合理的响应，那么能归纳证明可以规避事故的发生</p></li></ul><h5 id="a-lane-based-coordinate-system-基于车道的坐标系"><strong>3.2 ALane-Based Coordinate System 基于车道的坐标系</strong></h5><ul><li><p>车道中心是平面上一条平滑有向的曲线 <spanclass="math inline">\(r\)</span> ,其中所有部分可以表示为 <spanclass="math inline">\(r^{(1)},...,r^{(k)}\)</span>即可以是线性的，也可以是弧形的</p></li><li><p>构造 <span class="math inline">\(R-&gt;R^2\)</span>的变换为 <spanclass="math inline">\(\phi\)</span>就是横纵坐标，从而来保证在逻辑上的前后车辆的关系</p></li><li><p>具体的映射的方式可以表示为如下：</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915172406204.png"alt="道路映射的方式" /><figcaption aria-hidden="true">道路映射的方式</figcaption></figure></li><li><p>横纵速度/加速度的计算就可以通过这样的坐标系定义之下得到的一阶/二阶的导数计算得到</p></li></ul><h5id="longitudinal-safe-distance-and-proper-response-纵向约束"><strong>3.3Longitudinal Safe Distance and Proper Response 纵向约束</strong></h5><ul><li><p>给出安全距离的定义：</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915172437378.png"alt="Definition 2" /><figcaption aria-hidden="true">Definition 2</figcaption></figure><p>安全距离定义的想法是，如果两辆车都能对违反安全距离的行为做出“适当”反应，那么就不会发生碰撞。如果其中一个没有“正确”反应，那么它就应对事故负责。</p></li><li><p>那么我们需要知道危险发生的时间，定义这样一个时刻<strong>DangerousLongitudinal Situation and Danger Threshold</strong></p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915172501683-20231022115917321.png"alt="真正的危险时间" /><figcaption aria-hidden="true">真正的危险时间</figcaption></figure><p>给定一个纵向的危险发生的时间段</p></li><li><p><strong>longitudinal proper response 纵向的适当响应</strong></p><p>blame time责任时间表示的是这个时间能够将驾驶的责任从自动驾驶汽车转移到驾驶员身上，如果接管了那么后续的责任将由驾驶员负责，否则由汽车负责</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915172514045-20231022115917843.png"alt="Definition 4" /><figcaption aria-hidden="true">Definition 4</figcaption></figure><p>给出了对于纵向单向行驶而言的速度和加速的要求，需要在危险到来之前做出合理的响应</p></li></ul><h5id="lateral-safe-distance-and-proper-response-横向的约束"><strong>3.4Lateral Safe Distance and Proper Response 横向的约束</strong></h5><ul><li><p>稳健侧向速度 <spanclass="math inline">\(\mu\)</span>：汽车总是存在横向的一个微小摆动:<span class="math display">\[\mu-lateral-v=(l_{out}-l)/(t_{out}-t)\]</span></p></li><li><p>横向安全距离：</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915172633796.png"alt="Definition 6" /><figcaption aria-hidden="true">Definition 6</figcaption></figure><p>对于双方而言都有一个加速度，同时有一个最小的制动加速度</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915172648760.png"alt="Lemma 4" /><figcaption aria-hidden="true">Lemma 4</figcaption></figure></li><li><p>同样定义横向的危险时间和危险区间时间：</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173056976-20231022115918644.png"alt="Definition 7" /><figcaption aria-hidden="true">Definition 7</figcaption></figure></li><li><p><strong>Lateral Proper response 给出横向的适当反应</strong></p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173119252.png"alt="Definition 8" /><figcaption aria-hidden="true">Definition 8</figcaption></figure><p>首先如果在适当的响应时间范围之内，那么只需要限制两车的加速度在一定的范围之内</p><p>如果超出了适当响应时间，那么对于两车的加速度限制需要更改</p></li></ul><h5id="combining-longitudinal-and-lateral-proper-responses-横向和纵向相结合"><strong>3.5Combining Longitudinal and Lateral Proper Responses横向和纵向相结合</strong></h5><ul><li><p>对于横向和纵向结合的车道，定义危险时间和危险情况</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173150615.png"alt="Defintion 9" /><figcaption aria-hidden="true">Defintion 9</figcaption></figure></li><li><p>危险阈值时间定义为横向和纵向的危险阈值时间的最大值，同样定义了危险时间t</p></li><li><p><strong>Basic Proper response to dangerous situations对于危险情况的正确反应处理</strong></p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173218415.png"alt="Definition 10" /><figcaption aria-hidden="true">Definition 10</figcaption></figure><p>对于危险的阈值速度进行分析，如果分别为纵向的阈值速度和横向的阈值速度，那么分别根据前面所述的Definition4和Definition 8 进行速度的限制</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173251798-20231022115919728.png" alt="横向纵向情况" style="zoom:50%;" /></p><p>上面的这张图可以说明问题，当横纵的任意一个方向到达危险的阈值情况，分别作出ProperResponse，那么就可以按照合理的方式来规避风险</p></li><li><p><strong>Lemma5 Utopia is possible</strong></p><p>Consider a multi-lane road where all lanes share the same geometry.Suppose that at all times, all cars on the road comply with the basicproper response as given in Definition 10. Then, there will be<strong>no collisions</strong></p><p>归纳证明说明如果在合适的范围之内作出合理的响应，那么能规避碰撞</p></li></ul><h5id="compensating-for-improper-behavior-of-others-他人的不正当行为"><strong>3.6Compensating for improper behavior of others他人的不正当行为</strong></h5><ul><li><p>如果对方没做出合理反应，那么自己应当作出合适反应避免发生事故，同时不引起下一个事故</p></li><li><p>Naive Prediction：根据速度和加速度线性外推</p></li><li><p>EvasiveManoeuvre：给出两个函数来尽量规避出现车祸，就是根据时间来给速度和加速度的变化规划</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173348421.png"alt="Definition 12" /><figcaption aria-hidden="true">Definition 12</figcaption></figure><p>相当于给出两个函数来知道汽车应当在某个时间范围内到达什么样的位置是安全的，那么要达到这样的位置汽车要采取什么样的速度和加速度来实现</p><p><strong>if you can avoid an accident without causing anotheraccident, you must do it</strong></p></li></ul><h5id="proper-response-with-extra-evasive-effort-制动规避的适当反应"><strong>ProperResponse with Extra Evasive Effort 制动规避的适当反应</strong></h5><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173422047-20231022115920481.png"alt="Definition 13" /><figcaption aria-hidden="true">Definition 13</figcaption></figure><h5id="multiple-geometry-and-right-of-way-rules处理几何图形区域的车辆优先权问题"><strong>3.7Multiple Geometry and Right-of-WayRules处理几何图形区域的车辆优先权问题</strong></h5><ul><li><p>如果有存在不同的几何形状的情形会导致响应的冲突</p></li><li><p>定义横向的安全距离对于<strong>不同的几何路径</strong>对于相同的几何路径仍然成立</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173615571.png"alt="Definition14" /><figcaption aria-hidden="true">Definition14</figcaption></figure><p>向位置范围为[x_i,min,x_i,max]，按照不同的加速度行驶，且不能超过指定的加速度制动那么，则c_1和c_2之间的横向安全距离需要满足：<strong>两车之间横向距离的最小值应大于Definition7中定义的横向安全距离</strong></p></li><li><p>那么如何作出适当的反应 Proper response，给出合适的速度约束</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173634068-20231022115921111.png"alt="横向的合适响应" /><figcaption aria-hidden="true">横向的合适响应</figcaption></figure><p>在反应时间之内可以按照加速度范围内进行移动，但是当超过反应时间之后就要对侧向的速度进行制动</p></li><li><p>定义不同几何路况的纵向的顺序</p><ul><li><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173650265-20231022115921291.png"alt="路况优先权问题" /><figcaption aria-hidden="true">路况优先权问题</figcaption></figure><p>如果在同一条路上那么直接有先后顺序</p><p>如果不在同一条路上，那么根据车辆距离两条道路的相交的位置来定</p><p>当存在纵向的安全距离才会用到这个定义，同时应当是明显的前后顺序</p></li></ul></li><li><p>纵向的安全距离（不同的几何路径）</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173703808-20231022115921710.png"alt="Definition 17" /><figcaption aria-hidden="true">Definition 17</figcaption></figure><ol type="1"><li>如果c_i没有路径的优先级，那么将在路口汇入的位置执行加速到减速的过程停在路口</li><li>如果c_1在c_2前面，c_1执行任意动作（最大刹车加速度的意思是保证这个动作的距离下限），c_2执行最大加速-最小减速过程。当两车速度都为0时，c_1仍然在c_2前面（即后车要刹得住，当前车停下时，纵向顺序关系依然能保持）</li><li>如果没有优先级和前后关系，则考虑两车到达路口的时间范围，如果两者时间范围相交，则有碰撞风险，都需要刹车，反之就正常走。</li></ol><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173722252.png"alt="示意图" /><figcaption aria-hidden="true">示意图</figcaption></figure></li><li><p>纵向的安全响应（Proper response）</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173840619.png"alt="Definition18" /><figcaption aria-hidden="true">Definition18</figcaption></figure><ol type="1"><li>longitudinal proper response取决于Danger ThresholdTime前的situation：</li><li>如果17.1满足，则优先车辆正常开，另外一个则需要在反应时间后刹车。</li><li>如果17.2满足，则前面车辆正常开，候车需要在反应时间后刹车。</li><li>如果17.3满足，两车都需要在横向和纵向上刹车（这里又提到了横向，是纵向已经不能完全规避碰撞风险，所以需要引入横向动作）。</li></ol></li><li><p>Traffic Lights</p><ol type="1"><li>不能简单通过红绿灯的情况来将责任分配给不同的车辆，对于例外的路口的车辆</li><li>绿灯的有优先权 但不是有优先权的就对于规则而言没有责任</li><li>The above discussion is a formalism of the common sense rule of<strong>right of way is given, not taken.</strong></li></ol></li></ul><h5 id="unstructured-road-非结构化的道路"><strong>3.8 Unstructured Road非结构化的道路</strong></h5><ol type="1"><li><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173851532-20231022115922491.png"alt="Definition 19" /><figcaption aria-hidden="true">Definition 19</figcaption></figure><p>轨迹这个表示了根据时间而改变的位置状态，ts的定义就表示车辆第一次完全停止的时间</p><p><strong>未来某部分时刻汽车的位置、某个时间车辆的角度</strong></p></li><li><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173902698-20231022115922745.png"alt="Definition20" /><figcaption aria-hidden="true">Definition20</figcaption></figure><p>当两车的轨迹不满足以下条件时，则称会发生碰撞：</p><p>（1）对于两车均停止之前的任意时刻，两车之间距离均大于epsilon。</p><p>（2）在某车停车之前，两车之前距离均大于epsilon，且此时第二辆车的速度矢量指向第一辆车。即当前车停车，后车依然往前车方向开，后车需要与前车保持距离。</p></li><li><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173913570.png"alt="Definition 21" /><figcaption aria-hidden="true">Definition 21</figcaption></figure><p>定义Constrains（C）下的轨迹T(C,c)，刹车/正常向前行驶的轨迹分别表示为T(Cb, c)和T(Cf,c).</p></li><li><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173936523.png"alt="Definition 22" /><figcaption aria-hidden="true">Definition 22</figcaption></figure><ol type="1"><li>其中一辆车的刹车轨迹和另一辆车的前进轨迹不相交，那么安全（注意保持先后关系对两辆车都适用）</li><li>两辆车都刹车，轨迹没有相交</li></ol></li><li><p>如果不满足安全的要求，那么应当选择Proper Response：</p><ol type="1"><li>如果两辆车都停着，那么其中一辆车应当远离另一辆车选择用Definition20的方法远离</li><li>否则，如果根据safedistance(1)的定义是安全的，一辆车执行刹车，另一辆车在停下来之前就要按照Cf的轨迹正常开，都停下来之后就回到了（1）</li><li>同时选择刹车</li></ol></li></ol><h5 id="pedestrians-行人"><strong>3.9 Pedestrians 行人</strong></h5><ul><li><p>安全距离和合理反应；和汽车相比调整参数且增加非结构化的假设</p></li><li><p>在斑马线或者是人行道上规定行人的行为，行人的合理活动范围是一个以他为圆心的圆</p></li><li><p>遵循互不干扰否则有责任的准则，当汽车进入行人的可能出事的范围那么汽车有责，否则行人有责任</p></li></ul><h5 id="cautiousness-with-respect-to-occlusion-遮挡问题"><strong>3.10Cautiousness with respect to Occlusion 遮挡问题</strong></h5><ul><li><p>Exposure Time 曝光时间：第一次看到这个物体的时间</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173954765-20231022115923512.png"alt="Definition23" /><figcaption aria-hidden="true">Definition23</figcaption></figure></li><li><p><strong>速度不合理导致的不合理情况</strong>：</p><p>相当于速度的范围不在给定的合理的区间。上述提到的参数和地图上的每个汽车的位置、优先级规则和其他的场景结构等条件相关联</p><ol type="1"><li><p>具有道路优先级的汽车的最大速度优先级较高</p></li><li><p>速度的阈值范围根据具体的道路结构</p></li></ol><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915174217869.png"alt="遮挡示意图" /><figcaption aria-hidden="true">遮挡示意图</figcaption></figure></li></ul><p>相当于对于遮挡问题需要对双方的车辆有速度限制才能保证危险的发生</p><h5 id="不当行为造成的不合理的情况"><strong>3.11不当行为造成的不合理的情况</strong></h5><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915174242726.png"alt="Definition 25" /><figcaption aria-hidden="true">Definition 25</figcaption></figure><p>对于出现遮挡的参与者都要保持合理的行为才能规避事故</p><p><strong>对于有遮挡的正确响应方法</strong>：规避不合理的情况，包括但不限于24-25的</p><h5 id="responsibility"><strong>3.12 Responsibility</strong></h5><ul><li>明确智能体责任</li><li>发生碰撞那么有可能是其中一个智能体没有遵守适当的响应约束，那么需要对事故负责</li></ul><h5 id="utopia">3.13 Utopia</h5><ul><li>Lemma 5证明如果所有汽车都遵循基本的响应规则，那么不会发生碰撞</li><li>Lemma6证明如果对于遮挡的问题都能做出合理的响应规则，那么就不会发生事故（反证法）</li></ul><h4 id="driving-policy-rl"><strong>4. Driving Policy（RL）</strong></h4><ul><li><p>驾驶策略的定义：驾驶策略是从感知状态到驾驶命令的映射</p></li><li><p>构建高效的驾驶策略，拓展到百万级别的策略</p></li><li><p>描述驾驶策略的语言：(利用强化学习的描述方法)</p><ol type="1"><li><p><span class="math inline">\(s_t\)</span>表示某一时刻的状态，<spanclass="math inline">\(\pi\)</span>表示的是策略函数，<spanclass="math inline">\(a_t\)</span>表示的是汽车能够选择的动作，根据策略函数来确定，得到一块序列<span class="math inline">\(&lt;s_t,a_t&gt;\)</span></p></li><li><p><span class="math inline">\(P_{\pi}\)</span>表示的是根据 <spanclass="math inline">\(\pi\)</span> 选择产生的后面不同序列<spanclass="math inline">\(&lt;s_t,a_t&gt;\)</span>的概率</p></li><li><p><span class="math inline">\(E_{s~P_\pi}[\rho(s)]\)</span>用于衡量当前策略的好坏程度，相当于对当下这个策略可能产生的不同奖励值选择期望，同时<spanclass="math inline">\(\rho(s)\)</span>表示的是当前状态下的奖励</p></li><li><p>在实际的实现过程中，<spanclass="math inline">\(a_t\)</span>表示的是本车与其他道路使用者的位置、速度和加速度等问题，<spanclass="math inline">\(s_{t+1}\)</span>表示的是下一时刻的状态，同时取决于当前时刻的动作以及其他智能体的行为，奖励函数<spanclass="math inline">\(\rho(s)\)</span>取决于当前环境中的其他智能体的相对位置速度等信息。</p></li><li><p>价值函数 <spanclass="math inline">\(Q\)</span>表示的是当前智能体执行某一个动作所能造成的长期回报,由此来选择最好的策略函数来保证<span class="math inline">\(\pi(s)=argmaxQ(s,a)\)</span></p></li><li><p><span class="math display">\[Q(s, a)=\max _{(a_t, \ldots, a_{t+T})} \sum_{\tau=t}^T \rho(s_\tau,a_\tau )  \quad  {  s.t. } \quad s_t=s, a_t=a, \forall \tau,s_{\tau+1}=f(s_\tau, a_\tau)\]</span></p><p>定义价值函数的计算方式，根据每个时刻汇总得到的奖励值进行求和得到的总的价值</p></li><li><p>参数 <span class="math inline">\(T\)</span>表示的是“规划时间范围” 控制计算时间和评估质量之间的自然权衡，如果 <spanclass="math inline">\(T\)</span>越大那么说明当前的动作评估效果越好</p></li></ol></li><li><p>计算价值函数挑战：</p><ol type="1"><li>如果将动作空间进行离散，那么需要较大的计算空间，依赖于巨大的计算能力</li><li>采用离线计算，离散化动作域和状态域，然后采用离线的计算方式评估每个<span class="math inline">\(（s,a）\)</span> 的价值</li><li>采用动态规划，计算每个 <spanclass="math inline">\(（s,a）\)</span>的价值函数值 <spanclass="math inline">\(Q（s,a）\)</span> 仍然面临计算空间较大的问题</li><li>利用有限类函数来近似价值函数，但是无法做出良好的近似，同时对于这样的神经网络比较难以学习</li><li>当更新时间较小存在一定的信噪比，导致学习速度及其缓慢，逼近类方法固有的问题</li><li>总结：<strong>资源计算量巨大的方法</strong>和<strong>粗糙近似逼近</strong>会带来不同程度的问题</li></ol></li><li><p><strong>Semantics</strong> to the rescue重新定义自动驾驶语义</p><ul><li><p>在语义动作空间上定义价值函数Q：语义空间较小无语大量计算资源，能够对价值函数Q进行准确的估计</p></li><li><p>语义动作空间：</p><ol type="1"><li><p>主要思想：纵向目标；横向目标；实现目标的积极性程度</p><p>横向：Lateral goals are desired positions in lane coordinate system(e.g., “my goal is to be in the center of lane number 2”).</p><p>纵向： Longitudinal goals are of three types. The first is relativeposition and speed w.r.t. other vehicles (e.g., “my goal is to be behindcar number 3, at its same speed, and at a distance of 2 seconds fromit”).</p><p>速度目标：speed target (e.g., “drive at the allowed speed for thisroad times 110%”).</p><p>速度限制：speed constraint at a certain position (e.g., whenapproaching a junction, “speed of 0 at the stop line”, or when passing asharp curve, “speed of at most 60kmh at a certain position on thecurve”).<strong>速度曲线</strong></p></li><li><p>确定横向目标和纵向目标之间的组合，利用运动学公式来实现目标</p></li><li><p>语义动作空间产生了所有可能的几何曲线的子集，除了特殊的情况</p></li></ol></li></ul></li><li><p><strong>Constructing an evaluation function for semanticactions</strong> 构建<strong>语义动作的评估</strong>函数</p><ul><li>定义语义动作 <spanclass="math inline">\(A^s\)</span>空间，通过当前的状态 <spanclass="math inline">\(s\)</span>,选择最好的动作 <spanclass="math inline">\(a^s\in A^s\)</span>, 根据一些列的几何轨迹 <spanclass="math inline">\((s_1,a_1),...,(s_T,a_T)\)</span>，同时认为新的下一时刻的状态有一个新的函数给出<span class="math inline">\(s_{t+1}=f(s_t,a_t)\)</span>同时继续根据奖励函数的值来评估执行的语义动作的好坏程度 <spanclass="math inline">\(\frac{1}{T}\sum_{t=1}^T\rho(s_t,a_t)\)</span></li><li>利用语义动作来评估能规避信噪比低等问题</li><li>利用机器学习来泛化，在不同类型的道路上进行训练，推广到不同的道路</li><li>语义动作空间：<strong>资源高效利用同时很准确地进行评估</strong></li></ul></li><li><p><strong>The dynamics of the other agents其他智能体的动态</strong></p><ul><li><span class="math inline">\(s_{t+1}=f(s_t,a_t)\)</span>这样的确定性函数与现实不符合，多个智能体之间会相互影响</li><li>通过高频次地重新应用决策，不断调整策略来适应新的环境</li></ul></li></ul><h4 id="sensing-传感"><strong>Sensing 传感</strong></h4><h5 id="传感研究的内容">传感研究的内容：</h5><p>静态对象：(a fence that occludes relevant part of a mergingroad).；</p><p>动态对象：车辆（边界框、速度、加速度）、行人（边界框、速度、加速度）、交通灯、动态道路分隔线（例如建筑区域的锥体）、临时交通标志和警察活动以及道路上的其他障碍物。</p><h5 id="sensing-system"><strong>Sensing system</strong></h5><ol type="1"><li>Let <span class="math inline">\(S\)</span> denote the domain ofsensing state and let X be the domain of raw sensor and mapping data. A传感系统表示的是一个函数 <span class="math inline">\(\hat{s}\)</span> :<span class="math inline">\(X → S.\)</span></li><li>什么时候传感器的值 <span class="math inline">\(\hat{s}\)</span>能够和状态 <span class="math inline">\(s\)</span>近似？<strong>通过近似之后对驾驶策略的总体表现：安全性和舒适性</strong></li><li>传感器系统可能会犯的<strong>错误类型</strong>：<ul><li>False negative: the sensing system misses an object误报：传感器错过了一个物体</li><li>False positive: the sensing system indicates a “ghost” object错误：传感器系统提示存在幽灵物体</li><li>Inaccurate measurements: the sensing system correctly detects anobject but incorrectly estimates its position or speed测量不准确：传感系统正确检测到物体但是错误估计位置和速度</li><li>Inaccurate semantic: the sensing system correctly detects an objectbut misinterpret its semantic meaning, for example, the color of atraffic light语义信息不准确：传感系统正确检测物体，但误解了语义信息，比如交通灯的颜色</li></ul></li></ol><h5 id="comfort"><strong>Comfort</strong></h5><ul><li>相当于利用传感器函数来近似估计 <spanclass="math inline">\(s\)</span> ,如果 <spanclass="math inline">\(\pi(\hat{s}(x))=\pi(s)\)</span> 也就是说<spanclass="math inline">\(\pi(\hat{s}(x))=argmaxQ(\hat{s}(x),a)\)</span>，那么就说明当前这个传感器是可以的，同时允许有一定的误差范围：<span class="math inline">\(Q(\hat{s}(x),a)\geQ(s,\pi(s))-\epsilon\)</span>，这个时候可以说是 <spanclass="math inline">\(\epsilon-\)</span>准确的，同时也允许传感器有小概率发生故障 <spanclass="math inline">\(\delta\)</span></li><li>For example, we can choose three thresholds, $$1 &lt; $<spanclass="math inline">\(2 &lt;\)</span>$3 to represent mild, medium, andgross mistakes，表示传感器的错误程度，轻中重</li></ul><h5 id="pac-sensing-system"><strong>PAC sensing system</strong></h5><ol type="1"><li><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915174341417.png"alt="Definition 28" /><figcaption aria-hidden="true">Definition 28</figcaption></figure><p><strong>Probably-Approximately-Correct (PAC)</strong>X表示的是原始的数据与映射的数据域，从期望的角度给出误差率的平均值：<span class="math display">\[\mathbb{P}_{(x, s) \sim D}\left[Q(s, \pi(\hat{s}(x))) \geq Q(s,\pi(s))-\epsilon_i\right] \geq 1-\delta_i\]</span></p></li><li><p>通过记录许多人类驾驶员的数据来构建此分布，而不是遵循自动驾驶车辆的特定策略（不切实际），由于任何合理策略对D的影响都很小，通过应用简单的数据增强技术，我们可以构建适当的分布，然后在传感系统的每次重大更新后执行离线验证。</p></li><li><p>重点关注经常发生的“测量不准确”类型的错误</p></li><li><p>let <span class="math inline">\(p(o)\)</span>，<spanclass="math inline">\(\hat{p}(o)\)</span> be the positions of o in thecoordinate system of the host vehicle according to <spanclass="math inline">\(s(x)\)</span>, <spanclass="math inline">\(\hat{s}(x)\)</span>respectively.分别表示某个对象的<strong>真实的位置信息</strong>和<strong>传感器的位置信息</strong>。</p><p>目标到主车辆的距离为：<span class="math inline">\(\|p\|\)</span>，加性误差：<spanclass="math inline">\(\|p(o)-\hat{p}(o)\|\)</span>，相对误差为 <spanclass="math inline">\(\frac{\|p(o)-\hat{p}(o)\|}{\|p(o)\|}\)</span></p></li><li><p>对于positions a set of objects <spanclass="math inline">\(O\)</span>表示的是一堆对象，要求 <spanclass="math inline">\(p(o)\)</span> 和 <spanclass="math inline">\(\hat{p}(o)\)</span>之间的相对误差小于一个精确度不妨计作$$ ,但是<span class="math inline">\(\epsilon-ego-accurate\)</span>的传感状态不能保证PAC传感系统能够满足每个合理的价值函数：当相对误差很小的时候，尽管认为合理了，但是对于实际的情况而言会出现不同的价值函数结果。选择制动or继续前进，<strong>横向不能用相对距离</strong></p></li><li><p>表明<span class="math inline">\(\epsilon-ego-accurate\)</span>并不能保证我们的传感系统是PAC。是否还有其他属性足以满足 PAC传感系统的要求</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915174411587-20231022115924657.png"alt="Definition 29" /><figcaption aria-hidden="true">Definition 29</figcaption></figure></li><li><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915174449633.png"alt="Definition 31" /><figcaption aria-hidden="true">Definition 31</figcaption></figure><p>给出价值函数合理的L-语义-<spanclass="math inline">\(Lipschitz\)</span>条件</p></li><li><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915174520766.png"alt="Lemma 7" /><figcaption aria-hidden="true">Lemma 7</figcaption></figure><p>判定为PAC传感系统的终极判定</p></li></ol><h5 id="safety"><strong>Safety</strong></h5><ul><li><p>目标是减少事故发生的概率，存在两类安全情况：</p><ol type="1"><li>传感系统认为危险情况是不危险的；</li><li>传感器系统认为不危险情况是危险的：当安全的时候突然出现紧急刹车会导致危险</li></ol></li><li><p>解决的是如何确保和验证safety-critic sensingmistake足够小，采用的方法是融合多个工程和技术都独立的子系统。多数子系统认为安全才算安全：</p></li><li><p><strong>单侧c-近似独立</strong>的多个子系统</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915174623604-20231022115925281.png"alt="Definition 32" /><figcaption aria-hidden="true">Definition 32</figcaption></figure></li><li><p>对于服从单侧-c近似独立的子系统，能够推出：</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915174653068.png"alt="Corollary 3" /><figcaption aria-hidden="true">Corollary 3</figcaption></figure><p>基于多子系统方案和Corollary 3，为了达到10^-9失效率，对sensing系统的验证不再需要10^9小时的数据，而是分别对每个子系统验证10^5小时就可以了</p></li><li><p>独立假设背后的合理性留给我们去推理。有些传感器对会产生完全不相关的误差；单侧-c近似独立是否成立</p></li><li><p>对于安全幽灵而言，当出现至少有两个传感器认为的情况是危险的，才能认为是危险的</p></li><li><p><strong>Building a scalable sensingsystem可扩展的传感器系统</strong></p><ol type="1"><li>Cameras</li><li>Road Experience Management (REM)，不使用点云，而是一种基于语义的方法approach，利用大量的车端detects semantically meaningful objects in thescene (lane marks, curbs, poles, traffic lights,etc.)，并可以对云端进行更新。以可扩展的方式非常频繁地更新地图。此外，自动驾驶车辆可以通过现有的通信平台（蜂窝网络）接收小型地图数据</li><li>A complementary radar and lidarsystem，能够产生极高的精度；直接测量速度和距离，这进一步提高了乘坐的舒适度</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>智能安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
