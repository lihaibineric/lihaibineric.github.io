<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【大语言模型】大模型监督微调</title>
    <link href="/2024/03/24/dl-llm-ft/"/>
    <url>/2024/03/24/dl-llm-ft/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="大语言模型微调">大语言模型微调</h1><h1 id="大模型微调简介">1. 大模型微调简介</h1><h2 id="微调方法定义">1.1 微调方法定义</h2><p>微调（Fine-tuning）是<strong>一种迁移学习的方法</strong>，用于在一个预训练模型的基础上，通过在特定任务的数据上进行有监督训练，来适应该任务的要求并提高模型性能。微调利用了预训练模型在大规模通用数据上学习到的语言知识和表示能力，将其迁移到特定任务上。</p><p>下面是一般的微调步骤：</p><ol type="1"><li><strong>预训练模型选择</strong>：选择一个在大规模数据上进行预训练的模型作为基础模型。例如，可以选择一种预训练的语言模型，如BERT、GPT等。</li><li><strong>数据准备</strong>：准备用于微调的特定任务数据集。这些数据集应包含任务相关的样本和相应的标签或目标。确保数据集与任务的特定领域或问题相关。</li><li><strong>构建任务特定的模型头</strong>：根据任务的要求，构建一个特定的模型头（task-specifichead）。模型头是添加到预训练模型之上的额外层或结构，用于根据任务要求进行输出预测或分类。例如，对于文本分类任务，可以添加一个全连接层和softmax激活函数。</li><li><strong>参数初始化</strong>：将预训练模型的参数作为初始参数加载到微调模型中。这些参数可以被视为模型已经学习到的通用语言表示。</li><li><strong>微调训练</strong>：使用特定任务的数据集对模型进行有监督训练。这包括将任务数据输入到模型中，计算损失函数，并通过反向传播和优化算法（如梯度下降）更新模型参数。在微调过程中，只有模型头的参数会被更新，而预训练模型的参数会保持不变。</li><li><strong>调整超参数</strong>：微调过程中，可以根据需要调整学习率、批量大小、训练迭代次数等超参数，以达到更好的性能。</li><li><strong>评估和验证</strong>：在微调完成后，使用验证集或测试集对微调模型进行评估，以评估其在特定任务上的性能。可以使用各种指标，如准确率、精确率、召回率等。</li><li><strong>可选的后续微调</strong>：根据实际情况，可以选择在特定任务的数据上进行进一步的微调迭代，以进一步提高模型性能。</li></ol><p>微调的关键是在预训练模型的基础上进行训练，从而将模型的知识迁移到特定任务上。通过这种方式，可以在较少的数据和计算资源下，快速构建和训练高性能的模型。</p><h2 id="为什么需要-peft">1.2 为什么需要 PEFT</h2><p>Parameter-EfficientFine-Tuning（PEFT）是一种微调策略，<strong>旨在仅训练少量参数使模型适应到下游任务</strong>。对大规模PLM（pre-trainedlanguage models）进行微调的成本往往高得令人望而却步。在这方面，PEFT方法只微调了少量(额外的)模型参数，从而大大降低了计算和存储成本。最近最先进的PEFT技术实现了与完全微调相当的性能。</p><p>PEFT<strong>通过冻结预训练模型的某些层，并仅微调特定于下游任务的最后几层来实现这种效率</strong>。这样，模型就可以适应新的任务，计算开销更少，标记的例子也更少。尽管PEFT是一个相对较新的概念，但自从引入迁移学习以来，更新最后一层模型已经在计算机视觉领域得到了实践。即使在NLP中，静态和非静态词嵌入的实验也很早就进行了。</p><p>参数高效微调旨在提高预训练模型(如BERT和RoBERTa)在各种下游任务上的性能，包括情感分析、命名实体识别和问答。它在数据和计算资源有限的低资源设置中实现了这一点。它只修改模型参数的一小部分，并且不容易过度拟合。</p><p>参数高效的微调<strong>在计算资源有限或涉及大型预训练模型的情况下特别有用</strong>。在这种情况下，PEFT可以在不牺牲性能的情况下提供一种更有效的方法来微调模型。然而，需要注意的是，PEFT有时可能会达到与完全微调不同的性能水平，特别是在预训练模型需要进行重大修改才能在新任务上表现良好的情况下。</p><p>高效微调技术可以粗略分为以下三大类：增加额外参数（A）、选取一部分参数更新（S）、引入重参数化（R）。而在增加额外参数这类方法中，又主要分为类适配器（Adapter-like）方法和软提示（Softprompts）两个小类。</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240324143801117.png"alt="PEFT 方法汇总联系" /><figcaption aria-hidden="true">PEFT 方法汇总联系</figcaption></figure><blockquote><p>Scaling Down to Scale Up: A Guide to Parameter-EfficientFine-Tuning</p></blockquote><h2 id="微调和参数高效微调之间的区别">1.3微调和参数高效微调之间的区别</h2><p>微调和参数高效微调是机器学习中用于<strong>提高预训练模型在特定任务上的性能</strong>的两种方法。</p><p><strong>微调</strong>就是把<strong>一个预先训练好的模型用新的数据在一个新的任务上进一步训练它</strong>。整个预训练模型通常在微调中进行训练，包括它的所有层和参数。这个过程在计算上非常昂贵且耗时，特别是对于大型模型。</p><p>另一方面，<strong>参数高效微调</strong>是<strong>一种专注于只训练预训练模型参数的子集的微调方法</strong>。这种方法包括为新任务识别最重要的参数，并且只在训练期间更新这些参数。这样，PEFT可以显著减少微调所需的计算量。</p><h2 id="peft-有什么优点">1.4 PEFT 有什么优点</h2><p>在这里，只讨论PEFT相对于传统微调的好处。因此，理解为什么参数有效的微调比微调更有益。</p><ol type="1"><li><strong>减少计算和存储成本</strong>：PEFT只涉及微调少量额外的模型参数，而冻结预训练llm的大部分参数，从而显着降低计算和存储成本</li><li><strong>克服灾难性遗忘</strong>：在LLM的全面微调期间，灾难性遗忘可能发生在模型忘记它在预训练期间学到的知识的地方。PEFT通过只更新几个参数来克服这个问题。</li><li><strong>低数据环境下更好的性能</strong>：PEFT方法在低数据环境下的表现优于完全微调，并且可以更好地推广到域外场景。</li><li><strong>可移植性</strong>：与全面微调的大检查点相比，PEFT方法使用户能够获得价值几mb的小检查点。这使得来自PEFT方法的训练权重易于部署和用于多个任务，而无需替换整个模型。</li><li><strong>与完全微调相当的性能</strong>：PEFT仅使用少量可训练参数即可实现与完全微调相当的性能。</li></ol><h2 id="多种不同的高效微调方法对比">1.5 多种不同的高效微调方法对比</h2><p>参数有效策略可能涉及多种技术：</p><ol type="1"><li><strong>选择性层调整</strong>（<strong>Selective LayerTuning</strong>）：可以只微调层的一个子集，而不是微调模型的所有层。这减少了需要更新的参数数量。</li><li><strong>适配器</strong>（<strong>Adapters</strong>）：适配器层是插入预训练模型层之间的小型神经网络。在微调过程中，只训练这些适配器层，保持预先训练的参数冻结。通过这种方式，适配器学习将预先训练的模型提取的特征适应新任务。</li><li><strong>稀疏微调</strong>（<strong>SparseFine-Tuning</strong>）：传统的微调会略微调整所有参数，但稀疏微调只涉及更改模型参数的一个子集。这通常是基于一些标准来完成的，这些标准标识了与新任务最相关的参数。</li><li><strong>低秩近似</strong>（<strong>Low-RankApproximations</strong>）：另一种策略是用一个参数较少但在任务中表现相似的模型来近似微调后的模型。</li><li><strong>正则化技术</strong>（<strong>RegularizationTechniques</strong>）：可以将正则化项添加到损失函数中，以阻止参数发生较大变化，从而以更“参数高效”的方式有效地微调模型。</li><li><strong>任务特定的头</strong>（<strong>Task-specificHeads</strong>）：有时，在预先训练的模型架构中添加一个任务特定的层或“头”，只对这个头进行微调，从而减少需要学习的参数数量。</li></ol><h2 id="当前高效微调技术存在的一些问题">1.6当前高效微调技术存在的一些问题</h2><p>当前的高效微调技术很难在类似方法之间进行直接比较并评估它们的真实性能，主要的原因如下所示：</p><ul><li><strong>参数计算口径不一致</strong>：参数计算可以分为三类：可训练参数的数量、微调模型与原始模型相比改变的参数的数量、微调模型和原始模型之间差异的等级。例如，DiffPruning更新0.5%的参数，但是实际参与训练的参数量是200%。这为比较带来了困难。尽管可训练的参数量是最可靠的存储高效指标，但是也不完美。Ladder-sideTuning使用一个单独的小网络，参数量高于LoRA或BitFit，但是因为反向传播不经过主网络，其消耗的内存反而更小。</li><li><strong>缺乏模型大小的考虑</strong>：已有工作表明，大模型在微调中需要更新的参数量更小（无论是以百分比相对而论还是以绝对数量而论），因此（基）模型大小在比较不同PEFT方法时也要考虑到。</li><li><strong>缺乏测量基准和评价标准</strong>：不同方法所使用的的模型/数据集组合都不一样，评价指标也不一样，难以得到有意义的结论。</li><li><strong>代码实现可读性差</strong>：很多开源代码都是简单拷贝Transformer代码库，然后进行小修小补。这些拷贝也不使用gitfork，难以找出改了哪里。即便是能找到，可复用性也比较差（通常指定某个Transformer版本，没有说明如何脱离已有代码库复用这些方法）。</li></ul><h2 id="peft技术实践">1.7 PEFT技术实践</h2><p>针对以上存在的问题，研究高效微调技术时，建议按照最佳实践进行实施：</p><ul><li>明确指出参数数量类型。</li><li>使用不同大小的模型进行评估。</li><li>和类似方法进行比较。</li><li>标准化PEFT测量基准。</li><li>重视代码清晰度，以最小化进行实现。</li></ul><h1 id="微调fine-tune">2. 微调Fine-Tune</h1><h2 id="为什么sft之后感觉llm傻了">2.1 为什么SFT之后感觉LLM傻了?</h2><p>在进行SupervisedFine-Tuning（SFT）之后，有时可能会观察到基座模型（如语言模型）的性能下降或产生一些“傻”的行为。这可能是由于以下原因：</p><ol type="1"><li><strong>数据偏移</strong>：SFT过程中使用的微调数据集可能与基座模型在预训练阶段接触到的数据分布有所不同。如果微调数据集与预训练数据集之间存在显著的差异，模型可能会在新任务上表现较差。这种数据偏移可能导致模型在新任务上出现错误的预测或不准确的输出。</li><li><strong>非典型标注</strong>：微调数据集的标注可能存在错误或不准确的标签。这些错误的标签可能会对模型的性能产生负面影响，导致模型产生“傻”的行为。</li><li><strong>过拟合</strong>：如果微调数据集相对较小，或者模型的容量（参数数量）较大，模型可能会过拟合微调数据，导致在新的输入上表现不佳。过拟合可能导致模型过于依赖微调数据的特定样本，而无法泛化到更广泛的输入。</li><li><strong>缺乏多样性</strong>：微调数据集可能缺乏多样性，未能涵盖模型在新任务上可能遇到的各种输入情况。这可能导致模型在面对新的、与微调数据集不同的输入时出现困惑或错误的预测。</li></ol><p>为了解决这些问题，可以尝试以下方法：</p><ul><li>收集更多的训练数据，以增加数据的多样性和覆盖范围。</li><li>仔细检查微调数据集的标注，确保标签的准确性和一致性。</li><li>使用正则化技术（如权重衰减、dropout）来减少过拟合的风险。</li><li>进行数据增强，通过对微调数据进行一些变换或扩充来增加多样性。</li><li>使用更复杂的模型架构或调整模型的超参数，以提高模型的性能和泛化能力。</li></ul><p>通过这些方法，可以尽量减少SupervisedFine-Tuning之后模型出现“傻”的情况，并提高模型在新任务上的表现。</p><h2 id="sft-指令微调数据-如何构建">2.2 SFT 指令微调数据 如何构建?</h2><p>构建Supervised Fine-Tuning（SFT）的微调数据需要以下步骤：</p><ol type="1"><li><strong>收集原始数据</strong>：首先，您需要收集与目标任务相关的原始数据。这可以是对话数据、分类数据、生成任务数据等，具体取决于您的任务类型。确保数据集具有代表性和多样性，以提高模型的泛化能力。</li><li><strong>标注数据</strong>：对原始数据进行标注，为每个样本提供正确的标签或目标输出。标签的类型取决于您的任务，可以是分类标签、生成文本、对话回复等。确保标注的准确性和一致性。</li><li><strong>划分数据集</strong>：将标注数据划分为训练集、验证集和测试集。通常，大部分数据用于训练，一小部分用于验证模型的性能和调整超参数，最后一部分用于最终评估模型的泛化能力。</li><li><strong>数据预处理</strong>：根据任务的要求，对数据进行预处理。这可能包括文本清洗、分词、去除停用词、词干化等处理步骤。确保数据格式和特征表示适合模型的输入要求。</li><li><strong>格式转换</strong>：将数据转换为适合模型训练的格式。这可能涉及将数据转换为文本文件、JSON格式或其他适合模型输入的格式。</li><li><strong>模型微调</strong>：使用转换后的数据对基座模型进行微调。根据任务的要求，选择适当的微调方法和超参数进行训练。这可以使用常见的深度学习框架（如PyTorch、TensorFlow）来实现。</li><li><strong>模型评估</strong>：使用测试集对微调后的模型进行评估，计算模型在任务上的性能指标，如准确率、召回率、生成质量等。根据评估结果对模型进行进一步的优化和调整。</li></ol><h2 id="如何训练自己的大模型">2.3 如何训练自己的大模型？</h2><ol type="1"><li><strong>数据收集和准备</strong>：首先，需要收集与目标任务和领域相关的大规模数据集。这可以包括从互联网上爬取数据、使用公开数据集或者与合作伙伴合作获取数据。然后，对数据进行预处理和清洗，包括去除噪声、处理缺失值、标准化数据等。</li><li><strong>模型设计和架构选择</strong>：根据任务的特点和目标，选择适合的模型架构。可以基于已有的模型进行修改和调整，或者设计全新的模型。常见的大模型架构包括深度神经网络（如卷积神经网络、循环神经网络、Transformer等）和预训练语言模型（如BERT、GPT等）。</li><li><strong>数据划分和预处理</strong>：将数据集划分为训练集、验证集和测试集。训练集用于模型的训练，验证集用于调整超参数和模型选择，测试集用于最终评估模型的性能。进行数据预处理，如分词、编码、标记化、特征提取等，以便输入到模型中。</li><li><strong>模型训练</strong>：使用训练集对模型进行训练。训练过程中，需要选择合适的优化算法、损失函数和学习率等超参数，并进行适当的调整和优化。可以使用GPU或者分布式训练来加速训练过程。</li><li><strong>模型调优和验证</strong>：使用验证集对训练过程中的模型进行调优和验证。根据验证集的性能指标，调整模型的超参数、网络结构或者其他相关参数，以提升模型的性能。</li><li><strong>模型评估和测试</strong>：使用测试集对最终训练好的模型进行评估和测试。计算模型的性能指标，如准确率、召回率、F1值等，评估模型的性能和泛化能力。</li><li><strong>模型部署和优化</strong>：将训练好的模型部署到实际应用中。根据实际需求，对模型进行进一步的优化和调整，以提高模型的效率和性能。</li></ol><h2 id="指令微调的好处">2.4 指令微调的好处？</h2><p>指令微调（InstructionFine-Tuning）是一种在预训练模型上进行微调的方法，其中<strong>模型接收指令或约束来生成特定的输出</strong>。指令微调具有以下几个好处：</p><ol type="1"><li><strong>控制生成输出</strong>：指令微调使得模型能够根据指定的指令或约束生成特定的输出。这对于需要精确控制模型生成结果的任务非常有用，例如自然语言生成任务中的文本摘要、翻译或对话系统。</li><li><strong>可解释性和可控性</strong>：通过指令微调，可以将任务的要求以指令的形式传达给模型。这增加了模型的可解释性和可控性，使得用户能够更好地理解和干预模型的生成过程。</li><li><strong>避免不符合要求的输出</strong>：通过指令微调，可以避免模型生成不符合任务要求或偏离期望的输出。通过明确的指令或约束，模型能够更好地遵循任务的要求，并生成符合期望的结果。</li><li><strong>提高任务性能</strong>：指令微调可以针对具体任务进行优化，使得模型在该任务上的性能得到提升。通过引入任务特定的指令或约束，模型可以更好地适应特定任务的需求，并生成更准确、更合理的输出。</li><li><strong>灵活性和可扩展性</strong>：指令微调是一种灵活且可扩展的方法，允许在不同任务和场景中进行微调。通过调整和修改指令或约束，可以适应不同的任务需求，并在多个任务上进行微调。</li></ol><p>请注意，指令微调需要提供明确的指令或约束，并对模型进行适当的调整和微调。在实践中，需要根据具体任务和应用场景来决定是否采用指令微调以及如何设计和实施指令。</p><h2 id="多轮对话任务微调调型">2.5 多轮对话任务微调调型</h2><p>在多轮对话任务中，微调模型的<strong>目标是使其能够更好地理解和生成连续的对话内容，并具备上下文理解和一致性回复的能力</strong>。下面是一种常见的微调模型的方法：</p><ol type="1"><li><strong>数据准备</strong>：收集或创建适用于多轮对话任务的数据集，包括对话文本和相应的标签或回复。确保数据集中包含上下文信息和对话的连续性。</li><li><strong>构建输入输出格式</strong>：将对话数据转换为适合模型输入的格式。通常情况下，输入可以是包含多个对话轮次的上下文文本，输出可以是下一轮对话的回复或标签。</li><li><strong>模型选择</strong>：选择适合多轮对话任务的预训练模型，如DialoGPT、BERT等。这些模型已经在大规模对话数据上进行了预训练，并具备一定的对话理解和生成能力。</li><li><strong>微调模型</strong>：使用多轮对话数据集对预训练模型进行微调。微调的过程通常包括以下步骤：<ol type="1"><li>初始化模型参数：将预训练模型的参数加载到模型中。</li><li><strong>定义损失函数</strong>：根据任务要求，定义适当的损失函数，如交叉熵损失函数或生成模型中的对抗损失函数。</li><li><strong>进行反向传播和参数更新</strong>：根据损失函数，通过反向传播算法计算梯度，并更新模型参数。</li><li><strong>重复训练步骤</strong>：重复进行微调步骤，直到模型在验证集上达到满意的性能。</li></ol></li><li><strong>超参数调优</strong>：根据任务需求和数据情况，调整微调过程中的超参数，如学习率、批大小、微调步数等。可以使用验证集来评估模型性能并选择最佳的超参数配置。</li><li><strong>评估和测试</strong>：使用测试集对微调后的模型进行评估和测试，评估模型在多轮对话任务上的性能和表现。</li></ol><p>需要注意的是，微调多轮对话模型时，<strong>除了常规的微调方法，还可以采用一些特定的技巧，如引入对话历史的注意力机制、使用特定的对话策略进行训练等</strong>，以进一步提升模型在多轮对话任务中的性能。</p><h2 id="微调后的模型出现能力劣化">2.6 微调后的模型出现能力劣化</h2><p>灾难性遗忘（CatastrophicForgetting）是指在模型微调过程中，<strong>当模型在新任务上进行训练时，可能会忘记之前学习到的知识，导致在旧任务上的性能下降</strong>。这种现象常见于神经网络模型的迁移学习或连续学习场景中。</p><p>在微调大语言模型时，灾难性遗忘可能出现的原因包括：</p><ol type="1"><li><strong>数据分布差异</strong>：微调过程中使用的新任务数据与预训练数据或旧任务数据的分布存在差异。如果新任务的数据分布与预训练数据差异较大，模型可能会过度调整以适应新任务，导致旧任务上的性能下降。</li><li><strong>参数更新冲突</strong>：微调过程中，对新任务进行训练时，模型参数可能会被更新，导致之前学习到的知识被覆盖或丢失。新任务的梯度更新可能会与旧任务的梯度更新发生冲突，导致旧任务的知识被遗忘。</li></ol><p>为了解决灾难性遗忘问题，可以尝试以下方法：</p><ol type="1"><li><strong>经验回放（ReplayBuffer）</strong>：在微调过程中，使用一个缓冲区来存储旧任务的样本，然后将旧任务的样本与新任务的样本一起用于训练。这样可以保留旧任务的知识，减少灾难性遗忘的发生。</li><li><strong>弹性权重共享（Elastic WeightConsolidation）</strong>：通过引入正则化项，限制模型参数的变动范围，以保护之前学习到的知识。这种方法可以在微调过程中平衡新任务和旧任务之间的重要性。</li><li><strong>增量学习（IncrementalLearning）</strong>：将微调过程分为多个阶段，每个阶段只微调一小部分参数。这样可以逐步引入新任务，减少参数更新的冲突，降低灾难性遗忘的风险。</li><li><strong>多任务学习（Multi-TaskLearning）</strong>：在微调过程中，同时训练多个相关任务，以提高模型的泛化能力和抗遗忘能力。通过共享模型参数，可以在不同任务之间传递知识，减少灾难性遗忘的影响。</li></ol><p>综上所述，灾难性遗忘是在模型微调过程中可能出现的问题。通过合适的方法和技术，可以减少灾难性遗忘的发生，保留之前学习到的知识，提高模型的整体性能。</p><h2 id="预训练和sft操作有什么不同">2.7 预训练和SFT操作有什么不同</h2><p>大语言模型的预训练和有监督微调（SupervisedFine-Tuning）是两个不同的操作，它们在目标、数据和训练方式等方面存在一些区别。</p><p><strong>目标</strong>：</p><ul><li><strong>预训练的目标是通过无监督学习从大规模的文本语料库中学习语言模型的表示能力和语言知识</strong>。预训练的目标通常是通过自我预测任务，例如掩码语言模型（MaskedLanguage Model，MLM）或下一句预测（Next SentencePrediction，NSP）等，来训练模型。</li><li><strong>有监督微调的目标是在特定的任务上进行训练</strong>，例如文本分类、命名实体识别等。在有监督微调中，模型会利用预训练阶段学到的语言表示和知识，<strong>通过有监督的方式调整模型参数，以适应特定任务的要求。</strong></li></ul><p><strong>数据</strong>：</p><ul><li>在预训练阶段，大语言模型通常使用大规模的<strong>无标签文本数据进行训练</strong>，例如维基百科、网页文本等。这些数据没有特定的标签或任务信息，模型通过自我预测任务来学习语言模型。</li><li>在有监督微调中，模型需要使用<strong>带有标签的任务相关数据进行训练</strong>。这些数据通常是人工标注的，包含了输入文本和对应的标签或目标。模型通过这些标签来进行有监督学习，调整参数以适应特定任务。</li></ul><p><strong>训练方式</strong>：</p><ul><li>预训练阶段通常使用<strong>无监督的方式进行训练</strong>，模型通过最大化预训练任务的目标函数来学习语言模型的表示能力。</li><li>有监督微调阶段则使用<strong>有监督的方式进行训练</strong>，模型通过最小化损失函数来学习任务相关的特征和模式。在微调阶段，通常会使用预训练模型的参数作为初始参数，并在任务相关的数据上进行训练。</li></ul><p>总的来说，预训练和有监督微调是大语言模型训练的两个阶段，目标、数据和训练方式等方面存在差异。预训练阶段通过无监督学习从大规模文本数据中学习语言模型，而有监督微调阶段则在特定任务上使用带有标签的数据进行有监督学习，以适应任务要求。</p><h2 id="大模型llm进行sft-如何对样本进行优化">2.8 大模型LLM进行SFT如何对样本进行优化？</h2><p>对于大语言模型进行有监督微调（SupervisedFine-Tuning）时，可以采用以下几种方式对样本进行优化：</p><ol type="1"><li><strong>数据清洗和预处理</strong>：对于有监督微调的任务，首先需要对样本数据进行清洗和预处理。这包括去除噪声、处理缺失值、进行标准化或归一化等操作，以确保数据的质量和一致性。</li><li><strong>数据增强</strong>：通过数据增强技术可以扩充训练数据，增加样本的多样性和数量。例如，可以使用数据扩充方法如随机裁剪、旋转、翻转、加噪声等来生成新的训练样本，从而提高模型的泛化能力。</li><li><strong>标签平衡</strong>：如果样本标签不平衡，即某些类别的样本数量远远多于其他类别，可以采取一些方法来平衡样本标签。例如，可以通过欠采样、过采样或生成合成样本等技术来平衡不同类别的样本数量。</li><li><strong>样本选择</strong>：在有限的资源和时间下，可以选择一部分具有代表性的样本进行微调训练。可以根据任务的需求和数据分布的特点，选择一些关键样本或难样本进行训练，以提高模型在关键样本上的性能。</li><li><strong>样本权重</strong>：对于一些重要的样本或困难样本，可以给予更高的权重，以便模型更加关注这些样本的学习。可以通过调整损失函数中样本的权重或采用加权采样的方式来实现。</li><li><strong>样本组合和分割</strong>：根据任务的特点和数据的结构，可以将多个样本组合成一个样本，或将一个样本分割成多个子样本。这样可以扩展训练数据，提供更多的信息和多样性。</li><li><strong>样本筛选和策略</strong>：根据任务需求，可以制定一些样本筛选和选择策略。例如，可以根据样本的置信度、难度、多样性等指标进行筛选和选择，以提高模型的性能和泛化能力。</li></ol><p>总的来说，对大语言模型进行有监督微调时，可以通过数据清洗和预处理、数据增强、标签平衡、样本选择、样本权重、样本组合和分割、样本筛选和策略等方式对样本进行优化。这些优化方法可以提高训练样本的质量、多样性和数量，从而提升模型的性能和泛化能力。具体的优化策略需要根据任务需求和数据特点进行选择和调整。</p><h1 id="预训练">3. 预训练</h1><h2 id="为什么要增量预训练">3.1 为什么要增量预训练？</h2><p><strong>预训练学知识</strong>，<strong>指令微调学格式</strong>，<strong>强化学习对齐人类偏好</strong>，所以要想大模型有领域知识，得增量预训练（靠指令微调记知识不靠谱，不是几十w条数据能做到的）。</p><h2 id="进行增量预训练需要做哪些准备工作">3.2进行增量预训练需要做哪些准备工作？</h2><ol type="1"><li><strong>选取底座模型</strong>：可以根据自己的项目需求和硬件基础来选择合适的底座模型及模型参数量的大小。</li><li><strong>收集数据</strong>：一般来说需要收集大量的文本数据，包含各个领域，主要从互联网上获取，一般预训练数据的大小都是TB 级别的。</li><li><strong>数据清洗</strong>：所有的信息都能够在互联网信息中被找到，只是<strong>信息密度</strong>相比「人工精选数据集」要更低。例如「明星信息」、「如何写代码」这些信息都能在新闻网站、或是问答网站中找到，只不过「维基百科」或是「Github」则是将这些信息给「高密度」且「结构化」地进行了存储。这使得我们在使用维基百科作为训练语料的时候，模型能够更快的学习到这些高密度信息（人物的经历、年龄、性别、职业等等），而这些内容在互联网信息（如新闻）中的信息密度则较低，即很少会有一条新闻完整的介绍一个艺人的过往经历。只要我们<strong>对互联网信息进行严格的处理</strong>（去除冗余信息，提高有用信息的密度），就能够加快模型的学习速度。</li></ol><h2 id="增量预训练训练流程是怎么样">3.3增量预训练训练流程是怎么样？</h2><ol type="1"><li><strong>数据预处理</strong>：参考 LLaMA的预训练长度，也把数据处理成2048长度（如果不够，做补全）。</li><li><strong>分词器</strong>：如果使用 LLaMA可能需要添加中文词表，目前有不少人做了相关工作，当然也可以自己添加自己需要的词表。</li><li><strong>原始模型</strong>：各家框架的模型层名不太一样，训练时可能需要做一些调整，在预训练时尽量选择基座模型，不选Chat 模型。</li><li><strong>训练模型</strong>：跑通只是第一步，根据训练情况反复调整比较重要。</li><li><strong>模型转换</strong>：不同框架的checkpoint格式不同，还会根据并行度分成很多个文件。</li><li><strong>模型测试</strong>：简单测试下续写能力，验证下模型是否正常。</li></ol><h1 id="prompting工程">4. Prompting工程</h1><h2 id="bitfit">4.1 BitFit</h2><h3 id="背景">4.1.1 背景</h3><p>虽然对每个任务进行全量微调非常有效，但它也会为每个预训练任务生成一个独特的大型模型，这使得很难推断微调过程中发生了什么变化，也很难部署，特别是随着任务数量的增加，很难维护。</p><p>理想状况下，我们希望有<strong>一种满足以下条件的高效微调方法</strong>：</p><ul><li>到达能够匹配全量微调的效果。</li><li>仅更改一小部分模型参数。</li><li>使数据可以通过流的方式到达，而不是同时到达，便于高效的硬件部署。</li><li>改变的参数在不同下游任务中是一致的。</li></ul><p>上述的问题取决于微调过程能多大程度引导新能力的学习以及暴露在预训练LM中学到的能力。</p><p>虽然，之前的高效微调方法Adapter-Tuning、Diff-Pruning也能够部分满足上述的需求。但是，作者提出了<strong>一种参数量更小的稀疏的微调方法BitFit</strong>，来满足上述的需求。</p><h3 id="技术原理">4.1.2 技术原理</h3><p>BitFit（论文：<strong>BitFit: Simple Parameter-efficient Fine-tuningor Transformer-based MaskedLanguage-models</strong>）是一种<strong>稀疏的微调方法</strong>，它<strong>训练时只更新bias的参数或者部分bias参数</strong>。</p><p>对于Transformer模型而言，<strong>冻结大部分 transformer-encoder参数，只更新bias参数跟特定任务的分类层参数</strong>。涉及到的bias参数有attention模块中计算<code>query</code>,<code>key</code>,<code>value</code>跟合并多个attention结果时涉及到的bias，MLP层中的bias，Layernormalization层的bias参数。</p><p>在Bert-Base/Bert-Large这种模型里，bias参数仅占模型全部参数量的0.08%～0.09%。但是通过在Bert-Large模型上基于GLUE数据集进行了BitFit、Adapter和Diff-Pruning的效果对比发现，BitFit在参数量远小于Adapter、Diff-Pruning的情况下，效果与Adapter、Diff-Pruning想当，甚至在某些任务上略优于Adapter、Diff-Pruning。</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240324145058170.png"alt="BitFit对比图 参数量更加少" /><figcaption aria-hidden="true">BitFit对比图 参数量更加少</figcaption></figure><p>同时，通过实验结果还可以看出，<strong>BitFit微调结果相对全量参数微调而言,只更新极少量参数的情况下，在多个数据集上都达到了不错的效果</strong>，虽不及全量参数微调，但是远超固定全部模型参数的Frozen方式。</p><p>同时，通过对比BitFit训练前后的参数，<strong>发现很多bias参数并没有太多变化</strong>（例如：跟计算key所涉及到的bias参数）。发现计算query和将特征维度从N放大到4N的FFN层（intermediate）的bias参数变化最为明显，只更新这两类bias参数也能达到不错的效果，反之，固定其中任何一者，模型的效果都有较大损失。</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240324145136374.png"alt="微调参数量对比" /><figcaption aria-hidden="true">微调参数量对比</figcaption></figure><h2 id="prefix-tuning">4.2 Prefix Tuning</h2><h3 id="背景-1">4.2.1 背景</h3><p>在PrefixTuning之前的工作主要是人工设计离散的模版或者自动化搜索离散的模版。对于人工设计的模版，模版的变化对模型最终的性能特别敏感，加一个词、少一个词或者变动位置都会造成比较大的变化。而对于自动化搜索模版，成本也比较高；同时，以前这种离散化的token搜索出来的结果可能并不是最优的。</p><p>除此之外，传统的微调范式利用预训练模型去对不同的下游任务进行微调，对每个任务都要保存一份微调后的模型权重，一方面微调整个模型耗时长；另一方面也会占很多存储空间。</p><p>基于上述两点，PrefixTuning提出<strong>固定预训练LM</strong>，<strong>为LM添加可训练，任务特定的前缀，</strong>这样就可以为不同任务保存不同的前缀，微调成本也小；同时，这种Prefix实际就是连续可微的VirtualToken（Soft Prompt/ContinuousPrompt），相比离散的Token，更好优化，效果更好。</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240324145233005.png" alt="prefix-tuning对比" style="zoom: 33%;" /></p><h3 id="技术原理-1">4.2.2 技术原理</h3><p>Prefix Tuning（论文：<strong>Prefix-Tuning: Optimizing ContinuousPrompts forGeneration</strong>），<strong>在输入token之前构造一段任务相关的virtualtokens作为Prefix，然后训练的时候只更新Prefix部分的参数，而PLM中的其他部分参数固定</strong>。</p><p>针对不同的模型结构，需要构造不同的Prefix。</p><ul><li><strong>针对自回归架构模型</strong>：<strong>在句子前面添加前缀</strong>，得到<code>z = [PREFIX; x; y]</code>，合适的上文能够在固定 LM的情况下去引导生成下文（比如：GPT3的上下文学习）。</li><li><strong>针对编码器-解码器架构模型</strong>：<strong>Encoder和Decoder都增加了前缀</strong>，得到<code>z = [PREFIX; x; PREFIX0; y]</code>。Encoder端增加前缀是为了引导输入部分的编码，Decoder端增加前缀是为了引导后续token的生成。</li></ul><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240324145346148.png"alt="prefix tuning技术细节" /><figcaption aria-hidden="true">prefix tuning技术细节</figcaption></figure><p>该方法其实和构造Prompt类似，只是Prompt是人为构造的“显式”的提示，并且无法更新参数，而Prefix则是可以学习的“隐式”的提示。同时，<strong>为了防止直接更新Prefix的参数导致训练不稳定和性能下降的情况，在Prefix层前面加了MLP结构，训练完成后，只保留Prefix的参数</strong>。</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240324145516361.png"alt="Prefix结构增加MLP结构" /><figcaption aria-hidden="true">Prefix结构增加MLP结构</figcaption></figure><p>除此之外，通过消融实验证实，只调整embedding层的表现力不够，将导致性能显著下降，因此，在每层都加了prompt的参数，改动较大。</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240324145614518.png" alt="prefix会在每层都加入prompt参数进行调整" style="zoom:33%;" /></p><p>另外，实验还对比了位置对于生成效果的影响，Prefix-tuning也是要略优于Infix-tuning的。其中，Prefix-tuning形式为<code>[PREFIX; x; y]</code>，Infix-tuning形式为<code>[x; INFIX; y]</code>。</p><h2 id="prompt-tuning">4.3 Prompt Tuning</h2><h3 id="背景-2">4.3.1 背景</h3><p>大模型全量微调对每个任务训练一个模型，开销和部署成本都比较高。同时，离散的prompts（指人工设计prompts提示语加入到模型）方法，成本比较高，并且效果不太好。</p><p>基于此，作者提出了PromptTuning，<strong>通过反向传播更新参数来学习prompts，而不是人工设计prompts；同时冻结模型原始权重，只训练prompts参数，</strong>训练完以后，用同一个模型可以做多任务推理。</p><h3 id="技术原理-2">4.3.2 技术原理</h3><p>Prompt Tuning（论文：<strong>The Power of Scale forParameter-Efficient Prompt Tuning</strong>），该方法可以看作是PrefixTuning的简化版本，它给<strong>每个任务定义了自己的Prompt，然后拼接到数据上作为输入，但只在输入层加入prompttokens</strong>，并且不需要加入 MLP 进行调整来解决难训练的问题。</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240324145735981.png"alt="Prompt Tuning整体结构题" /><figcaption aria-hidden="true">Prompt Tuning整体结构题</figcaption></figure><p>通过实验发现，随着预训练模型参数量的增加，PromptTuning的方法会逼近全参数微调的结果。</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240324145819719.png" alt="Prompt Tuning参数量对比" style="zoom:33%;" /></p><p>同时，Prompt Tuning 还提出了 PromptEnsembling，也就是<strong>在一个批次（Batch）里同时训练同一个任务的不同prompt（即采用多种不同方式询问同一个问题）</strong>，这样相当于训练了不同模型，比模型集成的成本小多了。</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240324145906704.png" alt="Prompt Ensembling 示意图" style="zoom:33%;" /></p><h2 id="p-tuning">4.4 <strong>P-Tuning</strong></h2><h3 id="背景-3">4.4.1 背景</h3><p>该方法的提出主要是为了解决这样一个问题：<strong>大模型的Prompt构造方式严重影响下游任务的效果</strong>。比如：GPT-3采用人工构造的模版来做上下文学习（incontextlearning），但人工设计的模版的变化特别敏感，加一个词或者少一个词，或者变动位置都会造成比较大的变化。</p><p>同时，近来的自动化搜索模版工作成本也比较高，以前这种离散化的token的搜索出来的结果可能并不是最优的，导致性能不稳定。基于此，作者提出了P-Tuning，设计了一种<strong>连续可微的virtualtoken</strong>（同Prefix-Tuning类似）。</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240324150014462.png"alt="Prompt Learing提出的P-Tuning" /><figcaption aria-hidden="true">Prompt Learing提出的P-Tuning</figcaption></figure><h3 id="技术原理-3">4.4.2 技术原理</h3><p>P-Tuning（论文：<strong>GPT Understands,Too</strong>），该方法<strong>将Prompt转换为可以学习的Embedding层，并用MLP+LSTM的方式来对PromptEmbedding进行一层处理</strong>。</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240324150115333.png"alt="P-Tuning算法" /><figcaption aria-hidden="true">P-Tuning算法</figcaption></figure><p>相比Prefix Tuning，P-Tuning加入的可微的virtualtoken，<strong>但仅限于输入层，没有在每一层都加；另外，virtualtoken的位置也不一定是前缀，插入的位置是可选的</strong>。这里的出发点实际是把传统人工设计模版中的真实token替换成可微的virtualtoken。</p><p>经过预训练的LM的词嵌入已经变得高度离散，如果随机初始化virtualtoken，容易优化到局部最优值，而这些virtualtoken理论是应该有相关关联的。因此，作者通过实验发现<strong>用一个promptencoder来编码会收敛更快，效果更好</strong>。即用一个LSTM+MLP去编码这些virtualtoken以后，再输入到模型。</p><p>从对比实验证实看出，P-Tuning获得了与全参数一致的效果。甚至在某些任务上优于全参数微调。</p><p>并且在实验中还发现，相同参数规模，如果进行全参数微调，Bert的在NLU任务上的效果，超过GPT很多；但是在P-Tuning下，GPT可以取得超越Bert的效果。</p><h2 id="p-tuning-v2">4.5 <strong>P-Tuning</strong> v2</h2><h3 id="背景-4">4.5.1 背景</h3><p>之前的Prompt Tuning和P-Tuning等方法存在两个主要的问题：</p><p>第一，<strong>缺乏模型参数规模和任务通用性</strong>。</p><ul><li><strong>缺乏规模通用性</strong>：PromptTuning论文中表明当模型规模超过100亿个参数时，提示优化可以与全量微调相媲美。但是对于那些较小的模型（从100M到1B），提示优化和全量微调的表现有很大差异，这大大限制了提示优化的适用性。</li><li><strong>缺乏任务普遍性</strong>：尽管Prompt Tuning和P-tuning在一些NLU基准测试中表现出优势，但提示调优对硬序列标记任务（即序列标注）的有效性尚未得到验证。</li></ul><p>第二，<strong>缺少深度提示优化</strong>，在PromptTuning和P-tuning中，连续提示只被插入transformer第一层的输入embedding序列中，在接下来的transformer层中，插入连续提示的位置的embedding是由之前的transformer层计算出来的，这可能导致两个可能的优化挑战。</p><ul><li>由于序列长度的限制，可调参数的数量是有限的。</li><li>输入embedding对模型预测只有相对间接的影响。</li></ul><p>考虑到这些问题，作者提出了Ptuningv2，它<strong>利用深度提示优化（如：Prefix Tuning），对PromptTuning和P-Tuning进行改进，作为一个跨规模和NLU任务的通用解决方案</strong>。</p><h3 id="技术原理-4">4.5.2 技术原理</h3><p>P-Tuning v2（论文： <strong>P-Tuning v2: Prompt Tuning Can BeComparable to Fine-tuning Universally Across Scales andTasks</strong>），该方法<strong>在每一层都加入了Promptstokens作为输入，而不是仅仅加在输入层</strong>，这带来两个方面的好处：</p><ul><li>更多可学习的参数（从P-tuning和PromptTuning的0.01%增加到0.1%-3%），同时也足够参数高效。</li><li>加入到更深层结构中的Prompt能给模型预测带来更直接的影响。</li></ul><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240324150229444.png"alt="P-Tuning V2" /><figcaption aria-hidden="true">P-Tuning V2</figcaption></figure><p>具体做法基本同Prefix Tuning，可以看作是将文本生成的PrefixTuning技术适配到NLU任务中，然后做了一些改进：</p><ul><li><strong>移除重参数化的编码器</strong>。以前的方法利用重参数化功能来提高训练速度和鲁棒性（如：PrefixTuning中的MLP、P-Tuning中的LSTM））。在 P-tuning v2中，作者发现重参数化的改进很小，尤其是对于较小的模型，同时还会影响模型的表现。</li><li><strong>针对不同任务采用不同的提示长度</strong>。提示长度在提示优化方法的超参数搜索中起着核心作用。在实验中，我们发现不同的理解任务通常用不同的提示长度来实现其最佳性能，这与Prefix-Tuning中的发现一致，不同的文本生成任务可能有不同的最佳提示长度。</li><li><strong>引入多任务学习</strong>。先在多任务的Prompt上进行预训练，然后再适配下游任务。多任务学习对我们的方法来说是可选的，但可能是相当有帮助的。一方面，连续提示的随机惯性给优化带来了困难，这可以通过更多的训练数据或与任务相关的无监督预训练来缓解；另一方面，连续提示是跨任务和数据集的特定任务知识的完美载体。我们的实验表明，在一些困难的序列任务中，多任务学习可以作为P-tuningv2的有益补充。</li><li><strong>回归传统的分类标签范式，而不是映射器</strong>。标签词映射器（LabelWordVerbalizer）一直是提示优化的核心组成部分，它将one-hot类标签变成有意义的词，以利用预训练语言模型头。尽管它在few-shot设置中具有潜在的必要性，但在全数据监督设置中，Verbalizer并不是必须的。它阻碍了提示调优在我们需要无实际意义的标签和句子嵌入的场景中的应用。因此，P-Tuningv2回归传统的CLS标签分类范式，采用随机初始化的分类头（ClassificationHead）应用于tokens之上，以增强通用性，可以适配到序列标注任务。</li></ul><p>论文中展示了P-tuningv2在不同模型规模下的表现。对于简单的NLU任务，如SST-2（单句分类），PromptTuning和P-Tuning在较小的规模下没有显示出明显的劣势。但是当涉及到复杂的挑战时，如：自然语言推理（RTE）和多选题回答（BoolQ），它们的性能会非常差。相反，P-Tuningv2在较小规模的所有任务中都与微调的性能相匹配。并且，P-tuningv2在RTE中的表现明显优于微调，特别是在BERT中。</p><h1 id="adapter-tuning">5. Adapter-Tuning</h1><h2 id="adapter-tuning-1">5.1 Adapter Tuning</h2><h3 id="背景-5">5.1.1 背景</h3><p>预训练模型参数量越来越多，在训练下游任务时进行全量微调变得昂贵且耗时。</p><p>基于此，作者提出了Adapter Tuning，Adapter 的出现缓解了上述问题Adapter<strong>在预训练模型每层中插入用于下游任务的参数</strong>（针对每个下游任务，仅增加3.6%的参数），<strong>在微调时将模型主体冻结，仅训练特定于任务的参数</strong>，从而减少了训练时的算力开销。</p><h3 id="技术原理-5">5.1.2 技术原理</h3><p>Adapter Tuning（论文：<strong>Parameter-Efficient Transfer LearningforNLP</strong>），该方法<strong>设计了Adapter结构</strong>，并将其嵌入Transformer的结构里面，<strong>针对每一个Transformer层，增加了两个Adapter结构(分别是多头注意力的投影之后和第二个feed-forward层之后)</strong>，<strong>在训练时，固定住原来预训练模型的参数不变，只对新增的==Adapter 结构和 Layer Norm层==进行微调，从而保证了训练的高效性</strong>。</p><p>每当出现新的下游任务，通过添加Adapter模块来产生一个易于扩展的下游模型，从而避免全量微调与灾难性遗忘的问题。</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240324150521350.png"alt="Adapting 微调" /><figcaption aria-hidden="true">Adapting 微调</figcaption></figure><h3 id="具体细节">5.1.3 具体细节</h3><p>每个 Adapter模块主要由<strong>两个前馈（Feedforward）子层组成</strong>，第一个前馈子层（down-project）将Transformer块的输出作为输入，将原始输入维度<code>d</code>（高维特征）投影到<code>m</code>（低维特征），通过控制m的大小来限制Adapter模块的参数量，通常情况下，<code>m&lt;&lt;d</code>。然后，中间通过一个非线形层。在输出阶段，通过第二个前馈子层（up-project）还原输入维度，将m（低维特征）重新映射回d（原来的高维特征），作为Adapter模块的输出。同时，通过一个skipconnection来将Adapter的输入重新加到最终的输出中去，这样可以保证，即便Adapter 一开始的参数初始化接近0，Adapter也由于skipconnection的设置而接近于一个恒等映射，从而确保训练的有效性。</p><p><span class="math display">\[h \leftarrow h+f\left(h W_{\text {down }}\right) W_{u p}\]</span></p><p>通过实验发现，只训练少量参数的Adapter方法的效果可以媲美全量微调，这也验证了Adapter是一种高效的参数训练方法，可以快速将语言模型的能力迁移到下游任务中去。</p><p>总之，Adapter通过引入0.5%～5%的模型参数可以达到不落后全量微调模型1%的性能。</p><h2 id="adapterfusion">5.2 AdapterFusion</h2><h3 id="背景-6">5.2.1 背景</h3><p>为了整合来自多个任务的知识，传统的两个方法是按一定顺序微调（Sequentialfine-tuning）或者多任务学习（multi-tasklearning）。前者的一大问题是需要先验知识来确定顺序，且模型容易遗忘之前任务学到的知识，后者的问题是不同的任务会互相影响，也难以平衡数据集大小差距很大的任务。</p><p>而之前的工作，AdapterTuning的一个优势就是不用更新预训练模型的参数，而是插入比较少的新的参数就可以很好地学会一个任务。此时，Adapter的参数某种程度上就表达了解决这个任务需要的知识。</p><p>作者受此启发，如果<strong>想要把来自多个任务的知识结合起来，是否可以考虑把多个任务的Adapter的参数结合起来</strong>？基于此，作者提出了AdapterFusion，这是一种新的两阶段学习算法，可以利用来自多个任务的知识。</p><h3 id="技术原理-6">5.2.2 技术原理</h3><p>Adapter Fusion（论文：<strong>AdapterFusion:Non-Destructive TaskComposition for TransferLearning</strong>），<strong>一种融合多任务信息的Adapter的变体</strong>，在Adapter的基础上进行优化，通过将学习过程分为两阶段来提升下游任务表现。</p><ul><li><strong>知识提取阶段</strong>：在不同任务下引入各自的Adapter模块，用于学习特定任务的信息。</li><li><strong>知识组合阶段</strong>：将预训练模型参数与特定于任务的Adapter参数固定，<strong>引入新参数（AdapterFusion）来学习组合多个Adapter中的知识，以提高模型在目标任务中的表现</strong>。</li></ul><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240324150638005.png" alt="Adapter Fusion结构图" style="zoom: 33%;" /></p><p>对于<strong>第一阶段</strong>，有两种训练方式，分别如下：</p><ul><li><strong>Single-TaskAdapters(ST-A)</strong>：对于N个任务，模型都分别独立进行优化，各个任务之间互不干扰，互不影响。</li><li><strong>Multi-TaskAdapters(MT-A)</strong>：N个任务通过多任务学习的方式，进行联合优化。</li></ul><p>对于<strong>第二阶段</strong>，为了避免通过引入特定任务参数而带来的灾难性遗忘问题，AdapterFusion提出了<strong>一个共享多任务信息的结构</strong>。针对特定任务<code>m</code>，AdapterFusion联合了第一阶段训练得到的<code>N</code>个Adapter信息。固定语言模型的参数跟<code>N</code>个Adapter的参数，新引入AdapterFusion的参数，目标函数也是学习针对特定任务<code>m</code>的AdapterFusion的参数。</p><h3 id="adapterfusion结构">5.2.3 <strong>AdapterFusion结构</strong></h3><p>AdapterFusion具体结构就是一个Attention，它的参数包括<code>query</code>，<code>key</code>,<code>value</code>的矩阵参数，在transformer的每一层都存在，它的query是transformer每个子模块的输出结果，它的key跟value则是N个任务的adapter的输出。通过AdapterFusion，模型可以为不同的任务对应的adapter分配不同的权重，聚合N个任务的信息，从而为特定任务输出更合适的结果。</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240324150741300.png" alt="AdapterFusion内部结构" style="zoom:33%;" /></p><p>通过对全量微调、Adapter Tuning、AdapterFusion这三种方法在各个数据集上进行对比实验可以看出，AdapterFusion在大多数情况下性能优于全模型微调和Adapter Tuning，特别在MRPC与RTE数据集中，性能显著优于另外两种方法。</p><p>总之，通过将适配器的训练分为知识提取和知识组合两部分，<strong>解决了灾难性遗忘、任务间干扰和训练不稳定的问题</strong>。但是，Adapter模块的添加也导致模型整体参数量的增加，降低了模型推理时的性能。</p><h2 id="adapterdrop">5.3 AdapterDrop</h2><h3 id="背景-7">5.3.1 背景</h3><p>近年来Adapter已被证明可以很好地用于机器翻译、跨语言迁移、社区问答和迁移学习的任务组合。尽管它们最近很受欢迎，但Adapter的计算效率尚未在参数效率之外得到探索。</p><p>作者通过对Adapter的计算效率进行分析，<strong>发现与全量微调相比，Adapter在训练时快60%，但是在推理时慢4%-6%</strong>。</p><p>基于此，作者提出了<strong>AdapterDrop</strong>方法缓解该问题。</p><h3 id="技术原理-7">5.3.2 技术原理</h3><p>AdapterDrop（论文：AdapterDrop: On the Efficiency of Adapters inTransformers），在不影响任务性能的情况下，<strong>对Adapter动态高效的移除，尽可能的减少模型的参数量，提高模型在反向传播（训练）和正向传播（推理）时的效率</strong>。</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240324150845885.png" alt="关键位置参数移除" style="zoom:33%;" /></p><p>实验表明，<strong>从较低的 Transformer 层中删除Adapter可以显着提高多任务设置中的推理速度</strong>。例如，将前五个Transformer层中的Adapter丢弃，在对 8个任务进行推理时，速度提高了 39%。并且即使有多个丢弃层，AdapterDrop也能保持良好的结果。</p><p>除此之外，作者还研究了对AdapterFusion中的Adapter进行剪枝后的效果。</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240324150919888.png" alt="对AdapterFusion中的Adapter进行剪枝后" style="zoom:33%;" /></p><p>通过实验表明可以移除 AdapterFusion中的大多数Adapter而不影响任务性能。使用剩余的两个Adapter，实现了与具有八个Adapter的完整AdapterFusion 模型相当的结果，并将推理速度提高了 68%。</p><p>因此，作者建议在实际部署这些模型之前执行 AdaperFusion 剪枝。这是一种简单而有效的技术，即使在完全保持性能的情况下也能实现效率提升。</p><p>总之，<strong>AdapterDrop通过从较低的 Transformer 层删除可变数量的Adaper来提升推理速度</strong>。当对多个任务执行推理时，动态地减少了运行时的计算开销，并在很大程度上保持了任务性能。</p><h2 id="mam-adapter">5.4 MAM Adapter</h2><h3 id="背景-8">5.4.1 背景</h3><p>近年来提出了多种参数高效的迁移学习方法，这些方法<strong>仅微调少量（额外）参数即可获得强大的性能</strong>。虽然有效，但人们对为什么有效的关键要素以及各种高效微调方法之间的联系知之甚少。</p><p>下图展示了不同的微调方法，在Xsum数据集上做英文文本摘要任务的效果（ROUGE-2是该任务的评价指标（越大越好））以及其他高效微调方法参数量相对于全参数微调参数量的百分比。图中的左上角的位置是理想化的方法。从图中发现，<strong>Adapter，PrefixTuning和LoRA</strong>都是性能比较好的方法。</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240324151426754.png" alt="Fine-tuned 参数量对比" style="zoom: 33%;" /></p><p>为什么看起来Adapter、PrefixTuning、LoRA（在结构上和公式上）都不太一样，尤其是PrefixTuning，但是这三种方法有近似的效果？</p><p>基于此，作者分解了当下最先进的参数高效迁移学习方法（Adapter、PrefixTuning和LoRA）的设计，并提出了一种新方法<strong>MAMAdapter</strong>，<strong>一个在它们之间建立联系的统一框架</strong>。具体来说，将它们<strong>重新构建为对预训练模型中特定隐藏状态的修改，并定义一组设计维度，不同的方法沿着这些维度变化</strong>。</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240324151515946.png" alt="不同板块具体内部结构的展示" style="zoom: 33%;" /></p><p>首先，作者通过对Prefix Tuning变换，发现PrefixTuning和Adapters的公式高度相似。</p><p>然后，分析不同微调方法的内部结构和结构插入形式的相似之处。下图展示了高效微调方法Adapter、PrefixTuning、LoRA以及新变体（通过更换一些元素，设计了前人的工作里没有的变体）Parallel Adapter、 Scaled PA的结构。</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240324151647197.png"alt="不同微调方法的对比" /><figcaption aria-hidden="true">不同微调方法的对比</figcaption></figure><p>下表展示了高效微调方法Adapter、PrefixTuning、LoRA以及新变体在新增可训练参数结构形式（functionalform）、结构插入形式（Insertionform）、新增结构在PLM修改的具体位置（modifiedrepresentation）、新增结构与PLM的组合函数（compositionfunction）。其中，新增可训练参数结构形式为需要学习的部分（注：PrefixTuning为经过转换后的格式）；插入形式有串联或并联；模型修改的具体位置有Attention、FFN层。</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240324151719022.png"alt="需要学习的参数部分" /><figcaption aria-hidden="true">需要学习的参数部分</figcaption></figure><h3 id="技术原理-8">5.4.2 技术原理</h3><p>MAM Adapter（论文：TOWARDS A UNIFIED VIEW OF PARAMETER-EFFICIENTTRANSFER LEARNING），<strong>一个在Adapter、PrefixTuning和LoRA之间建立联系的统一方法</strong>。</p><p>作者对Adapter的放置和软提示（softprompt）进行了详细的调查。得出如下结论：</p><ul><li>并行放置的Adapter优于顺序放置的Adapter，并且与 FFN并行放置的Adapter优于多头注意力（MHA）并行放置的Adapter（模型修改的位置如下图中所示，蓝色表示修改Attention、红色表示修改FFN）。</li><li>软提示可以通过仅更改 0.1% 的参数来有效地修改注意力。</li></ul><p>然后，提出了“mix-and-match”（MAM）。 因此，最终模型 MAM Adapter 是用FFN 层的并行Adapter和软提示的组合。</p><p>通过最终的实验结果，可以看到 MAM Adapter在仅用了6.7%参数量（相比全量微调）的情况下，在Xsum和MT这两个任务上达到了和全量微调相近的效果，并且该方法大大优于BitFit 和 Prompt Tuning，并始终优于 LoRA、Adapter 和 Prefix Tuning。</p><h2 id="unipelt">5.5 UniPELT</h2><h3 id="背景-9">5.5.1 背景</h3><p>近年来，涌现出了许多针对语言模型的参数高效微调（PELT）方法，在模型训练参数极大的减少的情况下，模型效果与全量微调相当。但是不同的PELT方法在同一个任务上表现差异可能都非常大，这让针对特定任务选择合适的方法非常繁琐。</p><p>基于此，作者提出了UniPELT方法，<strong>将不同的PELT方法作为子模块，并通过门控机制学习激活最适合当前数据或任务的方法</strong>。</p><h3 id="技术原理-9">5.5.2 技术原理</h3><p>UniPELT（论文： UNIPELT: A Unified Framework for Parameter-EfficientLanguage Model Tuning）是 LoRA、Prefix Tuning和Adapter的门控组合。</p><p>更具体地说，LoRA 重新参数化用于 WQ 和 WV 注意力矩阵，PrefixTuning应用于每一Transformer层的key和value，并在Transformer块的feed-forward子层之后添加Adapter。对于每个模块，门控被实现为线性层，通过GP参数控制Prefix-tuning方法的开关，GL控制LoRA方法的开关，GA控制Adapter方法的开关。可训练参数包括LoRA 矩阵WA（Down）和WB（Up），提示调优参数Pk和Pv、Adapter参数和门函数权重。即图中蓝颜色的参数为可学习的参数。</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240324151853173.png" alt="UniPELT" style="zoom:50%;" /></p><p>UniPELT 仅用 100 个示例就在低数据场景中展示了相对于单个 LoRA、Adapter和 Prefix Tuning 方法的显著改进。在更高数据的场景中，UniPELT的性能与这些方法相当或更好。</p><p>实验还对不同 PELT 方法训练时间和推理时间进行了分析。</p><ul><li>从训练速度来看，UniPELT比之前微调的方法多一些，但是还在能接受的范围，</li><li>从推理时间来看，BitFit方法增加的最少，UniPELT方法时间增加了27%。</li><li>从训练参数量来看，LoRA，BitFit，Prefix-tuning都比较小，UniPELT参数量相对会多一些。</li></ul><h1 id="lora">6. lora</h1><h2 id="lora-1">6.1 LoRA</h2><h3 id="背景-10">6.1.1 背景</h3><p>神经网络包含很多全连接层，其借助于矩阵乘法得以实现，然而，很多全连接层的权重矩阵都是满秩的。当针对特定任务进行微调后，<strong>模型中权重矩阵其实具有很低的本征秩</strong>（intrinsicrank），因此，论文的作者认为<strong>权重更新的那部分参数矩阵尽管随机投影到较小的子空间，仍然可以有效的学习，可以理解为针对特定的下游任务这些权重矩阵就不要求满秩</strong>。</p><h3 id="技术原理-10">6.1.2 技术原理</h3><p>LoRA（论文：<strong>LoRA: LOW-RANK ADAPTATION OF LARGE LANGUAGEMODELS</strong>），该方法的核心思想就是<strong>通过低秩分解来模拟参数的改变量，从而以极小的参数量来实现大模型的间接训练。</strong></p><p>在涉及到矩阵相乘的模块，在原始的PLM旁边增加一个新的通路，通过前后两个矩阵A,B相乘，第一个矩阵A负责降维，第二个矩阵B负责升维，中间层维度为r，从而来模拟所谓的本征秩（intrinsicrank）。</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240324153113255.png" alt="Lora基本原理和结构" style="zoom:50%;" /></p><p>可训练层维度和预训练模型层维度一致为<code>d</code>，先将维度<code>d</code>通过全连接层降维至<code>r</code>，再从<code>r</code>通过全连接层映射回<code>d</code>维度，其中，<code>r&lt;&lt;d</code>，r是矩阵的秩，这样矩阵计算就从<code>d x d</code>变为<code>d x r + r x d</code>，参数量减少很多。</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240324153159299.png" alt="Lora微调的基本结构" style="zoom:33%;" /></p><p>在下游任务训练时，固定模型的其他参数，只优化新增的两个矩阵的权重参数，将PLM跟新增的通路两部分的结果加起来作为最终的结果（两边通路的输入跟输出维度是一致的），即<code>h=Wx+BAx</code>。第一个矩阵的A的权重参数会通过高斯函数初始化，而第二个矩阵的B的权重参数则会初始化为零矩阵，这样能保证训练开始时新增的通路BA=0从而对模型结果没有影响。</p><p><span class="math display">\[h=W_{0} x+\Delta W x=W_{0} x+B A x\]</span></p><p>在推理时，将左右两部分的结果加到一起即可，<code>h=Wx+BAx=(W+BA)x</code>，所以只要将训练完成的矩阵乘积<code>BA</code>跟原本的权重矩阵<code>W</code>加到一起作为新权重参数替换原本PLM的W即可，对于推理来说，不会增加额外的计算资源。</p><p>此外，Transformer的权重矩阵包括Attention模块里用于计算<code>query</code>,<code>key</code>,<code>value</code>的<code>Wq</code>，<code>Wk</code>，<code>Wv</code>以及多头attention的<code>Wo</code>,以及MLP层的权重矩阵，LoRA只应用于Attention模块中的4种权重矩阵，而且通过消融实验发现同时调整Wq 和 Wv 会产生最佳结果。</p><p>实验还发现，保证权重矩阵的种类的数量比起增加隐藏层维度r更为重要，增加r并不一定能覆盖更加有意义的子空间。</p><h2 id="adalora">6.2 AdaLoRA</h2><h3 id="背景-11">6.2.1 背景</h3><p>在NLP领域，对于下游任务进行大型预训练语言模型的微调已经成为一种重要的做法。一般而言，我们会采用对原有的预训练模型进行全量微调的方法来适配下游任务，但这种方法存在两个问题。</p><ul><li><strong>训练阶段</strong>。对于预训练模型进行微调的时候，为了更新权重参数，需要大量的显存来存储参数的梯度和优化器信息，在当今预训练模型的参数变得越来越大的情况下，针对下游任务微调门槛变得越来越高。</li><li><strong>推理阶段</strong>。由于我们训练的时候是对于模型参数进行全量的更新，所以多个下游任务需要为每个任务维护一个大型模型的独立副本，这样就导致我们在实际应用的时候浪费了不必要的存储。</li></ul><p>为了解决这些问题，研究者提出了两个主要研究方向，以减少微调参数的数量，同时保持甚至提高预训练语言模型的性能。</p><ul><li><strong>方向一：添加小型网络模块</strong>：将小型网络模块添加到PLMs中，保持基础模型保持不变的情况下仅针对每个任务微调这些模块，可以用于所有任务。这样，只需引入和更新少量任务特定的参数，就可以适配下游的任务，大大提高了预训练模型的实用性。如：Adaptertuning、Prefix tuning、PromptTuning等，这类方法虽然大大减少了内存消耗。但是这些方法存在一些问题，比如：Adaptertuning引入了推理延时；Prefix tuning或Prompttuning直接优化Prefix和Prompt是非单调的，比较难收敛，并且消耗了输入的token。</li><li><strong>方向二：下游任务增量更新</strong>：对预训练权重的增量更新进行建模，而无需修改模型架构，即W=W0+△W。比如：Diffpruning、LoRA等，此类方法可以达到与完全微调几乎相当的性能，但是也存在一些问题，比如：Diffpruning需要底层实现来加速非结构化稀疏矩阵的计算，不能直接使用现有的框架，训练过程中需要存储完整的∆W矩阵，相比于全量微调并没有降低计算成本。LoRA则需要预先指定每个增量矩阵的本征秩 r相同，忽略了在微调预训练模型时，权重矩阵的重要性在不同模块和层之间存在显著差异，并且只训练了Attention，没有训练FFN，事实上FFN更重要。</li></ul><p>基于以上问题进行总结：</p><ul><li>第一，我们不能预先指定矩阵的秩，需要动态更新增量矩阵的R，因为权重矩阵的重要性在不同模块和层之间存在显著差异。</li><li>第二，需要找到更加重要的矩阵，分配更多的参数，裁剪不重要的矩阵。找到重要的矩阵，可以提升模型效果；而裁剪不重要的矩阵，可以降低参数计算量，降低模型效果差的风险。</li></ul><p>为了弥补这一差距，作者提出了AdaLoRA，它根据权重矩阵的重要性得分，在权重矩阵之间自适应地分配参数预算。</p><h3 id="技术原理-11">6.2.2 技术原理</h3><p>AdaLoRA（论文：<strong>ADAPTIVE BUDGET ALLOCATION FORPARAMETEREFFICIENTFINE-TUNING</strong>），是对LoRA的一种改进，它根据<strong>重要性评分动态分配参数预算给权重矩阵</strong>。具体做法如下：</p><ul><li><strong>调整增量矩分配</strong>。AdaLoRA将关键的增量矩阵分配高秩以捕捉更精细和任务特定的信息，而将较不重要的矩阵的秩降低，以防止过拟合并节省计算预算。</li><li><strong>以奇异值分解的形式对增量更新进行参数化，并根据重要性指标裁剪掉不重要的奇异值，同时保留奇异向量</strong>。由于对一个大矩阵进行精确SVD分解的计算消耗非常大，这种方法通过减少它们的参数预算来加速计算，同时，保留未来恢复的可能性并稳定训练。</li></ul><p><span class="math display">\[W=W^{(0)}+\Delta=W^{(0)}+P \Lambda Q\]</span></p><ul><li><strong>在训练损失中添加了额外的惩罚项</strong>，以规范奇异矩阵P和Q的正交性，从而避免SVD的大量计算并稳定训练。</li></ul><p>通过实验证明，AdaLoRA实现了在所有预算、所有数据集上与现有方法相比，性能更好或相当的水平。例如，当参数预算为 0.3M 时，AdaLoRA在RTE数据集上，比表现最佳的基线（Baseline）高 1.8%。</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240324153310413.png" alt="AdaLoRA和其他算法的对比" style="zoom: 33%;" /></p><h2 id="qlora">6.3 QLoRA</h2><h3 id="背景-12">6.3.1 背景</h3><p>微调大型语言模型 (LLM)是提高其性能以及添加所需或删除不需要的行为的一种非常有效的方法。然而，微调非常大的模型非常昂贵；以LLaMA 65B 参数模型为例，常规的 16 bit微调需要超过 780 GB 的 GPU内存。</p><p>虽然最近的量化方法可以减少 LLM的内存占用，但此类技术仅适用于推理场景。</p><p>基于此，作者提出了QLoRA，并首次证明了<strong>可以在不降低任何性能的情况下微调量化为4 bit的模型。</strong></p><h3 id="技术原理-12">6.3.2 技术原理</h3><p>QLoRA（论文： <strong>QLORA: Efficient Finetuning of QuantizedLLMs</strong>），使用<strong>一种新颖的高精度技术将预训练模型量化为 4bit，然后添加一小组可学习的低秩适配器权重，这些权重通过量化权重的反向传播梯度进行微调</strong>。QLORA有一种低精度存储数据类型（4bit），还有一种计算数据类型（BFloat16）。实际上，这意味着无论何时使用QLoRA 权重张量，我们都会将张量反量化为 BFloat16，然后执行 16位矩阵乘法。QLoRA提出了两种技术实现高保真 4 bit微调——4 bitNormalFloat(NF4)量化和双量化。此外，还引入了分页优化器，以防止梯度检查点期间的内存峰值，从而导致内存不足的错误，这些错误在过去使得大型模型难以在单台机器上进行微调。具体说明如下：</p><ul><li><strong>4bitNormalFloat</strong>（NF4）：对于正态分布权重而言，一种信息理论上最优的新数据类型，该数据类型对正态分布数据产生比4 bit整数和 4bit 浮点数更好的实证结果。</li><li><strong>双量化</strong>：对第一次量化后的那些常量再进行一次量化，减少存储空间。</li><li><strong>分页优化器</strong>：使用NVIDIA统一内存特性，该特性可以在在GPU偶尔OOM的情况下，进行CPU和GPU之间自动分页到分页的传输，以实现无错误的GPU 处理。该功能的工作方式类似于 CPU内存和磁盘之间的常规内存分页。使用此功能为优化器状态（Optimizer）分配分页内存，然后在GPU 内存不足时将其自动卸载到 CPU内存，并在优化器更新步骤需要时将其加载回 GPU 内存。</li></ul><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240324153407744.png" alt="Qlora和其他微调方法对比" style="zoom: 50%;" /></p><p>实验证明，无论是使用16bit、8bit还是4bit的适配器方法，都能够复制16bit全参数微调的基准性能。这说明，尽管量化过程中会存在性能损失，但通过适配器微调，完全可以恢复这些性能。</p><h1 id="微调方法总结">7. 微调方法总结</h1><h2 id="当前高效微调技术的简述">7.1<strong>当前高效微调技术的简述</strong></h2><p>之前对一些常见的高效微调技术进行了背景介绍及技术原理剖析，下面对每一种高效微调技术的特点进行简要的总结。</p><h2 id="bitfit-1">7.2 <strong>BitFit</strong></h2><p>对微调机制的一种积极探索，也很简单，<strong>通过仅调整bias效果就能有不错的效果</strong>，但没有具体阐述原理，就是通过猜测加实验得到的结果。同时，作者提出一个观点：微调的过程不是让模型适应另外的数据分布，而是让模型更好的应用出本身的表征能力。</p><p>特点：</p><ul><li>训练参数量极小（约0.1%）。</li><li>在大部分任务上效果会差于LoRA、Adapter等方法。</li></ul><h2 id="prefix-tuning-1">7.3 <strong>Prefix Tuning</strong></h2><p>在每一个Transformer层都带上一些virtualtoken作为前缀，以适应不同的任务。</p><p>特点：</p><ul><li>前缀Token会占用序列长度，有一定的额外计算开销。</li><li>Prefix Tuning的线性插值是比较复杂的。</li></ul><h2 id="prompt-tuning-1">7.4 <strong>Prompt Tuning</strong></h2><p>该方法可以看着是PrefixTuning的简化版本，针对不同的任务，仅在输入层引入virtualtoken形式的软提示（soft prompt）。</p><p>特点：</p><ul><li>相对于PrefixTuning，参与训练的参数量和改变的参数量更小，更节省显存。</li><li>对一些简单的NLU任务还不错，但对硬序列标记任务（即序列标注）表现欠佳。</li></ul><h2 id="p-tuning-1">7.5 <strong>P-Tuning</strong></h2><p>将Prompt转换为可以学习的Embedding层，并用MLP+LSTM的方式来对PromptEmbedding进行一层处理。相比Prefix Tuning，仅在输入层加入的可微的virtualtoken；另外，virtual token的位置也不一定是前缀，插入的位置是可选的。</p><p>特点：</p><ul><li>引入一个prompt encoder（由一个双向的LSTM+两层MLP组成）来建模virtualtoken的相互依赖会收敛更快，效果更好。</li></ul><h2 id="p-tuning-v2-1">7.6 <strong>P-Tuning v2</strong></h2><p>该方法在每一个Transformer层都加入了prompttoken作为输入，引入多任务学习，针对不同任务采用不同的提示长度。并且回归传统的分类标签范式，而不是映射器。</p><p>特点：</p><ul><li>解决了Prompt Tuning无法在小模型上有效提升的问题。</li><li>移除了对模型效果改进较小的重参数化的编码器（如：PrefixTuning中的MLP、P-Tuning中的LSTM）。</li><li>对于一些复杂的硬序列标记任务（即序列标注）取得了不错的效果。</li></ul><h2 id="adapter-tuning-2">7.7 <strong>Adapter Tuning</strong></h2><p>该方法设计了Adapter结构，并将其嵌入Transformer的结构里面，针对每一个Transformer层，增加了两个Adapter结构，在训练时，固定住原来预训练模型的参数不变，只对新增的Adapter结构和LayerNorm 层进行微调。</p><p>特点：</p><ul><li>通过在Transformer层中嵌入Adapter结构，在推理时会额外增加推理时长。</li></ul><h2 id="adapterfusion-1">7.8 <strong>AdapterFusion</strong></h2><p>一种融合多任务信息的Adapter的变体，在 Adapter的基础上进行优化，通过将学习过程分为两阶段来提升下游任务表现。</p><h2 id="adapterdrop-1">7.9 <strong>AdapterDrop</strong></h2><p>该方法在不影响任务性能的情况下，对Adapter动态高效的移除，尽可能的减少模型的参数量，提高模型在反向传播（训练）和正向传播（推理）时的效率。</p><p>特点：</p><ul><li>通过从较低的 Transformer 层删除可变数量的Adaper来提升推理速度。当对多个任务执行推理时，动态地减少了运行时的计算开销，并在很大程度上保持了任务性能。</li></ul><h2 id="lora-2">7.10 <strong>LoRA</strong></h2><p>该方法通过低秩分解来模拟参数的改变量，从而以极小的参数量来实现大模型的间接训练。</p><p>特点：</p><ul><li>将BA加到W上可以消除推理延迟。</li><li>可以通过可插拔的形式切换到不同的任务。</li><li>设计的比较好，简单且效果好。</li></ul><h2 id="adalora-1">7.11 <strong>AdaLoRA</strong></h2><p>对LoRA的一种改进，它根据重要性评分动态分配参数预算给权重矩阵，将关键的增量矩阵分配高秩以捕捉更精细和任务特定的信息，而将较不重要的矩阵的秩降低，以防止过拟合并节省计算预算。</p><h2 id="qlora-1">7.12 <strong>QLoRA</strong></h2><p>使用一种新颖的高精度技术将预训练模型量化为 4bit，然后添加一小组可学习的低秩适配器权重，这些权重通过量化权重的反向传播梯度进行微调。</p><p>特点：</p><ul><li>使用 QLoRA微调模型，可以显著降低对于显存的要求。同时，模型训练的速度会慢于LoRA。</li></ul><h2 id="mam-adapter-1">7.13 <strong>MAM Adapter</strong></h2><p>一种在 Adapter、Prefix Tuning 和 LoRA之间建立联系的统一方法。最终的模型 MAM Adapter 是用于 FFN 的并行 Adapter和 软提示的组合。</p><p>特点：</p><ul><li>整体上来说，最终的模型MAM Adapter效果会优于单个高效微调方法。</li></ul><h2 id="unipelt-1">7.14 <strong>UniPELT</strong></h2><p>一种将不同的PELT方法LoRA、PrefixTuning和Adapter作为子模块，并通过门控机制学习激活最适合当前数据或任务的方法。</p><p>特点：</p><ul><li>相对于LoRA，BitFit，Prefix-tuning，训练的参数量更大；同时，推理更耗时；并且，输入会占用额外的序列长度。</li><li>多种 PELT 方法的混合涉及PLM的不同部分对模型有效性和鲁棒性都有好处</li></ul><h2 id="总结">7.15 <strong>总结</strong></h2><p>本文针对之前介绍的几种参数高效微调方法进行了简单的概述，主要有如下几类：</p><ul><li>增加额外参数，如：Prefix Tuning、Prompt Tuning、AdapterTuning及其变体。</li><li>选取一部分参数更新，如：BitFit。</li><li>引入重参数化，如：LoRA、AdaLoRA、QLoRA。</li><li>混合高效微调，如：MAM Adapter、UniPELT。</li></ul><p>并比较了不同的高效微调方法之间的差异；同时，还指出当前大多数高效微调方法存在的一些问题并给出了最佳实践。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>大语言模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【大语言模型】基础模型概念</title>
    <link href="/2024/03/08/dl_llm_model/"/>
    <url>/2024/03/08/dl_llm_model/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="大语言模型简介">大语言模型简介</h1><h1 id="llm概念">1.llm概念</h1><h2 id="主流的开源模型体系">1.1 主流的开源模型体系</h2><p>目前主流的开源LLM（语言模型）模型体系包括以下几个：</p><ol type="1"><li><strong>GPT（Generative Pre-trainedTransformer）系列</strong>：由OpenAI发布的一系列基于Transformer架构的语言模型，包括GPT、GPT-2、GPT-3等。GPT模型通过在大规模无标签文本上进行预训练，然后在特定任务上进行微调，具有很强的生成能力和语言理解能力。</li><li><strong>BERT（Bidirectional Encoder Representations fromTransformers）</strong>：由Google发布的一种基于Transformer架构的双向预训练语言模型。BERT模型通过在大规模无标签文本上进行预训练，然后在下游任务上进行微调，具有强大的语言理解能力和表征能力。</li><li><strong>XLNet</strong>：由CMU和GoogleBrain发布的一种基于Transformer架构的自回归预训练语言模型。XLNet模型通过自回归方式预训练，可以建模全局依赖关系，具有更好的语言建模能力和生成能力。</li><li><strong>RoBERTa</strong>：由Facebook发布的一种基于Transformer架构的预训练语言模型。RoBERTa模型在BERT的基础上进行了改进，通过更大规模的数据和更长的训练时间，取得了更好的性能。</li><li><strong>T5（Text-to-Text TransferTransformer）</strong>：由Google发布的一种基于Transformer架构的多任务预训练语言模型。T5模型通过在大规模数据集上进行预训练，可以用于多种自然语言处理任务，如文本分类、机器翻译、问答等。</li></ol><p>这些模型在自然语言处理领域取得了显著的成果，并被广泛应用于各种任务和应用中。</p><h2 id="prefix-lm-和-causal-lm-区别是什么">1.2 prefix LM 和 causal LM区别是什么？</h2><p>Prefix LM（前缀语言模型）和CausalLM（因果语言模型）是两种不同类型的语言模型，它们的区别在于生成文本的方式和训练目标。</p><ol type="1"><li><strong>PrefixLM</strong>：前缀语言模型是一种生成模型，它在生成每个词时都可以考虑之前的上下文信息。在生成时，前缀语言模型会根据给定的前缀（即部分文本序列）预测下一个可能的词。这种模型可以用于文本生成、机器翻译等任务。</li><li><strong>CausalLM</strong>：因果语言模型是一种自回归模型，它只能根据之前的文本生成后续的文本，而不能根据后续的文本生成之前的文本。在训练时，因果语言模型的目标是预测下一个词的概率，给定之前的所有词作为上下文。这种模型可以用于文本生成、语言建模等任务。</li></ol><p>总结来说，前缀语言模型可以根据给定的前缀生成后续的文本，而因果语言模型只能根据之前的文本生成后续的文本。它们的训练目标和生成方式略有不同，适用于不同的任务和应用场景。</p><h2 id="大模型llm的训练目标">1.3 大模型LLM的训练目标</h2><p>大型语言模型（Large LanguageModels，LLM）的训练目标通常是<strong>最大似然估计（Maximum LikelihoodEstimation，MLE）</strong>。最大似然估计是一种统计方法，用于从给定数据中估计概率模型的参数。</p><p>在LLM的训练过程中，使用的数据通常是大量的文本语料库。训练目标是<strong>最大化模型生成训练数据中观察到的文本序列的概率</strong>。具体来说，对于每个文本序列，模型根据前面的上下文生成下一个词的条件概率分布，并通过最大化生成的词序列的概率来优化模型参数。</p><p>为了最大化似然函数，可以使用梯度下降等优化算法来更新模型参数，使得模型生成的文本序列的概率逐步提高。在训练过程中，通常会使用批量训练（batchtraining）的方法，通过每次处理一小批数据样本来进行参数更新。</p><h2 id="涌现能力是啥原因">1.4 涌现能力是啥原因？</h2><p><a href="https://zhuanlan.zhihu.com/p/621438653"title="大语言模型的涌现能力：现象与解释 - 知乎 (zhihu.com)">大语言模型的涌现能力：现象与解释- 知乎 (zhihu.com)</a></p><p>涌现能力（EmergentAbility）是指<strong>模型在训练过程中能够生成出令人惊喜、创造性和新颖的内容或行为</strong>。这种能力使得模型能够超出其训练数据所提供的内容，并产生出具有创造性和独特性的输出。</p><p>涌现能力的产生可以归因于以下几个原因：</p><ol type="1"><li><strong>任务的评价指标不够平滑</strong>：因为很多任务的评价指标不够平滑，导致我们现在看到的涌现现象。如果评价指标要求很严格，要求一字不错才算对，那么Emoji_movie任务我们就会看到涌现现象的出现。但是，如果我们把问题形式换成多选题，就是给出几个候选答案，让LLM选，那么随着模型不断增大，任务效果在持续稳定变好，但涌现现象消失，如上图图右所示。这说明评价指标不够平滑，起码是一部分任务看到涌现现象的原因。</li><li><strong>复杂任务</strong> <strong>vs</strong><strong>子任务</strong>：展现出涌现现象的任务有一个共性，就是任务往往是由多个子任务构成的复杂任务。也就是说，最终任务过于复杂，如果仔细分析，可以看出它由多个子任务构成，这时候，子任务效果往往随着模型增大，符合Scaling Law，而最终任务则体现为涌现现象。</li><li><strong>用</strong> <strong>Grokking</strong>（顿悟）<strong>来解释涌现</strong>：对于某个任务T，尽管我们看到的预训练数据总量是巨大的，但是与T相关的训练数据其实数量很少。当我们推大模型规模的时候，往往会伴随着增加预训练数据的数据量操作，这样，当模型规模达到某个点的时候，与任务T相关的数据量，突然就达到了最小要求临界点，于是我们就看到了这个任务产生了Grokking现象。</li></ol><p>尽管涌现能力为模型带来了创造性和独特性，但也需要注意其生成的内容可能存在偏差、错误或不完整性。因此，在应用和使用涌现能力强的模型时，需要谨慎评估和验证生成的输出，以确保其质量和准确性。</p><h2 id="为何现在的大模型大部分是decoder-only结构">1.5为何现在的大模型大部分是Decoder only结构</h2><ol type="1"><li><strong>自回归生成</strong>：Decoder-only结构适用于自回归生成任务，其中模型根据先前的输入生成下一个输出。这种结构在自然语言处理任务中非常有用，如文本生成、机器翻译和对话生成等。<strong>Decoder-only结构能够利用上下文信息来生成连续的输出序列，使得生成的结果更加准确和连贯</strong>。</li><li><strong>生成多样性</strong>：Decoder-only结构可以通过在训练期间使用不同的解码策略来生成多样化的结果。例如，在生成文本时，可以使用不同的采样策略（如贪婪采样或随机采样）或温度参数来调整生成的多样性。这种能力对于一些任务（如对话生成）非常重要，因为它可以产生更加有趣和多样化的回复。</li><li><strong>模型训练和推理的一致性</strong>：Decoder-only结构使得模型的训练和推理过程更加一致。在训练期间，模型可以使用教师强制（teacherforcing）策略，即将真实的目标输出作为输入传递给解码器。而在推理期间，模型可以逐步生成输出，将前一个时间步的输出作为输入传递给下一个时间步。这种一致性有助于更好地控制模型的生成过程，并提高模型的稳定性和可靠性。</li></ol><h2 id="大模型架构介绍">1.6 大模型架构介绍</h2><p>LLM（Large LanguageModel，大型语言模型）是指基于大规模数据和参数量的语言模型。具体的架构可以有多种选择，以下是一种常见的大模型LLM的架构介绍：</p><ol type="1"><li><strong>Transformer架构</strong>：大模型LLM常使用Transformer架构，它是一种基于自注意力机制的序列模型。Transformer架构由多个编码器层和解码器层组成，每个层都包含多头自注意力机制和前馈神经网络。这种架构可以捕捉长距离的依赖关系和语言结构，适用于处理大规模语言数据。</li><li><strong>自注意力机制（Self-Attention）</strong>：自注意力机制是Transformer架构的核心组件之一。它允许模型在生成每个词时，根据输入序列中的其他词来计算该词的表示。自注意力机制能够动态地为每个词分配不同的权重，从而更好地捕捉上下文信息。</li><li><strong>多头注意力（Multi-HeadAttention）</strong>：多头注意力是自注意力机制的一种扩展形式。它将自注意力机制应用多次，每次使用不同的权重矩阵进行计算，得到多个注意力头。多头注意力可以提供更丰富的上下文表示，增强模型的表达能力。</li><li><strong>前馈神经网络（Feed-ForwardNetwork）</strong>：在Transformer架构中，每个注意力层后面都有一个前馈神经网络。前馈神经网络由两个全连接层组成，通过非线性激活函数（如ReLU）进行变换。它可以对注意力层输出的表示进行进一步的映射和调整。</li><li><strong>预训练和微调</strong>：大模型LLM通常采用预训练和微调的方法进行训练。预训练阶段使用大规模无标签数据，通过自监督学习等方法进行训练，使模型学习到丰富的语言知识。微调阶段使用有标签的特定任务数据，如文本生成、机器翻译等，通过有监督学习进行模型的微调和优化。</li></ol><p>需要注意的是，大模型LLM的具体架构可能会因不同的研究和应用而有所不同。上述介绍的是一种常见的架构，但实际应用中可能会有一些变体或改进。</p><h2 id="llms复读机问题">1.7 LLMs复读机问题</h2><h3 id="什么是-llms-复读机问题">1.7.1 什么是 LLMs 复读机问题？</h3><p>LLMs复读机问题（LLMs ParrotingProblem）是指大型语言模型在生成文本时过度依赖输入文本的复制，而缺乏创造性和独特性。当面对一个问题或指令时，模型可能会简单地复制输入文本的一部分或全部内容，并将其作为生成的输出，而不是提供有意义或新颖的回应。</p><h3 id="为什么会出现-llms-复读机问题">1.7.2 为什么会出现 LLMs复读机问题？</h3><ol type="1"><li><strong>数据偏差</strong>：大型语言模型通常是通过预训练阶段使用大规模无标签数据进行训练的。如果训练数据中存在大量的重复文本或者某些特定的句子或短语出现频率较高，模型在生成文本时可能会倾向于复制这些常见的模式。</li><li><strong>训练目标的限制</strong>：大型语言模型的训练通常是基于自监督学习的方法，通过预测下一个词或掩盖词来学习语言模型。这样的训练目标可能使得模型更倾向于生成与输入相似的文本，导致复读机问题的出现。</li><li><strong>缺乏多样性的训练数据</strong>：虽然大型语言模型可以处理大规模的数据，但如果训练数据中缺乏多样性的语言表达和语境，模型可能无法学习到足够的多样性和创造性，导致复读机问题的出现。</li><li><strong>模型结构和参数设置</strong>：大型语言模型的结构和参数设置也可能对复读机问题产生影响。例如，模型的注意力机制和生成策略可能导致模型更倾向于复制输入的文本。</li></ol><h3 id="如何缓解-llms-复读机问题">1.7.3 如何缓解 LLMs 复读机问题？</h3><p>为了缓解LLMs复读机问题，可以尝试以下方法：</p><ol type="1"><li><strong>多样性训练数据</strong>：在训练阶段，使用多样性的语料库来训练模型，避免数据偏差和重复文本的问题。这可以包括从不同领域、不同来源和不同风格的文本中获取数据。</li><li><strong>引入噪声</strong>：在生成文本时，引入一些随机性或噪声，例如通过采样不同的词或短语，或者引入随机的变换操作，以增加生成文本的多样性。这可以通过在生成过程中对模型的输出进行采样或添加随机性来实现。</li><li><strong>温度参数调整</strong>：温度参数是用来控制生成文本的多样性的一个参数。通过调整温度参数的值，可以控制生成文本的独创性和多样性。较高的温度值会增加随机性，从而减少复读机问题的出现。</li><li><strong>Beam搜索调整</strong>：在生成文本时，可以调整Beam搜索算法的参数。Beam搜索是一种常用的生成策略，它在生成过程中维护了一个候选序列的集合。通过调整Beam大小和搜索宽度，可以控制生成文本的多样性和创造性。</li><li><strong>后处理和过滤</strong>：对生成的文本进行后处理和过滤，去除重复的句子或短语，以提高生成文本的质量和多样性。可以使用文本相似度计算方法或规则来检测和去除重复的文本。</li><li><strong>人工干预和控制</strong>：对于关键任务或敏感场景，可以引入人工干预和控制机制，对生成的文本进行审查和筛选，确保生成结果的准确性和多样性。</li></ol><p>需要注意的是，缓解LLMs复读机问题是一个复杂的任务，没有一种通用的解决方案。不同的方法可能适用于不同的场景和任务，需要根据具体情况进行选择和调整。此外，解决复读机问题还需要综合考虑数据、训练目标、模型架构和生成策略等多个因素，需要进一步的研究和实践来提高大型语言模型的生成文本多样性和创造性。</p><h2 id="llms输入句子长度理论上可以无限长吗">1.8LLMs输入句子长度理论上可以无限长吗？</h2><p><strong>理论上来说，LLMs（大型语言模型）可以处理任意长度的输入句子，但实际上存在一些限制和挑战</strong>。下面是一些相关的考虑因素：</p><ol type="1"><li><strong>计算资源</strong>：生成长句子需要更多的计算资源，包括内存和计算时间。由于LLMs通常是基于神经网络的模型，计算长句子可能会导致内存不足或计算时间过长的问题。</li><li><strong>模型训练和推理</strong>：训练和推理长句子可能会面临一些挑战。在训练阶段，处理长句子可能会导致梯度消失或梯度爆炸的问题，影响模型的收敛性和训练效果。在推理阶段，生成长句子可能会增加模型的错误率和生成时间。</li><li><strong>上下文建模</strong>：LLMs是基于上下文建模的模型，长句子的上下文可能会更加复杂和深层。模型需要能够捕捉长句子中的语义和语法结构，以生成准确和连贯的文本。</li></ol><h2 id="如何让大模型处理更长的文本">1.9如何让大模型处理更长的文本？</h2><p>要让大模型处理更长的文本，可以考虑以下几个方法：</p><ol type="1"><li><strong>分块处理</strong>：将长文本分割成较短的片段，然后逐个片段输入模型进行处理。这样可以避免长文本对模型内存和计算资源的压力。在处理分块文本时，可以使用重叠的方式，即将相邻片段的一部分重叠，以保持上下文的连贯性。</li><li><strong>层次建模</strong>：通过引入层次结构，将长文本划分为更小的单元。例如，可以将文本分为段落、句子或子句等层次，然后逐层输入模型进行处理。这样可以减少每个单元的长度，提高模型处理长文本的能力。</li><li><strong>部分生成</strong>：如果只需要模型生成文本的一部分，而不是整个文本，可以只输入部分文本作为上下文，然后让模型生成所需的部分。例如，输入前一部分文本，让模型生成后续的内容。</li><li><strong>注意力机制</strong>：注意力机制可以帮助模型关注输入中的重要部分，可以用于处理长文本时的上下文建模。通过引入注意力机制，模型可以更好地捕捉长文本中的关键信息。</li><li><strong>模型结构优化</strong>：通过优化模型结构和参数设置，可以提高模型处理长文本的能力。例如，可以增加模型的层数或参数量，以增加模型的表达能力。还可以使用更高效的模型架构，如Transformer等，以提高长文本的处理效率。</li></ol><p>需要注意的是，处理长文本时还需考虑计算资源和时间的限制。较长的文本可能需要更多的内存和计算时间，因此在实际应用中需要根据具体情况进行权衡和调整。</p><h1 id="llama系列模型">2.LLama系列模型</h1><h2 id="llama">2.1LLama</h2><h3 id="简介">2.1.1 简介</h3><p>LLaMA 所采用的 Transformer 结构和细节，与标准的 Transformer架构不同的地方包括采用了<strong>前置层归一化（Pre-normalization）</strong>并使用<strong>RMSNorm 归一化函数</strong> （NormalizingFunction）、激活函数更换为<strong>SwiGLU</strong>，并使用了<strong>旋转位置嵌入（RoP）</strong>，整体Transformer 架构与 GPT-2 类似。</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240305200623338.png" alt="LLAMA结构" style="zoom: 33%;" /></p><h3 id="rmsnorm归一化函数">2.1.2 RMSNorm归一化函数</h3><p><strong>为了使得模型训练过程更加稳定</strong>，GPT-2 相较于 GPT就引入了<strong>前置层归一化方法</strong>，将第一个层归一化移动到多头自注意力层之前，第二个层归一化也移动到了全连接层之前，同时残差连接的位置也调整到了多头自注意力层与全连接层之后。层归一化中也采用了<strong>RMSNorm 归一化函数</strong>。 针对输入向量<strong>a</strong>，RMSNorm 函数计算公式如下 <spanclass="math display">\[R M S(a)=\sqrt{\frac{1}{n} \sum_{i=1}^{n} a_{i}^{2}}\]</span></p><p><span class="math display">\[\bar{a}_{i}=\frac{a_{i}}{R M S(\boldsymbol{a})}\]</span></p><p>此外，RMSNorm 还可以引入可学习的缩放因子 $ g_ i $和偏移参数 <spanclass="math inline">\(b_i\)</span>，从而得到 <spanclass="math inline">\(\bar{a}_{i}=\frac{a_{i}}{\operatorname{RMS}(\boldsymbol{a})}g_{i}+b_{i}\)</span>。 RMSNorm 在 HuggingFace Transformer库中代码实现如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LlamaRMSNorm</span>(nn.Module):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, hidden_size, eps=<span class="hljs-number">1e-6</span></span>): <br>    <span class="hljs-string">&quot;&quot;&quot; </span><br><span class="hljs-string">    LlamaRMSNorm is equivalent to T5LayerNorm </span><br><span class="hljs-string">    &quot;&quot;&quot;</span> <br>    <span class="hljs-built_in">super</span>().__init__() <br>    self.weight = nn.Parameter(torch.ones(hidden_size)) <br>    self.variance_epsilon = eps <span class="hljs-comment"># eps 防止取倒数之后分母为 0 </span><br>  <br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, hidden_states</span>): <br>    input_dtype = hidden_states.dtype <br>    variance = hidden_states.to(torch.float32).<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>).mean(-<span class="hljs-number">1</span>, keepdim=<span class="hljs-literal">True</span>) <br>    hidden_states = hidden_states * torch.rsqrt(variance + self.variance_epsilon) <span class="hljs-comment"># weight 是末尾乘的可训练参数, 即 g_i </span><br>    <br>    <span class="hljs-keyword">return</span> (self.weight * hidden_states).to(input_dtype)<br></code></pre></td></tr></table></figure><p><strong>为什么要用RMSNorm优势在哪里？</strong></p><p>不用计算均值，直接算一次就能得到结果</p><h3 id="swiglu激活函数">2.1.3 SwiGLU激活函数</h3><p>SwiGLU激活函数是相较于 ReLU 函数在大部分评测中都有不少提升。在 LLaMA中全连接层使用带有 SwiGLU 激活函数的 FFN（Position-wise Feed-ForwardNetwork）的计算公式如下：</p><p><span class="math display">\[\operatorname{FFN}_{\text {SwiGLU }}\left(\boldsymbol{x},\boldsymbol{W}, \boldsymbol{V},\boldsymbol{W}_{2}\right)=\operatorname{SwiGLU}(\boldsymbol{x},\boldsymbol{W}, \boldsymbol{V}) \boldsymbol{W}_{2}\]</span></p><p><span class="math display">\[\operatorname{SwiGLU}(\boldsymbol{x}, \boldsymbol{W},\boldsymbol{V})=\operatorname{Swish}_{\beta}(x \boldsymbol{W}) \otimes\boldsymbol{x} \boldsymbol{V}\]</span></p><p><span class="math display">\[\operatorname{Swish}_{\beta}(\boldsymbol{x})=\boldsymbol{x}\sigma(\boldsymbol{\beta} \boldsymbol{x})\]</span></p><p>其中，<span class="math inline">\(σ(x)\)</span> 是 Sigmoid函数。下图给出了 Swish 激活函数在参数 <spanclass="math inline">\(β\)</span> 不同取值下的形状。可以看 到当 <spanclass="math inline">\(β\)</span> 趋近于 0 时，Swish 函数趋近于线性函数<span class="math inline">\(y = x\)</span>，当 $ β <spanclass="math inline">\(趋近于无穷大时，Swish 函数趋近于 ReLU函数，\)</span>β$ 取值为 1 时，Swish 函数是光滑且非单调。在 HuggingFace的 Transformer 库中 Swish1 函数使用 silu 函数代替。</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240305201045943.png" alt="Swish激活函数参数变化" style="zoom: 33%;" /></p><p>LLaMA中直接将FFN中的ReLU替换为SwiGLU，并将维度放缩为<spanclass="math inline">\((2/3) ⋅ 4d\)</span></p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240305201148810.png" alt="LLAMA中FFN的实现" style="zoom: 33%;" /></p><h3 id="旋转位置嵌入rope">2.1.4 旋转位置嵌入（RoPE）</h3><p>在位置编码上，使用旋转位置嵌入（Rotary PositionalEmbeddings，RoPE）代替原有的绝对位置编码。RoPE借助了<strong>复数的思想</strong>，出发点是<strong>通过绝对位置编码的方式实现相对位置编码</strong>。其目标是通过下述运算来给<code>q</code>，<code>k</code> 添加绝对位置信息：</p><p><span class="math display">\[\tilde{\boldsymbol{q}}_{m}=f(\boldsymbol{q}, m),\tilde{\boldsymbol{k}}_{n}=f(\boldsymbol{k}, n)\]</span></p><p>经过上述操作后，<spanclass="math inline">\(\tilde{\boldsymbol{q}}_{m}\)</span>和<spanclass="math inline">\(\tilde{\boldsymbol{k}}_{n}\)</span>就带有位置m和n的绝对位置信息。</p><p>最终可以得到二维情况下用复数表示的 RoPE：</p><p><span class="math display">\[f(\boldsymbol{q}, m)=R_{f}(\boldsymbol{q}, m) e^{i\Theta_{f}(\boldsymbol{q}, m)}=\|\boldsymbol{q}\|e^{i(\Theta(\boldsymbol{q})+m \theta)}=\boldsymbol{q} e^{i m \theta}\]</span></p><p>根据复数乘法的几何意义，上述变换实际上是对应向量旋转，所以位置向量称为“旋转式位置编码”。还可以使用矩阵形式表示</p><p><span class="math display">\[f(\boldsymbol{q}, m)=\left(\begin{array}{cc}\cos m \theta &amp; -\sin\cos m \theta \\ \sin m \theta &amp; \cos m\theta\end{array}\right)\left(\begin{array}{l}\boldsymbol{q}_{0} \\\boldsymbol{q}_{1}\end{array}\right)\]</span></p><p>根据内积满足线性叠加的性质，任意偶数维的RoPE，都可以表示为二维情形的拼接，即：</p><p><span class="math display">\[f(\boldsymbol{q}, m)=\underbrace{\left(\begin{array}{ccccccc}\cos m\theta_{0} &amp; -\sin m \theta_{0} &amp; 0 &amp; 0 &amp; \cdots &amp; 0&amp; 0 \\ \sin m \theta_{0} &amp; \cos m \theta_{0} &amp; 0 &amp; 0&amp; \cdots &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; \cos m \theta_{1} &amp;-\sin m \theta_{1} &amp; \cdots &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; \sinm \theta_{1} &amp; \cos m \theta_{1} &amp; \cdots &amp; 0 &amp; 0 \\\cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \ddots &amp; \cdots&amp; \cdots \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; \cos m\theta_{d / 2-1} &amp; -\sin m \theta_{d / 2-1} \\ 0 &amp; 0 &amp; 0&amp; 0 &amp; \cdots &amp; \sin m \theta_{d / 2-1} &amp; \cos m\theta_{d /2-1}\end{array}\right)}_{\boldsymbol{R}_{d}}\left(\begin{array}{c}\boldsymbol{q}_{0}\\ \boldsymbol{q}_{1} \\ \boldsymbol{q}_{2} \\ \boldsymbol{q}_{3} \\\cdots \\ \boldsymbol{q}_{d-2} \\ \boldsymbol{q}_{d-1}\end{array}\right)\]</span></p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240305201608876.png"alt="旋转位置编码" /><figcaption aria-hidden="true">旋转位置编码</figcaption></figure><p>RoPE 在 HuggingFace Transformer 库中代码实现如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">precompute_freqs_cis</span>(<span class="hljs-params">dim: <span class="hljs-built_in">int</span>, end: <span class="hljs-built_in">int</span>, constant: <span class="hljs-built_in">float</span> = <span class="hljs-number">10000.0</span></span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    计算cos和sin的值，cos值在实部，sin值在虚部，类似于 cosx+j*sinx</span><br><span class="hljs-string">    :param dim: q,k,v的最后一维，一般为emb_dim/head_num</span><br><span class="hljs-string">    :param end: 句长length</span><br><span class="hljs-string">    :param constant： 这里指10000</span><br><span class="hljs-string">    :return:</span><br><span class="hljs-string">    复数计算 torch.polar(a, t)输出， a*(cos(t)+j*sin(t))</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-comment"># freqs: 计算 1/(10000^(2i/d) )，将结果作为参数theta</span><br>    <span class="hljs-comment"># 形式化为 [theta_0, theta_1, ..., theta_(d/2-1)]</span><br>    freqs = <span class="hljs-number">1.0</span> / (constant ** (torch.arange(<span class="hljs-number">0</span>, dim, <span class="hljs-number">2</span>)[: (dim // <span class="hljs-number">2</span>)].<span class="hljs-built_in">float</span>() / dim)) <span class="hljs-comment"># [d/2]</span><br><br>    <span class="hljs-comment"># 计算m</span><br>    t = torch.arange(end, device=freqs.device)  <span class="hljs-comment"># [length]</span><br>    <span class="hljs-comment"># 计算m*theta</span><br>    freqs = torch.outer(t, freqs).<span class="hljs-built_in">float</span>()  <span class="hljs-comment"># [length, d/2]</span><br>    <span class="hljs-comment"># freqs形式化为 [m*theta_0, m*theta_1, ..., m*theta_(d/2-1)],其中 m=0,1,...,length-1</span><br><br>    <span class="hljs-comment"># 计算cos(m*theta)+j*sin(m*theta)</span><br>    freqs_cis = torch.polar(torch.ones_like(freqs), freqs)  <span class="hljs-comment"># complex64</span><br>    <span class="hljs-comment"># freqs_cis: [cos(m*theta_0)+j*sin(m*theta_0),  cos(m*theta_1)+j*sin(m*theta_1),), ..., cos(m*theta_(d/2-1))+j*sin(m*theta_(d/2-1))]</span><br>    <span class="hljs-comment"># 其中j为虚数单位， m=0,1,...,length-1</span><br>    <span class="hljs-keyword">return</span> freqs_cis <span class="hljs-comment"># [length, d/2]</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">reshape_for_broadcast</span>(<span class="hljs-params">freqs_cis: torch.Tensor, x: torch.Tensor</span>):<br>    ndim = x.ndim<br>    <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span> &lt;= <span class="hljs-number">1</span> &lt; ndim<br>    <span class="hljs-keyword">assert</span> freqs_cis.shape == (x.shape[<span class="hljs-number">1</span>], x.shape[-<span class="hljs-number">1</span>])<br>    shape = [d <span class="hljs-keyword">if</span> i == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> i == ndim - <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i, d <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(x.shape)] <span class="hljs-comment"># (1, length, 1, d/2)</span><br>    <span class="hljs-keyword">return</span> freqs_cis.view(*shape) <span class="hljs-comment"># [1, length, 1, d/2]</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">apply_rotary_emb</span>(<span class="hljs-params">xq: torch.Tensor, xk: torch.Tensor, freqs_cis: torch.Tensor,</span>):<br>    <span class="hljs-comment"># 先将xq维度变为[bs, length, head,  d/2, 2], 利用torch.view_as_complex转变为复数</span><br>    <span class="hljs-comment"># xq:[q0, q1, .., q(d-1)] 转变为 xq_: [q0+j*q1, q2+j*q3, ..., q(d-2)+j*q(d-1)]</span><br>    xq_ = torch.view_as_complex(xq.<span class="hljs-built_in">float</span>().reshape(*xq.shape[:-<span class="hljs-number">1</span>], -<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)) <span class="hljs-comment"># [bs, length, head, d/2]</span><br>    <span class="hljs-comment"># 同样的，xk_:[k0+j*k1, k2+j*k3, ..., k(d-2)+j*k(d-1)]</span><br>    xk_ = torch.view_as_complex(xk.<span class="hljs-built_in">float</span>().reshape(*xk.shape[:-<span class="hljs-number">1</span>], -<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br><br>    freqs_cis = reshape_for_broadcast(freqs_cis, xq_) <span class="hljs-comment"># [1, length, 1, d/2]</span><br>    <span class="hljs-comment"># 下式xq_ * freqs_cis形式化输出，以第一个为例, 如下</span><br>    <span class="hljs-comment"># (q0+j*q1)(cos(m*theta_0)+j*sin(m*theta_0)) = q0*cos(m*theta_0)-q1*sin(m*theta_0) + j*(q1*cos(m*theta_0)+q0*sin(m*theta_0))</span><br>    <span class="hljs-comment"># 上式的实部为q0*cos(m*theta_0)-q1*sin(m*theta_0)，虚部为q1*cos(m*theta_0)+q0*sin(m*theta_0)</span><br>    <span class="hljs-comment"># 然后通过torch.view_as_real函数，取出实部和虚部，维度由[bs, length, head, d/2]变为[bs, length, head, d/2, 2]，最后一维放实部与虚部</span><br>    <span class="hljs-comment"># 最后经flatten函数将维度拉平，即[bs, length, head, d]</span><br>    <span class="hljs-comment"># 此时xq_out形式化为 [实部0，虚部0，实部1，虚部1，..., 实部(d/2-1), 虚部(d/2-1)]</span><br>    xq_out = torch.view_as_real(xq_ * freqs_cis).flatten(<span class="hljs-number">3</span>) <span class="hljs-comment"># [bs, length, head, d]</span><br>    <span class="hljs-comment"># 即为新生成的q</span><br><br>    xk_out = torch.view_as_real(xk_ * freqs_cis).flatten(<span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">return</span> xq_out.type_as(xq), xk_out.type_as(xk)<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># (bs, length, head, d)</span><br>    q = torch.randn((<span class="hljs-number">2</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">32</span>))  <span class="hljs-comment"># q=[q0, q1, .., qd-1]</span><br>    k = torch.randn((<span class="hljs-number">2</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">32</span>))<br>    v = torch.randn((<span class="hljs-number">2</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">32</span>))<br>    freqs_cis= precompute_freqs_cis(dim=<span class="hljs-number">32</span>, end=<span class="hljs-number">10</span>, constant= <span class="hljs-number">10000.0</span>)<br>    <span class="hljs-comment"># print(freqs_cis.detach().numpy())</span><br><br>    q_new, k_new = apply_rotary_emb(xq=q, xk=k, freqs_cis=freqs_cis)<br>    <span class="hljs-built_in">print</span>()<br><br></code></pre></td></tr></table></figure><h2 id="alpaca">1.2 Alpaca</h2><h3 id="简介-1">1.2.1 简介</h3><p>Stanford Alpaca: An Instruction-following LLaMA Model</p><p>Alpaca是在<strong>LLaMA基础上使用52K指令数据精调的预训练模型</strong>，作者只用了不到600美元的成本训练出了该模型（数据$500+ 机器$100）。初步实验结果表明Alpaca可以达到与OpenAItext-davinci-003相匹敌的效果</p><h3 id="微调方法">1.2.2 微调方法</h3><ol type="1"><li>第一步：构造175条self-instruct 种子示例任务</li><li>第二步：基于上述种子任务，利 用text-davinci-003爬取指令数据</li><li>第三步：使用爬取下来的52K指令 数据在LLaMA上进行精调，最终得到Alpaca</li></ol><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image_-j860i8DgK.png"alt="Alpaca微调方法" /><figcaption aria-hidden="true">Alpaca微调方法</figcaption></figure><h3 id="self-instruct数据构造">1.2.3 Self-instruct数据构造</h3><p>首先由人工构造175条种子数据</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;seed_task_25&quot;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;perfect_numbers&quot;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;instruction&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Find the four smallest perfect numbers.&quot;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;instances&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;input&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;output&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;6, 28, 496, and 8128”&#125;], </span><br><span class="hljs-string">  &quot;</span>is_classification<span class="hljs-string">&quot;: false</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p>将“爬取要求”和种子数据进行适当组合，送入textdavinci-003，要求生成类似的指令数据。要求包括：提升指令多样性、包含真实数据、字数要求、语言要求、拒绝不合适指令等</p><h3 id="指令数据格式">1.2.4 指令数据格式</h3><ul><li><code>instruction</code>: 描述模型需要执行的指令内容</li><li><code>input</code>（可选）:任务上下文或输入信息，例如当指令是“对文章进行总结”，则input是文章内容</li><li><code>output</code>: 由text-davinci-003生成的针对指令的回复</li></ul><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240305202208115.png"alt="指令数据格式" /><figcaption aria-hidden="true">指令数据格式</figcaption></figure><h2 id="llama-2">1.3.Llama-2</h2><h3 id="简介-2">1.3.1 简介</h3><p>Llama 2: Open Foundation and Fine-Tuned Chat Models </p><p>2023年7月，Meta推出了Llama-2开源大模型，并且推出了Llama-2-Chat对话模型</p><p>与一代LLaMA主要区别体现在<strong>更多的训练数据、更⻓的上下文窗口、GQA技术</strong>等</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image_24Q7m-usAc.png"alt="LLAMA2与LLAMA的各项指标的对比" /><figcaptionaria-hidden="true">LLAMA2与LLAMA的各项指标的对比</figcaption></figure><p><strong>二次分发是什么？</strong></p><p>模型结构的变动主要是体现在<strong>GQA</strong>和<strong>FFN</strong>缩放上</p><ul><li><strong>MHA改成GQA</strong>：整体参数量会有减少</li><li><strong>FFN模块矩阵维度有扩充</strong>：增强泛化能力，整体参数量增加</li><li><strong>上下文长度是llama两倍</strong>(长度从2048-&gt;4096)训练语料增加约 40%，体现在1.4T-&gt;2.0T的Tokensllama2-34B和llama2-70B使用了GQA，加速模型训练和推理速度</li></ul><h3 id="gqa">1.3.2 GQA</h3><p>GQA和MQA都是注意力的变体，其中多个查询头关注相同的键和值头，以减少推理过程中KV 缓存的大小，并可以显著提高推理吞吐量。</p><p>MHA、GQA、MQA的区别和联系，具体的优点如下：</p><ul><li><code>Mutil-Head Attention</code>因为自回归模型生成回答时，需要前面生成的KV缓存起来，来加速计算。</li><li><code>Multi-Query Attention</code>多个头之间可以共享KV对，因此速度上非常有优势，实验验证大约减少30-40%吞吐。</li><li><code>Group Query Attention</code>没有像MQA那么极端，将query分组，组内共享KV，效果接近MQA，速度上与MQA可比较。</li></ul><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240305202602136.png"alt="注意力变体" /><figcaption aria-hidden="true">注意力变体</figcaption></figure><p>Llama-2中使用了8个KV映射，即GQA-8，<strong>GQA在多数任务上与MHA效果相当，且平均效果优于MQA；GQA和MQA均比MHA有更好的吞吐量</strong></p><h3 id="源码">1.3.3 源码</h3><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240305202807112.png"alt="MQA代码示意图" /><figcaption aria-hidden="true">MQA代码示意图</figcaption></figure><h1 id="chatglm">2.ChatGLM</h1><h2 id="背景">2.1 背景</h2><p>主流的预训练框架主要有三种：</p><ol type="1"><li><strong>autoregressive自回归模型（AR模型）</strong>：代表作GPT。本质上是一个left-to-right的语言模型。<strong>通常用于生成式任务</strong>，在长文本生成方面取得了巨大的成功，比如自然语言生成（NLG）领域的任务：摘要、翻译或抽象问答。当扩展到十亿级别参数时，表现出了少样本学习能力。缺点是单向注意力机制，在NLU任务中，无法完全捕捉上下文的依赖关系。</li><li><strong>autoencoding自编码模型（AE模型）</strong>：代表作BERT。是<strong>通过某个降噪目标（比如MLM）训练的双向文本编码器</strong>。编码器会产出适用于NLU任务的上下文表示，但无法直接用于文本生成。</li><li><strong>encoder-decoder（Seq2seq模型）</strong>：代表作T5。采用双向注意力机制，<strong>通常用于条件生成任务</strong>，比如文本摘要、机器翻译等。</li></ol><p>三种预训练框架各有利弊，没有一种框架在以下三种领域的表现最佳：自然语言理解（NLU）、无条件生成以及条件生成。T5曾经尝试使用MTL的方式统一上述框架，然而自编码和自回归目标天然存在差异，简单的融合自然无法继承各个框架的优点。</p><p>在这个天下三分的僵持局面下，GLM诞生了。</p><p><strong>GLM模型基于autoregressive blankinfilling方法，结合了上述三种预训练模型的思想</strong>。</p><h2 id="glm预训练框架">2.2 GLM预训练框架</h2><p>GLM特点</p><ol type="1"><li><strong>自编码思想</strong>：在输入文本中，随机删除连续的tokens。</li><li><strong>自回归思想</strong>：顺序重建连续tokens。在使用自回归方式预测缺失tokens时，模型既可以访问corrupted文本，又可以访问之前已经被预测的spans。</li><li><strong>span shuffling + 二维位置编码技术</strong>。</li><li>通过改变缺失spans的数量和长度，自回归空格填充目标可以为条件生成以及无条件生成任务预训练语言模型。</li></ol><h3 id="自回归空格填充任务">2.2.1 自回归空格填充任务</h3><p>给定一个输入文本<span class="math inline">\(x=\left[x_{1}, \ldotsx_{n}\right]\)</span>，可以采样得到多个文本spans <spanclass="math inline">\(\left\{s_{1}, \ldotss_{m}\right\}\)</span>。为了充分捕捉各spans之间的相互依赖关系，可以对spans的顺序进行随机排列，得到所有可能的排列集合<spanclass="math inline">\(Z_m\)</span>，其中：<spanclass="math inline">\(S_{z&lt;i}=\left[s_{z_{1}}, \ldots,s_{z_{i-1}}\right]\)</span>。所以预训练目标很清晰：</p><p><span class="math display">\[\max _{\theta} \mathbb{E}_{\boldsymbol{z} \simZ_{m}}\left[\sum_{i=1}^{m} \log p_{\theta}\left(\boldsymbol{s}_{z_{i}}\mid \boldsymbol{x}_{\text {corrupt }},\boldsymbol{s}_{\boldsymbol{z}_{&lt;i}}\right)\right]\]</span></p><p>GLM自回归空格填充任务的技术细节：</p><ol type="1"><li>输入<span class="math inline">\(x\)</span>可以被分成两部分：PartA是被mask的文本 <span class="math inline">\(x_{\text {corrupt}}\)</span>，Part B由masked spans组成。假设原始输入文本是<spanclass="math inline">\([x1, x2, x3, x4, x5,x6]\)</span>，采样的两个文本片段是<spanclass="math inline">\([x3]\)</span>以及<span class="math inline">\([x5,x6]\)</span>。那么mask后的文本序列是：<span class="math inline">\(x1,x2, [M], x4, [M]\)</span>，即Part A；同时我们需要对PartB的片段进行shuffle。每个片段使用<code>[S]</code>填充在开头作为输入，使用<code>[E]</code>填充在末尾作为输出。</li><li><strong>二维位置编码</strong>：Transformer使用位置编码来标记tokens中的绝对和相对位置。在GLM中，使用二维位置编码，第一个位置id用来标记PartA中的位置，第二个位置id用来表示跨度内部的相对位置。这两个位置id会通过embedding表被投影为两个向量，最终都会被加入到输入token的embedding表达中。</li><li>观察GLM中自定义attention mask的设计，非常巧妙：<ol type="1"><li>Part A中的tokens彼此可见，但是不可见B中的任意tokens。</li><li>Part B tokens可见Part A。</li><li>Part B tokens可见B中过去的tokens，不可见B中未来的tokens。</li></ol></li><li>采样方式：文本片段的采样遵循泊松分布，重复采样，直到原始tokens中有15%被mask。</li><li>总结：模型可以自动学习双向encoder（Part A）以及单向decoder（PartB）。</li></ol><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240314115323407.png"alt="自回归空格填充任务" /><figcaption aria-hidden="true">自回归空格填充任务</figcaption></figure><h3 id="多目标预训练">2.2.2 多目标预训练</h3><p>上述方法适合于NLU任务。作者希望可以训练一个既可以解决NLU任务，又具备文本生成能力的模型。因此除了空格填充目标之外，还需要增加一个生成长文本目标的任务。具体包含以下两个目标：</p><ol type="1"><li><strong>文档级别</strong>。从文档中采样一个文本片段进行mask，且片段长度为文档长度的50%～100%。这个目标用于长文本生成。</li><li><strong>句子级别</strong>。限制被mask的片段必须是完整句子。多个片段需覆盖原始tokens的15%。这个目标是用于预测完整句子或者段落的seq2seq任务。</li></ol><h3 id="模型结构">2.2.3 模型结构</h3><p>GLM在原始single Transformer的基础上进行了一些修改：</p><ol type="1"><li>重组了LN和残差连接的顺序；</li><li>使用单个线性层对输出token进行预测；</li><li>激活函数从ReLU换成了GeLUS。</li></ol><p>但我觉得这部分的修改比较简单常见。核心和亮点还是空格填充任务的设计。</p><h3 id="glm微调">2.2.4 GLM微调</h3><p>对于下游NLU任务来说，通常会将预训练模型产出的序列或tokens表达作为输入，使用线性分类器预测label。所以预训练与微调之间存在天然不一致。</p><p>作者按照PET的方式，将下游NLU任务重新表述为空白填充的生成任务。具体来说，比如给定一个已标注样本(x,y)，将输入的文本x转换成一个包含masktoken的完形填空问题。比如，情感分类任务可以表述为："{SENTENCE}. It’sreally [MASK]"。输出label y也同样会被映射到完形填空的答案中。“positive”和 “negative” 对应的标签就是“good” 和 “bad。</p><p>其实，预训练时，对较长的文本片段进行mask，以确保GLM的文本生成能力。但是在微调的时候，相当于将NLU任务也转换成了生成任务，这样其实是为了适应预训练的目标。但难免有一些牵强。</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240314115445663.png"alt="GLM的微调" /><figcaption aria-hidden="true">GLM的微调</figcaption></figure><h2 id="chatglm-2">2.3 ChatGLM-2</h2><h3 id="主要创新">2.3.1 主要创新</h3><ol type="1"><li><strong>更长的上下文</strong>：<strong>基于 </strong><ahref="https://github.com/HazyResearch/flash-attention"title="FlashAttention"><strong>FlashAttention</strong></a>**技术<strong>，将基座模型的上下文长度（Context Length）由 ChatGLM-6B 的</strong>2K 扩展到了 32K**，并在对话阶段使用 8K的上下文长度训练。对于更长的上下文，发布了 <ahref="https://huggingface.co/THUDM/chatglm2-6b-32k"title="ChatGLM2-6B-32K">ChatGLM2-6B-32K</a> 模型。<ahref="https://github.com/THUDM/LongBench"title="LongBench">LongBench</a>的测评结果表明，在等量级的开源模型中，ChatGLM2-6B-32K有着较为明显的竞争优势。</li><li><strong>更强大的性能</strong>：基于 ChatGLM初代模型的开发经验，全面升级了 ChatGLM2-6B 的基座模型。ChatGLM2-6B<strong>使用了 </strong><a href="https://github.com/THUDM/GLM"title="GLM"><strong>GLM</strong></a>** 的混合目标函数**，经过了 1.4T中英标识符的预训练与人类偏好对齐训练，<ahref="https://github.com/THUDM/ChatGLM2-6B#评测结果"title="评测结果">评测结果</a>显示，相比于初代模型，ChatGLM2-6B 在MMLU（+23%）、CEval（+33%）、GSM8K（+571%）、BBH（+60%）等数据集上的性能取得了大幅度的提升，在同尺寸开源模型中具有较强的竞争力。</li><li><strong>更高效的推理</strong>：基于 <ahref="http://arxiv.org/abs/1911.02150"title="Multi-Query Attention">Multi-Query Attention</a>技术，ChatGLM2-6B有更高效的推理速度和更低的显存占用：在官方的模型实现下，推理速度相比初代提升了42%，INT4 量化下，6G 显存支持的对话长度由 1K 提升到了 8K。 </li><li><strong>更开放的协议</strong>：ChatGLM2-6B权重对学术研究<strong>完全开放</strong>，在填写<ahref="https://open.bigmodel.cn/mla/form"title="问卷">问卷</a>进行登记后<strong>亦允许免费商业使用</strong>。</li></ol><h3 id="与chatglm的变化">2.3.2 与ChatGLM的变化</h3><ol type="1"><li><strong>使用了RoPE替换二维位置编码</strong>。这也是GLM中提出的亮点设计之一。但是目前大部分主流的LLMs都在使用RoPE，所以大势所趋。当前版本仍然采用了最初的RoPE设计，事实上现在的RoPE经过了xPOS→线性内插→NTK-AwareScaled RoPE→…若干次进化。</li><li><strong>Multi-QueryAttention</strong>：这是一种共享机制的Attention，相比Multi-HeadAttention，其Query部分没有区别，Key和Value可以只用一个Head。计算时，对Key和Value进行expand或者repeat操作，使它们填充到与Query一样的维度，后续计算就与Multi-HeadAttention没区别。</li><li><strong>Attention Mask</strong>: V1的attention mask分了2部分，PartA和Part B，Part A部分是双向Attention（代码中的<ahref="https://huggingface.co/THUDM/chatglm-6b/blob/main/modeling_chatglm.py#L963"title="prefix_attention_mask">prefix_attention_mask</a>），PartB部分是CausalAttention(原代码文件中的get_masks函数)。在V2版本，全部换成了CausalAttention，不再区分是Part A还是PartB，<strong>完全变成了decoder-only的架构</strong>。</li><li><strong>多目标任务</strong>：Chat版本主要还是用的gMask生成式任务，但是在V1版本的代码还能看到mask、gMask等字样，V2已经摒弃了这些特殊token，原因与AttentionMask一致，均因为变成了decoder-only的架构，不再需要区分Part A和PartB。</li></ol><h3 id="chatglm-3">2.3.3 ChatGLM-3</h3><p>省流：<strong>ChatGLM2与ChatGLM3模型架构是完全一致的</strong>，ChatGLM与后继者结构不同。可见ChatGLM3相对于ChatGLM2没有模型架构上的改进。</p><p>相对于ChatGLM，ChatGLM2、ChatGLM3模型上的变化：</p><ol type="1"><li>词表的大小从ChatGLM的150528缩小为65024（一个直观的体验是ChatGLM2、3加载比ChatGLM快不少）</li><li><strong>位置编码从每个GLMBlock一份提升为全局一份</strong></li><li><strong>SelfAttention之后的前馈网络有不同</strong>。ChatGLM用GELU（GaussianError LinearUnit）做激活；ChatGLM用Swish-1做激活。而且ChatGLM2、3应该是修正了之前的一个bug，因为GLU（GatedLinearUnit）本质上一半的入参是用来做门控制的，不需要输出到下层，所以ChatGLM2、3看起来前后维度不一致（27392-&gt;13696)反而是正确的。</li></ol><h1 id="bert">3.BERT</h1><h2 id="bert用字粒度和词粒度的优缺点有哪些">3.1BERT用字粒度和词粒度的优缺点有哪些？</h2><p>BERT可以使用字粒度（character-level）和词粒度（word-level）两种方式来进行文本表示，它们各自有优缺点：</p><p>字粒度（Character-level）：</p><ul><li><strong>优点</strong>：处理未登录词（Out-of-Vocabulary，OOV）：字粒度可以处理任意字符串，包括未登录词，不需要像词粒度那样遇到未登录词就忽略或使用特殊标记。对于少见词和低频词，字粒度可以学习更丰富的字符级别表示，使得模型能够更好地捕捉词汇的细粒度信息。</li><li><strong>缺点</strong>：计算复杂度高：使用字粒度会导致输入序列的长度大大增加，进而增加模型的计算复杂度和内存消耗。需要更多的训练数据：字粒度模型对于少见词和低频词需要更多的训练数据来学习有效的字符级别表示，否则可能会导致过拟合。</li></ul><p>词粒度（Word-level）：</p><ul><li><strong>优点</strong>：计算效率高：使用词粒度可以大大减少输入序列的长度，从而降低模型的计算复杂度和内存消耗。学习到更加稳定的词级别表示：词粒度模型可以学习到更加稳定的词级别表示，特别是对于高频词和常见词，有更好的表示能力。</li><li><strong>缺点</strong>：处理未登录词（OOV）：词粒度模型无法处理未登录词，遇到未登录词时需要采用特殊处理（如使用未登录词的特殊标记或直接忽略）。对于多音字等形态复杂的词汇，可能无法准确捕捉其细粒度的信息。</li></ul><h2 id="bert的encoder与decoder掩码有什么区别"><strong>3.2BERT的Encoder与Decoder掩码有什么区别？</strong></h2><p>Encoder主要使用自注意力掩码和填充掩码，而Decoder除了自注意力掩码外，还需要使用编码器-解码器注意力掩码来避免未来位置信息的泄露。这些掩码操作保证了Transformer在处理自然语言序列时能够准确、有效地进行计算，从而获得更好的表现。</p><h2 id="bert用的是transformer里面的encoder还是decoder">3.3BERT用的是transformer里面的encoder还是decoder？</h2><p>BERT使用的是Transformer中的<strong>Encoder部分</strong>，而不是Decoder部分。</p><p>Transformer模型由Encoder和Decoder两个部分组成。Encoder用于将输入序列编码为一系列高级表示，而Decoder用于基于这些表示生成输出序列。</p><p>在BERT模型中，只使用了Transformer的Encoder部分，并且对其进行了一些修改和自定义的预训练任务，而没有使用Transformer的Decoder部分。</p><h2 id="为什么bert选择mask掉15这个比例的词可以是其他的比例吗">3.4为什么BERT选择mask掉15%这个比例的词，可以是其他的比例吗？</h2><p>BERT选择mask掉15%的词是一种经验性的选择，是原论文中的一种选择，并没有一个固定的理论依据，实际中当然可以尝试不同的比例，15%的比例是由BERT的作者在原始论文中提出，并在实验中发现对于BERT的训练效果是有效的</p><h2 id="为什么bert在第一句前会加一个cls-标志"><strong>3.5为什么BERT在第一句前会加一个[CLS] 标志?</strong></h2><p>BERT在第一句前会加一个 [CLS]标志，<strong>最后一层该位对应向量可以作为整句话的语义表示，从而用于下游的分类任务等</strong>。为什么选它？因为与文本中已有的其它词相比，这个无明显语义信息的符号会更“公平”地融合文本中各个词的语义信息，从而更好的表示整句话的语义。</p><p>具体来说，self-attention是用文本中的其它词来增强目标词的语义表示，但是目标词本身的语义还是会占主要部分的，因此，经过BERT的12层，每次词的embedding融合了所有词的信息，可以去更好的表示自己的语义。而[CLS]位本身没有语义，经过12层，得到的是attention后所有词的加权平均，相比其他正常词，可以更好的表征句子语义。</p><h2 id="bert非线性的来源在哪里">3.6 BERT非线性的来源在哪里？</h2><p>主要来自两个地方：<strong>前馈层的gelu激活函数</strong>和<strong>self-attention</strong>。</p><p><strong>前馈神经网络层</strong>：在BERT的Encoder中，每个自注意力层之后都跟着一个前馈神经网络层。前馈神经网络层是全连接的神经网络，通常包括一个线性变换和一个非线性的激活函数，如gelu。这样的非线性激活函数引入了非线性变换，使得模型能够学习更加复杂的特征表示。</p><p><strong>self-attentionlayer</strong>：在自注意力层中，查询（Query）、键（Key）、值（Value）之间的点积得分会经过softmax操作，形成注意力权重，然后将这些权重与值向量相乘得到每个位置的自注意输出。这个过程中涉及了softmax操作，使得模型的计算是非线性的。</p><h2id="bert训练时使用的学习率-warm-up-策略是怎样的为什么要这么做"><strong>3.7BERT训练时使用的学习率 warm-up策略是怎样的？为什么要这么做？</strong></h2><p>在BERT的训练中，使用了学习率warm-up策略，这是<strong>为了在训练的早期阶段增加学习率，以提高训练的稳定性和加快模型收敛</strong>。</p><p>学习率warm-up策略的具体做法是，在训练开始的若干个步骤（通常是一小部分训练数据的迭代次数）内，<strong>将学习率逐渐从一个较小的初始值增加到预定的最大学习率</strong>。在这个过程中，学习率的变化是线性的，即学习率在warm-up阶段的每个步骤按固定的步幅逐渐增加。学习率warm-up的目的是为了解决BERT在训练初期的两个问题：</p><ul><li><strong>不稳定性</strong>：在训练初期，由于模型参数的随机初始化以及模型的复杂性，模型可能处于一个较不稳定的状态。此时使用较大的学习率可能导致模型的参数变动太大，使得模型很难收敛，学习率warm-up可以在这个阶段将学习率保持较小，提高模型训练的稳定性。</li><li><strong>避免过拟合</strong>：BERT模型往往需要较长的训练时间来获得高质量的表示。如果在训练的早期阶段就使用较大的学习率，可能会导致模型在训练初期就过度拟合训练数据，降低模型的泛化能力。通过学习率warm-up，在训练初期使用较小的学习率，可以避免过度拟合，等模型逐渐稳定后再使用较大的学习率进行更快的收敛。</li></ul><h2 id="在bert应用中如何解决长文本问题"><strong>3.8在BERT应用中，如何解决长文本问题？</strong></h2><p>在BERT应用中，处理长文本问题有以下几种常见的解决方案：</p><ul><li><strong>截断与填充</strong>：将长文本截断为固定长度或者进行填充。BERT模型的输入是一个固定长度的序列，因此当输入的文本长度超过模型的最大输入长度时，需要进行截断或者填充。通常，可以根据任务的要求，选择适当的最大长度，并对文本进行截断或者填充，使其满足模型输入的要求。</li><li><strong>SlidingWindow</strong>：将长文本分成多个短文本，然后分别输入BERT模型。这种方法被称为SlidingWindow技术。具体来说，将长文本按照固定的步长切分成多个片段，然后分别输入BERT模型进行处理。每个片段的输出可以进行进一步的汇总或者融合，得到最终的表示。</li><li><strong>HierarchicalModel</strong>：使用分层模型来处理长文本，其中底层模型用于处理短文本片段，然后将不同片段的表示进行汇总或者融合得到整个长文本的表示。这样的分层模型可以充分利用BERT模型的表示能力，同时处理长文本。</li><li><strong>Longformer、BigBird等模型</strong>：使用专门针对长文本的模型，如Longformer和BigBird。这些模型采用了不同的注意力机制，以处理超长序列，并且通常在处理长文本时具有更高的效率。</li><li><strong>Document-LevelModel</strong>：将文本看作是一个整体，而不是将其拆分成句子或段落，然后输入BERT模型进行处理。这样的文档级模型可以更好地捕捉整个文档的上下文信息，但需要更多的计算资源。</li></ul>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>大语言模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【深度学习】DeepL｜LLM基础知识</title>
    <link href="/2024/03/05/dl_llm_basic/"/>
    <url>/2024/03/05/dl_llm_basic/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>这里将分享深度学习和大语言模型的基础知识和内容</p><h1 id="深度学习基础">深度学习基础</h1><h2 id="训练细节">训练细节</h2><h3 id="逻辑回归和线性回归">1.<strong>逻辑回归和线性回归</strong></h3><p><strong>线性回归解决的是回归问题，逻辑回归相当于是线性回归的基础上，来解决分类问题</strong>。</p>线性回归(Linear Regression) <span class="math display">\[\begin{aligned}&amp;f_{w, b}(x)=\sum_i w_i x_i+b\\\end{aligned}\]</span> 逻辑回归(Logistic Regression) $$<span class="math display">\[\begin{aligned}&amp;f_{w, b}(x)=\sigma\left(\sum_i w_i x_i+b\right)\end{aligned}\]</span><p>$$ 逻辑回归可以理解为在线性回归后加了一个 <code>sigmoid</code>函数。将线性回归变成一个<code>0~1</code>输出的分类问题。逻辑回归本质上是一个线性回归模型，因为除去<code>sigmoid</code>映射函数关系，其他的步骤，算法都是线性回归的。可以说，逻辑回归都是以线性回归为理论支持的，只不过逻辑回归可以轻松解决<code>0/1</code> 分类问题。</p><h3 id="深度学习模型的参数范围">2. 深度学习模型的参数范围</h3><p>因为参数越小代表模型越简单，越是复杂的模型，越是尝试对所有样本进行拟合，包括异常点。这就会造成在较小的区间中产生较大的波动，这个较大的波动也会反映在这个区间的导数比较大。只有越大的参数才可能产生较大的导数。因此参数越小，模型就越简单。</p><h3 id="实现参数稀疏">3. 实现参数稀疏</h3><p>参数的稀疏，在一定程度上实现了特征的选择。一般而言，大部分特征对模型是没有贡献的。这些没有用的特征虽然可以减少训练集上的误差，但是对测试集的样本，反而会产生干扰。稀疏参数的引入，可以将那些无用的特征的权重置为0</p><h3 id="batch-size的大小对学习率的影响">4. Batchsize的大小对学习率的影响</h3><ul><li>batch-size大，学习率也可以取得大一点，而且，batch-size大通常更新次数少，所以需要更多的epoch才能让loss收敛。</li><li>batch-size小，学习率应该取得小一点，取的大会发生nan（梯度爆炸了），batch-size小通常更新次数多，较少的epoch就课可以让loss收敛，但是缺点是训练过程慢。</li></ul><p>为什么batch-size小，学习率取的大会发生nan？学习率较高的情况下，直接影响到每次更新值的程度比较大，走的步伐因此也会大起来。过大的学习率会导致无法顺利地到达最低点，稍有不慎就会跳出可控制区域，此时我们将要面对的就是损失成倍增大(跨量级)</p><h3 id="优化器于损失函数">5. 优化器于损失函数</h3><p>优化器<code>optimizer</code>和损失函数<code>loss function</code>的区别：</p><ol type="1"><li>优化器定义了哪些参数是要用来更新的，并且设置了更新的方式（学习率、动量、SGD等），还有一些权重衰减的设置。</li><li>损失函数是用来计算损失的，也可以说损失函数是负责反向传播求导用的</li></ol><h3 id="训练中loss快速增大">6. 训练中loss快速增大</h3><p>训练过程中发现loss快速增大应该从哪些方面考虑?</p><ol type="1"><li>学习率过大，导致学习的过程非常不平稳导致的损失值快速增大</li><li>训练的样本中存在坏数据，造成了数据的污染</li></ol><h3 id="梯度消失和梯度爆炸">7. 梯度消失和梯度爆炸</h3><p><strong>梯度消失的原因和解决</strong></p><ol type="1"><li><p>隐藏层的层数过多</p><p>反向传播求梯度时的链式求导法则，某部分梯度小于1，则多层连乘后出现梯度消失</p></li><li><p>采用了不合适的激活函数</p><p>如sigmoid函数的最大梯度为1/4，这意味着隐藏层每一层的梯度均小于1（权值小于1时），出现梯度消失</p></li><li><p>解决方法：1、relu激活函数，使导数衡为1 2、batch norm3、残差结构</p></li></ol><p><strong>梯度爆炸的原因和解决办法</strong></p><ol type="1"><li>隐藏层的层数过多，某部分梯度大于1，则多层连乘后，梯度呈指数增长，产生梯度爆炸。</li><li>权重初始值太大，求导时会乘上权重</li><li>解决方法：1、梯度裁剪 2、权重L1/L2正则化 3、残差结构 4、batchnorm</li></ol><h3 id="如何取消张量梯度">8. 如何取消张量梯度</h3><p>可以选择使用torch.no_grad来将某个张量的值取消计算梯度，<strong>model.evalvs和torch.no_grad区别</strong>：</p><ul><li>model.eval():依然计算梯度，但是不反传；dropout层保留概率为1；batchnorm层使用全局的mean和var</li><li>with torch.no_grad: 不计算梯度</li></ul><h3 id="dropout和batchnorm">9.Dropout和BatchNorm</h3><p><strong>Dropout和Batch norm能否一起使用？</strong></p><p>可以，但是只能将Dropout放在Batchnorm之后使用。因为Dropout训练时会改变输入X的方差，从而影响Batchnorm训练过程中统计的滑动方差值；而测试时没有Dropout，输入X的方差和训练时不一致，这就导致Batchnorm测试时期望的方差和训练时统计的有偏差。</p><h2 id="其余参考">其余参考</h2><p>神经网络权重初始化 <ahref="https://blog.csdn.net/kebu12345678/article/details/103084851">https://blog.csdn.net/kebu12345678/article/details/103084851</a></p><p><ahref="https://zhuanlan.zhihu.com/p/667048896">https://zhuanlan.zhihu.com/p/667048896</a></p><p><ahref="https://zhuanlan.zhihu.com/p/643560888">https://zhuanlan.zhihu.com/p/643560888</a></p><p>https://zhuanlan.zhihu.com/p/599016986</p><ul><li><p>L1L2范数 <ahref="https://blog.csdn.net/weixin_35849560/article/details/113395018">https://blog.csdn.net/weixin_35849560/article/details/113395018</a></p></li><li><p>L2范数<ahref="https://blog.csdn.net/u010725283/article/details/79212762">https://blog.csdn.net/u010725283/article/details/79212762</a></p></li></ul><h1 id="llm基础">LLM基础</h1><h1 id="attention">1.Attention</h1><h2 id="讲讲对attention的理解"><strong>1.1讲讲对Attention的理解</strong></h2><p>Attention机制是一种在处理时序相关问题的时候常用的技术，主要用于处理序列数据。</p><p>核心思想是在处理序列数据时，网络应该更关注输入中的重要部分，而忽略不重要的部分，它通过学习不同部分的权重，将输入的序列中的重要部分显式地加权，从而使得模型可以更好地关注与输出有关的信息。</p><p>在序列建模任务中，比如机器翻译、文本摘要、语言理解等，输入序列的不同部分可能具有不同的重要性。传统的循环神经网络（RNN）或卷积神经网络（CNN）在处理整个序列时，难以捕捉到序列中不同位置的重要程度，可能导致信息传递不够高效，特别是在处理长序列时表现更明显。</p><p>Attention机制的关键是引入一种机制来动态地计算输入序列中各个位置的权重，从而在每个时间步上，对输入序列的不同部分进行加权求和，得到当前时间步的输出。这样就实现了模型对输入中不同部分的关注度的自适应调整。</p><h2 id="attention的计算步骤"><strong>1.2Attention的计算步骤</strong></h2><p>具体的计算步骤如下：</p><ul><li><strong>计算查询（Query）</strong>：查询是当前时间步的输入，用于和序列中其他位置的信息进行比较。</li><li><strong>计算键（Key）和值（Value）</strong>：键表示序列中其他位置的信息，值是对应位置的表示。键和值用来和查询进行比较。</li><li><strong>计算注意力权重</strong>：通过将查询和键进行内积运算，然后应用softmax函数，得到注意力权重。这些权重表示了在当前时间步，模型应该关注序列中其他位置的重要程度。</li><li><strong>加权求和</strong>：根据注意力权重将值进行加权求和，得到当前时间步的输出。</li></ul><p>在Transformer中，Self-Attention 被称为"Scaled Dot-ProductAttention"，其计算过程如下：</p><ol type="1"><li>对于输入序列中的每个位置，通过计算其与所有其他位置之间的相似度得分（通常通过点积计算）。</li><li>对得分进行缩放处理，以防止梯度爆炸。</li><li>将得分用softmax函数转换为注意力权重，以便计算每个位置的加权和。</li><li>使用注意力权重对输入序列中的所有位置进行加权求和，得到每个位置的自注意输出。</li></ol><p><span class="math display">\[Attention(Q,K,V)=softmax(\frac{QK^T}{\sqrt{d_k}})V\]</span></p><h2 id="attention机制和传统的seq2seq模型的区别"><strong>1.3Attention机制和传统的Seq2Seq模型的区别</strong></h2><p>Seq2Seq模型是一种基于编码器-解码器结构的模型，主要用于处理序列到序列的任务，例如机器翻译、语音识别等。</p><p>传统的Seq2Seq模型只使用编码器来捕捉输入序列的信息，而解码器只从编码器的最后状态中获取信息，并将其用于生成输出序列。</p><p>而Attention机制则允许解码器在生成每个输出时，根据输入序列的不同部分给予不同的注意力，从而使得模型更好地关注到输入序列中的重要信息。</p><h2 id="self-attention-和-target-attention的区别"><strong>1.4self-attention 和 target-attention的区别</strong></h2><p>self-attention是指在序列数据中，<strong>将当前位置与其他位置之间的关系建模</strong>。它通过计算每个位置与其他所有位置之间的相关性得分，从而为每个位置分配一个权重。这使得模型能够根据输入序列的不同部分的重要性，自适应地选择要关注的信息。</p><p>target-attention则是指将<strong>注意力机制应用于目标（或查询）和一组相关对象之间的关系</strong>。它用于将目标与其他相关对象进行比较，并将注意力分配给与目标最相关的对象。这种类型的注意力通常用于任务如机器翻译中的编码-解码模型，其中需要将源语言的信息对齐到目标语言。</p><p>因此，<strong>自注意力主要关注序列内部的关系，而目标注意力则关注目标与其他对象之间的关系</strong>。这两种注意力机制在不同的上下文中起着重要的作用，帮助模型有效地处理序列数据和相关任务。</p><h2 id="在常规attention中一般有kv那self-attention-可以吗"><strong>1.5在常规attention中，一般有k=v，那self-attention 可以吗</strong></h2><p>self-attention实际只是attention中的一种特殊情况，因此k=v是没有问题的，也即K，V参数矩阵相同。实际上，在Transformer模型中，Self-Attention的典型实现就是k等于v的情况。Transformer中的Self-Attention被称为"ScaledDot-ProductAttention"，其中通过将词向量进行线性变换来得到Q、K、V，并且这三者是相等的。</p><h2 id="目前主流的attention方法有哪些"><strong>1.6目前主流的attention方法有哪些？</strong></h2><p>讲自己熟悉的就可：</p><ul><li><strong>Scaled Dot-Product Attention</strong>:这是Transformer模型中最常用的Attention机制，用于计算查询向量（Q）与键向量（K）之间的相似度得分，然后使用注意力权重对值向量（V）进行加权求和。</li><li><strong>Multi-Head Attention</strong>:这是Transformer中的一个改进，通过同时使用多组独立的注意力头（多个QKV三元组），并在输出时将它们拼接在一起。这样的做法允许模型在<strong>不同的表示空间</strong>上学习不同类型的注意力模式。</li><li><strong>Relative Positional Encoding</strong>:传统的Self-Attention机制在处理序列时并未直接考虑位置信息，而相对位置编码引入了位置信息，使得模型能够更好地处理序列中不同位置之间的关系。</li><li><strong>Transformer-XL</strong>:一种改进的Transformer模型，通过使用循环机制来扩展Self-Attention的上下文窗口，从而处理更长的序列依赖性。</li></ul><h2 id="self-attention-在计算的过程中如何对padding位做mask"><strong>1.7self-attention 在计算的过程中，如何对padding位做mask？</strong></h2><p>在 Attention 机制中，同样需要忽略 padding部分的影响，这里以transformerencoder中的self-attention为例：self-attention中，Q和K在点积之后，需要先经过mask再进行softmax，因此，<strong>对于要屏蔽的部分，mask之后的输出需要为负无穷</strong>，这样softmax之后输出才为0。</p><h2 id="深度学习中attention与全连接层的区别何在"><strong>1.8深度学习中attention与全连接层的区别何在？</strong></h2><p>这是个非常有意思的问题，要回答这个问题，我们必须重新定义一下Attention。</p><p>TransformerPaper里重新用QKV定义了Attention。所谓的QKV就是Query，Key，Value。如果我们用这个机制来研究传统的RNNattention，就会发现这个过程其实是这样的：RNN最后一步的output是Q，这个Qquery了每一个中间步骤的K。Q和K共同产生了Attention Score，最后AttentionScore乘以V加权求和得到context。那如果我们不用Attention，单纯用全连接层呢？很简单，全链接层可没有什么Query和Key的概念，只有一个Value，也就是说给每个V加一个权重再加到一起（如果是SelfAttention，加权这个过程都免了，因为V就直接是从rawinput加权得到的。）</p><p><strong>可见Attention和全连接最大的区别就是Query和Key</strong>，而这两者也恰好产生了AttentionScore这个Attention中最核心的机制。<strong>而在Query和Key中，我认为Query又相对更重要，因为Query是一个锚点，AttentionScore便是从过计算与这个锚点的距离算出来的</strong>。任何Attention basedalgorithm里都会有Query这个概念，但全连接显然没有。</p><p>最后来一个比较形象的比喻吧。如果一个神经网络的任务是从一堆白色小球中找到一个略微发灰的，那么全连接就是在里面随便乱抓然后凭记忆和感觉找，而attention则是左手拿一个白色小球，右手从袋子里一个一个抓出来，两两对比颜色，你左手抓的那个白色小球就是Query。</p><h2 id="mha">1.9 MHA</h2><p>从多头注意力的结构图中，貌似这个所谓的<strong>多个头就是指多组线性变换层</strong>，其实并不是，只有使用了一组线性变化层，即三个变换张量对Q，K，V分别进行线性变换，<strong>这些变换不会改变原有张量的尺寸</strong>，因此每个变换矩阵都是方阵，得到输出结果后，多头的作用才开始显现，每个头开始从词义层面分割输出的张量，也就是每个头都想获得一组Q，K，V进行注意力机制的计算，但是句子中的每个词的表示只获得一部分，也就是只分割了最后一维的词嵌入向量。这就是所谓的多头，将每个头的获得的输入送到注意力机制中,就形成多头注意力机制.</p><p>Multi-headattention允许模型<strong>共同关注来自不同位置的不同表示子空间的信息</strong>，如果只有一个attentionhead，它的平均值会削弱这个信息。</p><p><span class="math display">\[MultiHead(Q,K,V)=Concat(head_1,...,head_h)W^O \\where ~ head_i = Attention(QW_i^Q, KW_i^K, VW_i^V)\]</span></p><p>其中映射由权重矩阵完成：$ W^Q_i ^{d_ d_k} $, <spanclass="math inline">\(W^K_i \in \mathbb{R}^{d_{\text{model}} \timesd_k}\)</span>, <span class="math inline">\(W^V_i \in\mathbb{R}^{d_{\text{model}} \times d_v}\)</span>和<spanclass="math inline">\(W^O_i \in \mathbb{R}^{hd_v \times d_{\text{model}}}\)</span>。</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240305210401843.png"alt="MHA示意图" /><figcaption aria-hidden="true">MHA示意图</figcaption></figure><p><strong>多头注意力作用</strong></p><p>这种结构设计能<strong>让每个注意力机制去优化每个词汇的不同特征部分</strong>，从而均衡同一种注意力机制可能产生的偏差，让词义拥有来自更多元的表达，实验表明可以从而提升模型效果.</p><p><strong>为什么要做多头注意力机制呢</strong>？</p><ul><li>一个 dot product的注意力里面，没有什么可以学的参数。具体函数就是内积，为了识别不一样的模式，希望有不一样的计算相似度的办法。加性attention 有一个权重可学，也许能学到一些内容。</li><li>multi-head attention 给 h 次机会去学习不一样的投影的方法，使得在投影进去的度量空间里面能够去匹配不同模式需要的一些相似函数，然后把h 个 heads 拼接起来，最后再做一次投影。</li><li>每一个头 hi 是把 Q,K,V 通过 可以学习的 Wq, Wk, Wv 投影到 dv上，再通过注意力函数，得到 headi。</li></ul><h2 id="mqa">1.10 MQA</h2><p>MQA（Multi Query Attention）最早是出现在2019年谷歌的一篇论文 《FastTransformer Decoding: One Write-Head is All You Need》。</p><p>MQA的思想其实比较简单，MQA 与 MHA 不同的是，<strong>MQA让所有的头之间共享同一份 Key 和 Value 矩阵，每个头正常的只单独保留了一份Query 参数，从而大大减少 Key 和 Value 矩阵的参数量</strong>。</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240305210627099.png" alt="MQA示意图" style="zoom:50%;" /></p><p>在 Multi-Query Attention方法中只会保留一个单独的key-value头，这样<strong>虽然可以提升推理的速度，但是会带来精度上的损失</strong>。《Multi-HeadAttention:Collaborate Instead of Concatenate》这篇论文的第一个思路是<strong>基于多个 MQA 的 checkpoint 进行finetuning，来得到了一个质量更高的 MQA 模型</strong>。这个过程也被称为Uptraining。</p><p>具体分为两步：</p><ol type="1"><li>对多个 MQA 的 checkpoint 文件进行融合，融合的方法是: 通过对 key 和value 的 head 头进行 mean pooling 操作，如下图。</li><li>对融合后的模型使用少量数据进行 finetune训练，重训后的模型大小跟之前一样，但是效果会更好</li></ol><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240305210748093.png" alt="多个MQA的finetune" style="zoom: 50%;" /></p><h2 id="gqa">1.11 GQA</h2><p>Google 在 2023 年发表的一篇 <ahref="https://arxiv.org/pdf/2305.13245.pdf"title="《GQA: Training Generalized Multi-Query Transformer Models from Multi-Head Checkpoints》">《GQA:Training Generalized Multi-Query Transformer Models from Multi-HeadCheckpoints》</a>的论文</p><p>如下图所示</p><ul><li>在 <strong>MHA（Multi Head Attention）</strong>中，每个头有自己单独的 key-value 对；</li><li>在 <strong>MQA（Multi Query Attention）</strong> 中只会有一组key-value 对；</li><li>在 <strong>GQA（Grouped Query Attention）</strong> 中，会对attention 进行分组操作，query 被分为 N 组，每个组共享一个 Key 和 Value矩阵。</li></ul><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240305210859405.png"alt="MHA,MQA,GQA对比" /><figcaption aria-hidden="true">MHA,MQA,GQA对比</figcaption></figure><p>GQA-N 是指具有 N 组的 Grouped QueryAttention。GQA-1具有单个组，因此具有单个Key 和Value，等效于MQA。而GQA-H具有与头数相等的组，等效于MHA。</p><p>在基于 Multi-head 多头结构变为 Grouped-query分组结构的时候，也是采用跟上图一样的方法，对每一组的 key-value 对进行mean pool 的操作进行参数融合。<strong>融合后的模型能力更综合，精度比Multi-query 好，同时速度比 Multi-head 快</strong>。</p><h2 id="mhamqagqa对比总结">1.12 MHA&amp;MQA&amp;GQA对比总结</h2><p>MHA（Multi-head Attention）是标准的多头注意力机制，h个Query、Key 和Value 矩阵。</p><p>MQA（Multi-QueryAttention）是多查询注意力的一种变体，也是用于自回归解码的一种注意力机制。与MHA不同的是，<strong>MQA让所有的头之间共享同一份 Key 和 Value 矩阵，每个头只单独保留了一份 Query参数，从而大大减少 Key 和 Value 矩阵的参数量</strong>。</p><p>GQA（Grouped-QueryAttention）是分组查询注意力，<strong>GQA将查询头分成G组，每个组共享一个Key和 Value 矩阵</strong>。GQA-G是指具有G组的grouped-queryattention。GQA-1具有单个组，因此具有单个Key 和Value，等效于MQA。而GQA-H具有与头数相等的组，等效于MHA。</p><p>GQA介于MHA和MQA之间。GQA 综合 MHA 和 MQA ，既不损失太多性能，又能利用MQA 的推理加速。不是所有 Q 头共享一组 KV，而是分组一定头数 Q 共享一组KV，比如上图中就是两组 Q 共享一组 KV。</p><h1 id="transformer">2.Transformer</h1><h2id="transformer中multi-head-attention中每个head为什么要进行降维"><strong>2.1transformer中multi-headattention中每个head为什么要进行降维？</strong></h2><p>在Transformer的Multi-HeadAttention中，对每个head进行降维是<strong>为了增加模型的表达能力和效率。</strong></p><p>每个head是独立的注意力机制，它们可以学习不同类型的特征和关系。通过使用多个注意力头，Transformer可以并行地学习多种不同的特征表示，从而增强了模型的表示能力。</p><p>然而，在使用多个注意力头的同时，注意力机制的计算复杂度也会增加。原始的ScaledDot-Product Attention的计算复杂度为<spanclass="math inline">\(O(d^2)\)</span>，其中d是输入向量的维度。如果使用h个注意力头，计算复杂度将增加到<spanclass="math inline">\(O(hd^2)\)</span>。这可能会导致Transformer在处理大规模输入时变得非常耗时。</p><p>为了缓解计算复杂度的问题，Transformer中在每个head上进行降维。在每个注意力头中，输入向量通过线性变换被映射到一个较低维度的空间。这个降维过程使用两个矩阵：一个是查询（Q）和键（K）的降维矩阵<spanclass="math inline">\(W_q\)</span>和<spanclass="math inline">\(W_k\)</span>，另一个是值（V）的降维矩阵<spanclass="math inline">\(W_v\)</span>。</p><p>通过降低每个head的维度，Transformer可以在<strong>保持较高的表达能力的同时，大大减少计算复杂度</strong>。降维后的计算复杂度为<spanclass="math inline">\((h\hat d ^ 2)\)</span>，其中<spanclass="math inline">\(\hat d\)</span>是降维后的维度。通常情况下，<spanclass="math inline">\(\hatd\)</span>会远小于原始维度d，这样就可以显著提高模型的计算效率。</p><h2 id="transformer在哪里做了权重共享为什么可以做权重共享"><strong>2.2transformer在哪里做了权重共享，为什么可以做权重共享？</strong></h2><p>Transformer在Encoder和Decoder中都进行了权重共享。</p><p>在Transformer中，Encoder和Decoder是由多层的Self-AttentionLayer和前馈神经网络层交叉堆叠而成。<strong>权重共享是指在这些堆叠的层中，相同位置的层共用相同的参数</strong>。</p><p>在Encoder中，所有的自注意力层和前馈神经网络层都共享相同的参数。这意味着每一层的自注意力机制和前馈神经网络都使用相同的权重矩阵来进行计算。这种共享保证了每一层都执行相同的计算过程，使得模型能够更好地捕捉输入序列的不同位置之间的关联性。</p><p>在Decoder中，除了和Encoder相同的权重共享方式外，还存在另一种特殊的权重共享：<strong>Decoder的自注意力层和Encoder的自注意力层之间也进行了共享</strong>。这种共享方式被称为"maskedself-attention"，因为在解码过程中，当前位置的注意力不能关注到未来的位置（后续位置），以避免信息泄漏。通过这种共享方式，Decoder可以利用Encoder的表示来理解输入序列并生成输出序列。权重共享的好处是大大减少了模型的参数数量，使得Transformer可以更有效地训练，并且更容易进行推理。此外，共享参数还有助于加快训练速度和提高模型的泛化能力，因为模型可以在不同位置共享并学习通用的特征表示。</p><h2 id="transformer的点积模型做缩放的原因是什么">2.3Transformer的点积模型做缩放的原因是什么？</h2><p>使用缩放的原因是为了控制注意力权重的尺度，以避免在计算过程中出现梯度爆炸的问题。</p><p>Attention的计算是在内积之后进行softmax，主要涉及的运算是<spanclass="math inline">\(e^{q \cdotk}\)</span>，可以大致认为内积之后、softmax之前的数值在<spanclass="math inline">\(-3\sqrt{d}\)</span>到<spanclass="math inline">\(3\sqrt{d}\)</span>这个范围内，由于d通常都至少是64，所以<spanclass="math inline">\(e^{3\sqrt{d}}\)</span>比较大而 <spanclass="math inline">\(e^{-3\sqrt{d}}\)</span>比较小，因此经过softmax之后，Attention的分布非常接近一个onehot分布了，这带来严重的梯度消失问题，导致训练效果差。（例如y=softmax(x)在|x|较大时进入了饱和区，x继续变化y值也几乎不变，即饱和区梯度消失）</p><p>相应地，解决方法就有两个:</p><ol type="1"><li>像NTK参数化那样，在内积之后除以 <spanclass="math inline">\(\sqrt{d}\)</span>，使q⋅k的方差变为1，对应<spanclass="math inline">\(e^3,e^{−3}\)</span>都不至于过大过小，这样softmax之后也不至于变成onehot而梯度消失了，这也是常规的Transformer如BERT里边的SelfAttention的做法</li><li>另外就是不除以 <spanclass="math inline">\(\sqrt{d}\)</span>，但是初始化q,k的全连接层的时候，其初始化方差要多除以一个d，这同样能使得使q⋅k的初始方差变为1，T5采用了这样的做法。</li></ol><h2 id="transformer和rnn对比">2.4 Transformer和RNN对比</h2><p>最简单情况：没有残差连接、没有 layernorm、 attention单头、没有投影。看和 RNN 区别</p><ul><li>attention 对输入做一个加权和，加权和 进入 point-wiseMLP。（画了多个红色方块 MLP， 是一个权重相同的 MLP）</li><li>point-wise MLP 对 每个输入的点 做计算，得到输出。</li><li>attention 作用：把整个序列里面的信息抓取出来，做一次汇聚aggregation</li></ul><p>RNN 跟 transformer <strong>异：如何传递序列的信</strong>息</p><p>RNN 是把上一个时刻的信息输出传入下一个时候做输入。Transformer通过一个 attention 层，去全局的拿到整个序列里面信息，再用 MLP做语义的转换。</p><p>RNN 跟 transformer <strong>同：语义空间的转换 + 关注点</strong></p><p>用一个线性层 or 一个 MLP 来做语义空间的转换。</p><p><strong>关注点</strong>：怎么有效的去使用序列的信息。</p><h2 id="transformer结构细节">2.5 Transformer结构细节</h2><p><strong>Transformer为何使用多头注意力机制？</strong>（为什么不使用一个头）</p><ul><li>多头保证了transformer可以注意到不同子空间的信息，捕捉到更加丰富的特征信息。可以类比CNN中同时使用<strong>多个滤波器</strong>的作用，直观上讲，多头的注意力<strong>有助于网络捕捉到更丰富的特征/信息。</strong></li></ul><p><strong>Transformer为什么Q和K使用不同的权重矩阵生成，为何不能使用同一个值进行自身的点乘？</strong>（注意和第一个问题的区别）</p><ul><li>使用Q/K/V不相同可以保证在不同空间进行投影，增强了表达能力，提高了泛化能力。</li><li>同时，由softmax函数的性质决定，实质做的是一个soft版本的argmax操作，得到的向量接近一个one-hot向量（接近程度根据这组数的数量级有所不同）。如果令Q=K，那么得到的模型大概率会得到一个类似单位矩阵的attention矩阵，<strong>这样self-attention就退化成一个point-wise线性映射</strong>。这样至少是违反了设计的初衷。</li></ul><p><strong>Transformer计算attention的时候为何选择点乘而不是加法？两者计算复杂度和效果上有什么区别？</strong></p><ul><li>K和Q的点乘是为了得到一个attention score矩阵，用来对V进行提纯。K和Q使用了不同的W_k,W_Q来计算，可以理解为是在不同空间上的投影。正因为有了这种不同空间的投影，增加了表达能力，这样计算得到的attentionscore矩阵的泛化能力更高。</li><li>为了计算更快。矩阵加法在加法这一块的计算量确实简单，但是作为一个整体计算attention的时候相当于一个隐层，整体计算量和点积相似。在效果上来说，从实验分析，两者的效果和dk相关，dk越大，加法的效果越显著。</li></ul><p><strong>为什么在进行softmax之前需要对attention进行scaled（为什么除以dk的平方根）</strong>，并使用公式推导进行讲解</p><ul><li>这取决于softmax函数的特性，如果softmax内计算的数数量级太大，会输出近似one-hot编码的形式，导致梯度消失的问题，所以需要scale</li><li>那么至于为什么需要用维度开根号，假设向量q，k满足各分量独立同分布，均值为0，方差为1，那么qk点积均值为0，方差为dk，从统计学计算，若果让qk点积的方差控制在1，需要将其除以dk的平方根，是的softmax更加平滑</li></ul><p><strong>在计算attentionscore的时候如何对padding做mask操作？</strong></p><ul><li>padding位置置为负无穷(一般来说-1000就可以)，再对attentionscore进行相加。对于这一点，涉及到batch_size之类的，具体的大家可以看一下实现的源代码，位置在这里：<ahref="https://link.zhihu.com/?target=https://github.com/huggingface/transformers/blob/aa6a29bc25b663e1311c5c4fb96b004cf8a6d2b6/src/transformers/modeling_bert.py#L720"title="https://github.com/huggingface/transformers/blob/aa6a29bc25b663e1311c5c4fb96b004cf8a6d2b6/src/transformers/modeling_bert.py#L720">https://github.com/huggingface/transformers/blob/aa6a29bc25b663e1311c5c4fb96b004cf8a6d2b6/src/transformers/modeling_bert.py#L720</a></li><li>padding位置置为负无穷而不是0，是因为后续在softmax时，<spanclass="math inline">\(e^0=1\)</span>，不是0，计算会出现错误；而<spanclass="math inline">\(e^{-\infty} = 0\)</span>，所以取负无穷</li></ul><p><strong>为何在获取输入词向量之后需要对矩阵乘以embeddingsize的开方？意义是什么？</strong></p><ul><li>embeddingmatrix的初始化方式是<code>xavier init</code>，这种方式的方差是1/embeddingsize，因此乘以embedding size的开方使得embeddingmatrix的方差是1，在这个scale下可能更有利于embedding matrix的收敛。</li></ul><p><strong>简单介绍一下Transformer的位置编码？有什么意义和优缺点？</strong></p><ul><li>因为self-attention是位置无关的，无论句子的顺序是什么样的，通过self-attention计算的token的hiddenembedding都是一样的，这显然不符合人类的思维。因此要有一个办法能够在模型中表达出一个token的位置信息，transformer使用了固定的positionalencoding来表示token在句子中的绝对位置信息。</li></ul><p><strong>你还了解哪些关于位置编码的技术，各自的优缺点是什么？</strong>（参考上一题）</p><ul><li>相对位置编码（RPE）1.在计算attention score和weightedvalue时各加入一个可训练的表示相对位置的参数。2.在生成多头注意力时，把对key来说将绝对位置转换为相对query的位置3.复数域函数，已知一个词在某个位置的词向量表示，可以计算出它在任何位置的词向量表示。前两个方法是词向量+位置编码，属于亡羊补牢，复数域是生成词向量的时候即生成对应的位置信息。</li></ul><p><strong>为什么transformer块使用LayerNorm而不是BatchNorm？LayerNorm在Transformer的位置是哪里？</strong></p><ul><li>LN：针对每个样本序列进行Norm，没有样本间的依赖。对一个序列的不同特征维度进行Norm</li><li>CV使用BN是认为channel维度的信息对cv方面有重要意义，如果对channel维度也归一化会造成不同通道信息一定的损失。而同理nlp领域认为句子长度不一致，并且各个batch的信息没什么关系，因此只考虑句子内信息的归一化，也就是LN。</li></ul><p><strong>简答讲一下BatchNorm技术，以及它的优缺点。</strong></p><ul><li>优点：<ul><li>第一个就是可以解决内部协变量偏移，简单来说训练过程中，各层分布不同，增大了学习难度，BN缓解了这个问题。当然后来也有论文证明BN有作用和这个没关系，而是可以使<strong>损失平面更加的平滑</strong>，从而加快的收敛速度。</li><li>第二个优点就是缓解了<strong>梯度饱和问题</strong>（如果使用sigmoid激活函数的话），加快收敛。</li></ul></li><li>缺点：<ul><li>第一个，batch_size较小的时候，效果差。这一点很容易理解。BN的过程，使用整个batch中样本的均值和方差来模拟全部数据的均值和方差，在batch_size较小的时候，效果肯定不好。</li><li>第二个缺点就是 BN 在RNN中效果比较差。</li></ul></li></ul><p><strong>Encoder端和Decoder端是如何进行交互的？</strong>（在这里可以问一下关于seq2seq的attention知识）</p><ul><li>Cross Self-Attention，Decoder提供Q，Encoder提供K，V</li></ul><p><strong>Decoder阶段的多头自注意力和encoder的多头自注意力有什么区别？</strong>（为什么需要decoder自注意力需要进行sequence mask)</p><ul><li>让输入序列只看到过去的信息，不能让他看到未来的信息</li></ul><p><strong>引申一个关于bert问题，bert的mask为何不学习transformer在attention处进行屏蔽score的技巧？</strong></p><ul><li>BERT和transformer的目标不一致，bert是语言的预训练模型，需要充分考虑上下文的关系，而transformer主要考虑句子中第i个元素与前i-1个元素的关系。</li></ul><h1 id="normalization">3 Normalization</h1><h2 id="batch-norm">3.1 <strong>Batch Norm</strong></h2><p><strong>为什么要进行BN呢？</strong></p><ol type="1"><li>在深度神经网络训练的过程中，通常以输入网络的每一个mini-batch进行训练，这样每个batch具有不同的分布，使模型训练起来特别困难。</li><li>Internal Covariate Shift (ICS)问题：在训练的过程中，激活函数会改变各层数据的分布，随着网络的加深，这种改变（差异）会越来越大，使模型训练起来特别困难，收敛速度很慢，会出现梯度消失的问题。</li></ol><p><strong>BN的主要思想：</strong>针对每个神经元，<strong>使数据在进入激活函数之前，沿着通道计算每个batch的均值、方差，‘强迫’数据保持均值为0，方差为1的正态分布，</strong>避免发生梯度消失。具体来说，就是把第1个样本的第1个通道，加上第2个样本第1个通道...... 加上第 N 个样本第1个通道，求平均，得到通道 1 的均值（注意是除以N×H×W 而不是单纯除以 N，最后得到的是一个代表这个 batch第1个通道平均值的数字，而不是一个 H×W 的矩阵）。求通道 1的方差也是同理。对所有通道都施加一遍这个操作，就得到了所有通道的均值和方差。</p><p><strong>BN的使用位置：</strong>全连接层或卷积操作之后，激活函数之前。</p><p><strong>BN算法过程：</strong></p><ul><li>沿着通道计算每个batch的均值</li><li>沿着通道计算每个batch的方差</li><li>做归一化</li><li>加入缩放和平移变量<span class="math inline">\(\gamma\)</span>和<span class="math inline">\(\beta\)</span></li></ul><p><strong>加入缩放和平移变量的原因是：</strong>保证每一次数据经过归一化后还保留原有学习来的特征，同时又能完成归一化操作，加速训练。这两个参数是用来学习的参数。</p><p>encoder-decoder分类<ahref="https://zhuanlan.zhihu.com/p/642923989">https://zhuanlan.zhihu.com/p/642923989</a></p><p><strong>BN的作用：</strong></p><ol type="1"><li>允许较大的学习率；</li><li>减弱对初始化的强依赖性</li><li>保持隐藏层中数值的均值、方差不变，让数值更稳定，为后面网络提供坚实的基础；</li><li>有轻微的正则化作用（相当于给隐藏层加入噪声，类似Dropout）</li></ol><p><strong>BN存在的问题：</strong></p><ol type="1"><li>每次是在一个batch上计算均值、方差，如果batchsize太小，则计算的均值、方差不足以代表整个数据分布。</li><li><strong>batch size太大：</strong>会超过内存容量；需要跑更多的epoch，导致总训练时间变长；会直接固定梯度下降的方向，导致很难更新。</li></ol><h2 id="layer-norm">3.2 Layer Norm</h2><p>LayerNorm是大模型也是transformer结构中最常用的归一化操作，简而言之，它的作用是<strong>对特征张量按照某一维度或某几个维度进行0均值，1方差的归一化</strong>操作，计算公式为：</p><p><span class="math display">\[\mathrm{y}=\frac{\mathrm{x}-\mathrm{E}(\mathrm{x})}{\sqrt{\mathrm{V}\operatorname{ar}(\mathrm{x})+\epsilon}} * \gamma+\beta\]</span></p><p>这里的 <span class="math inline">\(x\)</span> 可以理解为**张量中具体某一维度的所有元素**，比如对于 shape 为 (2,2,4) 的张量input，若指定归一化的操作为第三个维度，则会对第三个维度中的四个张量（2,2,1），各进行上述的一次计算.</p><p>详细形式：</p><p><span class="math display">\[a_{i}=\sum_{j=1}^{m} w_{i j} x_{j}, \quady_{i}=f\left(a_{i}+b_{i}\right)\]</span></p><p><span class="math display">\[\bar{a}_{i}=\frac{a_{i}-\mu}{\sigma} g_{i}, \quady_{i}=f\left(\bar{a}_{i}+b_{i}\right),\]</span></p><p><span class="math display">\[\mu=\frac{1}{n} \sum_{i=1}^{n} a_{i}, \quad \sigma=\sqrt{\frac{1}{n}\sum_{i=1}^{n}\left(a_{i}-\mu\right)^{2}}.\]</span></p><p>这里结合PyTorch的nn.LayerNorm算子来看比较明白</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">nn.LayerNorm(normalized_shape, eps=<span class="hljs-number">1e-05</span>, elementwise_affine=<span class="hljs-literal">True</span>, device=<span class="hljs-literal">None</span>, dtype=<span class="hljs-literal">None</span>)<br><br></code></pre></td></tr></table></figure><ul><li><code>normalized_shape</code>：归一化的维度，int（最后一维）list（list里面的维度），还是以（2,2,4）为例，如果输入是int，则必须是4，如果是list，则可以是[4],[2,4], [2,2,4]，即最后一维，倒数两维，和所有维度</li><li><code>eps</code>：加在分母方差上的偏置项，防止分母为0</li><li><code>elementwise_affine</code>：是否使用可学习的参数 <spanclass="math inline">\(\gamma\)</span> 和 <spanclass="math inline">\(\beta\)</span>，前者开始为1，后者为0，设置该变量为True，则二者均可学习随着训练过程而变化</li></ul><p>Layer Normalization (LN)的一个优势是不需要批训练，在单条数据内部就能归一化。LN不依赖于batchsize和输入sequence的长度，因此可以用于batchsize为1和RNN中。<strong>LN用于RNN效果比较明显，但是在CNN上，效果不如BN</strong>。</p><h2 id="instance-norm">3.3 Instance Norm</h2><p>IN针对图像像素做normalization，最初用于图像的风格化迁移。在图像风格化中，生成结果主要依赖于某个图像实例，featuremap 的各个 channel的均值和方差会影响到最终生成图像的风格。所以对整个batch归一化不适合图像风格化中，因而对H、W做归一化。可以加速模型收敛，并且保持每个图像实例之间的独立。</p><p>对于，IN 对每个样本的 H、W 维度的数据求均值和标准差，保留 N 、C维度，也就是说，它只在 channel 内部求均值和标准差，其公式如下：</p><p><span class="math display">\[y_{t i j k}=\frac{x_{t i j k}-\mu_{t i}}{\sqrt{\sigma_{ti}^{2}+\epsilon}} \quad \mu_{t i}=\frac{1}{H W} \sum_{l=1}^{W}\sum_{m=1}^{H} x_{t i l m} \quad \sigma_{t i}^{2}=\frac{1}{H W}\sum_{l=1}^{W} \sum_{m=1}^{H}\left(x_{t i l m}-m u_{t i}\right)^{2}\]</span></p><h2 id="group-norm">3.4 <strong>Group Norm</strong></h2><p><strong>GN是为了解决BN对较小的mini-batch size效果差的问题。</strong>​</p><p>GN适用于占用显存比较大的任务，例如图像分割。对这类任务，可能 batchsize 只能是个位数，再大显存就不够用了。而当 batch size 是个位数时，BN的表现很差，因为没办法通过几个样本的数据量，来近似总体的均值和标准差。GN也是独立于 batch 的，它是 LN 和 IN 的折中。</p><p><strong>具体方法：</strong> GN 计算均值和标准差时，把每一个样本feature map 的 channel 分成 G 组，每组将有 C/G 个 channel，然后将这些channel 中的元素求均值和标准差。各组 channel用其对应的归一化参数独立地归一化。 <span class="math display">\[\mu_{n g}(x)=\frac{1}{(C / G) H W} \sum_{c=g C / G}^{(g+1) C / G}\sum_{h=1}^{H} \sum_{w=1}^{W} x_{n c h w}\]</span></p><p><span class="math display">\[\sigma_{n g}(x)=\sqrt{\frac{1}{(C / G) H W} \sum_{c=g C / G}^{(g+1) C /G} \sum_{h=1}^{H} \sum_{w=1}^{W}\left(x_{n c h w}-\mu_{ng}(x)\right)^{2}+\epsilon}\]</span></p><h2 id="几类归一化区别与联系">3.5 几类归一化区别与联系</h2><p><strong>Batch Normalization（Batch Norm）</strong>：<strong>缺点</strong>：在处理序列数据（如文本）时，BatchNorm可能不会表现得很好，因为序列数据通常长度不一，并且一次训练的Batch中的句子的长度可能会有很大的差异；此外，BatchNorm对于Batch大小也非常敏感。对于较小的Batch大小，BatchNorm可能会表现得不好，因为每个Batch的统计特性可能会有较大的波动。</p><p><strong>Layer Normalization（Layer Norm）</strong>：<strong>优点</strong>：LayerNorm是对每个样本进行归一化，因此它对Batch大小不敏感，这使得它在处理序列数据时表现得更好；另外，LayerNorm在处理不同长度的序列时也更为灵活。</p><p><strong>Instance Normalization（Instance Norm）</strong>：<strong>优点</strong>：InstanceNorm是对每个样本的每个特征进行归一化，因此它可以捕捉到更多的细节信息。InstanceNorm在某些任务，如风格迁移，中表现得很好，因为在这些任务中，细节信息很重要。<strong>缺点</strong>：InstanceNorm可能会过度强调细节信息，忽视了更宏观的信息。此外，InstanceNorm的计算成本相比Batch Norm和Layer Norm更高。</p><p><strong>Group Normalization（Group Norm）</strong>：<strong>优点</strong>：Group Norm是Batch Norm和InstanceNorm的折中方案，它在Batch的一个子集（即组）上进行归一化。这使得GroupNorm既可以捕捉到Batch的统计特性，又可以捕捉到样本的细节信息。此外，GroupNorm对Batch大小也不敏感。 <strong>缺点</strong>：GroupNorm的性能取决于组的大小，需要通过实验来确定最优的组大小。此外，GroupNorm的计算成本也比Batch Norm和Layer Norm更高。</p><p>将输入的 <strong>feature map shape</strong>记为**<code>[N, C, H, W]</code>**，其中N表示batchsize，即N个样本；C表示通道数；H、W分别表示特征图的高度、宽度。这几个方法主要的区别就是在：</p><ol type="1"><li>BN是在batch上，对N、H、W做归一化，而保留通道 C的维度。<strong>BN对较小的batchsize效果不好。BN适用于固定深度的前向神经网络</strong>，如CNN，不适用于RNN；</li><li>LN在通道方向上，对C、H、W归一化，主要对RNN效果明显；</li><li>IN在图像像素上，对H、W做归一化，用在风格化迁移；</li><li>GN将channel分组，然后再做归一化。</li></ol><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240314112440369.png"alt="几类归一化方式的对比图" /><figcaption aria-hidden="true">几类归一化方式的对比图</figcaption></figure><h2 id="rms-norm">3.6 RMS Norm</h2><p>与layerNorm相比，RMSNorm的主要区别在于<strong>去掉了减去均值的部分</strong>，计算公式为：</p><p><span class="math display">\[\bar{a}_{i}=\frac{a_{i}}{\operatorname{RMS}(\mathbf{a})} g_{i}, \quadwhere~ \operatorname{RMS}(\mathbf{a})=\sqrt{\frac{1}{n} \sum_{i=1}^{n}a_{i}^{2}}.\]</span></p><p>RMS中去除了<code>mean</code>的统计值的使用，只使用<code>root mean square(RMS)</code>进行归一化。</p><h2 id="prmsnorm介绍">3.7 pRMSNorm介绍</h2><p>RMS具有线性特征，所以提出可以用部分数据的RMSNorm来代替全部的计算，pRMSNorm表示使用前p%的数据计算RMS值。k=n*p表示用于RMS计算的元素个数。实测中，使用6.25%的数据量可以收敛</p><p><span class="math display">\[\overline{\operatorname{RMS}}(\mathbf{a})=\sqrt{\frac{1}{k}\sum_{i=1}^{k} a_{i}^{2}}\]</span></p><h2 id="post-ln-和-pre-ln">3.8 Post-LN 和 Pre-LN</h2><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240314112600172.png" alt="Post-LN和Pre-LN的对比图" style="zoom:50%;" /></p><p>左边是原版Transformer的Post-LN，即将LN放在addition之后；右边是改进之后的Pre-LN，即把LN放在FFN和MHA之前。</p><p>一般认为，Post-Norm在残差之后做归一化，对参数正则化的效果更强，进而模型的收敛性也会更好；而Pre-Norm有一部分参数直接加在了后面，没有对这部分参数进行正则化，可以在反向时防止梯度爆炸或者梯度消失，大模型的训练难度大，因而使用Pre-Norm较多。</p><p>目前比较明确的结论是：<strong>同一设置之下，PreNorm结构往往更容易训练，但最终效果通常不如Post Norm</strong>。PreNorm更容易训练好理解，因为它的恒等路径更突出，但为什么它效果反而没那么好呢？这个是解释的链接：<ahref="https://kexue.fm/archives/9009">https://kexue.fm/archives/9009</a></p><h1 id="pytorch几类优化器">4 PyTorch几类优化器</h1><h2 id="梯度下降-gradient-descent-gd">4.1 梯度下降 (Gradient Descent,GD):</h2><ul><li><p>公式表达: <spanclass="math inline">\(\theta_{t+1}=\theta_t-\alpha \nablaJ\left(\theta_t\right)\)</span></p></li><li><p>其中, <span class="math inline">\(\theta_t\)</span> 是第 <spanclass="math inline">\(t\)</span> 步的模型参数, <spanclass="math inline">\(\alpha\)</span> 是学习率, <spanclass="math inline">\(J\left(\theta_t\right)\)</span> 是损失函数, <spanclass="math inline">\(\nabla J\left(\theta_t\right)\)</span>是损失函数关于参数的梯度。 ## 4.2 随机梯度下降 (SGD):</p></li><li><p>公式表达: <spanclass="math inline">\(\theta_{t+1}=\theta_t-\alpha \nablaJ\left(\theta_t ; x^{(i)}, y^{(i)}\right)\)</span></p></li><li><p>与梯度下降不同的是, 每次更新时只随机选取一个样本 <spanclass="math inline">\(\left(x^{(i)}, y^{(i)}\right)\)</span>来计算梯度。</p></li><li><p><strong>优点:</strong></p><p>    虽然SGD需要走很多步的样子，但是对梯度的要求很低（计算梯度快）。而对于引入噪声，大量的理论和实践工作证明，只要噪声不是特别大，SGD都能很好地收敛。应用大型数据集时，训练速度很快。比如每次从百万数据样本中，取几百个数据点，算一个SGD梯度，更新一下模型参数。相比于标准梯度下降法的遍历全部样本，每输入一个样本更新一次参数，要快得多。</p><p><strong>缺点:</strong></p><p>    SGD在随机选择梯度的同时会引入噪声，使得权值更新的方向不一定正确。此外，SGD也没能单独克服局部最优解的问题。## 4.3 带动量的梯度下降 (Momentum):</p></li><li><p>公式表达: <span class="math inline">\(v_{t+1}=\beta v_t+(1-\beta)\nabla J\left(\theta_t\right), \theta_{t+1}=\theta_t-\alphav_{t+1}\)</span></p></li><li><p><span class="math inline">\(v_t\)</span> 是动量, <spanclass="math inline">\(\beta\)</span> 是动量系数。</p></li><li><p>动量主要解决SGD的两个问题：一是随机梯度的方法（引入的噪声）；二是Hessian矩阵病态问题（可以理解为SGD在收敛过程中和正确梯度相比来回摆动比较大的问题）。</p><p>    简单理解：由于当前权值的改变会受到上一次权值改变的影响，类似于小球向下滚动的时候带上了惯性。这样可以加快小球向下滚动的速度。## 4.4 自适应学习率优化器 :</p></li></ul><h3 id="rmsprop-root-mean-square-propagation">RMSprop (Root Mean SquarePropagation):</h3><ul><li><p>公式表达: <span class="math inline">\(v_{t+1}=\betav_t+(1-\beta)\left(\nabla J\left(\theta_t\right)\right)^2,\theta_{t+1}=\theta_t-\frac{\alpha}{\sqrt{v_{t+1}}+\epsilon} \nablaJ\left(\theta_t\right)\)</span></p></li><li><p>更新权重的时候，使用除根号的方法，可以使较大的梯度大幅度变小，而较小的梯度小幅度变小，这样就可以使较大梯度方向上的波动小下来，那么整个梯度下降的过程中摆动就会比较小，就能设置较大的learning-rate，使得学习步子变大，达到加快学习的目的。</p><p>    在实际的应用中，权重W或者b往往是很多维度权重集合，就是多维的，在进行除根号操作中，会将其中大的维度的梯度大幅降低，不是说权重W变化趋势一样。</p></li></ul><h3 id="adam-adaptive-moment-estimation">Adam (Adaptive MomentEstimation):</h3><ul><li><p>公式表达: <span class="math inline">\(m_{t+1}=\beta_1m_t+\left(1-\beta_1\right) \nabla J\left(\theta_t\right),v_{t+1}=\beta_2 v_t+\left(1-\beta_2\right)\left(\nablaJ\left(\theta_t\right)\right)^2\)</span>, <spanclass="math inline">\(\theta_{t+1}=\theta_t-\frac{\alpha}{\sqrt{v_{t+1}}+\epsilon}\frac{m_{t+1}}{1-\beta_1^{t+1}}\)</span></p></li><li><p>在这两种算法中, <span class="math inline">\(v_t\)</span> 和 <spanclass="math inline">\(m_t\)</span>分别是平方梯度的指数移动平均和梯度的指数移动平均。 <spanclass="math inline">\(\beta_1\)</span> 和 <spanclass="math inline">\(\beta_2\)</span>是动量和梯度平方的衰减率。</p></li><li><p>Adam的优点主要在于：</p><ul><li>考虑历史步中的梯度更新信息，能够降低梯度更新噪声。</li><li>此外经过偏差校正后，每一次迭代学习率都有个确定范围，使得参数比较平稳。</li></ul><p>但是Adam也有其自身问题：可能会对前期出现的特征过拟合，后期才出现的特征很难纠正前期的拟合效果。二者似乎都没法很好避免局部最优问题。</p></li></ul><p>这些优化器之间的区别主要体现在对梯度的处理方式上,以及对学习率的自适应调整。例如,动量优化器可以加速收玫并帮助逃离局部最优点,而自适应学习率优化器则可以根据梯度情况动态调整学习率,适应不同参数的更新速度。</p><h1 id="位置编码">5.位置编码</h1><h2 id="绝对位置编码">5.1 绝对位置编码</h2><p>不同于RNN、CNN等模型，对于Transformer模型来说，位置编码的加入是必不可少的，因为<strong>纯粹的Attention模块是无法捕捉输入顺序的，即无法区分不同位置的Token</strong>。为此我们大体有两个选择：</p><ol type="1"><li>想办法将位置信息融入到输入中，这构成了绝对位置编码的一般做法；</li><li>想办法微调一下Attention结构，使得它有能力分辨不同位置的Token，这构成了相对位置编码的一般做法。</li></ol><p>形式上来看，绝对位置编码是相对简单的一种方案，但即便如此，也不妨碍各路研究人员的奇思妙想，也有不少的变种。一般来说，绝对位置编码会加到输入中：在输入的第<spanclass="math inline">\(k\)</span>个向量<spanclass="math inline">\(x_k\)</span>中加入位置向量<spanclass="math inline">\(p_k\)</span>变为<spanclass="math inline">\(x_k+p_k\)</span>，其中<spanclass="math inline">\(p_k\)</span>只依赖于位置编号<spanclass="math inline">\(k\)</span>。</p><h3 id="训练式">5.1.1 训练式</h3><p>直接<strong>将位置编码当作可训练参数</strong>，比如最大长度为512，编码维度为768，那么就初始化一个512×768的矩阵作为位置向量，让它随着训练过程更新。</p><p>对于这种训练式的绝对位置编码，一般的认为它的缺点是没有<strong>外推性</strong>，即如果预训练最大长度为512的话，那么最多就只能处理长度为512的句子，再长就处理不了了。当然，也可以将超过512的位置向量随机初始化，然后继续微调。但笔者最近的研究表明，通过层次分解的方式，可以使得绝对位置编码能外推到足够长的范围，同时保持还不错的效果，细节请参考笔者之前的博文<ahref="https://kexue.fm/archives/7947"title="《层次分解位置编码，让BERT可以处理超长文本》">《层次分解位置编码，让BERT可以处理超长文本》</a>。因此，<strong>其实外推性也不是绝对位置编码的明显缺点</strong>。</p><h3 id="三角式">5.1.2 三角式</h3><p>三角函数式位置编码，一般也称为Sinusoidal位置编码，是Google的论文<ahref="https://arxiv.org/abs/1706.03762"title="《Attention is All You Need》">《Attention is All YouNeed》</a>所提出来的一个显式解：</p><p><span class="math display">\[\left\{\begin{array}{l}\boldsymbol{p}_{k, 2 i}=\sin \left(k / 10000^{2 i/ d}\right) \\ \boldsymbol{p}_{k, 2 i+1}=\cos \left(k / 10000^{2 i /d}\right)\end{array}\right.\]</span></p><p>其中<span class="math inline">\(p_{k,2i}\)</span>,<spanclass="math inline">\(p_{k,2i+1}\)</span>分别是位置<spanclass="math inline">\(k\)</span>的编码向量的第<spanclass="math inline">\(2i\)</span>,<spanclass="math inline">\(2i+1\)</span>个分量，<spanclass="math inline">\(d\)</span>是位置向量的维度。</p><p>很明显，三角函数式位置编码的特点是<strong>有显式的生成规律，因此可以期望于它有一定的外推性</strong>。另外一个使用它的理由是：由于<spanclass="math inline">\(\sin (\alpha+\beta)=\sin \alpha \cos \beta+\cos\alpha \sin \beta\)</span>以及<span class="math inline">\(\cos(\alpha+\beta)=\cos \alpha \cos \beta-\sin \alpha \sin\beta\)</span>，这表明位置<spanclass="math inline">\(\alpha+\beta\)</span>的向量可以表示成位置<spanclass="math inline">\(\alpha\)</span>和位置<spanclass="math inline">\(\beta\)</span>的向量组合，这提供了表达相对位置信息的可能性。但很奇怪的是，现在我们很少能看到直接使用这种形式的绝对位置编码的工作，原因不详。</p><h3 id="递归式">5.1.3 递归式</h3><p>原则上来说，RNN模型不需要位置编码，它在结构上就自带了学习到位置信息的可能性（因为递归就意味着我们可以训练一个“数数”模型），因此，<strong>如果在输入后面先接一层RNN，然后再接Transformer，那么理论上就不需要加位置编码了</strong>。同理，我们也可以用RNN模型来学习一种绝对位置编码，比如从一个向量<spanclass="math inline">\(p_0\)</span>出发，通过递归格式<spanclass="math inline">\(p_{k+1}=f(p_k)\)</span>来得到各个位置的编码向量。</p><p>ICML 2020的论文<a href="https://arxiv.org/abs/2003.09229"title="《Learning to Encode Position for Transformer with Continuous Dynamical Model》">《Learningto Encode Position for Transformer with Continuous DynamicalModel》</a>把这个思想推到了极致，它<strong>提出了用微分方程（ODE）</strong><spanclass="math inline">\(dp_t/dt=h(p_t,t)\)</span><strong>的方式来建模位置编码</strong>，该方案称之为FLOATER。显然，FLOATER也属于递归模型，函数<spanclass="math inline">\(h(p_t,t)\)</span>可以通过神经网络来建模，因此这种微分方程也称为神经微分方程，关于它的工作最近也逐渐多了起来。</p><p>理论上来说，<strong>基于递归模型的位置编码也具有比较好的外推性，同时它也比三角函数式的位置编码有更好的灵活性</strong>（比如容易证明三角函数式的位置编码就是FLOATER的某个特解）。但是很明显，递归形式的位置编码牺牲了一定的并行性，可能会带速度瓶颈。</p><h2 id="相对位置编码">5.2 相对位置编码</h2><p>相对位置并没有完整建模每个输入的位置信息，而是在<strong>算Attention的时候考虑当前位置与被Attention的位置的相对距离</strong>，由于自然语言一般更依赖于相对位置，所以相对位置编码通常也有着优秀的表现。对于相对位置编码来说，它的灵活性更大，更加体现出了研究人员的“天马行空”。</p><h3 id="经典式">5.2.1经典式</h3><p>相对位置编码起源于Google的论文<ahref="https://arxiv.org/abs/1803.02155"title="《Self-Attention with Relative Position Representations》">《Self-Attentionwith Relative PositionRepresentations》</a>，华为开源的NEZHA模型也用到了这种位置编码，后面各种相对位置编码变体基本也是依葫芦画瓢的简单修改。</p><p>一般认为，<strong>相对位置编码是由绝对位置编码启发而来</strong>，考虑一般的带绝对位置编码的Attention：</p><p><span class="math display">\[\left\{\begin{aligned} \boldsymbol{q}_{i} &amp;=\left(\boldsymbol{x}_{i}+\boldsymbol{p}_{i}\right) \boldsymbol{W}_{Q}\\ \boldsymbol{k}_{j} &amp;=\left(\boldsymbol{x}_{j}+\boldsymbol{p}_{j}\right) \boldsymbol{W}_{K}\\ \boldsymbol{v}_{j} &amp;=\left(\boldsymbol{x}_{j}+\boldsymbol{p}_{j}\right) \boldsymbol{W}_{V}\\ a_{i, j} &amp; =\operatorname{softmax}\left(\boldsymbol{q}_{i}\boldsymbol{k}_{j}^{\top}\right) \\ \boldsymbol{o}_{i} &amp; =\sum_{j}a_{i, j} \boldsymbol{v}_{j}\end{aligned}\right.\]</span></p><p>其中<code>softmax</code>对j那一维归一化，这里的向量都是指行向量。我们初步展开<spanclass="math inline">\(q_ik^T_j\)</span>：</p><p><span class="math display">\[\boldsymbol{q}_{i}\boldsymbol{k}_{j}^{\top}=\left(\boldsymbol{x}_{i}+\boldsymbol{p}_{i}\right)\boldsymbol{W}_{Q}\boldsymbol{W}_{K}^{\top}\left(\boldsymbol{x}_{j}+\boldsymbol{p}_{j}\right)^{\top}=\left(\boldsymbol{x}_{i}\boldsymbol{W}_{Q}+\boldsymbol{p}_{i}\boldsymbol{W}_{Q}\right)\left(\boldsymbol{W}_{K}^{\top}\boldsymbol{x}_{j}^{\top}+\boldsymbol{W}_{K}^{\top}\boldsymbol{p}_{j}^{\top}\right)\]</span></p><p>为了引入相对位置信息，Google把第一项位置去掉，第二项<spanclass="math inline">\(p_jW_K\)</span>改为二元位置向量<spanclass="math inline">\(R^K_{i,j}\)</span>，变成</p><p><span class="math display">\[a_{i, j}=\operatorname{softmax}\left(\boldsymbol{x}_{i}\boldsymbol{W}_{Q}\left(\boldsymbol{x}_{j}\boldsymbol{W}_{K}+\boldsymbol{R}_{i, j}^{K}\right)^{\top}\right)\]</span></p><p>以及<span class="math inline">\(\boldsymbol{o}_{i}=\sum_{j} a_{i, j}\boldsymbol{v}_{j}=\sum_{j} a_{i, j}\left(\boldsymbol{x}_{j}\boldsymbol{W}_{V}+\boldsymbol{p}_{j}\boldsymbol{W}_{V}\right)\)</span>中的中的<spanclass="math inline">\(p_jW_V\)</span>换成<spanclass="math inline">\(R^V_{i,j}\)</span>：</p><p><span class="math display">\[\boldsymbol{o}_{i}=\sum_{j} a_{i, j}\left(\boldsymbol{x}_{j}\boldsymbol{W}_{V}+\boldsymbol{R}_{i, j}^{V}\right)\]</span></p><p>所谓相对位置，是将本来依赖于二元坐标<spanclass="math inline">\((i,j)\)</span>的向量<spanclass="math inline">\(R^K_{i,j}\)</span>,<spanclass="math inline">\(R^V_{i,j}\)</span>，改为只依赖于相对距离<spanclass="math inline">\(i−j\)</span>，并且通常来说会进行截断，以适应不同任意的距离:</p><p><span class="math display">\[\begin{array}{l}\boldsymbol{R}_{i,j}^{K}=\boldsymbol{p}_{K}\left[\operatorname{clip}\left(i-j, p_{\min },p_{\max }\right)\right] \\ \boldsymbol{R}_{i,j}^{V}=\boldsymbol{p}_{V}\left[\operatorname{clip}\left(i-j, p_{\min },p_{\max }\right)\right]\end{array}\]</span></p><p>这样一来，只需要有限个位置编码，就可以表达出任意长度的相对位置（因为进行了截断），不管<spanclass="math inline">\(p_K\)</span>,<spanclass="math inline">\(p_V\)</span>是选择可训练式的还是三角函数式的，都可以达到处理任意长度文本的需求。</p><h3 id="xlnet式">5.2.2 XLNET式</h3><p>XLNET式位置编码其实源自Transformer-XL的论文<ahref="https://arxiv.org/abs/1901.02860"title="《Transformer-XL: Attentive Language Models Beyond a Fixed-Length Context》">《Transformer-XL:Attentive Language Models Beyond a Fixed-LengthContext》</a>，只不过因为使用了Transformer-XL架构的<ahref="https://arxiv.org/abs/1906.08237"title="XLNET">XLNET</a>模型并在一定程度上超过了BERT后，Transformer-XL才算广为人知，因此这种位置编码通常也被冠以XLNET之名。</p><p>XLNET式位置编码源于对上述<spanclass="math inline">\(q_ik^T_j\)</span>的完全展开：</p><p><span class="math display">\[\boldsymbol{q}_{i} \boldsymbol{k}_{j}^{\top}=\boldsymbol{x}_{i}\boldsymbol{W}_{Q} \boldsymbol{W}_{K}^{\top}\boldsymbol{x}_{j}^{\top}+\boldsymbol{x}_{i} \boldsymbol{W}_{Q}\boldsymbol{W}_{K}^{\top} \boldsymbol{p}_{j}^{\top}+\boldsymbol{p}_{i}\boldsymbol{W}_{Q} \boldsymbol{W}_{K}^{\top}\boldsymbol{x}_{j}^{\top}+\boldsymbol{p}_{i} \boldsymbol{W}_{Q}\boldsymbol{W}_{K}^{\top} \boldsymbol{p}_{j}^{\top}\]</span></p><p>Transformer-XL的做法很简单，直接将<spanclass="math inline">\(p_j\)</span>替换为相对位置向量<spanclass="math inline">\(R_{i−j}\)</span>，至于两个<spanclass="math inline">\(p_i\)</span>，则干脆替换为两个可训练的向量<spanclass="math inline">\(u,v\)</span>：</p><p><span class="math display">\[\boldsymbol{x}_{i} \boldsymbol{W}_{Q} \boldsymbol{W}_{K}^{\top}\boldsymbol{x}_{j}^{\top}+\boldsymbol{x}_{i} \boldsymbol{W}_{Q}\boldsymbol{W}_{K}^{\top} \boldsymbol{R}_{i-j}^{\top}+u\boldsymbol{W}_{Q} \boldsymbol{W}_{K}^{\top}\boldsymbol{x}_{j}^{\top}+\boldsymbol{v} \boldsymbol{W}_{Q}\boldsymbol{W}_{K}^{\top} \boldsymbol{R}_{i-j}^{\top}\]</span></p><p>该编码方式中的<spanclass="math inline">\(R_{i−j}\)</span>没有像经典模型那样进行截断，而是直接用了Sinusoidal式的生成方案，由于<spanclass="math inline">\(R_{i−j}\)</span>的编码空间与<spanclass="math inline">\(x_j\)</span>不一定相同，所以<spanclass="math inline">\(R_{i−j}\)</span>前面的<spanclass="math inline">\(W^T_K\)</span>换了另一个独立的矩阵<spanclass="math inline">\(W^T_{K,R}\)</span>，还有<spanclass="math inline">\(uW_Q\)</span> 、<spanclass="math inline">\(vW_Q\)</span>可以直接合并为单个<spanclass="math inline">\(u\)</span> 、<spanclass="math inline">\(v\)</span>，所以最终使用的式子是：</p><p><span class="math display">\[\boldsymbol{x}_{i} \boldsymbol{W}_{Q} \boldsymbol{W}_{K}^{\top}\boldsymbol{x}_{j}^{\top}+\boldsymbol{x}_{i} \boldsymbol{W}_{Q}\boldsymbol{W}_{K, R}^{\top} \boldsymbol{R}_{i-j}^{\top}+\boldsymbol{u}\boldsymbol{W}_{K}^{\top} \boldsymbol{x}_{j}^{\top}+\boldsymbol{v}\boldsymbol{W}_{K, R}^{\top} \boldsymbol{R}_{i-j}^{\top}\]</span></p><p>此外，<spanclass="math inline">\(v_j\)</span>上的位置偏置就直接去掉了，即直接令<spanclass="math inline">\(\boldsymbol{o}_{i}=\sum_{j} a_{i, j}\boldsymbol{x}_{j}\boldsymbol{W}_{V}\)</span>。似乎从这个工作开始，后面的相对位置编码都只加到Attention矩阵上去，而不加到<spanclass="math inline">\(v_j\)</span>上去了。</p><h3 id="t5式">5.2.3 T5式</h3><p>T5模型出自文章<a href="https://arxiv.org/abs/1910.10683"title="《Exploring the Limits of Transfer Learning with a Unified Text-to-Text Transformer》">《Exploringthe Limits of Transfer Learning with a Unified Text-to-TextTransformer》</a>，里边用到了一种更简单的相对位置编码。思路依然源自<spanclass="math inline">\(q_ik^T_j\)</span>展开式，如果非要分析每一项的含义，那么可以分别理解为“输入-输入”、“输入-位置”、“位置-输入”、“位置-位置”四项注意力的组合。如果我们认为输入信息与位置信息应该是独立（解耦）的，那么它们就不应该有过多的交互，所以“输入-位置”、“位置-输入”两项Attention可以删掉，而<spanclass="math inline">\(\boldsymbol{p}_{i} \boldsymbol{W}_{Q}\boldsymbol{W}_{K}^{\top}\boldsymbol{p}_{j}^{\top}\)</span>实际上只是一个只依赖于<spanclass="math inline">\((i,j)\)</span>的标量，我们可以直接将它作为参数训练出来，即简化为：</p><p><span class="math display">\[\boldsymbol{x}_{i} \boldsymbol{W}_{Q} \boldsymbol{W}_{K}^{\top}\boldsymbol{x}_{j}^{\top}+\boldsymbol{\beta}_{i, j}\]</span></p><p>说白了，它仅仅是在Attention矩阵的基础上加一个可训练的偏置项而已，而跟XLNET式一样，在<spanclass="math inline">\(v_j\)</span>上的位置偏置则直接被去掉了。包含同样的思想的还有微软在ICLR2021的论文<a href="https://arxiv.org/abs/2006.15595"title="《Rethinking Positional Encoding in Language Pre-training》">《RethinkingPositional Encoding in LanguagePre-training》</a>中提出的TUPE位置编码。</p><p>比较“别致”的是，不同于常规位置编码对将<spanclass="math inline">\(\beta_{i, j}\)</span>视为<spanclass="math inline">\(i−j\)</span>的函数并进行截断的做法，T5对相对位置进行了一个“分桶”处理，即相对位置是<spanclass="math inline">\(i−j\)</span>的位置实际上对应的是<spanclass="math inline">\(f(i−j)\)</span>位置，映射关系如下： </p><table><thead><tr class="header"><th><span class="math inline">\(i-j\)</span></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(f(i-j)\)</span></td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>8</td><td>8</td><td>8</td><td>9</td><td>9</td><td>9</td><td>9</td></tr><tr class="even"><td><span class="math inline">\(i-j\)</span></td><td>16</td><td>17</td><td>18</td><td>19</td><td>20</td><td>21</td><td>22</td><td>23</td><td>24</td><td>25</td><td>26</td><td>27</td><td>28</td><td>29</td><td>30</td><td>...</td></tr><tr class="odd"><td><span class="math inline">\(f(i-j)\)</span></td><td>10</td><td>10</td><td>10</td><td>10</td><td>10</td><td>10</td><td>10</td><td>11</td><td>11</td><td>11</td><td>11</td><td>11</td><td>11</td><td>11</td><td>11</td><td>...</td></tr></tbody></table><p>这个设计的思路其实也很直观，就是比较邻近的位置（0～7），需要比较得精细一些，所以给它们都分配一个独立的位置编码，至于稍远的位置（比如8～11），我们不用区分得太清楚，所以它们可以共用一个位置编码，距离越远，共用的范围就可以越大，直到达到指定范围再clip。</p><h3 id="deberta式">5.2.4 DeBERTa式</h3><p>DeBERTa也是微软搞的，去年6月就发出来了，论文为<ahref="https://arxiv.org/abs/2006.03654"title="《DeBERTa: Decoding-enhanced BERT with Disentangled Attention》">《DeBERTa:Decoding-enhanced BERT with DisentangledAttention》</a>，最近又小小地火了一把，一是因为它正式中了ICLR2021，二则是它登上<a href="https://super.gluebenchmark.com/"title="SuperGLUE">SuperGLUE</a>的榜首，成绩稍微超过了T5。</p><p>其实DeBERTa的主要改进也是在位置编码上，同样还是从<spanclass="math inline">\(q_ik^T_j\)</span>展开式出发，T5是干脆去掉了第2、3项，只保留第4项并替换为相对位置编码，而DeBERTa则刚刚相反，它扔掉了第4项，保留第2、3项并且替换为相对位置编码（果然，科研就是枚举所有的排列组合看哪个最优）：</p><p><span class="math display">\[\boldsymbol{q}_{i} \boldsymbol{k}_{j}^{\top}=\boldsymbol{x}_{i}\boldsymbol{W}_{Q} \boldsymbol{W}_{K}^{\top}\boldsymbol{x}_{j}^{\top}+\boldsymbol{x}_{i} \boldsymbol{W}_{Q}\boldsymbol{W}_{K}^{\top} \boldsymbol{R}_{i,j}^{\top}+\boldsymbol{R}_{j, i} \boldsymbol{W}_{Q}\boldsymbol{W}_{K}^{\top} \boldsymbol{x}_{j}^{\top}\]</span></p><p>不过，DeBERTa比较有意思的地方，是提供了使用相对位置和绝对位置编码的一个新视角，它指出NLP的大多数任务可能都只需要相对位置信息，但确实有些场景下绝对位置信息更有帮助，于是它将整个模型分为两部分来理解。以Base版的MLM预训练模型为例，它一共有13层，前11层只是用相对位置编码，这部分称为Encoder，后面2层加入绝对位置信息，这部分它称之为Decoder，还弄了个简称EMD（EnhancedMaskDecoder）；至于下游任务的微调截断，则是使用前11层的Encoder加上1层的Decoder来进行。</p><h2 id="旋转位置编码-rope篇">5.3 旋转位置编码 RoPE篇</h2><p>RoPE旋转位置编码是苏神提出来的一种相对位置编码，之前主要用在自研的语言模型roformer上，后续谷歌Palm和meta的LLaMA等都是采用此位置编码，通过复数形式来对于三角式绝对位置编码的改进。有一些同学可能没看懂苏神的公式推导，我这里来帮助大家推理理解下公式。</p><p>通过线性attention演算，现在q和k向量中引入绝对位置信息：</p><p><span class="math display">\[\tilde{\boldsymbol{q}}_{m}=\boldsymbol{f}(\boldsymbol{q}, m), \quad\tilde{\boldsymbol{k}}_{n}=\boldsymbol{f}(\boldsymbol{k}, n)\]</span></p><p>但是需要实现相对位置编码的话，需要显式融入相对。attention运算中q和k会进行内积，所以考虑在进行向量内积时考虑融入相对位置。所以假设成立恒等式：</p><p><span class="math display">\[\langle\boldsymbol{f}(\boldsymbol{q}, m), \boldsymbol{f}(\boldsymbol{k},n)\rangle=g(\boldsymbol{q}, \boldsymbol{k}, m-n)\]</span></p><p>其中<code>m-n</code>包含着token之间的相对位置信息。</p><p>给上述恒等式计算设置初始条件，例如<spanclass="math inline">\(f(q,0)=q\)</span>，<spanclass="math inline">\(f(k,0)=k\)</span>。</p><p>求解过程使用复数方式求解</p><p>将内积使用复数形式表示：</p><p><span class="math display">\[\langle\boldsymbol{q},\boldsymbol{k}\rangle=\operatorname{Re}\left[\boldsymbol{q}\boldsymbol{k}^{*}\right]\]</span></p><p>转化上面内积公式可得：</p><p><span class="math display">\[\operatorname{Re}\left[\boldsymbol{f}(\boldsymbol{q}, m)\boldsymbol{f}^{*}(\boldsymbol{k}, n)\right]=g(\boldsymbol{q},\boldsymbol{k}, m-n)\]</span></p><p>假设等式两边都存在复数形式，则有下式：</p><p><span class="math display">\[\boldsymbol{f}(\boldsymbol{q}, m) \boldsymbol{f}^{*}(\boldsymbol{k},n)=\boldsymbol{g}(\boldsymbol{q}, \boldsymbol{k}, m-n)\]</span></p><p>将两边公式皆用复数指数形式表示：</p><p>存在<span class="math inline">\(r e^{\theta \mathrm{j}}=r \cos\theta+r \sin \theta \mathrm{j}\)</span>，即任意复数<spanclass="math inline">\(z\)</span>可以表示为<spanclass="math inline">\(\boldsymbol{z}=r e^{\theta\mathrm{j}}\)</span>，其中<spanclass="math inline">\(r\)</span>为复数的模，<spanclass="math inline">\(\theta\)</span>为幅角。</p><p><span class="math display">\[\begin{aligned} \boldsymbol{f}(\boldsymbol{q}, m) &amp;=R_{f}(\boldsymbol{q}, m) e^{\mathrm{i} \Theta_{f}(\boldsymbol{q}, m)}\\ \boldsymbol{f}(\boldsymbol{k}, n) &amp; =R_{f}(\boldsymbol{k}, n)e^{\mathrm{i} \Theta_{f}(\boldsymbol{k}, n)} \\\boldsymbol{g}(\boldsymbol{q}, \boldsymbol{k}, m-n) &amp;=R_{g}(\boldsymbol{q}, \boldsymbol{k}, m-n) e^{\mathrm{i}\Theta_{g}(\boldsymbol{q}, \boldsymbol{k}, m-n)}\end{aligned}\]</span></p><p>由于带入上面方程中<spanclass="math inline">\(f(k,n)\)</span>带*是共轭复数，所以指数形式应该是<spanclass="math inline">\(e^{-x}\)</span>形式，带入上式公式可得方程组：</p><p><span class="math display">\[\begin{aligned} R_{f}(\boldsymbol{q}, m) R_{f}(\boldsymbol{k}, n) &amp;=R_{g}(\boldsymbol{q}, \boldsymbol{k}, m-n) \\\Theta_{f}(\boldsymbol{q}, m)-\Theta_{f}(\boldsymbol{k}, n) &amp;=\Theta_{g}(\boldsymbol{q}, \boldsymbol{k}, m-n)\end{aligned}\]</span></p><p>第一个方程带入条件<spanclass="math inline">\(m=n\)</span>化简可得：</p><p><span class="math display">\[R_{f}(\boldsymbol{q}, m) R_{f}(\boldsymbol{k}, m)=R_{g}(\boldsymbol{q},\boldsymbol{k}, 0)=R_{f}(\boldsymbol{q}, 0) R_{f}(\boldsymbol{k},0)=\|\boldsymbol{q}\|\|\boldsymbol{k}\|\]</span></p><p><span class="math display">\[R_{f}(\boldsymbol{q}, m)=\|\boldsymbol{q}\|, R_{f}(\boldsymbol{k},m)=\|\boldsymbol{k}\|\]</span></p><p>从上式可以看出来复数<spanclass="math inline">\(f(q,m)\)</span>和<spanclass="math inline">\(f(k,m)\)</span>与<spanclass="math inline">\(m\)</span>取值关系不大。</p><p>第二个方程带入<span class="math inline">\(m=n\)</span>化简可得：</p><p><span class="math display">\[\Theta_{f}(\boldsymbol{q}, m)-\Theta_{f}(\boldsymbol{k},m)=\Theta_{g}(\boldsymbol{q}, \boldsymbol{k},0)=\Theta_{f}(\boldsymbol{q}, 0)-\Theta_{f}(\boldsymbol{k},0)=\Theta(\boldsymbol{q})-\Theta(\boldsymbol{k})\]</span></p><p>上式公式变量两边挪动下得到：</p><p><span class="math display">\[\Theta_{f}(\boldsymbol{q}, m)-\Theta_{f}(\boldsymbol{k},m)=\Theta_{g}(\boldsymbol{q}, \boldsymbol{k},0)=\Theta_{f}(\boldsymbol{q}, 0)-\Theta_{f}(\boldsymbol{k},0)=\Theta(\boldsymbol{q})-\Theta(\boldsymbol{k})\]</span></p><p>其中上式结果相当于m是自变量，结果是与m相关的值，假设为 <spanclass="math inline">\(\varphi(m)\)</span>，即<spanclass="math inline">\(\Theta_{f}(\boldsymbol{q},m)=\Theta(\boldsymbol{q})+\varphi(m)\)</span></p><p><code>n</code>假设为<code>m</code>的前一个token，则可得<code>n=m-1</code>，带入上上个式子可得：</p><p><span class="math display">\[\varphi(m)-\varphi(m-1)=\Theta_{g}(\boldsymbol{q}, \boldsymbol{k},1)+\Theta(\boldsymbol{k})-\Theta(\boldsymbol{q})\]</span></p><p>即 <spanclass="math inline">\(\varphi(m)\)</span>是等差数列，假设等式右边为<span class="math inline">\(\theta\)</span>，则<code>m</code>和<code>m-1</code>位置的公差就是为<spanclass="math inline">\(\theta\)</span>，可推得 <spanclass="math inline">\(\varphi(m)=m \theta\)</span>。</p><p>得到二维情况下用复数表示的RoPE：</p><p><span class="math display">\[\boldsymbol{f}(\boldsymbol{q}, m)=R_{f}(\boldsymbol{q}, m) e^{\mathrm{i}\Theta_{f}(\boldsymbol{q}, m)}=\|q\|e^{\mathrm{i}(\Theta(\boldsymbol{q})+m \theta)}=\boldsymbol{q}e^{\mathrm{i} m \theta}\]</span></p><p>矩阵形式是：</p><p><span class="math display">\[\boldsymbol{f}(\boldsymbol{q}, m)=\left(\begin{array}{cc}\cos m \theta&amp; -\sin m \theta \\ \sin m \theta &amp; \cos m\theta\end{array}\right)\left(\begin{array}{l}q_{0} \\q_{1}\end{array}\right)\]</span></p><p>公式最后还会采用三角式一样的远程衰减，来增加周期性函数外推位置差异性。</p><p><span class="math display">\[\left(\boldsymbol{W}_{m}\boldsymbol{q}\right)^{\top}\left(\boldsymbol{W}_{n}\boldsymbol{k}\right)=\operatorname{Re}\left[\sum_{i=0}^{d / 2-1}\boldsymbol{q}_{[2 i: 2 i+1]} \boldsymbol{k}_{[2 i: 2 i+1]}^{*}e^{\mathrm{i}(m-n) \theta_{i}}\right]\]</span></p><h2 id="几种位置编码方式总结">5.4 几种位置编码方式总结</h2><h3 id="绝对位置编码-1"><strong>5.4.1 绝对位置编码</strong></h3><ul><li>最原始的正余弦位置编码（即sinusoidal位置编码）是一种绝对位置编码，但从其原理中的正余弦的和差化积公式来看，引入的其实也是相对位置编码。</li><li>优势： 实现简单，可预先计算好，不用参与训练，速度快。</li><li>劣势：没有外推性，即如果预训练最大长度为512的话，那么最多就只能处理长度为512的句子，再长就处理不了了。当然，也可以将超过512的位置向量随机初始化，然后继续微调。</li></ul><h3 id="相对位置编码-1"><strong>5.4.2 相对位置编码</strong></h3><ul><li>经典相对位置编码RPR式的讲解可看我的博客：相对位置编码之RPR式：《Self-Attentionwith Relative Position Representations》论文笔记 【在k,v中注入相对位置信息】</li><li>优势：直接地体现了相对位置信号，效果更好。具有外推性，处理长文本能力更强。</li></ul><h3 id="rope"><strong>5.4.3 RoPE</strong></h3><ul><li>RoPE通过绝对位置编码的方式实现相对位置编码，综合了绝对位置编码和相对位置编码的优点。</li><li>主要就是<strong>对attention中的q,k向量注入了绝对位置信息，然后用更新的q,k向量做attention中的内积就会引入相对位置信息了</strong>。</li></ul><h1 id="激活函数">6 激活函数</h1><h2 id="介绍一下-ffn-块-计算公式">6.1 介绍一下 FFN 块 计算公式？</h2><p>FFN（Feed-ForwardNetwork）块是Transformer模型中的一个重要组成部分，接受自注意力子层的输出作为输入，并通过一个带有Relu激活函数的两层全连接网络对输入进行更加复杂的非线性变换。实验证明，这一非线性变换会对模型最终的性能产生十分重要的影响。</p><p>FFN由两个全连接层（即前馈神经网络）和一个激活函数组成。下面是FFN块的计算公式：</p><p><span class="math display">\[\operatorname{FFN}(\boldsymbol{x})=\operatorname{Relu}\left(\boldsymbol{x}\boldsymbol{W}_{1}+\boldsymbol{b}_{1}\right)\boldsymbol{W}_{2}+\boldsymbol{b}_{2}\]</span></p><p>假设输入是一个向量 <spanclass="math inline">\(x\)</span>，FFN块的计算过程如下：</p><ol type="1"><li>第一层全连接层（线性变换）：<span class="math inline">\(z = xW1 +b1\)</span> 其中，W1 是第一层全连接层的权重矩阵，b1 是偏置向量。</li><li>激活函数：<span class="math inline">\(a = g(z)\)</span> 其中，g()是激活函数，常用的激活函数有ReLU（Rectified Linear Unit）等。</li><li>第二层全连接层（线性变换）：<span class="math inline">\(y = aW2 +b2\)</span> 其中，W2 是第二层全连接层的权重矩阵，b2 是偏置向量。</li></ol><p>增大前馈子层隐状态的维度有利于提升最终翻译结果的质量，因此，前馈子层隐状态的维度一般比自注意力子层要大。</p><p>需要注意的是，上述公式中的 W1、b1、W2、b2是FFN块的可学习参数，它们会通过训练过程进行学习和更新。</p><h2 id="介绍一下-gelu-计算公式">6.2 介绍一下 GeLU 计算公式？</h2><p>GeLU（Gaussian Error LinearUnit）是一种激活函数，常用于神经网络中的非线性变换。它在Transformer模型中广泛应用于FFN（Feed-ForwardNetwork）块。下面是GeLU的计算公式：</p><p>假设输入是一个标量 x，GeLU的计算公式如下：</p><p><span class="math display">\[GeLU(x) = 0.5 \times x \times (1 + tanh(\sqrt{\frac{2}{\pi}} \times (x +0.044715 \times x^3)))\]</span></p><p>其中，<code>tanh()</code>是双曲正切函数，<code>sqrt()</code>是平方根函数，$ $是圆周率。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">GELU</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0.5</span> * x * (<span class="hljs-number">1</span> + np.tanh(np.sqrt(<span class="hljs-number">2</span> / np.pi) * (x + <span class="hljs-number">0.044715</span> * np.power(x, <span class="hljs-number">3</span>))))<br></code></pre></td></tr></table></figure><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240314113922791.png"alt="几类激活函数的表示" /><figcaption aria-hidden="true">几类激活函数的表示</figcaption></figure><p>相对于 Sigmoid 和 Tanh 激活函数，ReLU 和 GeLU更为准确和高效，因为它们在神经网络中的梯度消失问题上表现更好。而 ReLU 和GeLU几乎没有梯度消失的现象，可以更好地支持深层神经网络的训练和优化。</p><p>而 <strong>ReLU 和 GeLU 的区别在于形状和计算效率</strong>。ReLU是一个非常简单的函数，仅仅是输入为负数时返回0，而输入为正数时返回自身，从而仅包含了一次分段线性变换。但是，<strong>ReLU函数存在一个问题，就是在输入为负数时，输出恒为0，这个问题可能会导致神经元死亡，从而降低模型的表达能力</strong>。GeLU函数则是一个连续的 S 形曲线，介于 Sigmoid 和 ReLU 之间，形状比 ReLU更为平滑，可以在一定程度上缓解神经元死亡的问题。不过，由于 GeLU函数中包含了指数运算等复杂计算，所以在实际应用中通常比 ReLU 慢。</p><p>总之，ReLU 和 GeLU都是常用的激活函数，它们各有优缺点，并适用于不同类型的神经网络和机器学习问题。一般来说，ReLU更适合使用在卷积神经网络（CNN）中，而 GeLU更适用于全连接网络（FNN）。</p><h2 id="介绍一下-swish-计算公式">6.3 介绍一下 Swish 计算公式？</h2><p>Swish是一种激活函数，它在深度学习中常用于神经网</p><p>络的非线性变换。Swish函数的计算公式如下： <spanclass="math display">\[Swish(x) = x \times sigmoid(\beta * x)\]</span></p><p>其中，<span class="math inline">\(sigmoid()\)</span>是Sigmoid函数，<span class="math inline">\(x\)</span> 是输入，<spanclass="math inline">\(\beta\)</span> 是一个可调节的超参数。</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240314114035744.png"alt="Swish图像随参数变化的趋势" /><figcaption aria-hidden="true">Swish图像随参数变化的趋势</figcaption></figure><p>Swish函数的特点是在接近零的区域表现得类似于线性函数，而在远离零的区域则表现出非线性的特性。相比于其他常用的激活函数（如ReLU、tanh等），Swish函数在某些情况下能够提供更好的性能和更快的收敛速度。</p><p>Swish函数的设计灵感来自于自动搜索算法，它通过引入一个可调节的超参数来增加非线性程度。当beta为0时，Swish函数退化为线性函数；当beta趋近于无穷大时，Swish函数趋近于ReLU函数。</p><p>需要注意的是，Swish函数相对于其他激活函数来说计算开销较大，因为它需要进行Sigmoid运算。因此，在实际应用中，也可以根据具体情况选择其他的激活函数来代替Swish函数。</p><h2 id="介绍一下使用-glu-线性门控单元的-ffn-块-计算公式">6.4介绍一下使用 GLU 线性门控单元的 FFN 块 计算公式？</h2><p>使用GLU（Gated Linear Unit）线性门控单元的FFN（Feed-ForwardNetwork）块是Transformer模型中常用的结构之一。它通过引入门控机制来增强模型的非线性能力。下面是使用GLU线性门控单元的FFN块的计算公式：</p><p>假设输入是一个向量 x，GLU线性门控单元的计算公式如下：</p><p><span class="math display">\[GLU(x) = x * sigmoid(W_1 * x)\]</span></p><p>其中，<span class="math inline">\(sigmoid()\)</span>是Sigmoid函数，<span class="math inline">\(W_1\)</span>是一个可学习的权重矩阵。</p><p>在公式中，首先将输入向量 x 通过一个全连接层（线性变换）得到一个与 x维度相同的向量，然后将该向量通过Sigmoid函数进行激活。这个Sigmoid函数的输出称为门控向量，用来控制输入向量x 的元素是否被激活。最后，将门控向量与输入向量 x逐元素相乘，得到最终的输出向量。</p><p>GLU线性门控单元的特点是能够对输入向量进行选择性地激活，从而增强模型的表达能力。它在Transformer模型的编码器和解码器中广泛应用，用于对输入向量进行非线性变换和特征提取。</p><p>需要注意的是，GLU线性门控单元的计算复杂度较高，可能会增加模型的计算开销。因此，在实际应用中，也可以根据具体情况选择其他的非线性变换方式来代替GLU线性门控单元。</p><h2 id="介绍一下-使用-gelu-的-glu-块-计算公式">6.5 介绍一下 使用 GeLU 的GLU 块 计算公式？</h2><p>使用GeLU作为激活函数的GLU块的计算公式如下：</p><p><span class="math display">\[GLU(x) = x * GeLU(W_1 * x)\]</span></p><p>其中，<code>GeLU()</code>是Gaussian Error LinearUnit的激活函数，<code>W_1</code>是一个可学习的权重矩阵。</p><p>在公式中，首先将输入向量 x 通过一个全连接层（线性变换）得到一个与 x维度相同的向量，然后将该向量作为输入传递给GeLU激活函数进行非线性变换。最后，将GeLU激活函数的输出与输入向量x 逐元素相乘，得到最终的输出向量。</p><p>GeLU激活函数的计算公式如下：</p><p><span class="math display">\[GeLU(x) = 0.5 \times x \times (1 + tanh(\sqrt{\frac{2}{\pi}} \times (x +0.044715 \times x^3)))\]</span></p><p>其中，<code>tanh()</code>是双曲正切函数，<code>sqrt()</code>是平方根函数，$ $是圆周率。</p><p>在公式中，GeLU函数首先对输入向量 x进行一个非线性变换，然后通过一系列的数学运算得到最终的输出值。</p><p>使用GeLU作为GLU块的激活函数可以增强模型的非线性能力，并在某些情况下提供更好的性能和更快的收敛速度。这种结构常用于Transformer模型中的编码器和解码器，用于对输入向量进行非线性变换和特征提取。</p><p>需要注意的是，GLU块和GeLU激活函数是两个不同的概念，它们在计算公式和应用场景上有所区别。在实际应用中，可以根据具体情况选择合适的激活函数来代替GeLU或GLU。</p><h2 id="介绍一下-使用-swish-的-glu-块-计算公式">6.6 介绍一下 使用 Swish的 GLU 块 计算公式？</h2><p>使用Swish作为激活函数的GLU块的计算公式如下：</p><p><span class="math display">\[GLU(x) = x * sigmoid(W_1 * x)\]</span></p><p>其中，<span class="math inline">\(sigmoid()\)</span>是Sigmoid函数，<span class="math inline">\(W_1\)</span>是一个可学习的权重矩阵。</p><p>在公式中，首先将输入向量 x 通过一个全连接层（线性变换）得到一个与 x维度相同的向量，然后将该向量通过Sigmoid函数进行激活。这个Sigmoid函数的输出称为门控向量，用来控制输入向量x 的元素是否被激活。最后，将门控向量与输入向量 x逐元素相乘，得到最终的输出向量。</p><p>Swish激活函数的计算公式如下：</p><p><span class="math display">\[Swish(x) = x \times sigmoid(\beta * x)\]</span></p><p>其中，<span class="math inline">\(sigmoid()\)</span>是Sigmoid函数，<span class="math inline">\(x\)</span> 是输入，<spanclass="math inline">\(\beta\)</span> 是一个可调节的超参数。</p><p>在公式中，Swish函数首先对输入向量 x进行一个非线性变换，然后通过Sigmoid函数进行激活，并将该激活结果与输入向量x 逐元素相乘，得到最终的输出值。</p><p>使用Swish作为GLU块的激活函数可以增强模型的非线性能力，并在某些情况下提供更好的性能和更快的收敛速度。GLU块常用于Transformer模型中的编码器和解码器，用于对输入向量进行非线性变换和特征提取。</p><p>需要注意的是，GLU块和Swish激活函数是两个不同的概念，它们在计算公式和应用场景上有所区别。在实际应用中，可以根据具体情况选择合适的激活函数来代替Swish或GLU。</p><h1 id="tokenize相关">7 Tokenize相关</h1><h2 id="总览">7.1 总览</h2><table><thead><tr class="header"><th>分词方法</th><th>特点</th><th>被提出的时间</th><th>典型模型</th></tr></thead><tbody><tr class="odd"><td>BPE</td><td>采用合并规则，可以适应未知词</td><td>2016年</td><td>GPT-2、RoBERTa</td></tr><tr class="even"><td>WordPiece</td><td>采用逐步拆分的方法，可以适应未知词</td><td>2016年</td><td>BERT</td></tr><tr class="odd"><td>Unigram LM</td><td>采用无序语言模型，训练速度快</td><td>2018年</td><td>XLM</td></tr><tr class="even"><td>SentencePiece</td><td>采用汉字、字符和子词三种分词方式，支持多语言</td><td>2018年</td><td>T5、ALBERT</td></tr></tbody></table><h3 id="背景与基础">背景与基础</h3><p>在使用GPT BERT模型输入词语常常会先进行tokenize，tokenize的目标是把输入的文本流，<strong>切分成一个个子串，每个子串相对有完整的语义</strong>，便于学习embedding表达和后续模型的使用。</p><p>tokenize有三种粒度：<strong>word/subword/char</strong></p><ul><li><strong>word/词</strong>，词，是最自然的语言单元。对于英文等自然语言来说，存在着天然的分隔符，如空格或一些标点符号等，对词的切分相对容易。但是对于一些东亚文字包括中文来说，就需要某种分词算法才行。顺便说一下，Tokenizers库中，基于规则切分部分，<strong>采用了spaCy和Moses两个库</strong>。如果基于词来做词汇表，由于长尾现象的存在，<strong>这个词汇表可能会超大</strong>。像TransformerXL库就用到了一个<strong>26.7万</strong>个单词的词汇表。这需要极大的embeddingmatrix才能存得下。embedding matrix是用于查找取用token的embeddingvector的。这对于内存或者显存都是极大的挑战。常规的词汇表，<strong>一般大小不超过5万</strong>。</li><li><strong>char/字符</strong>，即最基本的字符，如英语中的'a','b','c'或中文中的'你'，'我'，'他'等。而一般来讲，字符的数量是<strong>少量有限</strong>的。这样做的问题是，由于字符数量太小，我们在为每个字符学习嵌入向量的时候，每个向量就容纳了太多的语义在内，学习起来非常困难。</li><li><strong>subword/子词级</strong>，它介于字符和单词之间。比如说'Transformers'可能会被分成'Transform'和'ers'两个部分。这个方案<strong>平衡了词汇量和语义独立性</strong>，是相对较优的方案。它的处理原则是，<strong>常用词应该保持原状，生僻词应该拆分成子词以共享token压缩空间</strong>。</li></ul><h2 id="常用的tokenize算法">7.2 常用的tokenize算法</h2><p>最常用的三种tokenize算法：BPE（Byte-PairEncoding)，WordPiece和SentencePiece</p><h3 id="bpebyte-pair-encoding">7.2.1 BPE（Byte-Pair Encoding)</h3><p>BPE，即字节对编码。其核心思想在于将<strong>最常出现的子词对合并，直到词汇表达到预定的大小时停止</strong>。</p><p>BPE是一种基于数据压缩算法的分词方法。它通过不断地合并出现频率最高的字符或者字符组合，来构建一个词表。具体来说，BPE的运算过程如下：</p><ol type="1"><li>将所有单词按照字符分解为字母序列。例如：“hello”会被分解为["h","e","l","l","o"]。</li><li>统计每个字母序列出现的频率，将频率最高的序列合并为一个新序列。</li><li>重复第二步，直到达到预定的词表大小或者无法再合并。</li></ol><p>词表大小通常先增加后减小</p><p>每次合并后词表可能出现3种变化：</p><ul><li><code>+1</code>，表明加入合并后的新字词，同时原来的2个子词还保留（2个字词不是完全同时连续出现）</li><li><code>+0</code>，表明加入合并后的新字词，同时原来的2个子词中一个保留，一个被消解（一个字词完全随着另一个字词的出现而紧跟着出现）</li><li><code>-1</code>，表明加入合并后的新字词，同时原来的2个子词都被消解（2个字词同时连续出现）</li></ul><h3 id="wordpiece">7.2.2 WordPiece</h3><p>WordPiece，从名字好理解，它是一种<strong>子词粒度的tokenize算法</strong>subwordtokenizationalgorithm，很多著名的Transformers模型，比如BERT/DistilBERT/Electra都使用了它。</p><p>wordpiece算法可以看作是BPE的变种。不同的是，WordPiece基于概率生成新的subword而不是下一最高频字节对。WordPiece算法也是每次从词表中选出两个子词合并成新的子词。BPE选择频数最高的相邻子词合并，而WordPiece选择使得语言模型概率最大的相邻子词加入词表。即它每次合并的两个字符串A和B，应该具有最大的<spanclass="math inline">\(\frac{P(A B)}{P(A)P(B)}\)</span>值。合并AB之后，所有原来切成A+B两个tokens的就只保留AB一个token，整个训练集上最大似然变化量与<spanclass="math inline">\(\frac{P(A B)}{P(A) P(B)}\)</span>成正比。</p><p><span class="math display">\[\log P(S)=\sum_{i=1}^{n} \log P\left(t_{i}\right)\]</span></p><p><span class="math display">\[S=\left[t_{1}, t_{2}, t_{3}, \ldots, t_{n}\right]\]</span></p><p>比如说 $ P(ed) <span class="math inline">\(的概率比\)</span>P(e) +P(d)$单独出现的概率更大，可能比他们具有最大的互信息值，也就是两子词在语言模型上具有较强的关联性。</p><p>那wordPiece和BPE的区别：</p><ul><li><strong>BPE</strong>： apple 当词表有appl 和e的时候，apple优先编码为 appl和e（即使原始预料中 app 和 le的可能性更大）</li><li><strong>wordPiece</strong>：根据原始语料， app和le的概率更大 </li></ul><h3 id="unigram">7.2.3 Unigram</h3><p>与BPE或者WordPiece不同，Unigram的算法思想是<strong>从一个巨大的词汇表出发</strong>，再<strong>逐渐删除trimdown其中的词汇</strong>，直到size满足预定义。</p><p>初始的词汇表可以<strong>采用所有预分词器分出来的词，再加上所有高频的子串</strong>。</p><p>每次从词汇表中删除词汇的<strong>原则是使预定义的损失最小</strong>。训练时，计算loss的公式为：</p><p><span class="math display">\[Loss =-\sum_{i=1}^{N} \log \left(\sum_{x \in S\left(x_{i}\right)}p(x)\right)\]</span></p><p>假设训练文档中的所有词分别为<span class="math inline">\(x_{1} ;x_{2}, \ldots,x_{N}\)</span>，而<strong>每个词tokenize的方法</strong>是一个集合<spanclass="math inline">\(S\left(x_{i}\right)\)</span></p><p>当一个词汇表确定时，每个词tokenize的方法集合<spanclass="math inline">\(S\left(x_{i}\right)\)</span>就是确定的，而每种方法对应着一个概率<spanclass="math inline">\(P(x)\)</span>.</p><p>如果从词汇表中删除部分词，则某些词的tokenize的种类集合就会变少，log(*)中的求和项就会减少，从而增加整体loss。</p><p>Unigram算法每次<strong>会从词汇表中挑出使得loss增长最小的10%~20%的词汇</strong>来删除。</p><p>一般Unigram算法会与SentencePiece算法连用。</p><h3 id="sentencepiece">7.2.4 SentencePiece</h3><p>SentencePiece，顾名思义，它是<strong>把一个句子看作一个整体，再拆成片段</strong>，而没有保留天然的词语的概念。一般地，它<strong>把空格space也当作一种特殊字符来处理，再用BPE或者Unigram算法来构造词汇表</strong>。</p><p>比如，XLNetTokenizer就<strong>采用了_来代替空格</strong>，解码的时候会再用空格替换回来。</p><p>目前，Tokenizers库中，所有使用了SentencePiece的都是与Unigram算法联合使用的，比如ALBERT、XLNet、Marian和T5.</p><h1 id="长度外推问题篇">8 长度外推问题篇</h1><h2 id="长度外推问题">8.1 长度外推问题</h2><p>大模型的外推性问题是指<strong>大模型在训练时和预测时的输入长度不一致，导致模型的泛化能力下降的问题</strong>。在目前的大模型中，一般指的是超出预训练设置的上下文长度时，依旧保持良好推理效果的能力。</p><p>长度外推性=train short, test long</p><p><strong>trainshort</strong>：1）受限于训练成本；2）大部分文本的长度不会特别长，训练时的max_length特别特别大其实意义不大（长尾）。</p><p><strong>testlong</strong>：这里long是指比训练时的max_length长，希望不用微调就能在长文本上也有不错的效果。</p><h2 id="长度外推问题的解决方法有哪些">8.2长度外推问题的解决方法有哪些？</h2><h3 id="进制表示">（1）进制表示</h3><p>我们将整数n以一个三维向量[a,b,c]来输入，a,b,c分别是n的百位、十位、个位。这样，我们既缩小了数字的跨度，又没有缩小相邻数字的差距，代价了增加了输入的维度——刚好，神经网络擅长处理高维数据。</p><p>如果想要进一步缩小数字的跨度，我们还可以进一步缩小进制的基数，如使用8进制、6进制甚至2进制，代价是进一步增加输入的维度。</p><h3 id="直接外推">（2）直接外推</h3><p>简单来说，假如原来位置编码用三维向量表示，那外插就是直接增加一维。</p><p>可以提前预留多几维，训练阶段设为0，推理阶段直接改为其他数字，这就是外推（Extrapolation）。</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240314113451952.png" alt="长度外推问题的示意图" style="zoom:50%;" /></p><p>然而，训练阶段预留的维度一直是0，如果推理阶段改为其他数字，效果不见得会好，因为模型对没被训练过的情况不一定具有适应能力。也就是说，<strong>由于某些维度的训练数据不充分，所以直接进行外推通常会导致模型的性能严重下降</strong>。</p><h3 id="线性插值">（3）线性插值</h3><p>就是将2000以内压缩到1000以内，比如通过除以2，1749就变成了874.5，然后转为三维向量[8,7,4.5]输入到原来的模型中。从绝对数值来看，新的[7,4,9]实际上对应的是1498，是原本对应的2倍，映射方式不一致；从相对数值来看，原本相邻数字的差距为1，现在是0.5，最后一个维度更加“拥挤”。所以，做了内插修改后，通常都需要微调训练，以便模型重新适应拥挤的映射关系。</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240314113638944.png" alt="线性插值的表示" style="zoom:50%;" /></p><h3 id="进制转换">（4）进制转换</h3><p>有没有不用新增维度，又能保持相邻差距的方案呢？<strong>进制转换</strong>！三个数字的10进制编码可以表示0～999，如果是16进制呢？它最大可以表示163−1=4095&gt;1999。所以，只需要转到16进制，如1749变为[6,13,5]，那么三维向量就可以覆盖目标范围，代价是每个维度的数字从0～9变为0～15。</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240314113741425.png"alt="进制转换的示意图" /><figcaption aria-hidden="true">进制转换的示意图</figcaption></figure><h1 id="其他文章参考">其他文章参考</h1><p>深度学习八股文，这里将会收集深度学习中的基本概念和常见的问题，以下是主要的参考文章</p><ul><li><ahref="https://zhuanlan.zhihu.com/p/560482252">https://zhuanlan.zhihu.com/p/560482252</a></li><li><ahref="https://blog.csdn.net/weixin_42693876/article/details/120345924">https://blog.csdn.net/weixin_42693876/article/details/120345924</a></li><li><ahref="https://zhuanlan.zhihu.com/p/667048896">https://zhuanlan.zhihu.com/p/667048896</a></li></ul><p>LLAMA2结构<ahref="https://blog.csdn.net/sikh_0529/article/details/134375318">https://blog.csdn.net/sikh_0529/article/details/134375318</a></p><p>旋转位置嵌入<ahref="https://www.zhihu.com/tardis/zm/art/647109286?source_id=1005">https://www.zhihu.com/tardis/zm/art/647109286?source_id=1005</a></p><p>bert模型细节 <ahref="https://www.zhihu.com/question/534763354">https://www.zhihu.com/question/534763354</a></p><p>为什么Bert三个embedding可以相加 <ahref="https://www.zhihu.com/question/374835153/answer/1080315948">https://www.zhihu.com/question/374835153/answer/1080315948</a></p><p>Qlora <ahref="https://zhuanlan.zhihu.com/p/618894919">https://zhuanlan.zhihu.com/p/618894919</a></p><p>RLHF <ahref="https://zhuanlan.zhihu.com/p/631238431">https://zhuanlan.zhihu.com/p/631238431</a></p><p>LLAMA2 colab<ahref="https://zhuanlan.zhihu.com/p/652588148">https://zhuanlan.zhihu.com/p/652588148</a></p><p>LLAMA2+QLora微调大模型<ahref="https://www.bilibili.com/video/BV1594y1y76m/?spm_id_from=333.337.search-card.all.click&amp;vd_source=9710fe8f4dbfeb6bd0b7202815b341c2">https://www.bilibili.com/video/BV1594y1y76m/?spm_id_from=333.337.search-card.all.click&amp;vd_source=9710fe8f4dbfeb6bd0b7202815b341c2</a></p><p>fine-tuning llama2<ahref="https://ukey.co/blog/finetune-llama-2-peft-qlora-huggingface/">https://ukey.co/blog/finetune-llama-2-peft-qlora-huggingface/</a></p><p>fine-tuning Llama 2 with PEFT's QLoRa <ahref="https://ukey.co/blog/finetune-llama-2-peft-qlora-huggingface/">https://ukey.co/blog/finetune-llama-2-peft-qlora-huggingface/</a></p><h1 id="基础代码">基础代码</h1><h2 id="pytorch实现基础网络">PyTorch实现基础网络</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicNet</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, input_dim=<span class="hljs-number">784</span>, hidden_dim1=<span class="hljs-number">256</span>, hidden_dim2=<span class="hljs-number">128</span>, output_dim=<span class="hljs-number">10</span></span>):<br>        <span class="hljs-built_in">super</span>(BasicNet, self).__init__()<br>        self.fc1 = nn.Linear(input_dim, hidden_dim1)<br>        self.fc2 = nn.Linear(hidden_dim1, hidden_dim2)<br>        self.fc3 = nn.Linear(hidden_dim2, output_dim)<br>        self.relu = nn.ReLU()<br>        self.batchnorm1 = nn.BatchNorm1d(hidden_dim1)<br>        self.batchnorm2 = nn.BatchNorm1d(hidden_dim2)<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = self.relu(self.batchnorm1(self.fc1(x)))<br>        x = self.relu(self.batchnorm2(self.fc2(x)))<br>        x = self.fc3(x)<br>        <span class="hljs-keyword">return</span> x<br><br><span class="hljs-comment"># 创建模型</span><br>model = BasicNet()<br><br><span class="hljs-comment"># 定义损失函数</span><br>criterion = nn.CrossEntropyLoss()<br><br><span class="hljs-comment"># 定义优化器</span><br>optimizer = optim.Adam(model.parameters(), lr=<span class="hljs-number">0.001</span>)<br><br><span class="hljs-comment"># 训练模型</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">train</span>(<span class="hljs-params">model, train_loader, criterion, optimizer, num_epochs=<span class="hljs-number">5</span></span>):<br>    model.train()<br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):<br>        running_loss = <span class="hljs-number">0.0</span><br>        <span class="hljs-keyword">for</span> i, (inputs, labels) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(train_loader):<br>            optimizer.zero_grad()<br>            outputs = model(inputs)<br>            loss = criterion(outputs, labels)<br>            loss.backward()<br>            optimizer.step()<br>            running_loss += loss.item()<br>            <span class="hljs-keyword">if</span> (i+<span class="hljs-number">1</span>) % <span class="hljs-number">100</span> == <span class="hljs-number">0</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Epoch [<span class="hljs-subst">&#123;epoch+<span class="hljs-number">1</span>&#125;</span>/<span class="hljs-subst">&#123;num_epochs&#125;</span>], Step [<span class="hljs-subst">&#123;i+<span class="hljs-number">1</span>&#125;</span>/<span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(train_loader)&#125;</span>], Loss: <span class="hljs-subst">&#123;running_loss/<span class="hljs-number">100</span>:<span class="hljs-number">.4</span>f&#125;</span>&#x27;</span>)<br>                running_loss = <span class="hljs-number">0.0</span><br><br><span class="hljs-comment"># 保存模型</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">save_model</span>(<span class="hljs-params">model, filepath</span>):<br>    torch.save(model.state_dict(), filepath)<br><br><span class="hljs-comment"># 加载模型</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_model</span>(<span class="hljs-params">model, filepath</span>):<br>    model.load_state_dict(torch.load(filepath))<br>    model.<span class="hljs-built_in">eval</span>()  <span class="hljs-comment"># 设置为评估模式</span><br><br><span class="hljs-comment"># 示例数据加载</span><br><span class="hljs-comment"># train_loader = torch.utils.data.DataLoader(train_dataset, batch_size=64, shuffle=True)</span><br><br><span class="hljs-comment"># 示例训练过程</span><br><span class="hljs-comment"># train(model, train_loader, criterion, optimizer)</span><br><br><span class="hljs-comment"># 示例模型保存</span><br><span class="hljs-comment"># save_model(model, &#x27;model.pth&#x27;)</span><br><br><span class="hljs-comment"># 示例模型加载</span><br><span class="hljs-comment"># loaded_model = BasicNet()</span><br><span class="hljs-comment"># load_model(loaded_model, &#x27;model.pth&#x27;)</span><br><br></code></pre></td></tr></table></figure><h2 id="batch-norm代码实现">Batch Norm代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBN</span>:<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, momentum=<span class="hljs-number">0.01</span>, eps=<span class="hljs-number">1e-5</span>, feat_dim=<span class="hljs-number">2</span></span>):<br>    self._running_mean = np.zeros(shape = (feat_dim,))<br>    self._running_var = np.ones(shape = (fear_dim,))<br>    self._momentum = momentum<br>    <span class="hljs-comment">#防止分母计算为0</span><br>    self._eps = eps<br>    <br>    <span class="hljs-comment">#对应batch norm中需要更新beta 和 gamma， 采用pytorch文档中的初始化</span><br>    self._beta = np.zeros(shape=(feat_dim,))<br>    self._gamma = np.ones(shape=(feat_dim,))<br>    <br>    <br>   <span class="hljs-keyword">def</span> <span class="hljs-title function_">batch_norm</span>(<span class="hljs-params">self, x</span>):<br>    <span class="hljs-keyword">if</span> self.training:<br>      x_mean = x.mean(axis=<span class="hljs-number">0</span>)<br>      x_var = x.var(axis=<span class="hljs-number">0</span>)<br>      <span class="hljs-comment">#对应running_mean的更新公式</span><br>      self._running_mean = (<span class="hljs-number">1</span>-self._momentum)*x_mean +self._momentum*self._running_mean<br>      self._running_var = (<span class="hljs-number">1</span>-self._momentum)*x_var + self._momentum*self._running_var<br>      <span class="hljs-comment">#对应论文中计算BN公式</span><br>      x_hat = (x-x_mean)/np.sqrt(x_var+self._eps)<br>    <span class="hljs-keyword">else</span>:<br>      x_hat = (x-self._running_mean)/np.sqrt(self._running_var+self._eps)<br>    <span class="hljs-keyword">return</span> self._gamma*x_hat + self._beta<br></code></pre></td></tr></table></figure><h2 id="pytorch实现attention">PyTorch实现Attention</h2><p>自注意力机制的实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sqrt<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SelfAttention</span>(nn.Module):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, dim_in, dim_k, dim_v</span>):<br>    <span class="hljs-built_in">super</span>(SelfAttention, self).__init__()<br>    self.dim_in = dim_in<br>    self.dim_k = dim_k<br>    self.dim_v = dim_v<br>    self.linear_q = nn.Linear(dim_in, dim_k, bias=<span class="hljs-literal">False</span>)<br>    self.linear_k = nn.Linear(dim_in, dim_k, bias=<span class="hljs-literal">False</span>)<br>    self.linear_v = nn.Linear(dim_in, dim_v, bias=<span class="hljs-literal">False</span>)<br>    self._norm_fact = <span class="hljs-number">1</span>/sqrt(dim_k)<br>    <br>    <br>   <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>    batch, n, dim_in = x.shape<br>    <span class="hljs-keyword">assert</span> dim_in == self.dim_in<br>    <br>    q = self.linear_q(x) <span class="hljs-comment">#batch, n, dim_k</span><br>    k = self.linear_k(x)<br>    v = self.linear_v(x)<br>    <br>    dist = torch.bmm(q, k.transpose(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>))* self._norm_fact <span class="hljs-comment">#batch, n, n</span><br>    dist = torch.softmax(dist, dim=-<span class="hljs-number">1</span>)<br>    <br>    att = torch.bmm(dist, v)<br>    <span class="hljs-keyword">return</span> att<br>    <br></code></pre></td></tr></table></figure><p>多头注意力机制的实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sqrt<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiHeadAttention</span>(nn.Module):<br>  <span class="hljs-comment">#dim_in input dimention</span><br>  <span class="hljs-comment">#dim_k kq dimention</span><br>  <span class="hljs-comment">#dim_v value dimention</span><br>  <span class="hljs-comment">#num_heads number of heads</span><br>  <br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, dim_in, dim_k, dim_v, num_heads=<span class="hljs-number">8</span></span>):<br>    <span class="hljs-built_in">super</span>(MultiHeadAttention, self).__init__()<br>    <span class="hljs-keyword">assert</span> dim_k% num_heads ==<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> dim_v% num_heads ==<span class="hljs-number">0</span><br>    <br>    self.dim_in = dim_in<br>    self.dim_k = dim_k<br>    self.dim_v = dim_v<br>    self.num_heads = num_heads<br>    self.linear_q = nn.Linear(dim_in, dim_k, bias==<span class="hljs-literal">False</span>)<br>    self.linear_k = nn.Linear(dim_in, dim_k, bias==<span class="hljs-literal">False</span>)<br>    self.linear_v = nn.Linear(dim_in, dim_v, bias==<span class="hljs-literal">False</span>)<br>    self._norm_fact = <span class="hljs-number">1</span>/sqrt(dim_k//num_heads)<br>    <br>   <span class="hljs-keyword">def</span> <span class="hljs-title function_">forwards</span>(<span class="hljs-params">self, x</span>):<br>    <span class="hljs-comment"># x: tensor of shape(batch, n, dim_in)</span><br>    batch, n, dim_in = x.shape<br>    <span class="hljs-keyword">assert</span> dim_in = self.dim_in<br>    <br>    nh = self.num_heads<br>    dk = self.dim_k // nh<br>    dv = self.dim_v // nh<br>    <br>    q = self.linear_q(x).reshape(batch, n, nh, dk).transpose(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>    k = self.linear_k(x).reshape(batch, n, nh, dk).transpose(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>    v = self.linear_v(x).reshape(batch, n, nk, dk).transpose(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>    <br>    dist = torch.matmul(q, k.transpose(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))*self._norm_fact<br>    dist = torch.softmax(dist, dim=-<span class="hljs-number">1</span>)<br>    <br>    att = torch.matmul(dist, v)<br>    att = att.transpose(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>).reshape(batch, n, self.dim_v)<br></code></pre></td></tr></table></figure><h3 id="pytorch实现dqn">PyTorch实现DQN</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DQN</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, input_dim, output_dim</span>):<br>        <span class="hljs-built_in">super</span>(DQN, self).__init__()<br>        self.fc1 = nn.Linear(input_dim, <span class="hljs-number">128</span>)<br>        self.fc2 = nn.Linear(<span class="hljs-number">128</span>, <span class="hljs-number">128</span>)<br>        self.fc3 = nn.Linear(<span class="hljs-number">128</span>, output_dim)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = torch.relu(self.fc1(x))<br>        x = torch.relu(self.fc2(x))<br>        x = self.fc3(x)<br>        <span class="hljs-keyword">return</span> x<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DQNAgent</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, input_dim, output_dim, gamma=<span class="hljs-number">0.99</span>, lr=<span class="hljs-number">0.001</span></span>):<br>        self.input_dim = input_dim<br>        self.output_dim = output_dim<br>        self.gamma = gamma<br>        self.lr = lr<br>        self.device = torch.device(<span class="hljs-string">&quot;cuda&quot;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span>)<br>        self.policy_net = DQN(input_dim, output_dim).to(self.device)<br>        self.target_net = DQN(input_dim, output_dim).to(self.device)<br>        self.target_net.load_state_dict(self.policy_net.state_dict())<br>        self.target_net.<span class="hljs-built_in">eval</span>()<br>        self.optimizer = optim.Adam(self.policy_net.parameters(), lr=lr)<br>        self.loss_fn = nn.MSELoss()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">select_action</span>(<span class="hljs-params">self, state, epsilon</span>):<br>        <span class="hljs-keyword">if</span> np.random.rand() &lt; epsilon:<br>            <span class="hljs-keyword">return</span> np.random.randint(self.output_dim)<br>        state = torch.FloatTensor(state).unsqueeze(<span class="hljs-number">0</span>).to(self.device)<br>        <span class="hljs-keyword">with</span> torch.no_grad():<br>            q_values = self.policy_net(state)<br>        <span class="hljs-keyword">return</span> q_values.<span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>)[<span class="hljs-number">1</span>].item()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">train</span>(<span class="hljs-params">self, replay_buffer, batch_size</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(replay_buffer) &lt; batch_size:<br>            <span class="hljs-keyword">return</span><br>        transitions = replay_buffer.sample(batch_size)<br>        batch = Transition(*<span class="hljs-built_in">zip</span>(*transitions))<br>        state_batch = torch.FloatTensor(batch.state).to(self.device)<br>        next_state_batch = torch.FloatTensor(batch.next_state).to(self.device)<br>        action_batch = torch.LongTensor(batch.action).unsqueeze(<span class="hljs-number">1</span>).to(self.device)<br>        reward_batch = torch.FloatTensor(batch.reward).unsqueeze(<span class="hljs-number">1</span>).to(self.device)<br>        done_batch = torch.FloatTensor(batch.done).unsqueeze(<span class="hljs-number">1</span>).to(self.device)<br><br>        current_q_values = self.policy_net(state_batch).gather(<span class="hljs-number">1</span>, action_batch)<br>        next_q_values = self.target_net(next_state_batch).<span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>].unsqueeze(<span class="hljs-number">1</span>)<br>        target_q_values = reward_batch + (<span class="hljs-number">1</span> - done_batch) * self.gamma * next_q_values<br><br>        loss = self.loss_fn(current_q_values, target_q_values.detach())<br>        self.optimizer.zero_grad()<br>        loss.backward()<br>        self.optimizer.step()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update_target_net</span>(<span class="hljs-params">self</span>):<br>        self.target_net.load_state_dict(self.policy_net.state_dict())<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReplayBuffer</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, capacity</span>):<br>        self.capacity = capacity<br>        self.buffer = []<br>        self.position = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, state, action, reward, next_state, done</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.buffer) &lt; self.capacity:<br>            self.buffer.append(<span class="hljs-literal">None</span>)<br>        self.buffer[self.position] = (state, action, reward, next_state, done)<br>        self.position = (self.position + <span class="hljs-number">1</span>) % self.capacity<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sample</span>(<span class="hljs-params">self, batch_size</span>):<br>        <span class="hljs-keyword">return</span> random.sample(self.buffer, batch_size)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.buffer)<br><br>Transition = namedtuple(<span class="hljs-string">&#x27;Transition&#x27;</span>, (<span class="hljs-string">&#x27;state&#x27;</span>, <span class="hljs-string">&#x27;action&#x27;</span>, <span class="hljs-string">&#x27;reward&#x27;</span>, <span class="hljs-string">&#x27;next_state&#x27;</span>, <span class="hljs-string">&#x27;done&#x27;</span>))<br><br></code></pre></td></tr></table></figure><h3 id="pytorch实现ppo">PyTorch实现PPO</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ActorCritic</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, input_dim, output_dim</span>):<br>        <span class="hljs-built_in">super</span>(ActorCritic, self).__init__()<br>        self.fc1 = nn.Linear(input_dim, <span class="hljs-number">128</span>)<br>        self.fc2 = nn.Linear(<span class="hljs-number">128</span>, <span class="hljs-number">128</span>)<br>        self.fc_actor = nn.Linear(<span class="hljs-number">128</span>, output_dim)<br>        self.fc_critic = nn.Linear(<span class="hljs-number">128</span>, <span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = torch.relu(self.fc1(x))<br>        x = torch.relu(self.fc2(x))<br>        logits = self.fc_actor(x)<br>        value = self.fc_critic(x)<br>        <span class="hljs-keyword">return</span> logits, value<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PPOAgent</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, input_dim, output_dim, gamma=<span class="hljs-number">0.99</span>, lr=<span class="hljs-number">0.001</span></span>):<br>        self.input_dim = input_dim<br>        self.output_dim = output_dim<br>        self.gamma = gamma<br>        self.lr = lr<br>        self.device = torch.device(<span class="hljs-string">&quot;cuda&quot;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span>)<br>        self.policy_net = ActorCritic(input_dim, output_dim).to(self.device)<br>        self.optimizer = optim.Adam(self.policy_net.parameters(), lr=lr)<br>        self.loss_fn = nn.MSELoss()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">select_action</span>(<span class="hljs-params">self, state</span>):<br>        state = torch.FloatTensor(state).unsqueeze(<span class="hljs-number">0</span>).to(self.device)<br>        <span class="hljs-keyword">with</span> torch.no_grad():<br>            logits, _ = self.policy_net(state)<br>        action_probs = torch.softmax(logits, dim=-<span class="hljs-number">1</span>)<br>        action = np.random.choice(np.arange(self.output_dim), p=action_probs.cpu().numpy().ravel())<br>        <span class="hljs-keyword">return</span> action<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">train</span>(<span class="hljs-params">self, states, actions, rewards, next_states, dones, old_log_probs, epsilon_clip=<span class="hljs-number">0.2</span>, num_epochs=<span class="hljs-number">10</span></span>):<br>        states = torch.FloatTensor(states).to(self.device)<br>        actions = torch.LongTensor(actions).unsqueeze(-<span class="hljs-number">1</span>).to(self.device)<br>        rewards = torch.FloatTensor(rewards).unsqueeze(-<span class="hljs-number">1</span>).to(self.device)<br>        next_states = torch.FloatTensor(next_states).to(self.device)<br>        dones = torch.FloatTensor(dones).unsqueeze(-<span class="hljs-number">1</span>).to(self.device)<br>        old_log_probs = torch.FloatTensor(old_log_probs).unsqueeze(-<span class="hljs-number">1</span>).to(self.device)<br><br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):<br>            logits, values = self.policy_net(states)<br>            new_log_probs = torch.log_softmax(logits, dim=-<span class="hljs-number">1</span>).gather(<span class="hljs-number">1</span>, actions)<br>            ratio = (new_log_probs - old_log_probs).exp()<br>            advantages = rewards - values.detach()<br><br>            surr1 = ratio * advantages<br>            surr2 = torch.clamp(ratio, <span class="hljs-number">1.0</span> - epsilon_clip, <span class="hljs-number">1.0</span> + epsilon_clip) * advantages<br>            actor_loss = -torch.<span class="hljs-built_in">min</span>(surr1, surr2).mean()<br><br>            critic_loss = <span class="hljs-number">0.5</span> * (rewards - values).<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>).mean()<br><br>            loss = actor_loss + <span class="hljs-number">0.5</span> * critic_loss<br><br>            self.optimizer.zero_grad()<br>            loss.backward()<br>            self.optimizer.step()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【深度学习】推荐系统算法总结</title>
    <link href="/2024/02/04/dl_rec_al/"/>
    <url>/2024/02/04/dl_rec_al/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="推荐系统算法总结">推荐系统算法总结</h1><p>推荐系统近几年有了深度学习的助推发展之势迅猛，从前深度学习的传统推荐模型(协同过滤，矩阵分解，LR, FM, FFM,GBDT)到深度学习的浪潮之巅(DNN, Deep Crossing, DIN, DIEN, Wide&amp;Deep,Deep&amp;Cross, DeepFM, AFM, NFM, PNN, FNN,DRN)。推荐系统<strong>通过分析用户的历史行为给用户的兴趣建模，从而主动给用户推荐给能够满足他们兴趣和需求的信息</strong></p><h2 id="传统模型recall">传统模型(Recall)</h2><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240205155007538.png" alt="传统推荐算法宏观框架" style="zoom: 50%;" /></p><h3 id="数据集介绍">数据集介绍</h3><p><ahref="https://github.com/ZiyaoGeng/RecLearn/wiki/Movielens">https://github.com/ZiyaoGeng/RecLearn/wiki/Movielens</a></p><h4 id="rating">rating</h4><p>标签列表为：<code>UserID::MovieID::Rating::Timestamp</code></p><ul><li>UserIDs：用户ID（1～6040）</li><li>MovieIDs：电影ID（1～3952）</li><li>Ratings：评分（1～5）</li><li>Timestamp：时间戳</li></ul><h4 id="user">user</h4><p>标签列表为：<code>UserID::Gender::Age::Occupation::Zip-code</code></p><ul><li>Gender：性别， "M"代表男， "F"代表女；</li><li>Age：年龄，分为多个区间：<code>1，18， 25， 35， 45， 50；</code></li><li>Occupation：职业，0～20；</li></ul><h4 id="movies">movies</h4><p>标签列表为：<code>MovieID::Title::Genres</code></p><ul><li>Titles：电影名称；</li><li>Genres：电影分类</li></ul><h3 id="基于内容的推荐">基于内容的推荐</h3><p>这是一种比较简单的推荐方法，基于内容的推荐方法是非常直接的，它以物品的内容描述信息为依据来做出的推荐，本质上是基于对物品和用户自身的特征或属性的直接分析和计算。例如，假设已知电影A是一部喜剧，而恰巧我们得知某个用户喜欢看喜剧电影，那么我们基于这样的已知信息，就可以将电影A推荐给该用户。具体实现步骤：</p><ul><li>构建物品画像(主要包括物品的分类信息，标题， 各种属性等等)</li><li>构建用户画像(主要包括用户的喜好， 行为的偏好，基本的人口学属性，活跃程度，风控维度)</li><li>根据用户的兴趣， 去找相应的物品， 实施推荐。</li></ul><h4 id="基本流程">基本流程</h4><ul><li>建立物品画像<ul><li>基于用户给电影打的tag和电影的分类值，得到每一部电影的总标签</li><li>求每一部电影标签的tf-idf值</li><li>根据tf-idf的结果，为每一部电影选择top-n（tf-idf值较大)的关键词作为整部电影的关键词，最后得到了<code>电影id— 关键词 — 关键词权重</code></li></ul></li><li>建立倒排索引<ul><li>这个是为了能够根据关键词找到对应的电影，好方便得到用户画像之后(用户喜欢啥样的电影)对用户进行一些推荐</li></ul></li><li>建立用户画像<ul><li>看用户看过哪些电影， 基于前面的物品画像找到电影对应的关键词</li><li>把用户看过的所有关键词放到一起， 统计词频， 每个词出现了几次</li><li>出现次数最多的关键词作为用户的兴趣词， 这个就是用户的画像</li><li>根据用户的兴趣词， 基于倒排表找到电影，就可以对用户实施推荐了。</li></ul></li></ul><h4 id="物品画像">物品画像</h4><p>本质上是基于对<strong>物品和用户自身的特征或属性</strong>的直接分析和计算</p><p><strong>构建标签数据集</strong></p><p>数据集的四列关键词为：<strong><code>userId, movieId, tag, timestamp</code></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">_tags = pd.read_csv(<span class="hljs-string">&quot;ml-latest-small/all-tags.csv&quot;</span>, usecols=<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)).dropna()<br><span class="hljs-comment">#使用的范围是1-2列，dropna是将数值为nan的删除</span><br><br>tags = _tags.groupby(<span class="hljs-string">&quot;movieId&quot;</span>).agg(<span class="hljs-built_in">list</span>)<br><span class="hljs-comment">#根据某个名为movieId的列进行分组，并对每个组执行聚合操作，将每个组的标签列表合并为一个列表</span><br><br>tags.head()<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240204113943282.png" alt="聚合之后的列表数据集" style="zoom:50%;" /></p><p><strong>构建物料数据</strong></p><p>数据集关键标签为：<strong><code>movieId, title, genres</code></strong></p><hr /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">movies = pd.read_csv(<span class="hljs-string">&quot;ml-latest-small/movies.csv&quot;</span>, index_col=<span class="hljs-string">&quot;movieId&quot;</span>)<br><span class="hljs-comment">#参数告诉函数将CSV文件中的第一列（即电影ID列）作为DataFrame的索引</span><br><br>movies[<span class="hljs-string">&#x27;genres&#x27;</span>] = movies[<span class="hljs-string">&#x27;genres&#x27;</span>].apply(<span class="hljs-keyword">lambda</span> x: x.split(<span class="hljs-string">&quot;|&quot;</span>))<br><span class="hljs-comment">#.apply(lambda x: x.split(&quot;|&quot;)) 用于对genres列中的每个元素应用一个lambda函数。这个lambda函数接受一个参数x，并返回x split by &quot;|“的结果，即将字符串x按”|&quot;分割成列表</span><br><br>movies.head()<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240204114536506.png" alt="物品标签处理" style="zoom:50%;" /></p><p><strong>合并物品和标签的列表</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">movies_index = <span class="hljs-built_in">set</span>(movies.index) &amp; <span class="hljs-built_in">set</span>(tags.index)<br><span class="hljs-comment">#set(movies.index)  set(tags.index) 将索引转换为一个集合，去除了重复的索引值。</span><br><span class="hljs-comment">#&amp;set(tags.index) 返回两个集合中共同的元素组成的新集合。</span><br><br>new_tags = tags.loc[<span class="hljs-built_in">list</span>(movies_index)]<br><span class="hljs-comment">#根据之前得到的交集集合movies_index来筛选tags，只保留那些与movies DataFrame有相同索引的电影的标签</span><br><br>ret = movies.join(new_tags)<br><span class="hljs-comment">#这段代码的作用是将两个DataFrame（movies和tags）根据共同的索引（电影ID）进行合并</span><br><br>ret.head()<br></code></pre></td></tr></table></figure><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240204115110070.png"alt="image-20240204115110070" /><figcaption aria-hidden="true">image-20240204115110070</figcaption></figure><p>数据处理并补充缺失值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">df = <span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: (x[<span class="hljs-number">0</span>], x[<span class="hljs-number">1</span>], x[<span class="hljs-number">2</span>], x[<span class="hljs-number">2</span>]+x[<span class="hljs-number">3</span>]) <span class="hljs-keyword">if</span> x[<span class="hljs-number">3</span>] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> np.nan <span class="hljs-keyword">else</span> (x[<span class="hljs-number">0</span>], x[<span class="hljs-number">1</span>], x[<span class="hljs-number">2</span>], []), ret.itertuples())<br>movies_dataset = pd.DataFrame(df, columns=[<span class="hljs-string">&#x27;movieId&#x27;</span>, <span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;genres&#x27;</span>, <span class="hljs-string">&#x27;tags&#x27;</span>])<br>movies_dataset.head()<br></code></pre></td></tr></table></figure><p>这段代码的作用是对retDataFrame中的tags列进行处理，将缺失值替换为空列表，并创建一个新的DataFrame，以便于后续的数据分析和处理</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240204124549562.png"alt="数据预处理补充缺失值" /><figcaption aria-hidden="true">数据预处理补充缺失值</figcaption></figure><h4 id="tf-idf模型">TF-IDF模型</h4><p>引入相关的软件包，其中包含了<code>TfidfModel</code>相当于是TFIDF模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> gensim.models <span class="hljs-keyword">import</span> TfidfModel<br><span class="hljs-keyword">from</span> pprint <span class="hljs-keyword">import</span> pprint<br><span class="hljs-keyword">from</span> gensim.corpora <span class="hljs-keyword">import</span> Dictionary<br></code></pre></td></tr></table></figure><p>通常用于创建词典，它将数据集中的所有唯一单词作为键，每个单词出现的次数作为值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">dataset = movies_dataset[<span class="hljs-string">&quot;tags&quot;</span>].values<br><span class="hljs-comment"># 根据数据集建立词袋， 并统计词频， 将所有词放入一个词典， 使用索引进行获取</span><br>dct = Dictionary(dataset)<br><br><span class="hljs-comment"># 对于每条数据， 返回对应的词索引和词频</span><br>corpus = [dct.doc2bow(line) <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> dataset]     <span class="hljs-comment"># 这个东西统计每个单词在每部电影中出现的词频 tf</span><br><br><span class="hljs-comment">#doc2bow将文本转换为词袋模型的表示形式。在词袋模型中，文本被表示为一个矩阵</span><br></code></pre></td></tr></table></figure><p>构建TF-IDF模型并进行展示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 根据这个词频， 就可以训练Tf-IDF模型， 计算TF-IDF值</span><br>model = TfidfModel(corpus)<br><span class="hljs-comment">#corpus中的第一个文档（索引为0）应用TF-IDF模型</span><br>model[corpus[<span class="hljs-number">0</span>]]<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240204132411326.png" alt="TFIDF模型结果展示" style="zoom:50%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 保存每个电影tf-idf值最高的30个标签</span><br>movie_profile = &#123;&#125;<br><span class="hljs-keyword">for</span> i, mid <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(movies_dataset.index):<br>    <span class="hljs-comment"># 对于每部电影， 返回每个标签的tf-idf值</span><br>    tfidf_vec = model[corpus[i]]<br>    <span class="hljs-comment"># 按照tfidf值排序， 然后取Top-N</span><br>    movies_tags = <span class="hljs-built_in">sorted</span>(tfidf_vec, key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>], reverse=<span class="hljs-literal">True</span>)[:<span class="hljs-number">30</span>]<br>    <span class="hljs-comment"># 根据关键词提取对应的名称</span><br>    movie_profile[mid] = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: (dct[x[<span class="hljs-number">0</span>]], x[<span class="hljs-number">1</span>]), movies_tags))<br></code></pre></td></tr></table></figure><p>得出最终的结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">movie_profile = create_movie_profile(movie_dataset)<br>movie_profile.head()<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240204132700842.png" alt="物料数据的处理结果" style="zoom:50%;" /></p><h4 id="建立倒排索引">建立倒排索引</h4><p><strong>倒排索引</strong>就是用物品的其他数据作为索引，去提取他们对应的物品的ID列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 建立倒排索引  为了根据指定关键词迅速匹配到对应的电影，因此需要对物品画像的标签词，建立**倒排索引**</span><br><span class="hljs-comment"># 通常数据存储数据， 都是以物品的ID作为索引， 去提取物品的其他信息数据</span><br><span class="hljs-comment"># 而倒排索引就是用物品的其他数据作为索引， 去提取他们对应的物品的ID列表</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_inverted_table</span>(<span class="hljs-params">movie_profile</span>):<br>    inverted_table = &#123;&#125;<br>    <span class="hljs-keyword">for</span> mid, weights <span class="hljs-keyword">in</span> movie_profile[<span class="hljs-string">&#x27;weights&#x27;</span>].iteritems():<br>        <span class="hljs-keyword">for</span> tag, weight <span class="hljs-keyword">in</span> weights.items():<br>            <span class="hljs-comment"># 到inverted_table dict 用tag作为key去取值， 如果取不到就返回[]</span><br>            _ = inverted_table.get(tag, [])<br>            _.append((mid, weight))<br>            inverted_table.setdefault(tag, _)<br>    <span class="hljs-keyword">return</span> inverted_table<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">inverted_table = create_inverted_table(movie_profile)<br></code></pre></td></tr></table></figure><p>这样就可以<strong>直接根据标签去推荐电影</strong>了</p><h4 id="用户画像">用户画像</h4><p>构建步骤：</p><ol type="1"><li>根据用户的评分历史，结合物品画像，将有观影记录的电影的画像标签作为初始标签反打到用户身上</li><li>通过对用户观影标签的次数进行统计，计算用户的每个初始标签的权重值，排序后选取TOP-N作为用户最终的画像标签</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> collections<br><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#读取了名为ratings.csv的文件，只使用了文件中的第二列和第三列</span><br>watch_record = pd.read_csv(<span class="hljs-string">&quot;ml-latest-small/ratings.csv&quot;</span>, usecols=<span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>), dtype=&#123;<span class="hljs-string">&quot;userId&quot;</span>:np.int32, <span class="hljs-string">&quot;movieId&quot;</span>: np.int32&#125;)<br><br>watch_record = watch_record.groupby(<span class="hljs-string">&quot;userId&quot;</span>).agg(<span class="hljs-built_in">list</span>)<br><br><span class="hljs-comment">#从电影评分数据集中读取用户ID和电影ID</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240204235942580.png" alt="用户ID和电影ID" style="zoom:50%;" /></p><h4 id="产生top-n的推荐">产生Top-N的推荐</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">user_profile = &#123;&#125;<br><span class="hljs-keyword">for</span> uid, mids <span class="hljs-keyword">in</span> watch_record.itertuples():<br>    <span class="hljs-comment"># 这里把当前用户看过的电影从movie_profile中找出来</span><br>    record_movie_profile = movie_profile.loc[<span class="hljs-built_in">list</span>(mids)] <br>    <br>    <span class="hljs-comment"># 下面需要把这些电影的标签都合并到一块， 然后统计出现的次数, 这里的Counter和reduce用的秒</span><br>    counter = collections.Counter(reduce(<span class="hljs-keyword">lambda</span> x, y: <span class="hljs-built_in">list</span>(x) + <span class="hljs-built_in">list</span>(y), record_movie_profile[<span class="hljs-string">&#x27;profile&#x27;</span>].values))<br>    <br>    <span class="hljs-comment"># 兴趣词 从计数器对象中检索出出现次数最多的50个标签/关键词以及它们的计数</span><br>    interest_words = counter.most_common(<span class="hljs-number">50</span>)<br>    maxcount = interest_words[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] <span class="hljs-comment">#这些常见标签中的最大计数</span><br>    <br>    <span class="hljs-comment"># 这里归一化一下</span><br>    interest_words = [(w, <span class="hljs-built_in">round</span>(c/maxcount, <span class="hljs-number">4</span>)) <span class="hljs-keyword">for</span> w, c, <span class="hljs-keyword">in</span> interest_words]  <br>    user_profile[uid] = interest_words<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">user_profile[<span class="hljs-number">1</span>]        <span class="hljs-comment"># 用户1感兴趣的词</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240205002350851.png" alt="例子 用户1感兴趣的词语" style="zoom: 50%;" /></p><p>这个地方根据用户观看的视频以及视频对应的关键词和每个关键词的权重，<strong>给出每个用户感兴趣的关键词的权重归一化之后的值</strong></p><p>注意，这个地方给出的归一化的操作是<strong>使用频率进行归一化操作</strong></p><p><strong>下面给用户进行视频的推荐</strong></p><p>输出对应的用户的uid，推荐的视频编号，以及视频的推荐概率</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> uid, interest_words <span class="hljs-keyword">in</span> user_profile.items():<br>    result_table = &#123;&#125;   <span class="hljs-comment"># 电影id: [0.2, 0.5]</span><br>    <span class="hljs-keyword">for</span> interest_word, interest_weight <span class="hljs-keyword">in</span> interest_words:<br>        related_movies = inverted_table[interest_word]<br>        <span class="hljs-keyword">for</span> mid, relate_weight <span class="hljs-keyword">in</span> related_movies:<br>            _ = result_table.get(mid, [])<br>            _.append(interest_weight)    <span class="hljs-comment">#只考虑用户的兴趣程度</span><br>            <span class="hljs-comment"># _.append(related_weight)   # 只考虑兴趣词与电影的关联程度</span><br>            <span class="hljs-comment"># _.append(interest_weight * related_weight)     # 二者都考虑</span><br>            result_table.setdefault(mid, _)<br>    <br>    rs_result = <span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: (x[<span class="hljs-number">0</span>], <span class="hljs-built_in">sum</span>(x[<span class="hljs-number">1</span>])), result_table.items()) <br>    rs_result = <span class="hljs-built_in">sorted</span>(rs_result, key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>], reverse=<span class="hljs-literal">True</span>)[:<span class="hljs-number">100</span>]<br>    <span class="hljs-built_in">print</span>(uid)<br>    pprint(rs_result)<br>    <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h4 id="冷启动算法">冷启动算法</h4><p>这里主要包括两个很厉害的技术：</p><p><strong>* Word2Vec</strong>: 这个可以根据得到电影标签的词向量，根据这个词向量， 就能够得到tag之间的相似性，这样就能够根据用户看过的某个电影， 得到这个电影的标签，然后根据这些标签得到与其近似的标签，然后得到这些近似标签下的电影对该用户产生推荐</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> gensim.models <span class="hljs-keyword">import</span> Word2Vec<br><br><span class="hljs-comment"># 由于前面我们已经得到了每部影片的tags，物品画像里面。 所以这里我们就可以直接建立word2vec模型， 来进行标签的词向量计算</span><br>sentences = <span class="hljs-built_in">list</span>(movie_profile[<span class="hljs-string">&quot;profile&quot;</span>].values)   <span class="hljs-comment"># 二维列表  每个元素是字符串</span><br><br><span class="hljs-comment"># 这里可以直接建立模型</span><br>model = Word2Vec(sentences, window=<span class="hljs-number">3</span>, min_count=<span class="hljs-number">1</span>)<br><br>words = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;words: &quot;</span>)<br>ret = model.wv.most_similar(positive=[words], topn=<span class="hljs-number">10</span>)   <span class="hljs-comment"># 找到最相似的n 个词</span><br><span class="hljs-built_in">print</span>(ret)<br></code></pre></td></tr></table></figure><p><strong>* Doc2Vec</strong>：这个可以根据电影的所有标签，训练一个模型来得到最终电影的影片向量， 根据这个，就能够直接计算用户看过的某个电影与其他电影的相似性，然后根据这个相似性给用户推荐最相似的几篇文章。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> gensim.models.doc2vec <span class="hljs-keyword">import</span> Doc2Vec, TaggedDocument<br><span class="hljs-keyword">from</span> gensim.test.utils <span class="hljs-keyword">import</span> get_tmpfile<br><br><span class="hljs-comment"># 建立文档， words就是影片的tags， tags就是影片的id</span><br>documents = [TaggedDocument(words, [movie_id]) <span class="hljs-keyword">for</span> movie_id, words <span class="hljs-keyword">in</span> movie_profile[<span class="hljs-string">&quot;profile&quot;</span>].iteritems()]<br><br>documents<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240205004453718.png" alt="转化为文档的格式实例" style="zoom:50%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 训练Doc2Vec模型</span><br>model = Doc2Vec(documents, vector_size=<span class="hljs-number">100</span>, window=<span class="hljs-number">3</span>, min_count=<span class="hljs-number">1</span>, epochs=<span class="hljs-number">20</span>)<br><br><span class="hljs-comment"># 模型保存</span><br><span class="hljs-comment"># fname = get_tmpfile(&quot;my_doc2vec_model&quot;)</span><br><span class="hljs-comment"># model.save(fname)</span><br><br><span class="hljs-comment"># 获取某个电影的tages</span><br>words = movie_profile[<span class="hljs-string">&quot;profile&quot;</span>].loc[<span class="hljs-number">6</span>]<br><span class="hljs-built_in">print</span>(words)<br><span class="hljs-comment"># 拿到该影片的Doc2vec向量</span><br>inferred_vector = model.infer_vector(words)<br>sims = model.docvecs.most_similar([inferred_vector], topn=<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(sims)<br></code></pre></td></tr></table></figure><h3 id="协同过滤算法">协同过滤算法</h3><p>协同过滤(Collaborative Filtering)算法，基本思想是根据用户之前的喜好以及其他兴趣相近的用户的选择来给用户推荐物品(基于对用户历史行为数据的挖掘发现用户的喜好偏向，并预测用户可能喜好的产品进行推荐)，一般是仅仅基于用户的行为数据（评价、购买、下载等）,而不依赖于项的任何附加信息（物品自身特征）或者用户的任何附加信息（年龄，性别等）。目前应用比较广泛的协同过滤算法是基于邻域的方法，而这种方法主要有下面两种算法：</p><ul><li>基于用户的协同过滤算法(UserCF)：给用户推荐和他兴趣相似的其他用户喜欢的产品</li><li>基于物品的协同过滤算法(ItemCF)：给用户推荐和他之前喜欢的物品相似的物品</li></ul><h4 id="两种cf算法介绍">两种CF算法介绍</h4><p><strong>用户协同和物品协同的使用场景</strong></p><p>*UserCF的推荐更社会化，反映了用户所在的小型兴趣群体中物品的热门程度；</p><p>* ItemCF的推荐更加个性化，反映了用户自己的兴趣传承</p><p><strong>UserCF适合于新闻推荐</strong></p><ul><li>热门程度和时效性是个性化新闻推荐的重点，而个性化相对于这两点略显次要</li><li>UserCF需要维护一个用户兴趣相似表，而ItemCF需要维护一个物品相似表，在新闻推荐系统中物品的更新速度是很快的，那么如果采用ItemCF的话，物品相似度表也需要很快地更新，这是难以实现的</li></ul><p><strong>ItemCF适合于图书、电子商务和电影网站</strong></p><ul><li>用户的兴趣是比较固定和持久的</li><li>这些系统中用户不太需要流行度来辅助他们判断一个物品的好坏，而是可以通过自己熟知的领域的知识自己判断物品的质量</li></ul><p><strong>UserCF的适用场合</strong></p><ul><li><strong>用户较少</strong>的场合，如果用户很多，计算用户相似度度矩阵代价很大（新闻网站）</li><li>时效性较强，<strong>用户个性化兴趣不太明显</strong>的领域</li><li>不需要给出令用户信服的推荐解释</li></ul><p><strong>ItemCF的适用场合</strong></p><ul><li>适用于<strong>物品的数量明显小于用户的数量</strong>的场合，如物品很多（网站），计算物品的相似度矩阵代价很大</li><li>长尾物品丰富，<strong>用户个性化</strong>需求强烈的领域<br /></li><li>需要利用用户的历史行为给用户做推荐解释，可以令用户比较信服</li></ul><p>该实验使用的数据集来自:<ahref="http://grouplens.org/datasets/movielens/">http://grouplens.org/datasets/movielens/</a></p><h4 id="算法基本流程">算法基本流程</h4><p>不管是UserCF还是ItemCF， 行文逻辑都是下面的四个步骤： 1. 导入数据，读取文件得到"用户-电影"的评分数据， 并且分为训练集和测试集 2.计算用户(userCF)或者电影(itemcf)之间的相似度 3. 针对目标用户u，找到其最相似的k个用户/产品， 产生N个推荐 4. 产生推荐之后，通过准确率、召回率和覆盖率等进行评估。</p><h4 id="工业界协同过滤的流程">工业界协同过滤的流程</h4><ol type="1"><li>数据处理</li></ol><ul><li>对行为少不活跃的用户进行过滤， 行为少的用户， 数据太过于稀疏，召回难度大</li><li>对用户中热门物品进行过滤， 热门物品可能大部分用户都有过行为</li><li>非常活跃的用户， 用户协同可能会出现一种情况，就是每个用户的topN相似用户里都有些非常活跃的用户，所有需要适当过滤掉这些用户</li></ul><ol start="2" type="1"><li>建立用户embedding和物品embedding， 或者可以像案例这样，直接建立共现矩阵， 也可以训练embedding</li><li>计算用户和N个用户的相似度， 保存N个相似用户曾经看过的TopK个物品</li><li>模型（矩阵）进行定期更新， 这个要根据不同项目组的情况，可能是一天更新一次， 也可能不是， 看具体的情况，更新的时候使用前N天（N一般3-10）的活跃用户的数据进行更新</li><li>每次召回一次N条， 刷完N条再继续召回</li></ol><ul><li>还有可能用户两次行为（上拉或者下滑）之间间隔很长时间，也会进行重新召回</li><li>每次召回的数量，需要根据召回通道以及各个召回通道配置的召回占比进行配置</li></ul><ol start="6" type="1"><li>为了保证用户不疲劳， 一般情况下， 利用user-cf计算召回结果后，会做一定的类别去重， 保证召回覆盖度</li><li>实际过程中， 根据公司核心用户的数量大小， 考虑实现工具，如果数据量较大， 可使用spark进行用户协同的结果计算</li><li>如果用户量实在太过巨大， 可考虑使用稀疏存储的方式进行存储，即只存储含有1(或者其他值）的位置坐标索引index以及对应的值</li></ol><h4 id="用户协同过滤算法">用户协同过滤算法</h4><p><strong>TopN推荐的任务是预测用户会不会对某部电影评分，而不是预测用户在准备对某部电影评分的前提下给电影评多少分</strong>，下面我们开始， 从逻辑上看， 其实这个任务主要分为下面的步骤： 1.导入数据， 读取文件得到"用户-电影"的评分数据， 并且分为训练集和测试集 2.计算用户之间的相似度 3. 针对目标用户u， 找到其最相似的k个用户，产生N个推荐 4. 产生推荐之后， 通过准确率、召回率和覆盖率等进行评估。</p><p><strong>引入依赖包和读取数据</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">from</span> operator <span class="hljs-keyword">import</span> itemgetter<br><br>data_path = <span class="hljs-string">&#x27;./ml-latest-small/&#x27;</span><br>data = pd.read_csv(data_path+<span class="hljs-string">&#x27;ratings.csv&#x27;</span>)<br>data.head()<br><br>data.pivot(index=<span class="hljs-string">&#x27;userId&#x27;</span>, columns=<span class="hljs-string">&#x27;movieId&#x27;</span>, values=<span class="hljs-string">&#x27;rating&#x27;</span>)   <span class="hljs-comment"># 这样会发现有大量的稀疏， 所以才会用字典进行存放</span><br></code></pre></td></tr></table></figure><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240205141619896.png"alt="存在稀疏的情况举例" /><figcaption aria-hidden="true">存在稀疏的情况举例</figcaption></figure><p>存在大量的稀疏的情况，因此后续会对此进行数据的补全</p><p><strong>将数据集划分成训练集和测试集</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 声明两个字典， 分别是训练集和测试集</span><br>trainSet, testSet = &#123;&#125;, &#123;&#125;<br>trainSet_len, testSet_len = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>pivot = <span class="hljs-number">0.75</span>    <span class="hljs-comment"># 训练集的比例</span><br><br><span class="hljs-comment"># 遍历data的每一行， 把userId, movidId, rating按照&#123;user: &#123;movidId: rating&#125;&#125;的方式存储， 当然定义一个随机种子进行数据集划分</span><br><span class="hljs-keyword">for</span> ele <span class="hljs-keyword">in</span> data.itertuples():   <span class="hljs-comment"># 遍历行这里推荐用itertuples， 比iterrows会高效很多</span><br>    user, movie, rating = <span class="hljs-built_in">getattr</span>(ele, <span class="hljs-string">&#x27;userId&#x27;</span>), <span class="hljs-built_in">getattr</span>(ele, <span class="hljs-string">&#x27;movieId&#x27;</span>), <span class="hljs-built_in">getattr</span>(ele, <span class="hljs-string">&#x27;rating&#x27;</span>)<br>    <span class="hljs-keyword">if</span> random.random() &lt; pivot:<br>        trainSet.setdefault(user, &#123;&#125;)<br>        trainSet[user][movie] = rating<br>        trainSet_len += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        testSet.setdefault(user, &#123;&#125;)<br>        testSet[user][movie] = rating <br>        testSet_len += <span class="hljs-number">1</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Split trainingSet and testSet success!&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;TrainSet = %s&#x27;</span> % trainSet_len)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;TestSet = %s&#x27;</span> % testSet_len)<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">Split trainingSet and testSet success!<br>TrainSet = 75732<br>TestSet = 25104<br></code></pre></td></tr></table></figure><p><strong>建立用户相似度的表</strong></p><p>如果直接遍历用户表会产生比较大的时间复杂度，不如直接建立一个物品到用户的倒排表，对每个物品都保存对该物品都产生过的用户列表</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240205142142169.png" alt="image-20240205142142169" style="zoom:50%;" /></p><p>具体的代码如下所示：</p><ul><li>第一步将原来的列表转化成电影-用户的倒排索引</li><li>第二步计算每个用户之间的相似性矩阵</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">user_sim_matrix = &#123;&#125;<br><br><span class="hljs-comment"># 构建“电影-用户”倒排索引    # key = movidID,  value=list of userIDs who have seen this move</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Building movie-user table ...&#x27;</span>)<br>movie_user = &#123;&#125;<br><span class="hljs-keyword">for</span> user, movies <span class="hljs-keyword">in</span> trainSet.items():   <br><span class="hljs-comment"># 这里的user就是每个用户， movies还是个字典，&#123;movieID: rating&#125;</span><br>    <span class="hljs-keyword">for</span> movie <span class="hljs-keyword">in</span> movies:       <span class="hljs-comment"># 这里的movie就是movieID了</span><br>        <span class="hljs-keyword">if</span> movie <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> movie_user:     <span class="hljs-comment"># 如果movidID没在倒排索引里面</span><br>            movie_user[movie] = <span class="hljs-built_in">set</span>()  <span class="hljs-comment"># 声明这个键的值是set， 保证用户不重复</span><br>        movie_user[movie].add(user)     <span class="hljs-comment"># 把用户加进去， 看上面的图就明白了</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Build movie-user table success!&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 下面建立用户相似矩阵</span><br><br><span class="hljs-comment"># 计算总共的电影的数量</span><br>movie_count = <span class="hljs-built_in">len</span>(movie_user)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Total movie number = %d&#x27;</span> % movie_count)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Build user co-rated users matrix ...&#x27;</span>)<br><span class="hljs-keyword">for</span> movie, users <span class="hljs-keyword">in</span> movie_user.items():     <span class="hljs-comment"># movid是movieID， users是set集合</span><br>    <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> users:           <span class="hljs-comment"># 对于每个用户， 都得双层遍历</span><br>        <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> users:<br>            <span class="hljs-keyword">if</span> u == v:<br>                <span class="hljs-keyword">continue</span><br>            user_sim_matrix.setdefault(u, &#123;&#125;)      <span class="hljs-comment"># 把字典的值设置为字典的形式</span><br>            user_sim_matrix[u].setdefault(v, <span class="hljs-number">0</span>)<br>            user_sim_matrix[u][v] += <span class="hljs-number">1</span>     <span class="hljs-comment"># 这里统计两个用户对同一部电影产生行为的次数， 这个就是余弦相似度的分子</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Build user co-rated users matrix success!&#x27;</span>)<br><br><span class="hljs-comment"># 下面计算用户之间的相似性</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Calculating user similarity matrix ...&#x27;</span>)<br><span class="hljs-keyword">for</span> u, related_users <span class="hljs-keyword">in</span> user_sim_matrix.items():<br>    <span class="hljs-keyword">for</span> v, count <span class="hljs-keyword">in</span> related_users.items():    <span class="hljs-comment"># 这里面v是相关用户， count是共同对同一部电影打分的次数</span><br>        user_sim_matrix[u][v] = count / math.sqrt(<span class="hljs-built_in">len</span>(trainSet[u]) * <span class="hljs-built_in">len</span>(trainSet[v]))   <span class="hljs-comment"># len 后面的就是用户对电影产生过行为的个数   </span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Calculate user similarity matrix success!&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>针对用户u，找到和他最相似的k个用户，并产生N个推荐</strong></p><p>得到用户的兴趣相似度后，UserCF算法会对用户推荐和他兴趣最相似的K个用户喜欢的物品。下面公式度量了UserCF算法中用户u对物品i的感兴趣程度：</p><p><span class="math display">\[p(u, i)=\sum_{v \in S(u, K) \cap N(i)}w_{u v} r_{v i}\]</span></p><p>其中， <spanclass="math inline">\(S(u,k)\)</span>包含和兴趣u兴趣最接近的K个用户，<span class="math inline">\(N(i)\)</span>是对物品i有过行为的用户集合，<span class="math inline">\(w_{uv}\)</span>是用户u和用户v的兴趣相似度，<span class="math inline">\(r_{vi}\)</span>代表用户v对物品i的兴趣，因为使用单一行为的隐反馈数据， 所以这里<spanclass="math inline">\(r_{vi}=1\)</span></p><p>所以下面的代码逻辑是这样： * 首先， 给定我一个用户ID，我先拿到这个用户ID目前看过的所有电影， 以防后面推荐重了。<br />* 然后从相似性矩阵中，找到与当前用户最相近的K个用户 *遍历他们看过的电影， 如果当前用户没有看过， 该电影的权重等级累加 *最后给所有的电影进行排序， 推荐前n部给当前用户</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 找到最相似的20个用户， 产生10个推荐</span><br>k = <span class="hljs-number">20</span><br>n = <span class="hljs-number">10</span><br>aim_user = <span class="hljs-number">3</span>      <span class="hljs-comment"># 目标用户ID</span><br>rank =&#123;&#125;<br>watched_movies = trainSet[aim_user]      <span class="hljs-comment"># 找出目标用户看到电影</span><br><span class="hljs-comment"># 下面从相似性矩阵中找到与aim_user最相近的K个用户</span><br><br><span class="hljs-comment"># v 表示相似用户， wuv表示相似程度</span><br><span class="hljs-keyword">for</span> v, wuv <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(user_sim_matrix[aim_user].items(), key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>], reverse=<span class="hljs-literal">True</span>)[<span class="hljs-number">0</span>:k]:  <span class="hljs-comment"># 字典按值从大到小排序， 相关性高到第</span><br>    <br>    <span class="hljs-comment"># 把v用户看过的电影推荐给目标用户</span><br>    <span class="hljs-keyword">for</span> movie <span class="hljs-keyword">in</span> trainSet[v]:<br>        <span class="hljs-keyword">if</span> movie <span class="hljs-keyword">in</span> watched_movies:<br>            <span class="hljs-keyword">continue</span><br>        rank.setdefault(movie, <span class="hljs-number">0</span>)<br>        rank[movie] += wuv  <span class="hljs-comment">#这里给出的权重直接就是按照和用户的相似度的大小决定了最终的电影的大小推荐</span><br><br><span class="hljs-comment"># 产生最后的推荐列表</span><br>rec_movies = <span class="hljs-built_in">sorted</span>(rank.items(), key=itemgetter(<span class="hljs-number">1</span>), reverse=<span class="hljs-literal">True</span>)[:n]  <span class="hljs-comment"># itemgetter(1) 是简洁写法</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240205143207386.png" alt="产生的最终N个推荐" style="zoom:50%;" /></p><p><strong>推荐结果的评估</strong></p><ol type="1"><li><p>召回率</p><p>对用户u推荐N个物品记为<span class="math inline">\(R(u)\)</span>,令用户u在测试集上喜欢的物品集合为<spanclass="math inline">\(T(u)\)</span>， 那么召回率定义为： <spanclass="math display">\[\operatorname{Recall}=\frac{\sum_{u}|R(u) \cap T(u)|}{\sum_{u}|T(u)|}\]</span>这个意思就是说在用户真实购买或者看过的影片里面，我模型真正预测出了多少，这个考察的是模型推荐的一个全面性。分母的位置是测试集上的总的数量</p></li><li><p>准确率</p><p>准确率定义为： <span class="math display">\[\operatorname{Precision}=\frac{\sum_{u} \mid R(u) \capT(u)}{\sum_{u}|R(u)|}\]</span> 这个意思在我推荐的所有物品中， 用户真正看的有多少，这个考察的是我模型推荐的一个准确性。</p></li><li><p>覆盖率</p><p>覆盖率反映了推荐算法发掘长尾的能力， 覆盖率越高，说明推荐算法越能将长尾中的物品推荐给用户。 <span class="math display">\[\text { Coverage }=\frac{\left|\bigcup_{u \in U} R(u)\right|}{|I|}\]</span>该覆盖率表示最终的推荐列表中包含多大比例的物品。如果所有物品都被给推荐给至少一个用户，那么覆盖率是100%</p></li><li><p>新颖度</p><p>用推荐列表中物品的平均流行度度量推荐结果的新颖度。如果推荐出的物品都很热门， 说明推荐的新颖度较低。由于物品的流行度分布呈长尾分布， 所以为了流行度的平均值更加稳定，在计算平均流行度时对每个物品的流行度取对数。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 提供推荐的接口：def recommend(aim_user, k=20, n=10):</span><br><br><span class="hljs-comment"># 准确率、召回率和覆盖率</span><br>hit = <span class="hljs-number">0</span><br>rec_count = <span class="hljs-number">0</span>     <span class="hljs-comment"># 统计推荐的影片数量， 计算查准率</span><br>test_count = <span class="hljs-number">0</span>    <span class="hljs-comment"># 统计测试集的影片数量， 计算查全率</span><br>all_rec_movies = <span class="hljs-built_in">set</span>()    <span class="hljs-comment"># 统计被推荐出来的影片个数，无重复了，为了计算覆盖率</span><br>item_populatity = <span class="hljs-built_in">dict</span>()   <span class="hljs-comment"># 计算新颖度</span><br><br><span class="hljs-comment"># 先计算每部影片的流行程度</span><br><span class="hljs-keyword">for</span> user, items <span class="hljs-keyword">in</span> trainSet.items():<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> items.keys():<br>        <span class="hljs-keyword">if</span> item <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> item_populatity:<br>            item_populatity[item] = <span class="hljs-number">0</span><br>        item_populatity[item] += <span class="hljs-number">1</span>    <span class="hljs-comment"># 这里统计训练集中每部影片用户观看的总次数，代表每部影片的流行程度</span><br><br><span class="hljs-comment"># 计算评测指标</span><br>ret = <span class="hljs-number">0</span><br>ret_cou = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> user, items <span class="hljs-keyword">in</span> trainSet.items():    <span class="hljs-comment"># 这里得保证测试集里面的用户在训练集里面才能推荐</span><br>    test_movies = testSet.get(user, &#123;&#125;)<br>    rec_movies = recommend(user)<br>    <span class="hljs-keyword">for</span> movie, w <span class="hljs-keyword">in</span> rec_movies:<br>        <span class="hljs-keyword">if</span> movie <span class="hljs-keyword">in</span> test_movies:<br>            hit += <span class="hljs-number">1</span>  <span class="hljs-comment">#准确率++</span><br>        all_rec_movies.add(movie)<br>        ret += math.log(<span class="hljs-number">1</span>+item_populatity[movie])<br>        ret_cou += <span class="hljs-number">1</span><br>    rec_count += n<br>    test_count += <span class="hljs-built_in">len</span>(test_movies)<br>    <br>precision = hit / (<span class="hljs-number">1.0</span> * rec_count)<br>recall = hit / (<span class="hljs-number">1.0</span> * test_count) <br>coverage = <span class="hljs-built_in">len</span>(all_rec_movies) / movie_count<br>ret /= ret_cou*<span class="hljs-number">1.0</span><br>    <br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;precisioin = %.4f\nrecall = %.4f\ncoverage = %.4f\npopularity = %.4f&#x27;</span> % (precision, recall, coverage, ret))<br></code></pre></td></tr></table></figure><h4 id="物品协同过滤算法">物品协同过滤算法</h4><ol type="1"><li>导入数据， 读取文件得到"用户-电影"的评分数据，并且分为训练集和测试</li><li>计算电影之间的相似度</li><li>针对目标用户u， 找到其最相似的k个用户， 产生N个推荐</li><li>产生推荐之后， 通过准确率、召回率和覆盖率等进行评估。</li></ol><p>这一步之前都和基于用户的协同过滤算法一样，都进行了<strong>数据集的训练和测试的划分</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 声明两个字典， 分别是训练集和测试集</span><br>trainSet, testSet = &#123;&#125;, &#123;&#125;<br>trainSet_len, testSet_len = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>pivot = <span class="hljs-number">0.75</span>    <span class="hljs-comment"># 训练集的比例</span><br><br><span class="hljs-comment"># 遍历data的每一行， 把userId, movidId, rating按照&#123;user: &#123;movidId: rating&#125;&#125;的方式存储， 当然定义一个随机种子进行数据集划分</span><br><span class="hljs-keyword">for</span> ele <span class="hljs-keyword">in</span> data.itertuples():   <span class="hljs-comment"># 遍历行这里推荐用itertuples， 比iterrows会高效很多</span><br>    user, movie, rating = <span class="hljs-built_in">getattr</span>(ele, <span class="hljs-string">&#x27;userId&#x27;</span>), <span class="hljs-built_in">getattr</span>(ele, <span class="hljs-string">&#x27;movieId&#x27;</span>), <span class="hljs-built_in">getattr</span>(ele, <span class="hljs-string">&#x27;rating&#x27;</span>)<br>    <span class="hljs-keyword">if</span> random.random() &lt; pivot:<br>        trainSet.setdefault(user, &#123;&#125;)<br>        trainSet[user][movie] = rating<br>        trainSet_len += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        testSet.setdefault(user, &#123;&#125;)<br>        testSet[user][movie] = rating <br>        testSet_len += <span class="hljs-number">1</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Split trainingSet and testSet success!&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;TrainSet = %s&#x27;</span> % trainSet_len)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;TestSet = %s&#x27;</span> % testSet_len)<br></code></pre></td></tr></table></figure><p>和<strong>UserItemCF</strong>相似， 这里同样需要建立一个倒排表，只不过这里的倒排变成了<strong>{用户：物品}</strong>的倒排表， 如下：</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240205145510049.png" alt="用户，物品 的倒排表" style="zoom:50%;" /></p><p>我们这里的存储正好是“用户-物品"评分表， 所以现在正好是倒排的形式，所以不用刻意建立建立倒排表， 直接遍历trainSet即可， 但是在这之前，我们先计算下每部电影的流行程度， 也就是被用户观看的总次数，这个在衡量相似度的时候作为分母， 这里的其他逻辑和UserCF基本一致了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 计算每部电影的流行程度, 也就是每部电影被用户看的总次数， 这个衡量相似度的时候作为分母</span><br>movie_popular = &#123;&#125;<br><span class="hljs-keyword">for</span> user, movies <span class="hljs-keyword">in</span> trainSet.items():   <span class="hljs-comment"># 这里的user就是每个用户， movies还是个字典， &#123;movieID: rating&#125;</span><br>    <span class="hljs-keyword">for</span> movie <span class="hljs-keyword">in</span> movies:       <span class="hljs-comment"># 这里的movie就是movieID了</span><br>        <span class="hljs-keyword">if</span> movie <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> movie_popular:     <br>            movie_popular[movie] = <span class="hljs-number">0</span>  <br>        movie_popular[movie] += <span class="hljs-number">1</span><br>movie_count = <span class="hljs-built_in">len</span>(movie_popular)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Total movie number = %d&#x27;</span> % movie_count)<br><span class="hljs-comment"># 下面建立电影相似矩阵</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Build user co-rated movies matrix ...&#x27;</span>)<br>movie_sim_matrix = &#123;&#125;<br><span class="hljs-keyword">for</span> user, movies <span class="hljs-keyword">in</span> trainSet.items():     <span class="hljs-comment"># 注意这个地方与UserCF的不同</span><br>    <span class="hljs-keyword">for</span> m1 <span class="hljs-keyword">in</span> movies:           <span class="hljs-comment"># 对于每个电影， 都得双层遍历</span><br>        <span class="hljs-keyword">for</span> m2 <span class="hljs-keyword">in</span> movies:<br>            <span class="hljs-keyword">if</span> m1 == m2:<br>                <span class="hljs-keyword">continue</span><br>            movie_sim_matrix.setdefault(m1, &#123;&#125;)      <span class="hljs-comment"># 把字典的值设置为字典的形式</span><br>            movie_sim_matrix[m1].setdefault(m2, <span class="hljs-number">0</span>)<br>            movie_sim_matrix[m1][m2] += <span class="hljs-number">1</span>     <span class="hljs-comment"># 这里统计两个电影被同一个用户产生行为的次数， 这个就是余弦相似度的分子</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Build user co-rated movies matrix success!&#x27;</span>)<br><br><span class="hljs-comment"># 下面计算电影之间的相似性</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Calculating movies similarity matrix ...&#x27;</span>)<br><span class="hljs-keyword">for</span> m1, related_movies <span class="hljs-keyword">in</span> movie_sim_matrix.items():<br>    <span class="hljs-keyword">for</span> m2, count <span class="hljs-keyword">in</span> related_movies.items():    <span class="hljs-comment"># 这里面m2是相关电影， count是共同被同一个用户打分的次数</span><br>        <span class="hljs-comment"># 这里注意零向量的处理， 即某电影的用户数为0</span><br>        <span class="hljs-keyword">if</span> movie_popular[m1] == <span class="hljs-number">0</span>  <span class="hljs-keyword">or</span> movie_popular[m2] == <span class="hljs-number">0</span>:<br>            movie_sim_matrix[m1][m2] = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">else</span>:<br>            movie_sim_matrix[m1][m2] = count / math.sqrt(movie_popular[m1] * movie_popular[m2])  <br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Calculate movies similarity matrix success!&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>找到相似性最高的K个物品并进行N推荐</strong></p><p>所以下面的代码逻辑是这样： * 首先， 给定我一个用户ID，我先拿到这个用户ID目前看过的所有电影， 以防后面推荐重了。<br />* 然后从相似性矩阵中，找到与当前用户看的物品的最相近的K个物品 *遍历他们看过的电影， 如果当前用户没有看过， 该电影的权重等级累加 *最后给所有的电影进行排序， 推荐前n部给当前用户</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 找到最相似的K个产品， 并推荐给n个用户</span><br>k = <span class="hljs-number">20</span><br>n = <span class="hljs-number">10</span><br>aim_user = <span class="hljs-number">10</span>     <span class="hljs-comment"># 目标用户ID</span><br>rank =&#123;&#125;<br>watched_movies = trainSet[aim_user]      <span class="hljs-comment"># 找出目标用户看到电影</span><br><span class="hljs-keyword">for</span> movie, rating <span class="hljs-keyword">in</span> watched_movies.items():<br>    <span class="hljs-comment">#遍历与物品item最相似的前k个产品，获得这些物品及相似分数</span><br>    <span class="hljs-keyword">for</span> related_movie, w <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(movie_sim_matrix[movie].items(), key=itemgetter(<span class="hljs-number">1</span>), reverse=<span class="hljs-literal">True</span>)[:k]:<br>        <span class="hljs-comment"># 若该物品用户看过， 跳过</span><br>        <span class="hljs-keyword">if</span> related_movie <span class="hljs-keyword">in</span> watched_movies:<br>            <span class="hljs-keyword">continue</span><br>        <br>        <span class="hljs-comment"># 计算用户user对related_movie的偏好值， 初始化该值为0</span><br>        rank.setdefault(related_movie, <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">#通过与其相似物品对物品related_movie的偏好值相乘并相加。</span><br>        <span class="hljs-comment">#排名的依据—— &gt; 推荐电影与该已看电影的相似度(累计) * 用户对已看电影的评分</span><br>        rank[related_movie] += w * <span class="hljs-built_in">float</span>(rating) <br><span class="hljs-comment"># 产生最后的推荐列表</span><br>rec_movies = <span class="hljs-built_in">sorted</span>(rank.items(), key=itemgetter(<span class="hljs-number">1</span>), reverse=<span class="hljs-literal">True</span>)[:n]  <span class="hljs-comment"># itemgetter(1) 是简洁写法</span><br></code></pre></td></tr></table></figure><p><strong>对模型的性能进行评估</strong></p><p>这部分的内容和基于用户的协同过滤算法一样</p><ol type="1"><li>召回率</li><li>准确率</li><li>覆盖率</li><li>新颖率</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 准确率、召回率和覆盖率</span><br>hit = <span class="hljs-number">0</span><br>rec_count = <span class="hljs-number">0</span>     <span class="hljs-comment"># 统计推荐的影片数量， 计算查准率</span><br>test_count = <span class="hljs-number">0</span>    <span class="hljs-comment"># 统计测试集的影片数量， 计算查全率</span><br>all_rec_movies = <span class="hljs-built_in">set</span>()    <span class="hljs-comment"># 统计被推荐出来的影片个数， 无重复了， 为了计算覆盖率</span><br>item_populatity = <span class="hljs-built_in">dict</span>()   <span class="hljs-comment"># 计算新颖度</span><br><span class="hljs-comment"># 先计算每部影片的流行程度</span><br><span class="hljs-keyword">for</span> user, items <span class="hljs-keyword">in</span> trainSet.items():<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> items.keys():<br>        <span class="hljs-keyword">if</span> item <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> item_populatity:<br>            item_populatity[item] = <span class="hljs-number">0</span><br>        item_populatity[item] += <span class="hljs-number">1</span>    <span class="hljs-comment"># 这里统计训练集中每部影片用户观看的总次数， 代表每部影片的流行程度</span><br><span class="hljs-comment"># 计算评测指标</span><br>ret = <span class="hljs-number">0</span><br>ret_cou = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> user, items <span class="hljs-keyword">in</span> trainSet.items():    <span class="hljs-comment"># 这里得保证测试集里面的用户在训练集里面才能推荐</span><br>    test_movies = testSet.get(user, &#123;&#125;)<br>    rec_movies = recommend(user)<br>    <span class="hljs-keyword">for</span> movie, w <span class="hljs-keyword">in</span> rec_movies:<br>        <span class="hljs-keyword">if</span> movie <span class="hljs-keyword">in</span> test_movies:<br>            hit += <span class="hljs-number">1</span><br>        all_rec_movies.add(movie)<br>        ret += math.log(<span class="hljs-number">1</span>+item_populatity[movie])<br>        ret_cou += <span class="hljs-number">1</span><br>    rec_count += n<br>    test_count += <span class="hljs-built_in">len</span>(test_movies)<br>precision = hit / (<span class="hljs-number">1.0</span> * rec_count)<br>recall = hit / (<span class="hljs-number">1.0</span> * test_count)<br>coverage = <span class="hljs-built_in">len</span>(all_rec_movies) / movie_count<br>ret /= ret_cou*<span class="hljs-number">1.0</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;precisioin = %.4f\nrecall = %.4f\ncoverage = %.4f\npopularity = %.4f&#x27;</span> % (precision, recall, coverage, ret))<br></code></pre></td></tr></table></figure><h3 id="隐语义模型与矩阵分解"><strong>隐语义模型与矩阵分解</strong></h3><p>参考文档<ahref="https://blog.csdn.net/wuzhongqiang/article/details/108173885">https://blog.csdn.net/wuzhongqiang/article/details/108173885</a></p><h4 id="矩阵分解算法">矩阵分解算法</h4><p><strong>矩阵分解算法：BacisSVD, RSVD, ASVD, SVD++</strong></p><p>隐语义模型其实就是在<strong>想办法基于这个评分矩阵去找到上面例子中的那两个矩阵，也就是用户兴趣和物品的隐向量表达，然后就把这个评分矩阵分解成Q和P两个矩阵乘积的形式，这时候就可以基于这两个矩阵去预测某个用户对某个物品的评分了。然后基于这个评分去进行推荐</strong>。</p><ol type="1"><li>首先， 先初始化用户矩阵P和物品矩阵Q，P的维度是<code>[users_num, F]</code>,Q的维度是<code>[item_nums, F]</code>， 这个F是隐向量的维度。也就是通过隐向量的方式把用户的兴趣和F的特点关联了起来。初始化这两个矩阵的方式很多， 但根据经验，随机数需要和<code>1/sqrt(F)</code>成正比。</li><li>有了两个矩阵之后， 我就可以根据用户已经打分的数据去更新参数，这就是训练模型的过程， 方法很简单， 就是遍历用户， 对于每个用户，遍历它打分的电影，这样就拿到了该用户和电影的隐向量，然后两者相乘加上偏置就是预测的评分， 这时候与真实评分有个差距，根据上面的梯度下降就可以进行参数的更新</li><li>训练好模型之后， 就可以进行预测评分， 根据预测的评分对用户推荐</li><li>评估模型， 评估方式还是协同过滤里面的四种评估标准</li></ol><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240205164625576.png"alt="矩阵分解示意图" /><figcaption aria-hidden="true">矩阵分解示意图</figcaption></figure><p>矩阵分解算法将m × n维的共享矩阵R分解成m × k维的用户矩阵U和k ×n维的物品矩阵V相乘的形式。 其中m是用户数量， n是物品数量，k是隐向量维度， 也就是隐含特征个数，只不过这里的隐含特征变得不可解释了， 即我们不知道具体含义了，要模型自己去学。</p><p>最常用的方法是<strong>特征值分解(EVD)</strong>或者<strong>奇异值分解(SVD）</strong>，EVD要求分解的矩阵是方阵，显然用户-物品矩阵不满足这个要求</p><h4 id="svd矩阵分解算法">SVD矩阵分解算法</h4><p>这个算法的思路就是深度学习的思路</p><ol type="1"><li>首先先初始化这两个矩阵</li><li>把用户评分矩阵里面已经评过分的那些样本当做训练集的<code>label</code>，把对应的用户和物品的隐向量当做features，这样就会得到<code>(features, label)</code>相当于训练集</li><li>通过两个隐向量乘积得到预测值<code>pred</code></li><li>根据<code>label</code>和<code>pred</code>计算损失</li><li><strong>然后反向传播，通过梯度下降的方式，更新两个隐向量的值</strong></li><li>未评过分的那些样本当做测试集，通过两个隐向量就可以得到测试集的<code>label</code>值</li><li>这样就填充完了矩阵， 下一步就可以进行推荐了</li></ol><p>有个问题就是当参数很多的时候， 就是两个矩阵很大的时候，往往容易陷入过拟合的困境， 这时候，就需要在<strong>目标函数上面加上正则化的损失， 就变成了RSVD</strong></p><p>读取数据和对测试数据和训练数据的划分的步骤和之前没有差别具体的步骤可以<strong>看之前的协同过滤算法</strong></p><p><strong>建立SVD模型</strong></p><p>这里按照矩阵分解法初始化隐特征矩阵，转化为一个最优化问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, rating_data, F=<span class="hljs-number">5</span>, alpha=<span class="hljs-number">0.1</span>, lmbda=<span class="hljs-number">0.1</span>, max_iter=<span class="hljs-number">100</span></span>):<br>        self.F = F           <span class="hljs-comment"># 这个表示隐向量的维度</span><br>        self.P = <span class="hljs-built_in">dict</span>()          <span class="hljs-comment">#  用户矩阵P  大小是[users_num, F]</span><br>        self.Q = <span class="hljs-built_in">dict</span>()     <span class="hljs-comment"># 物品矩阵Q  大小是[item_nums, F]</span><br>        self.bu = <span class="hljs-built_in">dict</span>()   <span class="hljs-comment"># 用户偏差系数</span><br>        self.bi = <span class="hljs-built_in">dict</span>()    <span class="hljs-comment"># 物品偏差系数</span><br>        self.mu = <span class="hljs-number">0.0</span>        <span class="hljs-comment"># 全局偏差系数</span><br>        self.alpha = alpha   <span class="hljs-comment"># 学习率</span><br>        self.lmbda = lmbda    <span class="hljs-comment"># 正则项系数</span><br>        self.max_iter = max_iter    <span class="hljs-comment"># 最大迭代次数</span><br>        self.rating_data = rating_data <span class="hljs-comment"># 评分矩阵</span><br>        <br>        <span class="hljs-comment"># 初始化矩阵P和Q, 方法很多， 一般用随机数填充， 但随机数大小有讲究， 根据经验， 随机数需要和1/sqrt(F)成正比</span><br>        cnt = <span class="hljs-number">0</span>    <span class="hljs-comment"># 统计总的打分数， 初始化mu用</span><br>        <span class="hljs-keyword">for</span> user, items <span class="hljs-keyword">in</span> self.rating_data.items():<br>            self.P[user] = [random.random() / math.sqrt(self.F)  <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, F)]<br>            self.bu[user] = <span class="hljs-number">0</span><br>            cnt += <span class="hljs-built_in">len</span>(items) <br>            <span class="hljs-keyword">for</span> item, rating <span class="hljs-keyword">in</span> items.items():<br>                <span class="hljs-keyword">if</span> item <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.Q:<br>                    self.Q[item] = [random.random() / math.sqrt(self.F) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, F)]<br>                    self.bi[item] = <span class="hljs-number">0</span><br>        self.mu /= cnt<br></code></pre></td></tr></table></figure><p>训练的过程：采用的是梯度下降法进行更新参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 有了矩阵之后， 就可以进行训练, 这里使用随机梯度下降的方式训练参数P和Q</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">train</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">for</span> step <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.max_iter):<br>            <span class="hljs-keyword">for</span> user, items <span class="hljs-keyword">in</span> self.rating_data.items():<br>                <span class="hljs-keyword">for</span> item, rui <span class="hljs-keyword">in</span> items.items():<br>                    rhat_ui = self.predict(user, item)   <span class="hljs-comment"># 得到预测评分</span><br>                    <span class="hljs-comment"># 计算误差</span><br>                    e_ui = rui - rhat_ui<br>                    <br>                    self.bu[user] += self.alpha * (e_ui - self.lmbda * self.bu[user])<br>                    self.bi[item] += self.alpha * (e_ui - self.lmbda * self.bi[item])<br>                    <span class="hljs-comment"># 随机梯度下降更新梯度</span><br>                    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, self.F):<br>                        self.P[user][k] += self.alpha * (e_ui*self.Q[item][k] - self.lmbda * self.P[user][k])<br>                        self.Q[item][k] += self.alpha * (e_ui*self.P[user][k] - self.lmbda * self.Q[item][k])<br>                    <br>            self.alpha *= <span class="hljs-number">0.1</span>    <span class="hljs-comment"># 每次迭代步长要逐步缩小</span><br></code></pre></td></tr></table></figure><p>根据此产生推荐的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这里产生推荐列表， 遍历物品列表， 如果用户看了， 那么就跳过， 否则， 预测用户对该电影的打分， 然后记录， 最后排名</span><br>movie_list = []<br><span class="hljs-keyword">for</span> user, items <span class="hljs-keyword">in</span> trainSet.items():<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> items.keys():<br>        <span class="hljs-keyword">if</span> item <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> movie_list:<br>            movie_list.append(item)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">recommend</span>(<span class="hljs-params">aim_user, n=<span class="hljs-number">10</span></span>):<br>    rank = &#123;&#125;<br>    watched_movies = trainSet[aim_user] <span class="hljs-comment"># 目标用户看过的电影</span><br>    <br>    <span class="hljs-keyword">for</span> movie <span class="hljs-keyword">in</span> movie_list:<br>        <span class="hljs-keyword">if</span> movie <span class="hljs-keyword">in</span> watched_movies:<br>            <span class="hljs-keyword">continue</span>      <br>        <span class="hljs-comment"># 如果当前用户没看过， 就预测打分， 并保存到rank</span><br>        rank[movie] = basicsvd.predict(aim_user, movie)<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sorted</span>(rank.items(), key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>], reverse=<span class="hljs-literal">True</span>)[:n] <br></code></pre></td></tr></table></figure><p>最后进行模型结果的评估：准确率、召回率、覆盖率</p><h4 id="rsvd矩阵分解算法">RSVD矩阵分解算法</h4><p>在目标函数中加入正则化参数（加入惩罚项）, 对于目标函数来说, <spanclass="math inline">\(Q\)</span> 矩阵和 <spanclass="math inline">\(V\)</span> 矩阵中的所有值都是变量,这些变量在不知道哪个变量会带来过拟合的情况下，对所有变量都进行惩罚:<span class="math display">\[\begin{aligned}\mathrm{SSE} &amp; =\frac{1}{2} \sum_{\mathrm{u}, \mathrm{i}}\mathrm{e}_{\mathrm{ui}}^2+\frac{1}{2} \lambda\sum_{\mathrm{u}}\left|\mathrm{p}_{\mathrm{u}}\right|^2+\frac{1}{2}\lambda \sum_{\mathrm{i}}\left|\mathrm{q}_{\mathrm{i}}\right|^2 \\&amp; =\frac{1}{2} \sum_{\mathrm{u}, \mathrm{i}}\mathrm{e}_{\mathrm{ui}}^2+\frac{1}{2} \lambda \sum_{\mathrm{u}}\sum_{\mathrm{k}=0}^{\mathrm{K}} \mathrm{p}_{\mathrm{u},\mathrm{k}}^2+\frac{1}{2} \lambda \sum_{\mathrm{i}}\sum_{\mathrm{k}=0}^{\mathrm{K}} \mathrm{q}_{\mathrm{k}, \mathrm{i}}^2\end{aligned}\]</span></p><p>这时候目标函数对参数的导数就发生了变化, 前面的那块没变,无非就是加入了后面的梯度。所以此时对 <spanclass="math inline">\(\mathrm{p}_{\mathrm{u}, \mathrm{k}}\)</span> 求导,得到: <span class="math display">\[\begin{aligned}&amp; \frac{\partial}{\partial p_{u, k}}\mathrm{SSE}=-\mathrm{e}_{\mathrm{ui}} \mathrm{q}_{\mathrm{k},\mathrm{i}}+\lambda \mathrm{p}_{\mathrm{u}, \mathrm{k}} \\&amp; \frac{\partial}{\partial \mathrm{q}_{\mathrm{i}, \mathrm{k}}}\mathrm{SSE}=-\mathrm{e}_{\mathrm{u}, \mathrm{i}}\mathrm{p}_{\mathrm{u}, \mathrm{k}}+\lambda \mathrm{q}_{\mathrm{i},\mathrm{k}}\end{aligned}\]</span></p><p>这样, 正则化之后, 梯度的更新公式就变成了: <spanclass="math display">\[\begin{aligned}p_{\mathrm{u}, \mathrm{k}} &amp; =\mathrm{p}_{\mathrm{u},\mathrm{k}}+\eta\left(\mathrm{e}_{\mathrm{ui}} \mathrm{q}_{\mathrm{k},\mathrm{i}}-\lambda \mathrm{p}_{\mathrm{u}, \mathrm{k}}\right) \\\mathrm{q}_{\mathrm{k}, \mathrm{i}} &amp; =\mathrm{q}_{\mathrm{k},\mathrm{i}}+\eta\left(\mathrm{e}_{\mathrm{ui}} \mathrm{p}_{\mathrm{u},\mathrm{k}}-\lambda \mathrm{q}_{\mathrm{i}, \mathrm{k}}\right)\end{aligned}\]</span></p><h4 id="svd矩阵分解">SVD++矩阵分解</h4><p>SVD++， 它将<strong>用户历史评分的物品加入到了LFM模型里</strong></p><p>之前的矩阵分解是只分解的当前的共现矩阵， 比如某个用户<spanclass="math inline">\(u\)</span>对于某个物品<spanclass="math inline">\(i\)</span>的评分， 就单纯的分解成用户<spanclass="math inline">\(u\)</span>的隐向量与物品<spanclass="math inline">\(i\)</span>的隐向量乘积再加上偏置项，这时候注意并没有考虑该用户评分的历史物品</p><p>这个式子是预测用户 <span class="math inline">\(\mathrm{u}\)</span>对于物品 <span class="math inline">\(\mathrm{i}\)</span> 的打分, <spanclass="math inline">\(\mathrm{N}(\mathrm{u})\)</span> 表示用户 <spanclass="math inline">\(\mathrm{u}\)</span> 打过分的历史物品, <spanclass="math inline">\(\mathrm{w}_{\mathrm{ij}}\)</span> 表示物品 <spanclass="math inline">\(\mathrm{ij}\)</span> 的相似度,当然这里的这个相似度不再是ItemCF那样, 通过向量计算的, 而是想向LFM那样,让模型自己学出这个参数来, 那么相应的就可以通过优化的思想： <spanclass="math display">\[\mathrm{SSE}=\sum_{(\mathrm{u}, \mathrm{i}) \in \text { Train}}\left(\mathrm{r}_{\mathrm{ui}}-\sum_{\mathrm{j} \in\mathrm{N}(\mathrm{u})} \mathrm{w}_{\mathrm{ij}}\mathrm{r}_{\mathrm{uj}}\right)^2+\lambda \mathrm{w}_{\mathrm{ij}}^2\]</span></p><p>但是呢, 这么模型有个问题, 就是 <spanclass="math inline">\(\mathrm{w}\)</span> 比较稠密, 存储需要很大的空间,因为如果有 <span class="math inline">\(\mathrm{n}\)</span> 个物品,那么模型的参数就是 <span class="math inline">\(\mathrm{n}^2\)</span>,参数一多, 就容易造成过拟合。所以Koren提出应该对 <spanclass="math inline">\(\mathrm{w}\)</span> 矩阵进行分解, 将参数降到了<span class="math inline">\(2 * \mathrm{n} * \mathrm{~F}\)</span> :<span class="math display">\[\hat{\mathrm{r}}_{\mathrm{ui}}=\frac{1}{\sqrt{|\mathrm{N}(\mathrm{u})|}}\sum_{\mathrm{j} \in \mathrm{N}(\mathrm{u})}\mathrm{x}_{\mathrm{i}}^{\mathrm{T}}\mathrm{y}_{\mathrm{j}}=\frac{1}{\sqrt{|\mathrm{N}(\mathrm{u})|}}\mathrm{x}_{\mathrm{i}}^{\mathrm{T}} \sum_{\mathrm{j} \in\mathrm{N}(\mathrm{u})} \mathrm{y}_{\mathrm{j}}\]</span></p><p>相当于用 <spanclass="math inline">\(\mathrm{x}_{\mathrm{i}}^{\mathrm{T}}\mathrm{y}_{\mathrm{j}}\)</span> 代替了 <spanclass="math inline">\(\mathrm{w}_{\mathrm{ij}}\)</span>, 这里的 <spanclass="math inline">\(\mathrm{x}_{\mathrm{i}},\mathrm{y}_{\mathrm{j}}\)</span> 是两个 <spanclass="math inline">\(\mathrm{F}\)</span> 维的向量。有没有发现在这里,就出现了点 <span class="math inline">\(\mathrm{FM}\)</span>的改进身影了。这里其实就是又对物品 <spanclass="math inline">\(\mathrm{i}\)</span> 和某个用户 <spanclass="math inline">\(\mathrm{u}\)</span>买过的历史物品又学习一波隐向量, 这次是 <spanclass="math inline">\(\mathrm{F}\)</span> 维, 为了衡量出物品 <spanclass="math inline">\(\mathrm{i}\)</span> 和历史物品 <spanclass="math inline">\(\mathrm{j}\)</span> 之间的相似性来。这时候,参数的数量降了下来,并同时也考虑进来了用户的历史物品记录。所以这个和之前的LFM相加就得到了：<span class="math display">\[\hat{r}_{u i}=\mu+b_u+b_i+p_u^T \cdot q_i+\frac{1}{\sqrt{|N(u)|}} x_i^T\sum_{j \in N(u)} y_j\]</span></p><h3 id="fmffm模型"><strong>FM+FFM模型</strong></h3><p>基本的框架</p><p>因子分解机(Factorization Machine, FM)和域感知因子分解机(Field-awareFactorization Machine, FFM)</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240205170756448.png" alt="FM+FFM发展历程" style="zoom: 50%;" /></p><h4 id="fm算法与使用">FM算法与使用</h4><p>在逻辑回归里面, 如果想得到组合特征,往往需要人工在特征工程的时候手动的组合特征, 然后再进行篮选,但这个比较低效, 第一个是这个会有经验的成分在里面,第二个是可能会比较玄学, 不太好找到有用的组合特征。于是乎,采用POLY2模型进行特征的“暴力”组合就成了可行的选择。POLY2是二阶多项式模型,数学形式如下: <span class="math display">\[y=w_0+\sum_{i=1}^n w_i x_i+\sum_{i=1}^{n-1} \sum_{i+1}^n w_{i j} x_i x_j\]</span></p><p>看到这个基本上不用怎么解释就明白了，这个模型对所有的特征进行了两两的交叉，然后又算得了一个权重，这个其实和逻辑回归依然是超级像的，如果我们在逻辑回归中，做特征工程的时候，也可以自己做出这样的一些特征来</p><p><strong>POLY2缺点：</strong>任意两个参数相互独立，这时候如果数据非常稀疏， 再要训练这么多参数， 无疑是非常困难的，最终模型也不会很好。POLY2模型虽然是引入了特征的二阶交叉组合，但是由于其模型参数， 稀疏场景受限的问题使得FM登场了</p><p><strong>FM算法思路：</strong></p><p>对于稀疏的评分矩阵， 我们有办法分解成两个向量相乘的形式，那么为何不把这种思想用到解决POLY2的缺陷上呢？无非就是评分矩阵换成POLY2后面的W矩阵(所有二次项系数 <spanclass="math inline">\(w_{ij}\)</span>组成的）就是把W矩阵进行分解成两个矩阵相乘的方式</p><p>对于二次项参数 <spanclass="math inline">\(\mathrm{w}_{\mathrm{ij}}\)</span> 组成的对称阵<span class="math inline">\(\mathrm{W}\)</span> (为了方面说明 <spanclass="math inline">\(\mathrm{FM}\)</span> 的由来,对角元素设置为正实数)，我们就可以分解成 <spanclass="math inline">\(\mathrm{V}^{\mathrm{T}} \mathrm{V}\)</span>的形式， <span class="math inline">\(\mathrm{V}\)</span>的第 <spanclass="math inline">\(j\)</span> 列 <spanclass="math inline">\(v_j\)</span> 表示的是第 <spanclass="math inline">\(j\)</span> 维特征 <spanclass="math inline">\(x_j\)</span> 的隐向量。换句话说，特征分量 <spanclass="math inline">\(x_i\)</span> 和 <spanclass="math inline">\(x_j\)</span> 的交叉系数就等于 <spanclass="math inline">\(x_i\)</span> 和 <spanclass="math inline">\(x_j\)</span> 对应的隐向量的内积，即每个参数 <spanclass="math inline">\(\mathrm{w}_{\mathrm{ij}}=&lt;\mathrm{v}_{\mathrm{i}},\mathrm{v}_{\mathrm{j}}&gt;\)</span>, 这就是 <spanclass="math inline">\(F M\)</span> 模型的核心思想: <spanclass="math display">\[\mathrm{W}^{\star}=\left[\begin{array}{cccc}\omega_{11} &amp; \omega_{12} &amp; \ldots &amp; \omega_{1 \mathrm{n}}\\\omega_{21} &amp; \omega_{22} &amp; \ldots &amp; \omega_{2 \mathrm{n}}\\\ldots &amp; \ldots &amp; \ldots &amp; \ldots \\\omega_{\mathrm{n} 1} &amp; \omega_{\mathrm{n} 2} &amp; \ldots &amp;\omega_{\mathrm{nn}}\end{array}\right]=\mathrm{V}^{\mathrm{T}}\mathrm{V}=\left[\begin{array}{c}\mathrm{V}_1 \\\mathrm{~V}_2 \\\ldots \\\mathrm{V}_{\mathrm{n}}\end{array}\right] \times\left[\mathrm{V}_1, \mathrm{~V}_2, \ldots,\mathrm{V}_{\mathrm{n}}\right]=\left[\begin{array}{cccc}\mathrm{v}_{11} &amp; \mathrm{v}_{12} &amp; \ldots &amp; \mathrm{v}_{1\mathrm{k}} \\\mathrm{v}_{21} &amp; \mathrm{v}_{22} &amp; \ldots &amp; \mathrm{v}_{2\mathrm{k}} \\\ldots &amp; \ldots &amp; \ldots &amp; \ldots \\\mathrm{v}_{\mathrm{n} 1} &amp; \mathrm{v}_{\mathrm{n} 2} &amp; \ldots&amp; \mathrm{v}_{\mathrm{nk}}\end{array}\right] \times\left[\begin{array}{c}\mathrm{v}_{11} \\\mathrm{v}_{12} \\\ldots \\\mathrm{v}_{1 \mathrm{k}}\end{array}\right.\]</span></p><p>这时候, 为了求 <span class="math inline">\(w_{i j}\)</span>,我们需要求出特征分量 <span class="math inline">\(x_i\)</span> 的辅助向量<span class="math inline">\(v_i=\left(v_{i 1}, v_{i 2}, \ldots v_{ik}\right), v_j=\left(v_{j 1}, v_{j 2}, \ldots v_{j k}\right)\)</span>所以, 有了这样的一个铺垫, 就可以写出FM的模型方程了，就是POLY2 的基础上,把 <span class="math inline">\(\mathrm{w}_{\mathrm{ij}}\)</span>写成了两个隐向量相乘的方式。 <span class="math display">\[\hat{y}(X)=\omega_0+\sum_{i=1}^n \omega_i x_i+\sum_{i=1}^{n-1}\sum_{j=i+1}^n&lt;v_i, v_j&gt;x_i x_j\]</span>FM的公式是一个通用的拟合方程，可以采用不同的损失函数用于解决regression、classification等问题，比如可以采用MSE（MeanSquare Error）loss function来求解回归问题，也可以采用Hinge/Cross-Entropyloss来求解分类问题。</p><p>安装相关的包<code>pip install git+https://github.com/coreylynch/pyFM</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入包</span><br><span class="hljs-keyword">from</span> pyfm <span class="hljs-keyword">import</span> pylibfm<br><span class="hljs-keyword">from</span> sklearn.feature_extraction <span class="hljs-keyword">import</span> DictVectorizer<br><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> OneHotEncoder<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br></code></pre></td></tr></table></figure><p>使用这个类最简单的方式就是把数据存成字典的形式，然后用DictVectorizer进行one-hot</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">train = [<br>    &#123;<span class="hljs-string">&#x27;user&#x27;</span>: <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;item&#x27;</span>: <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">19</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;user&#x27;</span>: <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;item&#x27;</span>: <span class="hljs-string">&#x27;43&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">33</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;user&#x27;</span>: <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;item&#x27;</span>: <span class="hljs-string">&#x27;20&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">55</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;user&#x27;</span>: <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;item&#x27;</span>: <span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">20</span>&#125;<br>]<br>v = DictVectorizer()<br>X = v.fit_transform(train)      <span class="hljs-comment"># 本身被压缩了</span><br>X.toarray()<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240205175255366.png" alt="one-hot形式" style="zoom:50%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">y = np.repeat(<span class="hljs-number">1</span>, X.shape[<span class="hljs-number">0</span>])<br>fm = pylibfm.FM()<br>fm.fit(X, y)<br></code></pre></td></tr></table></figure><p>进行测试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 测试集</span><br>test = v.transform(&#123;<span class="hljs-string">&#x27;user&#x27;</span>: <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&#x27;item&#x27;</span>: <span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">24</span>&#125;)<br>fm.predict(test)<br></code></pre></td></tr></table></figure><p>给出另一个例子说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#加载数据集</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">loadData</span>():<br>    rating_data=&#123;<span class="hljs-number">1</span>: &#123;<span class="hljs-string">&#x27;A&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;B&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;C&#x27;</span>: <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;D&#x27;</span>: <span class="hljs-number">4</span>&#125;,<br>           <span class="hljs-number">2</span>: &#123;<span class="hljs-string">&#x27;A&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;B&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;C&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;D&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;E&#x27;</span>: <span class="hljs-number">3</span>&#125;,<br>           <span class="hljs-number">3</span>: &#123;<span class="hljs-string">&#x27;A&#x27;</span>: <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;B&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;C&#x27;</span>: <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;D&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;E&#x27;</span>: <span class="hljs-number">5</span>&#125;,<br>           <span class="hljs-number">4</span>: &#123;<span class="hljs-string">&#x27;A&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;B&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;C&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;D&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;E&#x27;</span>: <span class="hljs-number">4</span>&#125;,<br>           <span class="hljs-number">5</span>: &#123;<span class="hljs-string">&#x27;A&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;B&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;C&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;D&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;E&#x27;</span>: <span class="hljs-number">1</span>&#125;<br>          &#125;<br>    <span class="hljs-keyword">return</span> rating_data<br>    <br>rating_data = loadData()<br>df = pd.DataFrame(rating_data).T<br>df = df.stack().reset_index()<br>df.columns = [<span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;item&#x27;</span>, <span class="hljs-string">&#x27;rating&#x27;</span>]<br>df[<span class="hljs-string">&#x27;user&#x27;</span>] = df[<span class="hljs-string">&#x27;user&#x27;</span>].astype(<span class="hljs-string">&#x27;str&#x27;</span>)<br><br>item_map = &#123;item: <span class="hljs-built_in">str</span>(idx) <span class="hljs-keyword">for</span> idx, item <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">set</span>(df[<span class="hljs-string">&#x27;item&#x27;</span>]))&#125;<br>df[<span class="hljs-string">&#x27;item&#x27;</span>] = df[<span class="hljs-string">&#x27;item&#x27;</span>].<span class="hljs-built_in">map</span>(item_map)<br>train_data = df[[<span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;item&#x27;</span>]]<br>y = df[<span class="hljs-string">&#x27;rating&#x27;</span>]<br>one = OneHotEncoder()<br>x = one.fit_transform(train_data)<br><br><span class="hljs-comment"># 建立模型</span><br>fm = pylibfm.FM(num_factors=<span class="hljs-number">10</span>, num_iter=<span class="hljs-number">100</span>, verbose=<span class="hljs-literal">True</span>, task=<span class="hljs-string">&#x27;regression&#x27;</span>, initial_learning_rate=<span class="hljs-number">0.001</span>, learning_rate_schedule=<span class="hljs-string">&#x27;optimal&#x27;</span>)<br>fm.fit(x, y)<br><br><span class="hljs-comment"># 测试集</span><br>test = &#123;<span class="hljs-string">&#x27;user&#x27;</span>: <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;item&#x27;</span>: <span class="hljs-string">&#x27;4&#x27;</span>&#125;<br>x_test = one.transform(pd.DataFrame(test, index=[<span class="hljs-number">0</span>]))<br><br>pred_rating = fm.predict(x_test)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;FM的预测评分:&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(pred_rating[<span class="hljs-number">0</span>]))<br></code></pre></td></tr></table></figure><h4 id="fm算法的回归与分类任务">FM算法的回归与分类任务</h4><p><strong>回归任务</strong></p><p>数据集的下载地址: <ahref="http://www.grouplens.org/system/files/ml-100k.zip">http://www.grouplens.org/system/files/ml-100k.zip</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入包</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> sklearn.feature_extraction <span class="hljs-keyword">import</span> DictVectorizer<br><span class="hljs-keyword">from</span> pyfm <span class="hljs-keyword">import</span> pylibfm<br><br><span class="hljs-comment"># 导入数据</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">loadData</span>(<span class="hljs-params">filename, path=<span class="hljs-string">&#x27;ml-100k/&#x27;</span></span>):<br>    data = []<br>    y = []<br>    users = <span class="hljs-built_in">set</span>()<br>    items = <span class="hljs-built_in">set</span>()<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(path+filename) <span class="hljs-keyword">as</span> f:<br>        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:<br>            (user, movieid, rating, ts) = line.split(<span class="hljs-string">&#x27;\t&#x27;</span>)<br>            data.append(&#123;<span class="hljs-string">&#x27;user_id&#x27;</span>: <span class="hljs-built_in">str</span>(user), <span class="hljs-string">&#x27;movie_id&#x27;</span>: <span class="hljs-built_in">str</span>(movieid)&#125;)<br>            y.append(<span class="hljs-built_in">float</span>(rating))<br>            users.add(user)<br>            items.add(movieid)<br>    <br>    <span class="hljs-keyword">return</span> (data, np.array(y), users, items)<br></code></pre></td></tr></table></figure><p>数据类型：</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240205181713518.png" alt="数据类型展示" style="zoom:50%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 下面需要转成one-hot</span><br>v = DictVectorizer()<br>X_train = v.fit_transform(train_data)<br>X_test = v.transform(test_data)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 建立FM模型 </span><br>fm = pylibfm.FM(num_factors=<span class="hljs-number">10</span>, num_iter=<span class="hljs-number">100</span>, verbose=<span class="hljs-literal">True</span>, task=<span class="hljs-string">&#x27;regression&#x27;</span>, initial_learning_rate=<span class="hljs-number">0.001</span>, learning_rate_schedule=<span class="hljs-string">&#x27;optimal&#x27;</span>)<br><br><span class="hljs-comment"># 模型训练</span><br>fm.fit(X_train, y_train)<br></code></pre></td></tr></table></figure><p>FM的具体参数函数如下: 这里面重点需要设置的已标出(详细的可以参考源码)* <strong>num_factors</strong>: 隐向量的维度， 也就是k *<strong>num_iter</strong>: 迭代次数， 由于使用的SGD， 随机梯度下降，要指明迭代多少个epoch * k0, k1: k0表示是否用偏置（看FM的公式)，k1表示是否要第二项， 就是单个特征的， 这俩默认True * init_stdev:初始化隐向量时候的方差, 默认0.01 * <strong>validation_size</strong>:验证集的比例， 默认0.01 * learning_rate_schedule: 学习率衰减方式，有constant, optimal, 和invscaling三种方式， 具体公式看源码 *<strong>initial_learning_rate</strong>: 初始学习率， 默认0.01 *power_t， t0: 逆缩放学习率的指数，最优学习率分母常数，这两个和上面学习率衰减方式的计算有关 * <strong>task</strong>:分类或者回归任务， 要指明 * verbose: 是否打印当前的迭代次数， 训练误差 *shuffle_training: 是否在学习之前打乱训练集 * seed: 随机种子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 评估</span><br>preds = fm.predict(X_test)<br><br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_squared_error<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;FM MSE: %.4f&#x27;</span> % mean_squared_error(y_test, preds))<br></code></pre></td></tr></table></figure><p><strong>分类任务</strong></p><p>创建一个随机的分类数据集并对数据集进行测试集和验证集的划分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> make_classification   <span class="hljs-comment"># 创建一个随机的分类数据集</span><br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> log_loss<br><br>X, y = make_classification(n_samples=<span class="hljs-number">1000</span>, n_features=<span class="hljs-number">100</span>, n_clusters_per_class=<span class="hljs-number">1</span>) <span class="hljs-comment"># 1000个训练样本， 100维的数据</span><br>data = [&#123;v: k <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>(i, <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(i)))).items()&#125; <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> X]<br>x_train, x_test, y_train, y_test = train_test_split(data, y, test_size=<span class="hljs-number">0.1</span>, random_state=<span class="hljs-number">42</span>)<br></code></pre></td></tr></table></figure><p>对数据集进行one-hot的处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">v = DictVectorizer()<br>x_train = v.fit_transform(x_train)<br>x_test = v.transform(x_test)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 建立模型</span><br>fm = pylibfm.FM(num_factors=<span class="hljs-number">50</span>, num_iter=<span class="hljs-number">10</span>, verbose=<span class="hljs-literal">True</span>, task=<span class="hljs-string">&#x27;classification&#x27;</span>, initial_learning_rate=<span class="hljs-number">0.0001</span>, learning_rate_schedule=<span class="hljs-string">&#x27;optimal&#x27;</span>)<br><br>fm.fit(x_train, y_train)<br>y_pre = fm.predict(x_test)<br><br><span class="hljs-comment"># 评估模型</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;validation log loss: %.4f&#x27;</span> % log_loss(y_test, y_pre))<br></code></pre></td></tr></table></figure><h4 id="ffm算法介绍与使用">FFM算法介绍与使用</h4><p>FFM是基于FM进行的修改，<strong>FFM模型引入了特征域感知(filed-aware)</strong>，我们先回顾一下FM模型公式： <span class="math display">\[\hat{y}(X)=\omega_0+\sum_{i=1}^n \omega_i x_i+\sum_{i=1}^{n-1}\sum_{j=i+1}^n&lt;v_i, v_j&gt;x_i x_j\]</span> FFM就是一个特征对应多个隐向量。这样在与不同域(类）里面特征交叉的时候，用相应的隐向量去交叉计算权重，这样做的好处是学习隐向量的时候只需要考虑相应的域的数据，与不同类的特征进行关联采用不同的隐向量，这和不同类特征的内在差异也比较相符。 这其实就是FFM在FM的基础上做的改进，引入了<strong>域的概念</strong>，对于每个特征，<strong>针对不同的交叉域要学习不同的隐向量特征</strong></p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240205192049667.png" alt="引入不同的域的概念的分类" style="zoom:50%;" /></p><p>细品的话， 不同单词不同身份的时候,会有不同的embedding对待，其实这里的FFM域embedding，如果经过上面的铺垫感觉FFM差不多了,那么下面就是模型的方程了:</p><p><span class="math display">\[\hat{y}(X)=\omega_0+\sum_{i=1}^n \omega_i x_i+\sum_{i=1}^{n-1}\sum_{j=i+1}^n&lt;v_{i, f_j}, v_{j, f_i}&gt;x_i x_j\]</span> <span class="math inline">\(&lt;v_{i, f_j}, v_{j,f_i}&gt;\)</span>注意这里的已经是加上域的内容之后的结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FFM_Node</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    通常x是高维稀疏向量，所以用链表来表示一个x，链表上的每个节点是个3元组(j,f,v)</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    __slots__ = [<span class="hljs-string">&#x27;j&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>]    <span class="hljs-comment"># 按照元组不是字典的方式存储类的成员属性</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, j, f, v</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">            j: Feature index (0-n-1)</span><br><span class="hljs-string">            f: field index(0-m-1)</span><br><span class="hljs-string">            v: value</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self.j = j<br>        self.f = f<br>        self.v = v<br>    <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FFM</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, m, n, k, eta, lambd</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">            m: Number of fields</span><br><span class="hljs-string">            n: Number of features</span><br><span class="hljs-string">            k: Number of latent factors</span><br><span class="hljs-string">            eta: learning rate</span><br><span class="hljs-string">            lambd: regularization coefficient</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self.m = m<br>        self.n = n<br>        self.k = k<br>        <br>        <span class="hljs-comment">#超参数</span><br>        self.eta = eta<br>        self.lambd = lambd<br>        <br>        <span class="hljs-comment"># 初始化三维权重矩阵w~U(0, 1/sqrt(k))</span><br>        self.w = np.random.rand(n, m, k) / math.sqrt(k)<br>        <br>        <span class="hljs-comment"># 初始化累积梯度平方和， AdaGrad时要用到</span><br>        self.G = np.ones(shape=(n, m, k), dtype=np.float64)<br>        self.log = Logistic()<br><br>    <span class="hljs-comment"># 这个是计算第三项</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">phi</span>(<span class="hljs-params">self, node_list</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        特征组合式的线性加权求和</span><br><span class="hljs-string">        param node_list: 用链表存储x中的非0值</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        z = <span class="hljs-number">0.0</span><br>        <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(node_list)):<br>            node1 = node_list[a]<br>            j1 = node1.j<br>            f1 = node1.f<br>            v1 = node1.v<br>            <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(a+<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(node_list)):<br>                node2 = node_list[b]<br>                j2 = node2.j<br>                f2 = node2.f<br>                v2 = node2.v<br>                w1 = self.w[j1, f2]<br>                w2 = self.w[j2, f1]<br>                z += np.dot(w1, w2) * v1 * v2<br>        <br>        <span class="hljs-keyword">return</span> z<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">predict</span>(<span class="hljs-params">self, node_list</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        输入x， 预测y的值</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        z = self.phi(node_list)<br>        y = self.log.decide_by_tanh(z)<br>        <span class="hljs-keyword">return</span> y<br><br>    <span class="hljs-comment"># 随机梯度下降</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sgd</span>(<span class="hljs-params">self, node_list, y</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        根据一个样本更新模型参数：</span><br><span class="hljs-string">        node_list: 链表存储x中的非0值</span><br><span class="hljs-string">        y: 正样本1， 负样本-1</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        kappa = -y / (<span class="hljs-number">1</span>+math.exp(y*self.phi(node_list)))    <span class="hljs-comment"># 论文里面的那个导数</span><br>        <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(node_list)):<br>            node1 = node_list[a]<br>            j1 = node1.j<br>            f1 = node1.f<br>            v1 = node1.v<br>            <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(a+<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(node_list)):<br>                node2 = node_list[b]<br>                j2 = node2.j<br>                f2 = node2.f<br>                v2 = node2.v<br>                c = kappa * v1 * v2      <span class="hljs-comment"># 这是求导数</span><br>                <br>                <span class="hljs-comment"># self.w[j1,f2]和self.w[j2,f1]是向量，导致g_j1_f2和g_j2_f1也是向量</span><br>                g_j1_f2 = self.lambd * self.w[j1, f2] + c * self.w[j2, f1]<br>                g_j2_f1 = self.lambd * self.w[j2, f1] + c * self.w[j1, f2]<br>                <br>                <span class="hljs-comment"># 计算各个维度上的梯度累积平方和</span><br>                self.G[j1, f2] += g_j1_f2 ** <span class="hljs-number">2</span><br>                self.G[j2, f1] += g_j2_f1 ** <span class="hljs-number">2</span><br>                <br>                <span class="hljs-comment"># Adagrad 算法</span><br>                self.w[j1, f2] -= self.eta / np.sqrt(self.G[j1, f2]) * g_j1_f2  <span class="hljs-comment"># sqrt(G)作为分母，所以G必须是大于0的正数</span><br>                self.w[j2, f1] -= self.eta / np.sqrt(<br>                    self.G[j2, f1]) * g_j2_f1  <span class="hljs-comment"># math.sqrt()只能接收一个数字作为参数，而numpy.sqrt()可以接收一个array作为参数，表示对array中的每个元素分别开方</span><br>    <br>    <span class="hljs-comment"># 训练</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">train</span>(<span class="hljs-params">self, sample_generator, max_echo, max_r2</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        根据一堆样本训练模型</span><br><span class="hljs-string">        sample_generator: 样本生成器，每次yield (node_list, y)，node_list中存储的是x的非0值。通常x要事先做好归一化，即模长为1，这样精度会略微高一点</span><br><span class="hljs-string">        max_echo: 最大迭代次数</span><br><span class="hljs-string">        max_r2: 拟合系数r2达到阈值时即可终止学习</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">for</span> itr <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(max_echo):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;echo: &quot;</span>, itr)<br>            y_sum = <span class="hljs-number">0.0</span><br>            y_sqare_sum = <span class="hljs-number">0.0</span><br>            err_square_sum = <span class="hljs-number">0.0</span>    <span class="hljs-comment"># 误差平方和</span><br>            population = <span class="hljs-number">0</span>   <span class="hljs-comment"># 样本总数</span><br>            <span class="hljs-keyword">for</span> node_list, y <span class="hljs-keyword">in</span> sample_generator:<br>                y = <span class="hljs-number">0.0</span>  <span class="hljs-keyword">if</span> y == -<span class="hljs-number">1</span> <span class="hljs-keyword">else</span> y    <span class="hljs-comment"># 真实的y取值为&#123;-1,1&#125;，而预测的y位于(0,1)，计算拟合效果时需要进行统一</span><br>                self.sgd(node_list, y)<br>                y_hat = self.predict(node_list)<br>                y_sum += y<br>                y_sqare_sum += y ** <span class="hljs-number">2</span><br>                err_square_sum += (y-y_hat) ** <span class="hljs-number">2</span><br>                population += <span class="hljs-number">1</span><br>            <br>            var_y = y_sqare_sum - y_sum * y_sum / population  <span class="hljs-comment"># y的方差</span><br>            r2 = <span class="hljs-number">1</span> - err_square_sum / var_y<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;r2: &quot;</span>, r2)<br>            <span class="hljs-keyword">if</span> r2 &gt; max_r2:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;r2 have reach&quot;</span>, r2)<br>                <span class="hljs-keyword">break</span><br>        <br>    <span class="hljs-comment"># 模型保存</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">save_model</span>(<span class="hljs-params">self, outfile</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        序列化模型</span><br><span class="hljs-string">        :param outfile:</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        np.save(outfile, self.w)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">load_model</span>(<span class="hljs-params">self, infile</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        加载模型</span><br><span class="hljs-string">        :param infile:</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        self.w = np.load(infile)<br></code></pre></td></tr></table></figure><p>调用的过程如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 设置参数   5个特征， 2个域， 2维的k</span><br>n = <span class="hljs-number">5</span><br>m = <span class="hljs-number">2</span><br>k = <span class="hljs-number">2</span><br><br><span class="hljs-comment"># 路径</span><br>train_file = <span class="hljs-string">&quot;dataset/train.txt&quot;</span><br>valid_file = <span class="hljs-string">&quot;dataset/test.txt&quot;</span><br>model_file = <span class="hljs-string">&quot;ffm.npy&quot;</span><br><br><span class="hljs-comment"># 超参数</span><br>eta = <span class="hljs-number">0.01</span><br>lambd = <span class="hljs-number">1e-2</span><br>max_echo = <span class="hljs-number">30</span><br>max_r2 = <span class="hljs-number">0.9</span><br><br><span class="hljs-comment"># 训练模型，并保存模型参数</span><br>sample_generator = Sample(train_file)<br>ffm = FFM(m, n, k, eta, lambd)<br>ffm.train(sample_generator, max_echo, max_r2)<br>ffm.save_model(model_file)<br></code></pre></td></tr></table></figure><h3 id="逻辑回归模型与gbdtlr-模型"><strong>逻辑回归模型与GBDT+LR模型</strong></h3><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240205214722921.png" alt="总体结构图" style="zoom:50%;" /></p><p>协同过滤和矩阵分解利用用户的<strong>物品“相似度”进行推荐</strong>，逻辑回归模型将问题看成了一个分类问题，通过预测正样本的概率对物品进行排序</p><p>这里的正样本可以是用户“点击”了某个商品或者“观看”了某个视频，均是推荐系统希望用户产生“正反馈”行为，因此<strong>逻辑回归模型将推荐问题转成成了一个点击率预估问题</strong></p><h4 id="逻辑回归lr算法">逻辑回归LR算法</h4><p>逻辑回归是在线性回归的基础上加了一个 Sigmoid函数（非线形）映射，使得逻辑回归称为了一个优秀的分类算法，学习逻辑回归模型，首先要记住一句话：<strong>逻辑回归假设数据服从伯努利分布,通过极大化似然函数的方法，运用梯度下降来求解参数，来达到将数据二分类的目的。</strong></p><p><strong>逻辑回归模型已经将推荐问题转换成了一个点击率预测的问题</strong>，而点击率预测就是一个典型的二分类， 正好适合逻辑回归进行处理，那么逻辑回归是如何做推荐的呢？</p><ol type="1"><li><p>将用户年龄、性别、物品属性、物品描述、当前时间、当前地点等特征转成<strong>数值型向量</strong></p></li><li><p>确定逻辑回归的优化目标，比如把点击率预测转换成二分类问题，这样就可以得到分类问题常用的损失作为目标， 训练模型</p></li><li><p>在预测的时候， 将特征向量输入模型产生预测，得到用户“点击”物品的概率</p></li><li><p>利用点击概率对候选物品排序， 得到推荐列表</p></li></ol><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240205220635359.png"alt="训练和推断的过程" /><figcaption aria-hidden="true">训练和推断的过程</figcaption></figure><p>每个特征的权重参数<span class="math inline">\(w\)</span>，我们一般是使用梯度下降的方式， 首先会先随机初始化一批<spanclass="math inline">\(w\)</span>，然后将特征向量（也就是我们上面数值化出来的特征）输入到模型，就会通过计算会得到模型的预测概率， 然后通过对目标函数求导得到每个<spanclass="math inline">\(w\)</span>的梯度， 然后进行更新<spanclass="math inline">\(w\)</span></p><p>优点：</p><ol type="1"><li><p>LR模型形式简单，可解释性好，从特征的权重可以看到不同的特征对最后结果的影响。</p></li><li><p>训练时便于并行化，在预测时只需要对特征进行线性加权，所以性能比较好，往往适合处理海量id类特征，用id类特征有一个很重要的好处，就是防止信息损失（相对于范化的CTR 特征），对于头部资源会有更细致的描述</p></li><li><p>资源占用小,尤其是内存。在实际的工程应用中只需要存储权重比较大的特征及特征对应的权重</p></li><li><p>方便输出结果调整。逻辑回归可以很方便的得到最后的分类结果，因为输出的是每个样本的概率分数，我们可以很容易的对这些概率分数进行cutoff，也就是划分阈值(大于某个阈值的是一类，小于某个阈值的是一类)</p></li><li><p>工程化需要， 在深度学习技术之前， 逻辑回归凭借易于并行化，模型简单，训练开销小等特点，占领工程领域的主流，因为即使工程团队发现了复杂模型会提升效果，但一般如果没有把握击败逻辑回归的话仍然不敢尝试或者升级。</p></li></ol><p>当然， 逻辑回归模型也有一定的局限性</p><ol type="1"><li>表达能力不强， 无法<strong>进行特征交叉</strong>，特征筛选等一系列“高级“操作（这些工作都得人工来干，这样就需要一定的经验， 否则会走一些弯路）， 因此可能造成信息的损失</li><li>准确率并不是很高。因为这毕竟是一个线性模型加了个sigmoid，形式非常的简单(非常类似线性模型)，很难去拟合数据的真实分布</li><li>处理非线性数据较麻烦。逻辑回归在不引入其他方法的情况下，只能处理线性可分的数据，如果想处理非线性，首先对连续特征的处理需要先进行离散化（离散化的目的是为了引入非线性），如上文所说，人工分桶的方式会引入多种问题。</li><li>LR需要进行人工特征组合，这就需要开发者有非常丰富的领域经验，才能不走弯路。这样的模型迁移起来比较困难，换一个领域又需要重新进行大量的特征工程。</li></ol><h4 id="gbdt原理">GBDT原理</h4><p>GBDT全称<strong>梯度提升决策树</strong>，GBDT（Gradient BoostingDecisionTree，梯度提升决策树）是一种机器学习算法，它通过优化损失函数的梯度来构建一组树模型的集合，并希望这些树模型能够协同工作以获得更准确的结果。</p><p><strong>GBDT的工作原理：</strong></p><ol type="1"><li>初始化模型：使用一个简单的树模型作为起点。</li><li>训练模型：<ul><li>评估当前模型的损失函数。</li><li>根据当前模型的预测值来计算损失函数的梯度。</li><li>在当前模型的基础上，寻找能够最小化梯度下降的树模型。</li></ul></li><li>组合模型：将新树模型的预测结果与原模型的预测结果结合，作为下一轮迭代的初始模型。</li><li>重复迭代：重复步骤2和3，直到达到预设的迭代次数或模型性能不再提升</li></ol><p><strong>GBDT的优点：</strong></p><ul><li>​ 灵活性：可以处理非线性问题。</li><li>效率：在预测时，每个节点的计算只与少数特征有关，因此计算效率相对较高。</li><li>效果：在许多任务中，尤其是回归和分类任务中，GBDT都能取得很好的效果。</li></ul><p><strong>GBDT的缺点：</strong></p><ul><li>过拟合：由于模型复杂，容易过拟合，需要通过正则化、限制树的数量或深度等方法来控制。</li><li>调参复杂：需要调整多个超参数，如学习率、树的数量、节点的最大深度等。</li></ul><h4 id="gbdtlr算法原理">GBDT+LR算法原理</h4><p>利用GBDT自动进行<strong>特征筛选和组合</strong>，进而生成新的离散特征向量，再把<strong>该特征向量当做LR模型的输入</strong>， 来产生最后的预测结果，这就是著名的GBDT+LR模型了。GBDT+LR使用最广泛的场景是CTR点击率预估，即预测当给用户推送的广告会不会被用户点击</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240205222740504.png" alt="GBDT+LR结构图" style="zoom: 50%;" /></p><p><strong>训练时</strong>，GBDT建树的过程相当于自动进行的特征组合和离散化，然后从根结点到叶子节点的这条路径就可以看成是不同特征进行的特征组合，用叶子节点可以唯一的表示这条路径，并作为一个离散特征传入LR 进行<strong>二次训练</strong></p><p>比如上图中，有两棵树，x为一条输入样本，遍历两棵树后，x样本分别落到两颗树的叶子节点上，每个叶子节点对应LR一维特征，那么通过遍历树，就得到了该样本对应的所有LR特征。构造的新特征向量是取值0/1的。比如左树有三个叶子节点，右树有两个叶子节点，最终的特征即为五维的向量。对于输入x，假设他落在左树第二个节点，编码[0,1,0]，落在右树第二个节点则编码[0,1]，所以整体的编码为[0,1,0,0,1]，这类编码作为特征，输入到线性分类模型（LRor FM）中进行分类。</p><p><strong>预测时，</strong>会先走 GBDT的每棵树，得到某个叶子节点对应的一个离散特征(即一组特征组合)，然后把该特征以one-hot 形式传入 LR 进行线性加权预测。</p><h4 id="gbdtlr编程实践">GBDT+LR编程实践</h4><p>这个比赛的任务就是：开发预测广告点击率(CTR)的模型。给定一个用户和他正在访问的页面，预测他点击给定广告的概率是多少？比赛的地址链接：<ahref="https://www.kaggle.com/c/criteo-display-ad-challenge/overview">https://www.kaggle.com/c/criteo-display-ad-challenge/overview</a></p><p><strong>导入相关的依赖包和数据集</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LogisticRegression<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><span class="hljs-keyword">import</span> lightgbm <span class="hljs-keyword">as</span> lgb<br><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> MinMaxScaler, OneHotEncoder, LabelEncoder<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> log_loss<br><br><span class="hljs-keyword">import</span> gc<br><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> sparse<br><br><span class="hljs-keyword">import</span> warnings<br>warnings.filterwarnings(<span class="hljs-string">&#x27;ignore&#x27;</span>)<br><br><br><span class="hljs-comment"># 数据读取</span><br>path = <span class="hljs-string">&#x27;data/&#x27;</span><br>df_train = pd.read_csv(path + <span class="hljs-string">&#x27;train.csv&#x27;</span>)<br>df_test = pd.read_csv(path + <span class="hljs-string">&#x27;test.csv&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>数据预处理</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 数据读取</span><br>path = <span class="hljs-string">&#x27;data/&#x27;</span><br>df_train = pd.read_csv(path + <span class="hljs-string">&#x27;train.csv&#x27;</span>)<br>df_test = pd.read_csv(path + <span class="hljs-string">&#x27;test.csv&#x27;</span>)<br><br><span class="hljs-comment"># 简单的数据预处理</span><br><span class="hljs-comment"># 去掉id列， 把测试集和训练集合并， 填充缺失值</span><br>df_train.drop([<span class="hljs-string">&#x27;Id&#x27;</span>], axis=<span class="hljs-number">1</span>, inplace=<span class="hljs-literal">True</span>)<br>df_test.drop([<span class="hljs-string">&#x27;Id&#x27;</span>], axis=<span class="hljs-number">1</span>, inplace=<span class="hljs-literal">True</span>)<br><br>df_test[<span class="hljs-string">&#x27;Label&#x27;</span>] = -<span class="hljs-number">1</span><br><br>data = pd.concat([df_train, df_test])<br>data.fillna(-<span class="hljs-number">1</span>, inplace=<span class="hljs-literal">True</span>)<br><br>continuous_fea = [<span class="hljs-string">&#x27;I&#x27;</span>+<span class="hljs-built_in">str</span>(i+<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">13</span>)]<br>category_fea = [<span class="hljs-string">&#x27;C&#x27;</span>+<span class="hljs-built_in">str</span>(i+<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">26</span>)]<br></code></pre></td></tr></table></figure><p><strong>LR模型</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">lr_model</span>(<span class="hljs-params">data, category_fea, continuous_fea</span>):<br>    <span class="hljs-comment"># 连续特征归一化</span><br>    scaler = MinMaxScaler()<br>    <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> continuous_fea:<br>        data[col] = scaler.fit_transform(data[col].values.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<br>    <br>    <span class="hljs-comment"># 离散特征one-hot编码</span><br>    <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> category_fea:<br>        onehot_feats = pd.get_dummies(data[col], prefix=col)<br>        data.drop([col], axis=<span class="hljs-number">1</span>, inplace=<span class="hljs-literal">True</span>)<br>        data = pd.concat([data, onehot_feats], axis=<span class="hljs-number">1</span>)<br>    <br>    <span class="hljs-comment"># 把训练集和测试集分开</span><br>    train = data[data[<span class="hljs-string">&#x27;Label&#x27;</span>] != -<span class="hljs-number">1</span>]<br>    target = train.pop(<span class="hljs-string">&#x27;Label&#x27;</span>)<br>    test = data[data[<span class="hljs-string">&#x27;Label&#x27;</span>] == -<span class="hljs-number">1</span>]<br>    test.drop([<span class="hljs-string">&#x27;Label&#x27;</span>], axis=<span class="hljs-number">1</span>, inplace=<span class="hljs-literal">True</span>)<br>    <br>    <span class="hljs-comment"># 划分数据集</span><br>    x_train, x_val, y_train, y_val = train_test_split(train, target, test_size=<span class="hljs-number">0.2</span>, random_state=<span class="hljs-number">2020</span>)<br>    <br>    <span class="hljs-comment"># 建立模型</span><br>    lr = LogisticRegression()<br>    lr.fit(x_train, y_train)<br>    tr_logloss = log_loss(y_train, lr.predict_proba(x_train)[:, <span class="hljs-number">1</span>])   <span class="hljs-comment"># −(ylog(p)+(1−y)log(1−p)) log_loss</span><br>    val_logloss = log_loss(y_val, lr.predict_proba(x_val)[:, <span class="hljs-number">1</span>])<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;tr_logloss: &#x27;</span>, tr_logloss)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;val_logloss: &#x27;</span>, val_logloss)<br>    <br>    <span class="hljs-comment"># 模型预测</span><br>    y_pred = lr.predict_proba(test)[:, <span class="hljs-number">1</span>]  <span class="hljs-comment"># predict_proba 返回n行k列的矩阵，第i行第j列上的数值是模型预测第i个预测样本为某个标签的概率, 这里的1表示点击的概率</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;predict: &#x27;</span>, y_pred[:<span class="hljs-number">10</span>]) <span class="hljs-comment"># 这里看前10个， 预测为点击的概率</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 训练和预测</span><br>lr_model(data.copy(), category_fea, continuous_fea)<br></code></pre></td></tr></table></figure><p>LR预测的结果：</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240206000436387.png" alt="逻辑回归预测结果" style="zoom:50%;" /></p><p><strong>GBDT建模</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">gbdt_model</span>(<span class="hljs-params">data, category_fea, continuous_fea</span>):<br>    <br>    <span class="hljs-comment"># 离散特征one-hot编码</span><br>    <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> category_fea:<br>        onehot_feats = pd.get_dummies(data[col], prefix=col)<br>        data.drop([col], axis=<span class="hljs-number">1</span>, inplace=<span class="hljs-literal">True</span>)<br>        data = pd.concat([data, onehot_feats], axis=<span class="hljs-number">1</span>)<br>    <br>    <span class="hljs-comment"># 训练集和测试集分开</span><br>    train = data[data[<span class="hljs-string">&#x27;Label&#x27;</span>] != -<span class="hljs-number">1</span>]<br>    target = train.pop(<span class="hljs-string">&#x27;Label&#x27;</span>)<br>    test = data[data[<span class="hljs-string">&#x27;Label&#x27;</span>] == -<span class="hljs-number">1</span>]<br>    test.drop([<span class="hljs-string">&#x27;Label&#x27;</span>], axis=<span class="hljs-number">1</span>, inplace=<span class="hljs-literal">True</span>)<br>    <br>    <span class="hljs-comment"># 划分数据集</span><br>    x_train, x_val, y_train, y_val = train_test_split(train, target, test_size=<span class="hljs-number">0.2</span>, random_state=<span class="hljs-number">2020</span>)<br>    <br>    <span class="hljs-comment"># 建模</span><br>    gbm = lgb.LGBMClassifier(boosting_type=<span class="hljs-string">&#x27;gbdt&#x27;</span>,  <span class="hljs-comment"># 这里用gbdt</span><br>                             objective=<span class="hljs-string">&#x27;binary&#x27;</span>, <br>                             subsample=<span class="hljs-number">0.8</span>,<br>                             min_child_weight=<span class="hljs-number">0.5</span>, <br>                             colsample_bytree=<span class="hljs-number">0.7</span>,<br>                             num_leaves=<span class="hljs-number">100</span>,<br>                             max_depth=<span class="hljs-number">12</span>,<br>                             learning_rate=<span class="hljs-number">0.01</span>,<br>                             n_estimators=<span class="hljs-number">10000</span><br>                            )<br>    gbm.fit(x_train, y_train, <br>            eval_set=[(x_train, y_train), (x_val, y_val)], <br>            eval_names=[<span class="hljs-string">&#x27;train&#x27;</span>, <span class="hljs-string">&#x27;val&#x27;</span>],<br>            eval_metric=<span class="hljs-string">&#x27;binary_logloss&#x27;</span>,<br>            early_stopping_rounds=<span class="hljs-number">100</span>,<br>           )<br>    <br>    tr_logloss = log_loss(y_train, gbm.predict_proba(x_train)[:, <span class="hljs-number">1</span>])   <span class="hljs-comment"># −(ylog(p)+(1−y)log(1−p)) log_loss</span><br>    val_logloss = log_loss(y_val, gbm.predict_proba(x_val)[:, <span class="hljs-number">1</span>])<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;tr_logloss: &#x27;</span>, tr_logloss)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;val_logloss: &#x27;</span>, val_logloss)<br>    <br>    <span class="hljs-comment"># 模型预测</span><br>    y_pred = gbm.predict_proba(test)[:, <span class="hljs-number">1</span>]  <span class="hljs-comment"># predict_proba 返回n行k列的矩阵，第i行第j列上的数值是模型预测第i个预测样本为某个标签的概率, 这里的1表示点击的概率</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;predict: &#x27;</span>, y_pred[:<span class="hljs-number">10</span>]) <span class="hljs-comment"># 这里看前10个， 预测为点击的概率</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 模型训练和预测</span><br>gbdt_model(data.copy(), category_fea, continuous_fea)<br></code></pre></td></tr></table></figure><p>预测的结果：</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240206000626255.png" alt="GBDT预测结果展示" style="zoom:50%;" /></p><p><strong>LR + GBDT建模</strong></p><p>下面就是把上面两个模型进行组合， GBDT负责对各个特征进行交叉和组合，把原始特征向量转换为新的离散型特征向量， 然后在使用逻辑回归模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">gbdt_lr_model</span>(<span class="hljs-params">data, category_feature, continuous_feature</span>): <span class="hljs-comment"># 0.43616</span><br>    <span class="hljs-comment"># 离散特征one-hot编码</span><br><br>    <span class="hljs-comment"># 划分数据集</span><br>    x_train, x_val, y_train, y_val = train_test_split(train, target, test_size = <span class="hljs-number">0.2</span>, random_state = <span class="hljs-number">2020</span>)<br>    <br>    <span class="hljs-comment">#GBDT模型的搭建和训练过程</span><br>    gbm = lgb.LGBMClassifier(objective=<span class="hljs-string">&#x27;binary&#x27;</span>,<br>                            subsample= <span class="hljs-number">0.8</span>,<br>                            min_child_weight= <span class="hljs-number">0.5</span>,<br>                            colsample_bytree= <span class="hljs-number">0.7</span>,<br>                            num_leaves=<span class="hljs-number">100</span>,<br>                            max_depth = <span class="hljs-number">12</span>,<br>                            learning_rate=<span class="hljs-number">0.01</span>,<br>                            n_estimators=<span class="hljs-number">1000</span>,<br>                            )<br><br>    gbm.fit(x_train, y_train,<br>            eval_set = [(x_train, y_train), (x_val, y_val)],<br>            eval_names = [<span class="hljs-string">&#x27;train&#x27;</span>, <span class="hljs-string">&#x27;val&#x27;</span>],<br>            eval_metric = <span class="hljs-string">&#x27;binary_logloss&#x27;</span>,<br>            early_stopping_rounds = <span class="hljs-number">100</span>,<br>            )<br>    <br>    model = gbm.booster_<br>    <br>    gbdt_feats_train = model.predict(train, pred_leaf = <span class="hljs-literal">True</span>)<br>    gbdt_feats_test = model.predict(test, pred_leaf = <span class="hljs-literal">True</span>)<br>    gbdt_feats_name = [<span class="hljs-string">&#x27;gbdt_leaf_&#x27;</span> + <span class="hljs-built_in">str</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(gbdt_feats_train.shape[<span class="hljs-number">1</span>])]<br>    df_train_gbdt_feats = pd.DataFrame(gbdt_feats_train, columns = gbdt_feats_name) <br>    df_test_gbdt_feats = pd.DataFrame(gbdt_feats_test, columns = gbdt_feats_name)<br>    <br>    train = pd.concat([train, df_train_gbdt_feats], axis = <span class="hljs-number">1</span>)<br>    test = pd.concat([test, df_test_gbdt_feats], axis = <span class="hljs-number">1</span>)<br>    train_len = train.shape[<span class="hljs-number">0</span>]<br>    data = pd.concat([train, test])<br>    <span class="hljs-keyword">del</span> train<br>    <span class="hljs-keyword">del</span> test<br>    gc.collect()<br><br>    <span class="hljs-comment"># # 连续特征归一化</span><br>    scaler = MinMaxScaler()<br>    <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> continuous_feature:<br>        data[col] = scaler.fit_transform(data[col].values.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<br><br>    <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> gbdt_feats_name:<br>        onehot_feats = pd.get_dummies(data[col], prefix = col)<br>        data.drop([col], axis = <span class="hljs-number">1</span>, inplace = <span class="hljs-literal">True</span>)<br>        data = pd.concat([data, onehot_feats], axis = <span class="hljs-number">1</span>)<br><br>    train = data[: train_len]<br>    test = data[train_len:]<br>    <span class="hljs-keyword">del</span> data<br>    gc.collect()<br><br>    x_train, x_val, y_train, y_val = train_test_split(train, target, test_size = <span class="hljs-number">0.3</span>, random_state = <span class="hljs-number">2018</span>)<br>    <br>    <span class="hljs-comment">#再放进LR模型中</span><br>    lr = LogisticRegression()<br>    lr.fit(x_train, y_train)<br>    tr_logloss = log_loss(y_train, lr.predict_proba(x_train)[:, <span class="hljs-number">1</span>])<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;tr-logloss: &#x27;</span>, tr_logloss)<br>    val_logloss = log_loss(y_val, lr.predict_proba(x_val)[:, <span class="hljs-number">1</span>])<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;val-logloss: &#x27;</span>, val_logloss)<br>    y_pred = lr.predict_proba(test)[:, <span class="hljs-number">1</span>]<br>    <span class="hljs-built_in">print</span>(y_pred[:<span class="hljs-number">10</span>])<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240206000903122.png" alt="GBDT+LR预测结果展示" style="zoom:50%;" /></p><h2 id="深度学习模型rank">深度学习模型(Rank)</h2><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240308111249239.png"alt="image-20240308111249239" /><figcaption aria-hidden="true">image-20240308111249239</figcaption></figure><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240311120735173.png"alt="image-20240311120735173" /><figcaption aria-hidden="true">image-20240311120735173</figcaption></figure><p>对于1层cross和1层deep的DCN网络输入经过embedding和stack处理后维度为d，Cross部分网络参数为2d，Deep为d*d，当MLP的层数增多时，deep部分的参数量也急速增加。DCN网路的绝大部分参数都用于对隐性交叉特征进行建模。Cross部分的表达能力反而受限。</p><p>DCN-v2优化了cross网络的建模方式，增加了cross网络部分的表达能力；deep部分保持不变。</p><p>低维空间的交叉特征建模使得我们可以利用MoE。MoE由两部分组成：experts专家和gating门（一个关于输入x的函数）。我们可以使用多个专家，每个专家学习不同的交叉特征，最后通过gating将各个专家的学习结果整合起来，作为输出。这样就又能进一步增加对交叉特征的建模能力。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>深度学习</tag>
      
      <tag>推荐系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【后端开发】Consul服务与配置</title>
    <link href="/2024/02/02/develop_consul/"/>
    <url>/2024/02/02/develop_consul/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="consul介绍">Consul介绍</h1><p>Consul是hashicorp公司推出的开源工具，用于实现分布式系统的服务发现与配置。内置了服务注册与发现框架、分布一致性协议实现、健康检查、key/value存储、多数据中心方案，不再需要依赖其它工具。</p><p>Consul是一个服务网络解决方案，它使团队能够管理服务之间以及跨多云环境和运行时的安全网络连接。Consul提供服务发现、基于身份的授权、L7流量管理和服务到服务加密。</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240202225407197.png" alt="Consul示意图" style="zoom:50%;" /></p><h1 id="consul角色">Consul角色</h1><p>服务发现和注册</p><ul><li><strong>dev：</strong>开发模式</li><li><strong>client：</strong>客户端，接受请求转达给服务端集群，将http和dns接口请求转发给局域网内的服务端集群，它只是一个代理的角色</li><li><strong>server：</strong>服务端，保存配置信息，高可用集群，每个数据中心的server数据推荐为3个或5个</li></ul><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240203112411765.png" alt="Consul内部角色介绍" style="zoom:50%;" /></p><ul><li>不管是server还是<code>client</code>，统称为<code>agent</code></li><li><code>consul client</code>是相对无状态的，只负责转发<code>rpc</code>到<code>server</code>，资源开销很少</li><li><code>server</code>是一个有一组扩展功能的代理，这些功能包括参与<code>raft</code>选举，维护集群状态，响应<code>rpc</code>查询，与其它数据中心交互<code>wan gossip</code>和转发查询给<code>leader</code>或远程数据中心。</li><li>每个数据中心，<code>client</code>和<code>server</code>是混合的，一般建有3-5台<code>server</code></li></ul><h1 id="安装consul">安装Consul</h1><p>安装地址：<ahref="https://www.consul.io/">https://www.consul.io/</a>，这里建议安装终端版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">consul agent -dev -clinent=0.0.0.0<br><span class="hljs-comment">#-dev表示开发模式运行， -server表示服务模式运行</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#默认端口</span><br>localhost:8500<br></code></pre></td></tr></table></figure><p>登陆这个默认的端口就能看见可视化的界面 <imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240202231921098.png"alt="Consul的可视化界面" /></p><p>详细的运行指令解析</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">consul agent -server -ui -bootstrap-expect=1 -client=0.0.0.0 -<span class="hljs-built_in">bind</span> 0.0.0.0 -data-dir /Users/lihaibin/Workspace/consuldata<br></code></pre></td></tr></table></figure><ul><li><code>-bootstrap-expect</code>：设定一个数据中心需要的服务节点数，可以不设置，设置的数字必须和实际的服务节点数匹配。consul会等待直到数据中心下的服务节点满足设定才会启动集群服务。初始化leader选举，不能和bootstr-ap混用。必须配合-server配置。</li><li><code>-bind：</code>绑定的内部通讯地址，默认0.0.0.0，即，所有的本地地址，会将第一个可用的ip地址散播到集群中，如果有多个可用的ipv4，则consul启动报错。[::]ipv6，TCPUDP协议，相同的端口。防火墙配置。</li><li><code>-client：</code>客户端模式，httpdns，默认127.0.0.1，回环令牌网址</li><li><code>-data-dir：</code>状态数据存储文件夹，所有的节点都需要。文件夹位置需要不收consul节点重启影响，必须能够使用操作系统文件锁，unix-based系统下，文件夹文件权限为0600，注意做好账户权限控制</li><li><code>-dev：</code>开发模式，去掉所有持久化选项，内存服务器模式。</li><li><code>-server：</code>服务端节点模式。</li><li><code>-ui：</code>内置web ui界面</li><li><code>-log-file</code>：日志记录文件，如果没有提供文件名，则默认Consul-时间戳.log</li></ul><h1 id="consul-中默认的端口号"><strong>Consul中默认的端口号</strong></h1><ol type="1"><li><strong>服务器RPC（默认8300）</strong>：由服务器用来处理来自其他代理的传入请求，仅限TCP。</li><li><strong>SerfLAN（默认8301）</strong>：用来处理局域网中的八卦。所有代理都需要，TCP和UDP。</li><li><strong>SerfWAN（默认8302）</strong>：被服务器用来在WAN上闲聊到其他服务器，TCP和UDP。从Consul0.8开始，建议通过端口8302在LAN接口上为TCP和UDP启用服务器之间的连接，以及WAN加入泛滥功能。</li><li><strong>HTTP API（默认8500）</strong>：被客户用来与HTTPAPI交谈，仅限TCP。</li><li><strong>DNS接口（默认8600）</strong>：用于解析DNS查询，TCP和UDP。</li></ol><h1 id="consul工作原理">Consul工作原理</h1><p><strong><code>producer</code></strong>：服务提供者</p><p><strong><code>consumer</code></strong>：服务消费者</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240202230444248.png" alt="image-20240202230444248" style="zoom: 50%;" /></p><h2 id="服务发现与注册">服务发现与注册</h2><ul><li><strong>producer</strong>启动时，会将自己的<strong><code>ip/host</code></strong>等信息通过发送请求告知<strong>consul</strong></li><li><strong>consul</strong>接收到<strong>producer</strong>的注册信息后，每隔10秒（默认）会向<strong>producer</strong>发送一个健康检查的请求，检查<strong>producer</strong>是否处于可用状态</li><li><strong><code>post</code></strong>服务<strong><code>注册 /health</code></strong>健康定期检查</li></ul><h2 id="服务调用">服务调用</h2><ul><li>当<strong>consumer</strong>请求<strong>product</strong>时，会先从<strong><code>consul</code></strong>中拿存储的<code>producer</code>服务的ip和port的临时表（<strong><code>temp table</code></strong>)，从表中任选一个<code>producer</code>的ip和<code>port</code></li><li>根据这个<code>ip</code>和<code>port</code>,发送访问请求</li><li>此表只包含通过健康检查的<strong><code>producer</code></strong>信息，并且每隔10秒更新</li><li><code>Temp table</code> 拉取服务列表从临时表中拿<code>producer</code>的ip和端口发送请求</li></ul><h1 id="consulgo实现">Consul+Go实现</h1><p>下面给出一个例子对于在GO项目中是如何结合<strong><code>Consul</code></strong>进行使用的</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240203143606479.png" alt="consul中间件目录" style="zoom:50%;" /></p><p>首先给出<code>consul</code>中间件的结构体图，这里主要对<code>consul</code>进行了<code>sdk</code>的封装，包含了以下的内容：</p><ol type="1"><li><code>consulclient</code>：服务注册与发现的板块</li><li><code>consulconfig</code>：主要是中心化配置的内容</li><li><code>consulsdk</code>：主要是对以上的两个板块进行了封装</li><li><code>main_test</code>：是给出了一个例子对上述的内容进行测试</li></ol><h3 id="consulclient">Consulclient</h3><p>这部分着重来写如何实现对服务注册和服务发现的功能</p><ul><li><strong>定义 <code>ConsulClient</code> 结构体</strong>：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">goCopy code<br><span class="hljs-keyword">type</span> ConsulClient <span class="hljs-keyword">struct</span> &#123;<br>client     *consulapi.Client<br>serverPort <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>ConsulClient</code> 结构体包含了一个 Consul客户端指针和一个服务端口。</p><ul><li><strong>创建新的 Consul 客户端</strong>：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewConsulClient</span><span class="hljs-params">(consulAddress <span class="hljs-type">string</span>, serverPort <span class="hljs-type">int</span>)</span></span> (*ConsulClient, <span class="hljs-type">error</span>) &#123;<br>config := consulapi.DefaultConfig()<br>config.Address = consulAddress<br>client, err := consulapi.NewClient(config)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> &amp;ConsulClient&#123;client: client, serverPort: serverPort&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>NewConsulClient</code> 函数用于创建一个新的 Consul客户端实例。它接收 Consul 服务器的地址和服务端口作为参数，并返回一个<code>ConsulClient</code> 实例以及可能的错误。</p><ul><li><strong>注册服务</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *ConsulClient)</span></span> RegisterService(serviceID, serviceName, serviceHost <span class="hljs-type">string</span>, servicePort <span class="hljs-type">int</span>) <span class="hljs-type">error</span> &#123;<br>service := &amp;consulapi.AgentServiceRegistration&#123;<br>ID:      serviceID,<br>Name:    serviceName,<br>Address: serviceHost,<br>Port:    servicePort,<br>&#125;<br><span class="hljs-keyword">return</span> c.client.Agent().ServiceRegister(service)<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>RegisterService</code> 方法用于向 Consul注册服务。它接收服务的ID、名称、主机和端口作为参数，并向 Consul注册该服务。</p><ul><li><strong>服务发现</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *ConsulClient)</span></span> DiscoverService(serviceName <span class="hljs-type">string</span>) (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br>services, _, err := c.client.Health().Service(serviceName, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, err<br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(services) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, fmt.Errorf(<span class="hljs-string">&quot;service not found&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 随机选择一个服务实例</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(services) &gt; <span class="hljs-number">0</span> &#123;<br>index := rand.Intn(<span class="hljs-built_in">len</span>(services))<br>service := services[index].Service<br>address := fmt.Sprintf(<span class="hljs-string">&quot;%v:%v&quot;</span>, service.Address, service.Port)<br><span class="hljs-keyword">return</span> address, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, fmt.Errorf(<span class="hljs-string">&quot;no healthy instances found for service %s&quot;</span>, serviceName)<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>DiscoverService</code> 方法用于从 Consul中发现服务实例。它接收服务名称作为参数，并返回一个服务实例的地址。在内部，它通过健康检查来获取可用的服务实例，并随机选择一个健康的实例返回其地址。</p><h3 id="consulconfig">Consulconfig</h3><p>这段代码实现了一个基本的 Consul 配置中心客户端，用于从 Consul中获取、设置和删除键值对的配置信息。</p><ul><li><strong>定义 <code>ConsulConfigCenter</code> 结构体</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ConsulConfigCenter <span class="hljs-keyword">struct</span> &#123;<br>client *consulapi.Client<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>创建新的 <code>Consul</code> 配置中心客户端</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewConsulConfigCenter</span><span class="hljs-params">(consulAddress <span class="hljs-type">string</span>)</span></span> (*ConsulConfigCenter, <span class="hljs-type">error</span>) &#123;<br>config := consulapi.DefaultConfig()<br>config.Address = consulAddress<br>client, err := consulapi.NewClient(config)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> &amp;ConsulConfigCenter&#123;client: client&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>NewConsulConfigCenter</code> 函数用于创建一个新的 Consul配置中心客户端实例。它接收 Consul 服务器的地址作为参数，并返回一个<code>ConsulConfigCenter</code> 实例以及可能的错误</p><ul><li><strong>获取特定键对应的值</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cc *ConsulConfigCenter)</span></span> GetValue(key <span class="hljs-type">string</span>) (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br>kv := cc.client.KV()<br>pair, _, err := kv.Get(key, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, err<br>&#125;<br><span class="hljs-keyword">if</span> pair == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, fmt.Errorf(<span class="hljs-string">&quot;key &#x27;%s&#x27; not found&quot;</span>, key)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(pair.Value), <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>GetValue</code> 方法用于从 Consul中获取特定键对应的值。它接收键名作为参数，并返回键对应的值以及可能的错误。</p><ul><li><strong>设置键值对</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cc *ConsulConfigCenter)</span></span> SetValue(key, value <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>kv := cc.client.KV()<br>p := &amp;consulapi.KVPair&#123;Key: key, Value: []<span class="hljs-type">byte</span>(value)&#125;<br>_, err := kv.Put(p, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure><p><code>SetValue</code> 方法用于在 Consul的键值存储中设置一个键值对。它接收键名和值作为参数，并将其设置到 Consul中。</p><ul><li><strong>删除键值对</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cc *ConsulConfigCenter)</span></span> DeleteValue(key <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>kv := cc.client.KV()<br>_, err := kv.Delete(key, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure><p><code>DeleteValue</code> 方法用于从 Consul的键值存储中删除指定的键值对。它接收键名作为参数，并将对应的键值对从Consul 中删除。</p><h3 id="consulsdk">ConsulSDK</h3><p>实现了一个基于单例模式的 Consul SDK，用于管理 Consul客户端和配置中心。让我们逐段解释代码的功能</p><ul><li><strong>定义 <code>ConsulSDK</code> 结构体</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ConsulSDK <span class="hljs-keyword">struct</span> &#123;<br>Client       *ConsulClient<br>ConfigCenter *ConsulConfigCenter<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ConsulSDK</code> 结构体包含了 Consul 客户端和配置中心的实例</p><ul><li><strong>定义全局变量和 <code>sync.Once</code> 实例</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>instance *ConsulSDK<br>once     sync.Once<br>)<br></code></pre></td></tr></table></figure><p>定义了 <code>instance</code> 变量用于保存 ConsulSDK实例，<code>once</code> 变量用于确保 <code>GetInstance()</code>函数只被执行一次</p><ul><li><strong>实现 <code>NewConsulSDK</code> 函数</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewConsulSDK</span><span class="hljs-params">(consulAddress <span class="hljs-type">string</span>, serverPort <span class="hljs-type">int</span>)</span></span> (*ConsulSDK, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// 创建 Consul 客户端</span><br>client, err := NewConsulClient(consulAddress, serverPort)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-comment">// 创建 Consul 配置中心</span><br>configCenter, err := NewConsulConfigCenter(consulAddress)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-comment">// 返回 ConsulSDK 实例</span><br><span class="hljs-keyword">return</span> &amp;ConsulSDK&#123;<br>Client:       client,<br>ConfigCenter: configCenter,<br>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>NewConsulSDK</code> 函数用于创建一个新的 ConsulSDK 实例，它接收Consul 服务器地址和端口作为参数，并返回一个 ConsulSDK实例以及可能的错误</p><ul><li><strong>实现 <code>GetInstance()</code> 函数</strong>：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span> *ConsulSDK &#123;<br><span class="hljs-comment">// 保证只执行一次</span><br>once.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>consulAddress := <span class="hljs-string">&quot;127.0.0.1:8500&quot;</span><br>serverPort := <span class="hljs-number">8080</span><br><br><span class="hljs-comment">// 创建 Consul 客户端</span><br>client, err := NewConsulClient(consulAddress, serverPort)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Failed to create Consul client:&quot;</span>, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-comment">// 创建 Consul 配置中心</span><br>configCenter, err := NewConsulConfigCenter(consulAddress)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Failed to create Consul config center:&quot;</span>, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-comment">// 初始化 ConsulSDK 实例</span><br>instance = &amp;ConsulSDK&#123;<br>Client:       client,<br>ConfigCenter: configCenter,<br>&#125;<br>&#125;)<br><span class="hljs-keyword">return</span> instance<br>&#125;<br></code></pre></td></tr></table></figure><p><code>GetInstance()</code> 函数用于获取 ConsulSDK 的单例实例。它通过<code>once.Do()</code> 确保<strong>只执行一次</strong>，创建 Consul客户端和配置中心，并将其保存到全局变量 <code>instance</code>中，然后返回该实例</p><h3 id="main_test.go">Main_test.go</h3><p>这个部分主要对上述的sdk接口给出了一个具体的测试用例</p><p>注意在终端运行的时候的运行为：<strong><code>go test</code>go默认对<code>_test</code>会进行测试</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> consul<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestConsul</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-comment">//创建新的 consul sdk</span><br>sdk := GetInstance()<br><br><span class="hljs-comment">// 注册服务</span><br>serviceID := <span class="hljs-string">&quot;my_service&quot;</span><br>serviceName := <span class="hljs-string">&quot;my_service&quot;</span><br>serviceHost := <span class="hljs-string">&quot;127.0.0.1&quot;</span><br>servicePort := <span class="hljs-number">8080</span><br><br>err := sdk.Client.RegisterService(serviceID, serviceName, serviceHost, servicePort)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Error registering service: %v\n&quot;</span>, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-comment">// 发现服务</span><br>serviceAddress, err := sdk.Client.DiscoverService(serviceName)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Error discovering service: %v\n&quot;</span>, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;Discovered service address: %s\n&quot;</span>, serviceAddress)<br><br><span class="hljs-comment">//使用 ConsulConfig 获取键对应的值</span><br>value, err := sdk.ConfigCenter.GetValue(<span class="hljs-string">&quot;test&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Failed to get value:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;Value:&quot;</span>, value)<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="consul持久性">Consul持久性</h1><p>在Consul中，<strong>持久性是指存储的数据在服务重启或者集群重新选举等情况下仍然能够保持不变的特性</strong>。Consul提供了持久化存储功能，允许用户将重要的键值对数据存储在集群中，并确保<strong>==这些数据即使在Consul服务重启后也能被保留==</strong>。</p><ol type="1"><li><strong>Catalog数据持久化</strong>：Consul的Catalog存储了有关服务、节点和数据中心成员的信息。这些数据被用于服务发现、健康检查和路由等功能。Catalog数据的持久化确保了在Consul服务重启后这些关键信息不会丢失。</li><li><strong>健康检查状态持久化</strong>：Consul支持对注册的服务进行健康检查，以确保服务的可用性。健康检查状态也是Consul的持久化数据之一。持久化健康检查状态确保了即使Consul服务重启，之前的健康检查状态仍然有效。</li><li><strong>ACL（Access Control List）配置持久化</strong>：ACL是Consul中用于访问控制的重要功能。ACL配置包括用户、角色、权限和令牌等信息。这些配置的持久化确保了在Consul重启后ACL配置仍然有效，保障了安全访问。</li><li><strong>事件日志持久化</strong>：Consul记录了各种事件日志，包括服务注册、健康检查状态变化、成员变化等。事件日志的持久化确保了即使Consul服务重启，之前的事件记录不会丢失</li></ol><p>持久性存储通常是通过在Consul服务器上<strong>将数据写入磁盘</strong>来实现的，这样即使Consul服务停止运行，数据也不会丢失。</p><ul><li><p>第一步需要指定<strong>存储数据的磁盘文件夹位置</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">consul agent -server -ui -bootstrap-expect=<span class="hljs-number">1</span> -client=<span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span> -bind <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span> -data-dir /Users/lihaibin/Workspace/consuldata<br></code></pre></td></tr></table></figure><p>其中<code>-data-dir /Users/lihaibin/Workspace/consuldata</code>就是在指定需要持久性存储数据的文件夹位置，<u><strong>事实上只需要对data-dir位置进行了指定就能实现对数据的持久性存储</strong>，<strong>关键就在于在启动consul的时候有没有指定</strong></u></p></li><li><p>第二步<strong>代码指定数据存储</strong></p></li></ul><p>这里给出一个持久性存储的实例代码（KV存储）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>consulapi <span class="hljs-string">&quot;github.com/hashicorp/consul/api&quot;</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 创建 Consul 客户端</span><br>config := consulapi.DefaultConfig()<br>config.Address = <span class="hljs-string">&quot;localhost:8500&quot;</span><br>client, err := consulapi.NewClient(config)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Failed to create Consul client:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 获取 Consul KV 存储</span><br>kv := client.KV()<br></code></pre></td></tr></table></figure><p><strong>KV 存储</strong>是 Consul中用于持久化存储键值对数据的一种机制，而这种持久化存储正是与 Consul的持久性密切相关的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 写入数据到 Consul</span><br>key := <span class="hljs-string">&quot;example/key&quot;</span><br>value := []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;example value&quot;</span>)<br>p := &amp;consulapi.KVPair&#123;Key: key, Value: value&#125;<br>_, err = kv.Put(p, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Failed to write data to Consul:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码的作用是将指定的键值对写入到Consul的键值存储中，从而实现数据的持久化存储</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240203235939898.png" alt="KV存储的示意图" style="zoom:67%;" /></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 从 Consul 读取数据</span><br>pair, _, err := kv.Get(key, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Failed to read data from Consul:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> pair == <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Key not found in Consul&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;Key: %s, Value: %s\n&quot;</span>, pair.Key, pair.Value)<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码的功能是从Consul中读取指定键的值，并将其打印出来</p><p>通过实验也可以看出关闭了Consul之后重新打开仍然能够让设置的KV数据能存储在指定的位置上</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240204001705796.png" alt="持久性保持" style="zoom:67%;" /></p>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端开发</tag>
      
      <tag>go开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【后端开发】Go-kit与Gin框架</title>
    <link href="/2024/01/23/develop_go_kit/"/>
    <url>/2024/01/23/develop_go_kit/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="go-kit框架">Go-kit框架</h1><p>Go-kit是一个功能丰富、易于使用的<strong>分布式微服务框架</strong>，旨在帮助开发者构建健壮、可维护和可测试的分布式系统。它通过提供一系列可组合的组件，解决了分布式系统中的常见问题，使开发者能够专注于业务逻辑。Go-kit的核心理念是通过可插拔的组件来实现微服务的功能，这些组件包括服务发现、负载均衡、请求追踪、日志记录和监控等。</p><h2 id="go-kit基本架构">Go-kit基本架构</h2><p>Go-kit包含了一些基本的组件，如服务端点（Endpoint）、传输层（Transport）、服务发现、负载均衡等。服务端点是Go-kit 中微服务的基本构建块，用于定义 RPC消息模式。传输层提供了将特定序列化算法绑定到端点的辅助方法，目前支持JSON 和 HTTP 协议。</p><p>Go-kit的架构来源：https://github.com/go-kit/kit</p><p>基本的Go-kit的三层架构</p><ol type="1"><li><p>Transport</p><p>主要负责与HTTP、gRPC、thrift等相关的逻辑，提供端到端的通信服务，不同的传输协议来实现这些功能，最常见的协议是TCP（传输控制协议）和UDP（用户数据报协议）。</p></li><li><p>Endpoint</p><p>定义Request和Response格式,并可以使用装饰器包装函数，以此来实现各种中间件嵌套。</p></li><li><p>Service</p><p>主要职责是处理业务逻辑，也就是应用程序的核心功能和规则，这里就是我们的业务类、接口等。</p></li></ol><h2 id="go-kit的demo">Go-kit的demo</h2><p>接下来我们将给出一个简单的demo（对输入的字符串大写转换和字符串个数计数的功能）来对Go-kit的基本架构的实现和功能展示：</p><h3 id="service层"><strong>Service层</strong></h3><p>首先这个层会给出业务的逻辑实现，核心功能和规则</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> services<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;errors&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-comment">// StringService 定义了字符串处理服务的接口</span><br><span class="hljs-comment">// 这个地方给出接口，相当于是虚基类，后续的接口继承需要实现这部分的函数内容</span><br><span class="hljs-keyword">type</span> StringService <span class="hljs-keyword">interface</span> &#123;<br>Uppercase(<span class="hljs-type">string</span>) (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) <span class="hljs-comment">//返回的值是一个string和一个error</span><br>Count(<span class="hljs-type">string</span>) <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// SStringService 实现了 StringService 接口</span><br><span class="hljs-keyword">type</span> SStringService <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// Uppercase 将字符串转换为大写</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(SStringService)</span></span> Uppercase(s <span class="hljs-type">string</span>) (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> s == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, errors.New(<span class="hljs-string">&quot;Input string is empty&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> strings.ToUpper(s), <span class="hljs-literal">nil</span> <span class="hljs-comment">//直接调用string的功能来实现大小写转换</span><br>&#125;<br><br><span class="hljs-comment">// Count 返回字符串的字符数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(SStringService)</span></span> Count(s <span class="hljs-type">string</span>) <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(s)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>实现功能service的方式一般总结来说是：</p><ul><li>定义服务接口Interface{}，再定义结构体来实现这个接口的函数来实现继承</li><li>具体的函数内容就表示了业务的实际功能</li></ul><h3 id="endpoint层"><strong>Endpoint层</strong></h3><p>这部分会给出不同的endpoint接口的类型定义，使用不同的type定义request和response的json格式类型，用于后续的变量的选择命名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> endpoints<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;github.com/go-kit/kit/endpoint&quot;</span><br><span class="hljs-string">&quot;go-kit-test/services&quot;</span><br>)<br><br><span class="hljs-comment">//这个地方借助go-kit来实现endpoint的内容</span><br><span class="hljs-comment">// uppercaseRequest 和 uppercaseResponse 用于 Uppercase 端点</span><br><span class="hljs-keyword">type</span> uppercaseRequest <span class="hljs-keyword">struct</span> &#123;<br>S <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;s&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> uppercaseResponse <span class="hljs-keyword">struct</span> &#123;<br>V   <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;v&quot;`</span><br>Err <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;err,omitempty&quot;`</span><br>&#125;<br><br><span class="hljs-comment">// countRequest 和 countResponse 用于 Count 端点</span><br><span class="hljs-keyword">type</span> countRequest <span class="hljs-keyword">struct</span> &#123;<br>S <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;s&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> countResponse <span class="hljs-keyword">struct</span> &#123;<br>V <span class="hljs-type">int</span> <span class="hljs-string">`json:&quot;v&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>定义总的Endpoints接口，<code>type Endpoints</code>这个地方将会用于后续的对象的创建，<code>func MakeEndpoints</code>函数将被其他的函数进行调用用于创建内部的端点对象，其中在创建的过程中会调用以下的函数来分别创建两个功能的端口类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Endpoints <span class="hljs-keyword">struct</span> &#123;<br>UppercaseEndpoint endpoint.Endpoint<br>CountEndpoint     endpoint.Endpoint<br>&#125;<br><br><span class="hljs-comment">// MakeEndpoints 创建并返回所有服务端点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MakeEndpoints</span><span class="hljs-params">(svc services.StringService)</span></span> Endpoints &#123;<br><span class="hljs-keyword">return</span> Endpoints&#123;<br>UppercaseEndpoint: MakeUppercaseEndpoint(svc),<br>CountEndpoint:     MakeCountEndpoint(svc),<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// MakeUppercaseEndpoint 创建 Uppercase 端点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MakeUppercaseEndpoint</span><span class="hljs-params">(svc services.StringService)</span></span> endpoint.Endpoint &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, request <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>req := request.(uppercaseRequest)<br>result, err := svc.Uppercase(req.S)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> uppercaseResponse&#123;result, err.Error()&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> uppercaseResponse&#123;result, <span class="hljs-string">&quot;&quot;</span>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// MakeCountEndpoint 创建 Count 端点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MakeCountEndpoint</span><span class="hljs-params">(svc services.StringService)</span></span> endpoint.Endpoint &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, request <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>req := request.(countRequest)<br>result := svc.Count(req.S)<br><span class="hljs-keyword">return</span> countResponse&#123;result&#125;, <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="transport层">Transport层</h3><p>主体的实现框架，分别给出了两个不同服务接口的<code>response</code>和<code>request</code>的数据类型这部分给出<code>json</code>格式</p><p><code>http.NewServeMux()</code>返回一个新的<code>http.ServeMux</code>，这是一个用于处理HTTP请求的请求轮询器（requestrouter）。接下来，为<code>/uppercase和/count</code>路径分别配置了新的<code>httptransport.NewServer</code>服务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> uppercaseRequest <span class="hljs-keyword">struct</span> &#123;<br>S <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;s&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> uppercaseResponse <span class="hljs-keyword">struct</span> &#123;<br>V   <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;v&quot;`</span><br>Err <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;err,omitempty&quot;`</span><br>&#125;<br><br><span class="hljs-comment">// countRequest 和 countResponse 用于 Count 端点</span><br><span class="hljs-keyword">type</span> countRequest <span class="hljs-keyword">struct</span> &#123;<br>S <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;s&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> countResponse <span class="hljs-keyword">struct</span> &#123;<br>V <span class="hljs-type">int</span> <span class="hljs-string">`json:&quot;v&quot;`</span><br>&#125;<br><span class="hljs-comment">// MakeHTTPHandler 创建 HTTP 处理程序</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MakeHTTPHandler</span><span class="hljs-params">(endpoints endpoints.Endpoints)</span></span> http.Handler &#123;<br>options := []httptransport.ServerOption&#123;<br>httptransport.ServerErrorEncoder(errorEncoder),<br>&#125;<br><span class="hljs-comment">//http.NewServeMux()返回一个新的http.ServeMux，这是一个用于处理HTTP请求的请求轮询器（request router）。</span><br><span class="hljs-comment">//接下来，为/uppercase和/count路径分别配置了httptransport.NewServer：</span><br>m := http.NewServeMux()<br><span class="hljs-comment">//httptransport.NewServer是一个函数，它接受几个参数来创建一个新的HTTP服务器端点：</span><br>m.Handle(<span class="hljs-string">&quot;/uppercase&quot;</span>, httptransport.NewServer(<br>endpoints.UppercaseEndpoint,<br>decodeUppercaseRequest,<br>encodeResponse,<br>options...,<br>))<br>m.Handle(<span class="hljs-string">&quot;/count&quot;</span>, httptransport.NewServer(<br>endpoints.CountEndpoint,<br>decodeCountRequest,<br>encodeResponse,<br>options...,<br>))<br><br><span class="hljs-keyword">return</span> m<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意在定义endpoint的时候，要对request编码，对response解码</strong></p><p>具体的解码和编码的过程如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">decodeUppercaseRequest</span><span class="hljs-params">(_ context.Context, r *http.Request)</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">var</span> request uppercaseRequest<br><span class="hljs-keyword">if</span> err := json.NewDecoder(r.Body).Decode(&amp;request); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> request, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// decodeCountRequest 解码 HTTP 请求并创建 Count 请求结构</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">decodeCountRequest</span><span class="hljs-params">(_ context.Context, r *http.Request)</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">var</span> request countRequest<br><span class="hljs-keyword">if</span> err := json.NewDecoder(r.Body).Decode(&amp;request); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> request, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// encodeResponse 将响应编码为 JSON 并写入 HTTP 响应</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">encodeResponse</span><span class="hljs-params">(_ context.Context, w http.ResponseWriter, response <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> json.NewEncoder(w).Encode(response)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="main主层">Main主层</h3><p>这一层是最外层的调用层：<code>go run main.go</code>，这一层的逻辑实现主要是：</p><ul><li>创建一个service服务接口对象</li><li>将接口对象作为参数传入并生成endpoint相应的端点</li><li><code>httpHandler := transports.MakeHTTPHandler(eps)</code>这一步是产生<code>http</code>的根据提供的Endpoint配置来创建一个HTTP处理程序，这个处理程序负责处理来自客户端的HTTP请求，并将响应返回给客户端</li><li>对于任何来到根路径（<code>"/"</code>）的请求，都应该由<code>httpHandler</code>来处理。httpHandler是在之前的步骤中创建的HTTP处理程序，它知道如何处理<code>HTTP</code>请求并生成响应。这意味着当你访问服务器的根URL<code>（例如，http://localhost:8080/）</code>时，httpHandler中定义的处理逻辑将会被执行</li><li>其中端口8080可以根据自己的需求进行指定</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;go-kit-test/endpoints&quot;</span><br><span class="hljs-string">&quot;go-kit-test/services&quot;</span><br><span class="hljs-string">&quot;go-kit-test/transports&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>svc := services.SStringService&#123;&#125;    <span class="hljs-comment">//定义一个对象svc</span><br>eps := endpoints.MakeEndpoints(svc) <span class="hljs-comment">//接收svc作为输入，创建endpoint端点</span><br>httpHandler := transports.MakeHTTPHandler(eps)<br><br>http.Handle(<span class="hljs-string">&quot;/&quot;</span>, httpHandler)<br>port := <span class="hljs-string">&quot;:8080&quot;</span><br><span class="hljs-keyword">if</span> p := os.Getenv(<span class="hljs-string">&quot;PORT&quot;</span>); p != <span class="hljs-string">&quot;&quot;</span> &#123;<br>port = <span class="hljs-string">&quot;:&quot;</span> + p<br>&#125;<br><br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Service listening on port&quot;</span> + port)<br>http.ListenAndServe(port, <span class="hljs-literal">nil</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="go-kitgin架构">Go-kit+Gin架构</h1><p><strong>Go-kit</strong>是一个微服务工具集，它提供了服务发现、负载均衡、请求追踪、日志记录和监控等功能，帮助开发者构建健壮、可维护、可测试的分布式系统。</p><p><strong>Gin</strong>是一个轻量级的<strong>GoWeb</strong>框架，它提供了一个优雅的API和中间件支持，使得编写Web应用程序变得更加快速和简单</p><p><strong>将两者进行结合：</strong>Gin负责处理HTTP请求和响应，提供路由和中间件功能，而go-kit则可以处理服务间的通信，提供服务发现、负载均衡等分布式系统功能。go-kit和Gin的结合使用，可以使得GoWeb应用的开发更加高效和模块化，有助于构建高性能、可伸缩且易于维护的分布式系统。</p><h2 id="apiservice实现">ApiService实现</h2><p>我们需要利用gin对web端的应用程序进行实现，因此在这个架构之下我们设计的框架为：</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240127123105999.png" alt="Gin+Gokit架构图结构" style="zoom:50%;" /></p><p>其中<code>services、endpoints、transports</code>的功能和原来的<code>go-kit</code>基本一样，而<code>handler</code>主要处理的是gin的关于<code>web</code>端内容的控制，下面给出具体的实现</p><h3 id="service层-1">Service层</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> services<br><span class="hljs-keyword">type</span> IUserService <span class="hljs-keyword">interface</span> &#123;<br>GetName(userId <span class="hljs-type">int</span>) <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> UserService <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s UserService)</span></span> GetName(userId <span class="hljs-type">int</span>) <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> userId == <span class="hljs-number">101</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;calvin&quot;</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;guest&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个地方给出了具体的业务的实现接口功能</p><h3 id="endpoint层-1">Endpoint层</h3><p>在实现端口的过程中一般都需要对相关的<code>type</code>类型进行定义和对应的<code>json</code>格式的描述，函数<code>GetUserEndPoint</code>返回一个<code>endpoint.Endpoint</code>的类型，这个函数用于后续的调用产生<code>endpoint</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs GO"><span class="hljs-keyword">package</span> endpoints<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;ApiService/services&quot;</span><br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;github.com/go-kit/kit/endpoint&quot;</span><br>)<br><span class="hljs-keyword">type</span> UserRequest <span class="hljs-keyword">struct</span> &#123;<br>Uid <span class="hljs-type">int</span> <span class="hljs-string">`json:&quot;uid&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> UserResponse <span class="hljs-keyword">struct</span> &#123;<br>Result <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;result&quot;`</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetUserEndPoint</span><span class="hljs-params">(userService services.IUserService)</span></span> endpoint.Endpoint &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, request <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>r := request.(UserRequest)<br>result := userService.GetName(r.Uid)<br><span class="hljs-keyword">return</span> UserResponse&#123;Result: result&#125;, <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="transport层-1">Transport层</h3><p>主要做的事情就是对<code>request</code>和<code>response</code>的解码和编码过程，因为通过对<code>request</code>的解码才能转换成能识别的json格式，才能进行业务端的使用，而后面的编码是为了能够进入<code>web</code>端</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> transports<br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;ApiService/endpoints&quot;</span><br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;errors&quot;</span><br>httptransport <span class="hljs-string">&quot;github.com/go-kit/kit/transport/http&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;strconv&quot;</span><br>)<br><span class="hljs-comment">// 请求解码函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DecodeUserRequest</span><span class="hljs-params">(ctx context.Context, r *http.Request)</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// 限定参数来源,我们直接从url的params中获取用户id</span><br><span class="hljs-comment">// 请求格式类似于：http://127.0.0.1?uid=101</span><br><span class="hljs-keyword">if</span> r.URL.Query().Get(<span class="hljs-string">&quot;uid&quot;</span>) != <span class="hljs-string">&quot;&quot;</span> &#123;<br>uid, _ := strconv.Atoi(r.URL.Query().Get(<span class="hljs-string">&quot;uid&quot;</span>)) <span class="hljs-comment">//strconv.Atoi(...)将字符串转化为整数</span><br><span class="hljs-keyword">return</span> endpoints.UserRequest&#123;Uid: uid&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;参数错误&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 响应编码函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">EncodeUserResponse</span><span class="hljs-params">(ctx context.Context, w http.ResponseWriter, response <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 将返回体body置为json格式</span><br><span class="hljs-keyword">return</span> httptransport.EncodeJSONResponse(context.Background(), w, response)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="handle层">Handle层</h3><p>这一层主要的作用就是利用gin来对web的实现，传递的参数分别是</p><p><code>handler := httptransport.NewServer(endpoint, transports.DecodeUserRequest, transports.EncodeUserResponse)</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> handler<br><br><span class="hljs-keyword">import</span> (<br>. <span class="hljs-string">&quot;ApiService/endpoints&quot;</span> <br>. <span class="hljs-string">&quot;ApiService/services&quot;</span><br><span class="hljs-string">&quot;ApiService/transports&quot;</span><br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>httptransport <span class="hljs-string">&quot;github.com/go-kit/kit/transport/http&quot;</span><br>)<br><span class="hljs-comment">// 创建 Gin 路由</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MakeGinHandler</span><span class="hljs-params">(svc IUserService)</span></span> *gin.Engine &#123;<br><span class="hljs-comment">//初始化一个Gin引擎，并配置了一些中间件</span><br>r := gin.New()<br>r.Use(gin.Logger())   <span class="hljs-comment">//用于记录每个请求的详细信息，例如请求方法、URL、执行时间等</span><br>r.Use(gin.Recovery()) <span class="hljs-comment">//在程序发生 panic 时恢复运行，并返回一个500的HTTP状态码</span><br><br><span class="hljs-comment">// 创建 Go kit 的 endpoint</span><br>endpoint := GetUserEndPoint(svc)<br><br><span class="hljs-comment">// 创建 HTTP 传输层处理程序</span><br>handler := httptransport.NewServer(endpoint, transports.DecodeUserRequest, transports.EncodeUserResponse)<br>r.GET(<span class="hljs-string">&quot;/hello&quot;</span>, gin.WrapH(handler))<br><span class="hljs-keyword">return</span> r<br>&#125;<br><br></code></pre></td></tr></table></figure><p>注意在调用包的时候：</p><ul><li><code>. "ApiService/endpoints"</code>那么在引用函数的时候就不需要<code>endpoints.XXX()</code></li><li><code>"ApiService/transports"</code>那么在引用函数的时候需要<code>transports.XXX()</code></li></ul><h3 id="main层">Main层</h3><p>这一层的实现是通过以下三个步骤实现的：</p><ul><li><strong>创建go -kit服务</strong></li><li><strong>创建gin路由并绑定服务</strong></li><li><strong>启动gin服务器</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs GO"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> (<br>    . <span class="hljs-string">&quot;ApiService/handler&quot;</span><br>    . <span class="hljs-string">&quot;ApiService/services&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建 Go kit 服务</span><br>    userSvc := UserService&#123;&#125;<br>    <span class="hljs-comment">// 创建 Gin 路由并绑定服务</span><br>    r := MakeGinHandler(userSvc)<br>    <span class="hljs-comment">// 启动 Gin 服务器</span><br>    <span class="hljs-keyword">if</span> err := r.Run(<span class="hljs-string">&quot;:8080&quot;</span>); err != <span class="hljs-literal">nil</span> &#123;<br>       log.Fatal(err)<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">说明，这个demo运行后，浏览器输入 http://127.0.0.1:8080/hello?uid=1999 即可测试，还可以输入下面的内容进行测试：</span><br><span class="hljs-comment"> http://127.0.0.1:8080/hello</span><br><span class="hljs-comment"> http://127.0.0.1:8080</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h1 id="gin统一收集路由">Gin统一收集路由</h1><p>统一收集路由（unified routingcollection）通常指的是将所有的路由配置集中到一个地方管理，这样可以更方便地管理和维护路由。Gin本身已经提供了一个路由器（Router）对象，用于收集和管理所有的路由。统一收集路由的好处包括：</p><ul><li>易于维护：所有的路由都在一个地方，便于查看和修改。</li><li>路由重用：可以定义全局中间件，这些中间件会在所有路由上应用，而不需要在每个路由上重复编写。</li><li>更好的错误处理：可以在统一的地方处理路由错误，例如未找到路由或方法不允许等。</li><li>性能优化：Gin 路由器会预编译路由，这可以提高处理请求的效率</li></ul><h2 id="局部的路由规则初始化">局部的路由规则初始化</h2><p>首先定义局部的具体路由规则，这里给出例子<code>GetUserRoutes</code>和<code>GetVideoRoutes</code>，在 Gin路由器中注册与视频相关的路由规则。这个函数接受一个<code>*gin.RouterGroup</code>参数</p><p>它创建了一个新的子路由组video，这是通过调用<code>route.Group("/videos")</code>实现的。这个子路由组将会处理所有以<code>/videos</code>开头的请求。</p><p>然后，<code>video.GET("/getVideoId", handler.GetVideoId)</code>这行代码为路径<code>/videos/getVideoId</code> 注册了一个新的 GET请求处理函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> route<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;ApiService/handler&quot;</span><br>    <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetUserRoutes</span><span class="hljs-params">(route *gin.RouterGroup)</span></span> &#123;<br>    user := route.Group(<span class="hljs-string">&quot;/users&quot;</span>)<br>    &#123;<br>       user.GET(<span class="hljs-string">&quot;/getUserId&quot;</span>, handler.GetUserId)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;ApiService/handler&quot;</span><br>    <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetVideoRoutes</span><span class="hljs-params">(route *gin.RouterGroup)</span></span> &#123;<br>    video := route.Group(<span class="hljs-string">&quot;/videos&quot;</span>)<br>    &#123;<br>       video.GET(<span class="hljs-string">&quot;/getVideoId&quot;</span>, handler.GetVideoId)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="全局路由规则统一">全局路由规则统一</h2><p>设置Gin路由<strong>统一收集的</strong><strong><code>CollectRoute</code>的函数</strong>，它的作用是将一系列的路由规则注册到Gin 路由器实例中。r <strong>是 Gin的路由器实例</strong>，这部分内容可以忽略（svc是某个服务接口的实例，这里是指 IUserService 接口的实例）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> route<br><br><span class="hljs-keyword">import</span> (<br>    . <span class="hljs-string">&quot;ApiService/handler&quot;</span><br>    . <span class="hljs-string">&quot;ApiService/services&quot;</span><br>    <span class="hljs-string">&quot;ApiService/transports&quot;</span><br>    <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>    httptransport <span class="hljs-string">&quot;github.com/go-kit/kit/transport/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CollectRoute</span><span class="hljs-params">(r *gin.Engine, svc IUserService)</span></span> *gin.Engine &#123;<br>    r.Use(gin.Logger())<br>    r.Use(gin.Recovery())<br><br>    handler := httptransport.NewServer(MakeGinHandler(svc), transports.DecodeUserRequest, transports.EncodeUserResponse)<br>    api := r.Group(<span class="hljs-string">&quot;&quot;</span>)<br>    &#123;<br>       GetUserRoutes(api)<br>       GetVideoRoutes(api)<br>       api.GET(<span class="hljs-string">&quot;/hello&quot;</span>, gin.WrapH(handler))<br>    &#125;<br>    api.POST(<span class="hljs-string">&quot;/ping&quot;</span>, Ping)<br>    api.GET(<span class="hljs-string">&quot;/ping&quot;</span>, Ping)<br><br>    <span class="hljs-keyword">return</span> r<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="主函数初始化调用">主函数初始化调用</h2><p>在 Gin Web 框架中，<code>gin.Default()</code> 创建了一个默认的 Gin路由器实例</p><p><code>r = route.CollectRoute(r, userSvc)</code>这行代码的作用是将一系列的路由规则注册到Gin 路由器实例中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建 Go kit 服务</span><br>    userSvc := UserService&#123;&#125;<br>    <span class="hljs-comment">// 创建 Gin 路由并绑定服务</span><br>    r := gin.Default()<br>    r = route.CollectRoute(r, userSvc)<br>    <span class="hljs-comment">//r := MakeGinHandler(userSvc)</span><br>    <span class="hljs-comment">// 启动 Gin 服务器</span><br>    <span class="hljs-keyword">if</span> err := r.Run(<span class="hljs-string">&quot;:8080&quot;</span>); err != <span class="hljs-literal">nil</span> &#123;<br>       log.Fatal(err)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实际运行结果">实际运行结果</h2><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240127180429934.png" alt="根据不同的url地址选择不同的输出" style="zoom:67%;" /></p>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【多智能体强化学习】Pymarl代码分析</title>
    <link href="/2024/01/19/marl_pymarl_code/"/>
    <url>/2024/01/19/marl_pymarl_code/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="pymarl代码结构">Pymarl代码结构</h1><p>本文章主要介绍多智能体强化学习中的PyMarl框架的代码结构以及训练流程</p><h2 id="main">Main</h2><p>Pymarl的主文件（<code>main.py</code>)主要的作用是构建一个<strong>sacred.Experiment</strong> 类的对象 <code>ex</code>，<code>ex</code> 包含三个重要的内置变量：</p><ul><li><code>_run</code>：表示当前实验运行时的 <strong>run</strong>对象，<code>_run.info</code>可用于记录实验中产生的结果，实验初始时是空字典<code>&#123;&#125;</code>；</li><li><code>_config</code>：表示当前实验运行时的参数，字典类，pymarl首先读取配置文件然后利用<code>ex.add_config()</code>将配置文件中的参数添加到<code>_config</code>变量中；</li><li><code>_log</code>：一个<strong>logger</strong>，pymarl首先创建了一个<strong>logging.logger</strong> 类的对象<code>logger</code>，然后将<code>logger</code> 赋给了 <code>ex.logger</code> 也就是<code>_log</code>。<code>_log</code> 可以通过<code>_log.info('information')</code>在控制台打印实验过程中的中间信息，方便我们能够定期追踪实验状态。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@ex.main</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_main</span>(<span class="hljs-params">_run, _config, _log</span>):<br>    <span class="hljs-comment"># Setting the random seed throughout the modules</span><br>    config = config_copy(_config)<br>    np.random.seed(config[<span class="hljs-string">&quot;seed&quot;</span>])<br>    th.manual_seed(config[<span class="hljs-string">&quot;seed&quot;</span>])<br>    config[<span class="hljs-string">&#x27;env_args&#x27;</span>][<span class="hljs-string">&#x27;seed&#x27;</span>] = config[<span class="hljs-string">&quot;seed&quot;</span>]<br></code></pre></td></tr></table></figure><h2 id="run">Run</h2><p>如何进入：通过借助装饰器定义一个主函数，其中还定义了如何运行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># run</span><br>   <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;use_per&quot;</span> <span class="hljs-keyword">in</span> _config <span class="hljs-keyword">and</span> _config[<span class="hljs-string">&quot;use_per&quot;</span>]:<br>       run_REGISTRY[<span class="hljs-string">&#x27;per_run&#x27;</span>](_run, config, _log)<br>   <span class="hljs-keyword">else</span>:<br>       run_REGISTRY[_config[<span class="hljs-string">&#x27;run&#x27;</span>]](_run, config, _log)<br></code></pre></td></tr></table></figure><p>关于这部分<code>run_REGISTRY</code>字典的设置，在初始化中文件中会进行指定：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> .run <span class="hljs-keyword">import</span> run <span class="hljs-keyword">as</span> default_run<br><span class="hljs-keyword">from</span> .interval_run <span class="hljs-keyword">import</span> run <span class="hljs-keyword">as</span> interval_run<br><br>REGISTRY = &#123;&#125;<br>REGISTRY[<span class="hljs-string">&quot;default&quot;</span>] = default_run<br>REGISTRY[<span class="hljs-string">&quot;interval_run&quot;</span>] = interval_run<br></code></pre></td></tr></table></figure><p>这个地方引入的<code>import run as default_run</code>就是指定了在某个文件中的<code>run</code>函数主体，通过最<strong>外层的装饰器进行指定</strong>运行那个合适的<code>run</code>函数</p><p><code>run_REGISTRY[_config['run']](_run, config, _log)</code>表示了指定运行哪个函数，并传递相关的参数</p><p><code>run.py</code>文件中<code>run</code>函数的主要作用是构建实验参数变量 <code>args</code>以及一个自定义 <code>Logger</code> 类的记录器<code>logger</code>。内置变量<code>_config</code>的拷贝作为参数传入到了<code>run</code>函数中，<code>_config</code>是字典变量，因此查看参数时，需要利用 <code>_config[key]=value</code>，在<code>run</code>函数中，作者构建了一个<code>namespace</code>类的变量<code>args</code>，将<code>_config</code>中的参数都传给了<code>args</code>，这样就可以通过<code>args.key=value</code>的方式查看参数了。</p><p>其中<code>'run'</code> 指的是在参数文件中指定的，比如在<code>default.yaml</code> 文件中会进行指定字典中的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">logger = Logger(_log)<br><br>  _log.info(<span class="hljs-string">&quot;Experiment Parameters:&quot;</span>)<br>  experiment_params = pprint.pformat(_config,<br>                                     indent=<span class="hljs-number">4</span>,<br>                                     width=<span class="hljs-number">1</span>)<br>  _log.info(<span class="hljs-string">&quot;\n\n&quot;</span> + experiment_params + <span class="hljs-string">&quot;\n&quot;</span>)<br></code></pre></td></tr></table></figure><p>上述代码中创建了一个 <code>Logger</code>类的实例，用于封装日志记录的功能，用于记录信息，<code>_log.info()</code>使用的就是用于打印日志信息的语句，其中消息内容哥就是<code>Experiment Parameters</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">run_sequential(args=args, logger=logger)<br></code></pre></td></tr></table></figure><p>这一步是主要的实验运行的板块<strong>==<code>run_sequential</code>==</strong>，借助这个板块对实验运行的内容进行管理和控制，接下来将对这个板块的实现进行详细的介绍。将参数以及初始化创建之后的日志板块都传递进这个函数内部进行训练</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Clean up after finishing</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Exiting Main&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Stopping all threads&quot;</span>)<br>    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threading.<span class="hljs-built_in">enumerate</span>():<br>        <span class="hljs-keyword">if</span> t.name != <span class="hljs-string">&quot;MainThread&quot;</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Thread &#123;&#125; is alive! Is daemon: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(t.name, t.daemon))<br>            t.join(timeout=<span class="hljs-number">1</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Thread joined&quot;</span>)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Exiting script&quot;</span>)<br>    <span class="hljs-comment"># Making sure framework really exits</span><br>    os._exit(os.EX_OK)<br></code></pre></td></tr></table></figure><p>结尾部分就是对进程的退出和控制。</p><h2 id="run-sequential">Run Sequential</h2><p>这部分是<strong>run的核心</strong>，也是对内部的函数进行控制和调用的关键</p><h3 id="mac管理器">Mac管理器</h3><p><strong>主要被扔进 <code>runnner</code> 和 <code>learner</code>两个板块中使用</strong></p><p>属于自定义的<code>controller.basic_controller.BasicMAC</code>类，该对象的主要作用是<strong>控制智能体</strong>，因此<code>mac</code>对象中的一个重要属性就是<code>nn.module</code>类的智能体对象<code>mac.agent</code>，该对象定义了各个智能体的局部Q网络，即接收观测作为输入，输出智能体各个动作的Q值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Setup multiagent controller here</span><br>   mac = mac_REGISTRY[args.mac](buffer.scheme, groups, args)<br></code></pre></td></tr></table></figure><p><code>mac</code>对象有<strong>两个关键方法</strong>：</p><ul><li><code>mac.forward(ep_batch, t, test_mode=False)</code>：<code>ep_batch</code>表示一个episode的样本，<code>t</code>表示每个样本在该episode内的时间索引，<code>forward()</code>方法的作用是<strong>输出一个episode内每</strong>个时刻的观测对应的所有动作的Q值与<strong>隐层变量</strong><code>mac.hidden_states</code>。</li><li><code>mac.select_actions(self, ep_batch, t_ep, t_env, bs=slice(None), test_mode=False)</code>：该方法用于在一个episode中每个时刻<strong>为所有智能体选择动作</strong>。<code>t_ep</code>代表当前样本在一个episode中的时间索引。<code>t_env</code>代表当前时刻环境运行的总时间，用于计算epsilon-greedy中的epsilon。</li></ul><h3 id="环境运行器">环境运行器</h3><p>首先初始化环境的运行器，这部分能够获取环境的信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">runner = r_REGISTRY[args.runner](args=args, logger=logger)<br></code></pre></td></tr></table></figure><p>尝试从环境中获取相关的数据信息，如各种智能体数量、动作空间维度、状态的维度等</p><p>其中<code>getattr(args, "accumulated_episodes", None)</code>的意思是，如果<code>args</code>中有<code>"accumulated_episodes"</code>，那么就获取，否则就设置为<code>None</code> 一种很优雅的写法，下面的也是同理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">env_info = runner.get_env_info()<br>args.n_agents = env_info[<span class="hljs-string">&quot;n_agents&quot;</span>]<br>args.n_actions = env_info[<span class="hljs-string">&quot;n_actions&quot;</span>]<br>args.state_shape = env_info[<span class="hljs-string">&quot;state_shape&quot;</span>]<br>args.accumulated_episodes = <span class="hljs-built_in">getattr</span>(args, <span class="hljs-string">&quot;accumulated_episodes&quot;</span>, <span class="hljs-literal">None</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">getattr</span>(args, <span class="hljs-string">&#x27;agent_own_state_size&#x27;</span>, <span class="hljs-literal">False</span>):<br>        args.agent_own_state_size = get_agent_own_state_size(args.env_args)<br></code></pre></td></tr></table></figure><p>这个地方就是定义需要用到的强化学习字典数据结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">scheme = &#123;<br>     <span class="hljs-string">&quot;state&quot;</span>: &#123;<span class="hljs-string">&quot;vshape&quot;</span>: env_info[<span class="hljs-string">&quot;state_shape&quot;</span>]&#125;,<br>     <span class="hljs-string">&quot;obs&quot;</span>: &#123;<span class="hljs-string">&quot;vshape&quot;</span>: env_info[<span class="hljs-string">&quot;obs_shape&quot;</span>], <span class="hljs-string">&quot;group&quot;</span>: <span class="hljs-string">&quot;agents&quot;</span>&#125;,<br>     <span class="hljs-string">&quot;actions&quot;</span>: &#123;<span class="hljs-string">&quot;vshape&quot;</span>: (<span class="hljs-number">1</span>,), <span class="hljs-string">&quot;group&quot;</span>: <span class="hljs-string">&quot;agents&quot;</span>, <span class="hljs-string">&quot;dtype&quot;</span>: th.long&#125;,<br>     <span class="hljs-string">&quot;avail_actions&quot;</span>: &#123;<span class="hljs-string">&quot;vshape&quot;</span>: (env_info[<span class="hljs-string">&quot;n_actions&quot;</span>],), <span class="hljs-string">&quot;group&quot;</span>: <span class="hljs-string">&quot;agents&quot;</span>, <span class="hljs-string">&quot;dtype&quot;</span>: th.<span class="hljs-built_in">int</span>&#125;,<br>     <span class="hljs-string">&quot;probs&quot;</span>: &#123;<span class="hljs-string">&quot;vshape&quot;</span>: (env_info[<span class="hljs-string">&quot;n_actions&quot;</span>],), <span class="hljs-string">&quot;group&quot;</span>: <span class="hljs-string">&quot;agents&quot;</span>, <span class="hljs-string">&quot;dtype&quot;</span>: th.<span class="hljs-built_in">float</span>&#125;,<br>        <span class="hljs-string">&quot;reward&quot;</span>: &#123;<span class="hljs-string">&quot;vshape&quot;</span>: (<span class="hljs-number">1</span>,)&#125;,<br>        <span class="hljs-string">&quot;terminated&quot;</span>: &#123;<span class="hljs-string">&quot;vshape&quot;</span>: (<span class="hljs-number">1</span>,), <span class="hljs-string">&quot;dtype&quot;</span>: th.uint8&#125;,&#125;<br>groups = &#123; <span class="hljs-string">&quot;agents&quot;</span>: args.n_agents&#125;<br>preprocess = &#123;<span class="hljs-string">&quot;actions&quot;</span>: (<span class="hljs-string">&quot;actions_onehot&quot;</span>, [OneHot(out_dim=args.n_actions)])&#125;<br>buffer = ReplayBuffer(scheme, groups, args.buffer_size, env_info[<span class="hljs-string">&quot;episode_limit&quot;</span>] + <span class="hljs-number">1</span>,<br>                          preprocess=preprocess,<br>                          device=<span class="hljs-string">&quot;cpu&quot;</span> <span class="hljs-keyword">if</span> args.buffer_cpu_only <span class="hljs-keyword">else</span> args.device)<br></code></pre></td></tr></table></figure><p>初始化运行环境，确保所有必要的组件都已经配置好，以便开始运行或者训练算法。这个方法可能会创建必要的数据结构，设置好数据流，以及准备环境来执行特定的训练或测试循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">runner.setup(scheme=scheme, groups=groups, preprocess=preprocess, mac=mac)<br></code></pre></td></tr></table></figure><p><code>runner</code>对象中最关键的方法是：</p><p><code>runner.run(test_mode=False)</code>：利用当前智能体<code>mac</code>在环境中运行（需要用到<code>mac</code>对象），产生一个episode的样本数据<code>episode_batch</code>，存储在<code>runner.batch</code>中。</p><h3 id="buffer存储器">Buffer存储器</h3><p><code>buffer</code>对象属于自定义的<code>components.episode_buffer.ReplayBuffer(EpisodeBatch)</code>类，该对象的主要作用是<strong>存储样本以及采样样本</strong>。<code>ReplayBuffer</code>的父类是<code>EpisodeBatch</code>。<code>EpisodeBatch</code>类对象用于存储episode的样本，<code>ReplayBuffer(EpisodeBatch)</code>类对象则用于存储所有的off-policy样本，也即<code>EpisodeBatch</code>类变量的样本会持续地补充到<code>ReplayBuffer(EpisodeBatch)</code>类的变量中。同样由于QMix用的是DRQN结构，因此<code>EpisodeBatch</code>与<code>ReplayBuffer</code>中的样本都是以episode为单位存储的。在<code>EpisodeBatch</code>中数据的维度是<code>[batch_size, max_seq_length, *shape]</code>，<code>ReplayBuffer</code>类数据的维度是<code>[buffer_size, max_seq_length, *shape]</code>。<code>EpisodeBatch</code>中<code>Batch Size</code>表示此时batch中有多少episode，<code>ReplayBuffer</code>中<code>episodes_in_buffer</code>表示此时buffer中有多少个episode的有效样本。<code>max_seq_length</code>则表示一个episode的最大长度。</p><p><code>buffer</code>对象中的关键方法有：</p><ul><li><code>buffer.insert_episode_batch(ep_batch)</code>：将<code>EpisodeBatch</code>类变量<code>ep_batch</code>中的样本全部存储到<code>buffer</code>中。</li><li><code>buffer.sample(batch_size)</code>：从<code>buffer</code>中取出<code>batch_size</code>个episode的样本用于训练，这些样本组成了<code>EpisodeBatch</code>类的对象</li></ul><h3 id="learner学习器">Learner学习器</h3><p>自定义的<code>leaners.q_learner.QLearner</code>（与具体选择哪个算法有关），该对象的主要作用是<strong>依据特定算法对智能体参数进行训练更新</strong>。在QMix算法中，有<code>nn.module</code>类的混合网络<code>learner.mixer</code>，因此<code>learner</code>对象需要学习的参数包括各个智能体的局部Q网络参数<code>mac.parameters()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Learner</span><br>    learner = le_REGISTRY[args.learner](mac, buffer.scheme, logger, args)<br></code></pre></td></tr></table></figure><p>其中这个 <code>[args.learner]</code>参数是根据调用命令的时候传递的<code>config</code>的参数文件<code>config.yml</code>中的参数，在内部会一并将其参数统一收集使用</p><p><code>learner.train(batch: EpisodeBatch, t_env: int, episode_num: int)</code>：<code>batch</code>表示当前用于训练的样本，<code>t_env</code>表示当前环境运行的总时间步数，<code>episode_num</code>表示当前环境运行的总episode数，该方法利用特定算法对<code>learner.params</code>进行更新</p><h2 id="train过程">Train过程</h2><h3 id="收集buffer">收集buffer</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> th.no_grad():<br>            episode_batch = runner.run(test_mode=<span class="hljs-literal">False</span>)<br>            buffer.insert_episode_batch(episode_batch)<br></code></pre></td></tr></table></figure><p><code>with th.no_grad():</code>在前期的操作中我们只需要收集环境的交互信息，因此此时不需要用到梯度和推理</p><p><code>episode_batch = runner.run(test_mode=False)</code>这行代码调用了一个名为<code>runner</code>的对象的方法。这个<code>runner</code>可能是一个负责执行环境交互和收集经验的模块。<code>test_mode=False</code>表明这个调用是在训练模式下运行的，而不是测试模式在训练过程中，智能体（agent）会根据策略（policy）在环境中采取行动，收集一系列的剧集（episodes），这些剧集包含了状态（states）、动作（actions）、奖励（rewards）等信息.</p><p><code>buffer.insert_episode_batch(episode_batch)</code>这行代码将刚刚收集到的剧集批次（episode_batch）插入到一个名为buffer的数据结构中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">buffer.can_sample(args.batch_size)<br></code></pre></td></tr></table></figure><p>这一步是用来判断当前的<code>buffer</code>的容量是否超过了满足选择<code>batch_size</code>的大小，如果满足的话那么就可以在<code>buffer</code> 中开始选择对应的大小</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">episode_sample = buffer.sample(args.batch_size)<br></code></pre></td></tr></table></figure><p>上述的过程是对<code>buffer</code>中的元素内容进行采样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">max_ep_t = episode_sample.max_t_filled()<br>episode_sample = episode_sample[:, :max_ep_t]<br></code></pre></td></tr></table></figure><p>这一步是在补充时间步骤，在强化学习中，每个episode可能会有不同长度，因为它们可能由于早停或达到某个终止条件而长度不一。</p><p>第二步是在从其中<code>sample</code>之后的数据元素进行截取选择的结果</p><h3 id="train">Train</h3><p>具体的学习过程就会扔进<code>learner</code> 的学习器中进行训练参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">learner.train(episode_sample, runner.t_env, episode)<br></code></pre></td></tr></table></figure><p>调用学习器的<code>train</code>方法来实际进行训练。<code>episode_sample</code>是用来训练的数据，<code>runner.t_env</code>是环境步数（可能用于记录或者计算折扣因子等），<code>episode</code>可能是一个计数器或者记录当前是第几个<code>episode</code>的变量</p><p><strong>注意对于价值函数分解的方法会额外用到mixer</strong></p><p>为了具体分析<code>learner</code>的训练过程，我们这里给出基于<code>group</code>的学习代码来进行分析</p><ol type="1"><li><p>首先第一步是进行初始化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, mac, scheme, logger, args</span>):<br>        self.args = args<br>        self.mac = mac<br>        self.target_mac = copy.deepcopy(mac)<br>        self.params = <span class="hljs-built_in">list</span>(self.mac.parameters())<br>        self.logger = logger<br>        self.device = th.device(<span class="hljs-string">&#x27;cuda&#x27;</span> <span class="hljs-keyword">if</span> args.use_cuda  <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;cpu&#x27;</span>)<br>        <span class="hljs-keyword">if</span> args.mixer == <span class="hljs-string">&quot;group&quot;</span>:<br>            self.mixer = GroupMixer(args)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> <span class="hljs-string">&quot;mixer error&quot;</span><br>        self.target_mixer = copy.deepcopy(self.mixer)<br>        self.params += <span class="hljs-built_in">list</span>(self.mixer.parameters())<br>        <span class="hljs-comment">#其中这一步是将模型的参数量级进行输出</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Mixer Size: &#x27;</span>)<br>        <span class="hljs-built_in">print</span>(get_parameters_num(self.mixer.parameters()))<br>        <br>        <span class="hljs-keyword">if</span> self.args.optimizer == <span class="hljs-string">&#x27;adam&#x27;</span>:<br>            self.optimiser = Adam(params=self.params, lr=args.lr)<br>        <span class="hljs-keyword">else</span>:<br>            self.optimiser = RMSprop(params=self.params, lr=args.lr, alpha=args.optim_alpha, eps=args.optim_eps)<br>        self.last_target_update_episode = <span class="hljs-number">0</span><br>        self.log_stats_t = -self.args.learner_log_interval - <span class="hljs-number">1</span><br>        self.train_t = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>这里会初始化定义一些比如<code>mac/target mac</code>和<code>mixer/target mixer</code>的初始化参数内容，同时定义优化算子：Adam/RMSprop等内容</p></li><li><p>估计所有智能体的Q价值函数值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">mac_out = []<br>mac_hidden = []<br>mac_group_state = []<br><br>self.mac.init_hidden(batch.batch_size)<br><span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(batch.max_seq_length):<br>   agent_outs = self.mac.forward(batch, t=t)<br>   mac_hidden.append(self.mac.hidden_states)<br>   mac_group_state.append(self.mac.group_states)<br>   mac_out.append(agent_outs)<br><br>mac_out = th.stack(mac_out, dim=<span class="hljs-number">1</span>) <span class="hljs-comment">#得到所有的智能体的输出并堆在一起</span><br>mac_hidden = th.stack(mac_hidden, dim=<span class="hljs-number">1</span>)<br>mac_group_state = th.stack(mac_group_state, dim=<span class="hljs-number">1</span>)<br><br>mac_hidden = mac_hidden.detach() <span class="hljs-comment">#这一步相当于从计算图中取消不计算梯度</span><br></code></pre></td></tr></table></figure></li><li><p>学习并得到联合的Q价值函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Pick the Q-Values for the actions taken by each agent</span><br>chosen_action_qvals = th.gather(mac_out[:, :-<span class="hljs-number">1</span>], dim=<span class="hljs-number">3</span>, index=actions).squeeze(<span class="hljs-number">3</span>)<br><br> <span class="hljs-comment"># Mixer</span><br>chosen_action_qvals, w1_avg_list, sd_loss = self.mixer(chosen_action_qvals, batch[<span class="hljs-string">&quot;state&quot;</span>][:, :-<span class="hljs-number">1</span>], mac_hidden[:, :-<span class="hljs-number">1</span>], mac_group_state[:, :-<span class="hljs-number">1</span>], <span class="hljs-string">&quot;eval&quot;</span>)<br></code></pre></td></tr></table></figure><p>这一步中调用<code>mixer</code>的函数来学习联合的动作价值函数</p></li><li><p>计算target Q的值</p><p>最开始的步骤和Q函数的处理过程一样来学习每个智能体的价值函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> th.no_grad():<br>            target_mac_out = []<br>            target_mac_hidden = []<br>            target_mac_group_state = []<br><br>            self.target_mac.init_hidden(batch.batch_size)<br>            <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(batch.max_seq_length):<br>                target_agent_outs = self.target_mac.forward(batch, t=t)<br>                target_mac_hidden.append(self.target_mac.hidden_states)<br>                target_mac_group_state.append(self.target_mac.group_states)<br>                target_mac_out.append(target_agent_outs)<br></code></pre></td></tr></table></figure><p>计算得到目标的联合动作价值函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Calculate n-step Q-Learning targets</span><br>target_max_qvals, _, _ = self.target_mixer(target_max_qvals, batch[<span class="hljs-string">&quot;state&quot;</span>], target_mac_hidden, target_mac_group_state, <span class="hljs-string">&quot;target&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p>计算TD target</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">targets = build_td_lambda_targets(rewards, terminated, mask, target_max_qvals, <br>                                            self.args.n_agents, self.args.gamma, self.args.td_lambda)<br></code></pre></td></tr></table></figure><p>相当于计算 <span class="math inline">\(r+\gammaQ_{taregt}\)</span></p></li><li><p>计算TD error</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">td_error = (chosen_action_qvals - targets.detach())<br>td_error = <span class="hljs-number">0.5</span> * td_error.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure></li><li><p>注意填充的部分</p><ul><li><code>mask = mask.expand_as(td_error)</code>这一行代码中，<code>mask</code>它的元素为<code>True</code>的地方表示对应的序列元素是有效的，而<code>False</code>的地方表示对应的序列元素是填充的（或不存在的，在序列的开始部分）</li><li><code>expand_as</code>方法会将<code>mask</code>张量扩展到与<code>td_error</code>相同的大小，这样做是为了保证在计算<code>masked_td_error</code>时，<code>mask</code>能够覆盖<code>td_error</code>的每个元素。</li><li><code>masked_td_error = td_error * mask</code>在这一行中，结果<code>masked_td_error</code>只有在mask为<code>True</code>的位置才会有非零值，而在<code>mask</code>为<code>False</code>的位置（即填充的部分）将会是零。</li><li><code>td_loss = masked_td_error.sum() / mask.sum()</code>最后一行代码计算了<code>masked_td_error</code>的总和，然后除以<code>mask</code>的总和，这样可以得到一个标量损失值，这个值只包含了有效序列元素的贡献。这样做是为了在计算损失时忽略填充的部分，因为这些部分在训练过程中不应该影响模型的学习.</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">mask</span> = mask.expand_as(td_error)<br><span class="hljs-attr">masked_td_error</span> = td_error * mask<br><span class="hljs-attr">td_loss</span> = masked_td_error.sum() / mask.sum()<br></code></pre></td></tr></table></figure></li><li><p>最后的优化算子的部分反向传播</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">self.optimiser.zero_grad()<br>loss.backward()<br>grad_norm = th.nn.utils.clip_grad_norm_(self.params, self.args.grad_norm_clip)<br>self.optimiser.step()<br></code></pre></td></tr></table></figure></li><li><p>按照一定的时间步长更新目标网络</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> (episode_num - self.last_target_update_episode) / self.args.target_update_interval &gt;= <span class="hljs-number">1.0</span>:<br>     self._update_targets()<br>     self.last_target_update_episode = episode_num<br></code></pre></td></tr></table></figure><p>根据需要可以选择打印出log</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> t_env - self.log_stats_t &gt;= self.args.learner_log_interval:<br>            self.logger.log_stat(<span class="hljs-string">&quot;loss_td&quot;</span>, td_loss.item(), t_env)<br>            self.logger.log_stat(<span class="hljs-string">&quot;grad_norm&quot;</span>, grad_norm, t_env)<br>            mask_elems = mask.<span class="hljs-built_in">sum</span>().item()<br>            self.logger.log_stat(<span class="hljs-string">&quot;td_error_abs&quot;</span>, (masked_td_error.<span class="hljs-built_in">abs</span>().<span class="hljs-built_in">sum</span>().item()/mask_elems), t_env)<br>            self.logger.log_stat(<span class="hljs-string">&quot;q_taken_mean&quot;</span>, (chosen_action_qvals * mask).<span class="hljs-built_in">sum</span>().item()/(mask_elems * self.args.n_agents), t_env)<br>            self.logger.log_stat(<span class="hljs-string">&quot;target_mean&quot;</span>, (targets * mask).<span class="hljs-built_in">sum</span>().item()/(mask_elems * self.args.n_agents), t_env)<br>            self.logger.log_stat(<span class="hljs-string">&quot;total_loss&quot;</span>, loss.item(), t_env)<br>            self.logger.log_stat(<span class="hljs-string">&quot;lasso_loss&quot;</span>, lasso_loss.item(), t_env)<br>            self.logger.log_stat(<span class="hljs-string">&quot;sd_loss&quot;</span>, sd_loss.item(), t_env)          <br>            self.log_stats_t = t_env<br></code></pre></td></tr></table></figure></li></ol><h3 id="test">Test</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n_test_runs):<br>                runner.run(test_mode=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>注意这个地方就是对算法进行测试了</p>]]></content>
    
    
    <categories>
      
      <category>强化学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>深度学习</tag>
      
      <tag>强化学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【基础工具】Docker基础功能</title>
    <link href="/2024/01/19/tool_docker/"/>
    <url>/2024/01/19/tool_docker/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><ahref="https://docker.easydoc.net/doc/81170005/cCewZWoN/AWOEX9XM#nav_2">参考文档</a></p><h1 id="docker介绍">Docker介绍</h1><p>Docker是一个应用打包、分发、部署的工具，也可以把它理解为一个轻量的虚拟机，它只虚拟你软件需要的运行环境，多余的一点都不要，而普通虚拟机则是一个完整而庞大的系统，包含各种不管你要不要的软件。</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240119102920136.png" alt="Docker" style="zoom: 50%;" /></p><table><thead><tr class="header"><th>特性</th><th>普通虚拟机</th><th>Docker</th></tr></thead><tbody><tr class="odd"><td>跨平台</td><td>通常只能在桌面级系统运行，例如Windows/Mac，无法在不带图形界面的服务器上运行</td><td>支持的系统非常多，各类 windows 和 Linux 都支持</td></tr><tr class="even"><td>性能</td><td>性能损耗大，内存占用高，因为是把整个完整系统都虚拟出来了</td><td>性能好，只虚拟软件所需运行环境，最大化减少没用的配置</td></tr><tr class="odd"><td>自动化</td><td>需要手动安装所有东西</td><td>一个命令就可以自动部署好所需环境</td></tr><tr class="even"><td>稳定性</td><td>稳定性不高，不同系统差异大</td><td>稳定性好，不同系统都一样部署方式</td></tr></tbody></table><h3 id="docker-主要功能">Docker 主要功能</h3><ul><li><strong>打包</strong>：就是把你软件运行所需的依赖、第三方库、软件打包到一起，变成一个安装包</li><li><strong>分发</strong>：你可以把你打包好的“安装包”上传到一个镜像仓库，其他人可以非常方便的获取和安装</li><li><strong>部署</strong>：拿着“安装包”就可以一个命令运行起来你的应用，自动模拟出一摸一样的运行环境，不管是在Windows/Mac/Linux。</li></ul><h3 id="docker-用途介绍">Docker 用途介绍</h3><ul><li>应用分发、部署，方便传播给他人安装。特别是开源软件和提供私有部署的应用</li><li>快速安装测试/学习软件，用完就丢（类似小程序），不把时间浪费在安装软件上。例如Redis / MongoDB / ElasticSearch / ELK</li><li>多个版本软件共存，不污染系统，例如Python2、Python3，Redis4.0，Redis5.0</li><li>Windows 上体验/学习各种 Linux 系统</li></ul><h3 id="docker主要概念">Docker主要概念</h3><ul><li><strong>镜像</strong>：可以理解为软件安装包，可以方便的进行传播和安装。</li><li><strong>容器</strong>：软件安装后的状态，每个软件运行环境都是独立的、隔离的，称之为容器。</li><li>简单来说就是我们<strong>存储上传镜像，通过镜像生成容器</strong>，镜像可以在<strong>dockerhub</strong>中进行管理</li></ul><h1 id="docker的安装">Docker的安装</h1><h3 id="版本的安装">版本的安装</h3><ul><li>桌面版：<ahref="https://www.docker.com/products/docker-desktop">https://www.docker.com/products/docker-desktop</a></li><li>服务器版：<ahref="https://docs.docker.com/engine/install/#server">https://docs.docker.com/engine/install/#server</a></li></ul><h3 id="镜像加速源">镜像加速源</h3><table><thead><tr class="header"><th>镜像加速器</th><th>镜像加速器地址</th></tr></thead><tbody><tr class="odd"><td>Docker 中国官方镜像</td><td><ahref="https://registry.docker-cn.com">https://registry.docker-cn.com</a></td></tr><tr class="even"><td>DaoCloud 镜像站</td><td><ahref="http://f1361db2.m.daocloud.io">http://f1361db2.m.daocloud.io</a></td></tr><tr class="odd"><td>Azure 中国镜像</td><td><ahref="https://dockerhub.azk8s.cn">https://dockerhub.azk8s.cn</a></td></tr><tr class="even"><td>科大镜像站</td><td><ahref="https://docker.mirrors.ustc.edu.cn">https://docker.mirrors.ustc.edu.cn</a></td></tr><tr class="odd"><td>阿里云</td><td><ahref="https://ud6340vz.mirror.aliyuncs.com">https://ud6340vz.mirror.aliyuncs.com</a></td></tr><tr class="even"><td>七牛云</td><td><ahref="https://reg-mirror.qiniu.com">https://reg-mirror.qiniu.com</a></td></tr><tr class="odd"><td>网易云</td><td><ahref="https://hub-mirror.c.163.com">https://hub-mirror.c.163.com</a></td></tr><tr class="even"><td>腾讯云</td><td><ahref="https://mirror.ccs.tencentyun.com">https://mirror.ccs.tencentyun.com</a></td></tr></tbody></table><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240119103400627.png"alt="添加docker的镜像源" /><figcaption aria-hidden="true">添加docker的镜像源</figcaption></figure><p><strong>加入以下命令：=="registry-mirrors":["https://registry.docker-cn.com,https://hub-mirror.c.163.com"]==</strong></p><h1 id="docker镜像下载与软件安装">Docker镜像下载与软件安装</h1><h3 id="docker-安装的优点">Docker 安装的优点</h3><ul><li>一个命令就可以安装好，快速方便</li><li>有大量的镜像，可直接使用</li><li>没有系统兼容问题，Linux 专享软件也照样跑</li><li>支持软件多版本共存</li><li>用完就丢，不拖慢电脑速度</li><li>不同系统和硬件，只要安装好 Docker其他都一样了，一个命令搞定所有</li></ul><h3 id="docker-安装-redis">Docker 安装 Redis</h3><p>Docker 官方镜像仓库查找 Redis ：https://hub.docker.com/</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240119103742209.png" alt="查找redis镜像" style="zoom:67%;" /></p><p>找到如下的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run --name some-redis -d redis<br></code></pre></td></tr></table></figure><ul><li>--name的意思就是为产生的容器命名，比如这里命名为some-redis</li><li>-d的意思是在后台运行</li><li>执行<strong>docker run</strong>就能立刻<strong>pull镜像、生成容器、以及运行容器</strong></li></ul><h3 id="docker安装ubuntu">Docker安装ubuntu</h3><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240119105133828.png"alt="安装ubuntu" /><figcaption aria-hidden="true">安装ubuntu</figcaption></figure><p>首先先从远端拉取镜像，可以指定版本或者是最新的版本</p><p>接着本地进行run</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">- docker pull ubuntu:18.04<br>- docker run -it ubuntu /bin/bash<br></code></pre></td></tr></table></figure><h3 id="docker参考文档">Docker参考文档</h3><p>命令参考：<ahref="https://docs.docker.com/engine/reference/commandline/run/">https://docs.docker.com/engine/reference/commandline/run/</a></p><h1 id="docker的常见命令">Docker的常见命令</h1><ul><li><code>docker run</code>运行一个容器<strong>(-d后台运行、--name重命名container)</strong></li><li><code>docker stop</code> 停止运行一个容器</li><li><code>docker ps</code> 列出正在运行的容器</li><li><code>docker ps -a</code> 列出所有的容器</li><li><code>docker rm</code> 删除某个容器</li><li><code>docker exec</code> <strong>(-it <code>mycontainer</code>/bin/sh)</strong>进入某一个容器； <code>docker exit</code>退出某个容器</li><li><code>docker stop container-id</code> 停止指定 id的容器<code>docker start container-id</code> 启动某个id容器</li><li><code>docker images</code> 查看镜像列表</li><li><code>docker rm container-id</code> 删除指定 id 的容器</li><li><code>docker rmi image-id</code> 删除指定 id 的镜像</li><li><code>docker volume ls</code> 查看 volume 列表</li><li><code>docker network ls</code> 查看网络列表</li><li><code>docker-compose up</code>表示的意思是在docker-compose.yml的文件夹所在的位置运行如下</li><li><code>docker-compose up -d</code> 后台运行只需要加一个 -d 参数</li><li><code>docker-compose ps</code> 查看运行状态</li><li><code>docker-compose stop</code> 停止运行</li><li><code>docker-compose</code> 重启docker compose的服务</li><li><code>docker-compose restart service-name</code> 重启单个服务</li><li><code>docker-compose exec service-name sh</code> 进入容器命令行</li></ul><h1 id="docker创建镜像">Docker创建镜像</h1><p><code>Dockerfile</code>是用于创建自定义Docker镜像的文件，其主要作用包括配置文件、挂载点、对外暴露的端口和设置环境变量</p><p>容器其实是在镜像的最上面加了一层读写层，在运行容器里做的任何文件改动，都会写到这个读写层。如果删除了容器，也就删除了其最上面的读写层，文件改动也就丢失了。Docker使用存储驱动管理镜像每层内容及可读写层的容器层。</p><h2 id="dockerfile-操作常用指令">Dockerfile 操作常用指令</h2><ol type="1"><li><p><strong>FROM 镜像</strong></p><p>指定新镜像所基于的基础镜像，第一条指令必须为FROM指令，每创建一个镜像就需要一条 FROM 指令</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment">#指定了go的镜像：这个时候会从网上下载</span><br><span class="hljs-keyword">FROM</span> golang:<span class="hljs-number">1.20</span>-alpine<br></code></pre></td></tr></table></figure></li><li><p><strong>MAINTAINER 名字</strong></p><p>说明新镜像的维护人信息</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment">#指定维护者的信息</span><br><span class="hljs-keyword">LABEL</span><span class="language-bash"> maintainer=<span class="hljs-string">&quot;XXXXX@gmail.com&quot;</span></span><br></code></pre></td></tr></table></figure></li><li><p><strong>WORKDIR 路径</strong> 为后续的 RUN、CMD、ENTRYPOINT指定工作目录</p><p>这里定义的目录相当于是在docker的文件夹下定义新的目录并会将本地的文件内容上传上去</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 定义工作目录</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /Workspace/ApiService</span><br></code></pre></td></tr></table></figure></li><li><p><strong>RUN 命令</strong></p><p>在所基于的镜像上执行命令，并提交到新的镜像中</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment">#编译应用程序</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> go build -o api_service main.go</span><br></code></pre></td></tr></table></figure></li><li><p><strong>CMD ["要运行的程序", "参数1", "参数2"]</strong></p><p>Dockerfile只能有一条CMD命令。如果指定多条命令，只执行最后一条命令。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 运行应用程序</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;./api_service&quot;</span>]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>EXPOSE 端口号</strong></p><p>指定新镜像加载到 Docker 时要开启的端口</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 暴露端口</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure></li><li><p><strong>ENV 环境变量 变量值</strong></p><p>设置一个环境变量的值，会被后面的 RUN 使用</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 设置环境变量</span><br><span class="hljs-keyword">ENV</span> BUILD_ENV local<br><span class="hljs-keyword">ENV</span> TZ=Asia/Shanghai <span class="hljs-comment">#容器内部的时间设置与上海所在的时区一致</span><br></code></pre></td></tr></table></figure></li><li><p><strong>ADD 源文件/目录 目标文件/目录</strong></p><p>将源文件复制到镜像中，源文件要与 <code>Dockerfile</code>位于相同目录</p><p>例子本地的文件在<code>/Workspace/ApiService</code>中，这个时候会将本地的<code>/Workspace/ApiService</code>目录下所有的文件送到<code>docker</code>中的<code>/Workspace/ApiService/docker</code>中</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /Workspace/ApiService</span><br><br><span class="hljs-keyword">ADD</span><span class="language-bash"> docker .</span><br><span class="hljs-comment">#ADD . . #这里表示相同文件夹目录直接复制</span><br></code></pre></td></tr></table></figure></li><li><p><strong>VOLUME [“目录”]</strong> 在容器中创建一个挂载点</p></li></ol><h2 id="build镜像并运行">Build镜像并运行</h2><h4id="构建dockerfile镜像并运行"><strong>构建dockerfile镜像并运行</strong></h4><p>要运行 Dockerfile 文件，需要使用 Docker 工具。Docker可以在不同的操作系统上运行，包括 Windows、macOS 和各种 Linux发行版。以下是一些运行 Dockerfile 的步骤：</p><ol type="1"><li>安装 Docker 工具</li></ol><p>在官网上下载并安装 Docker工具，根据你的操作系统选择对应版本。安装完成后，可以在终端中运行<strong><code>docker</code></strong> 命令来检查是否安装成功。</p><ul><li>进入 Dockerfile 所在目录</li></ul><p>打开终端，进入 Dockerfile 所在目录。可以使用<strong><code>cd</code></strong> 命令切换目录。</p><ul><li>构建 Docker 镜像</li></ul><p>使用以下命令构建 Docker 镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">docker build -t &lt;镜像名称&gt; .<br><span class="hljs-comment">#docker build -t api_service . </span><br></code></pre></td></tr></table></figure><p>其中 <strong><code>-t</code></strong>参数用于指定镜像的名称，<strong><code>.</code></strong> 表示 Dockerfile所在目录。执行该命令后，Docker 会根据 Dockerfile文件中的指令创建镜像。</p><ul><li>运行 Docker 容器</li></ul><p>使用以下命令运行 Docker 容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">docker run -p &lt;主机端口&gt;:&lt;容器端口&gt; &lt;镜像名称&gt;<br>docker run -d --name my_container -p&lt;主机端口&gt;:&lt;容器端口&gt; &lt;镜像名称&gt;<br><span class="hljs-comment">#docker run -d --name api-container -p 8080:8080 api_service</span><br></code></pre></td></tr></table></figure><p>其中 <strong><code>-p</code></strong>参数用于指定主机端口和容器端口的映射关系，<strong><code>&lt;镜像名称&gt;</code></strong>是在第 3 步中指定的镜像名称。执行该命令后，Docker会在后台启动一个容器，并将容器的标准输出输出到终端中。如果 Dockerfile中没有指定端口，需要在运行容器时指定 <strong><code>-p</code></strong>参数，并将容器端口映射到主机上的一个端口。否则，容器会启动失败。</p><p><code>-d</code>表示的当前的容器可以在后台运行</p><p><code>--name</code>表示给指定的容器起个名字，否则会随机生成名字</p><h4 id="停止docekr容器"><strong>停止docekr容器</strong></h4><p>使用如下命令停止：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">docker stop &lt;container-id&gt;<br></code></pre></td></tr></table></figure><p>其中，<strong><code>&lt;container-id&gt;</code></strong>是要停止的容器的 ID。可以使用以下命令查看正在运行的容器列表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">docker ps<br></code></pre></td></tr></table></figure><p>如果要停止所有容器，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">docker stop $(docker ps -aq)<br></code></pre></td></tr></table></figure><p>其中，<strong><code>docker ps -aq</code></strong>命令用于列出所有容器的 ID。</p><h2 id="scratch最小镜像">Scratch最小镜像</h2><p>使用<code>scratch</code>镜像时，确保应用程序是静态的可执行文件或者不需要额外的操作系统层，这样可以最大程度地减少镜像的大小</p><p>我们这里给出一个例子</p><p>首先在创建一个最小的镜像的时候需要一个应用程序，这个程序可以通过dockerfile生成或者是从其他地方引入，那么这里给出一个<code>golang</code>镜像构建应用程序<code>api_service</code></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 第一阶段：使用 golang 镜像构建应用程序</span><br><span class="hljs-keyword">FROM</span> golang:<span class="hljs-number">1.20</span>-alpine AS builder<br><br><span class="hljs-comment"># 定义工作目录</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /workspace</span><br><br><span class="hljs-comment"># 复制源代码到工作目录</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . .</span><br><br><span class="hljs-comment"># 设置环境变量</span><br><span class="hljs-keyword">ENV</span> CGO_ENABLED=<span class="hljs-number">0</span><br><span class="hljs-keyword">ENV</span> GOOS=linux<br><span class="hljs-keyword">ENV</span> GOARCH=amd64<br><br><span class="hljs-comment"># 编译应用程序</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> go build -o api_service main.go</span><br></code></pre></td></tr></table></figure><p>接着第二阶段就建一个最小的轻量级的docker镜像，首先需要按照构建镜像的基本步骤确定工作目录，环境变量、端口等信息，接着通过从已经编译好的环境中获取应用程序，最后执行程序</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 第二阶段：创建一个新的轻量级镜像</span><br><span class="hljs-keyword">FROM</span> scratch<br><br><span class="hljs-comment"># 设置工作目录</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><br><span class="hljs-comment"># 从 builder 镜像中复制编译好的应用程序</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> --from=builder /workspace/api_service .</span><br><br><span class="hljs-comment"># 设置环境变量</span><br><span class="hljs-keyword">ENV</span> BUILD_ENV local<br><span class="hljs-keyword">ENV</span> TZ=Asia/Shanghai<br><br><span class="hljs-comment"># 暴露端口</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><br><br><span class="hljs-comment"># 运行应用程序</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;./api_service&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>写好dockerfile之后就可以构建并运行了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t api_scratch .<br>docker run -d --name scratch_container -p 8080:8080 api_scratch<br></code></pre></td></tr></table></figure><p><strong>注意：通过这个方式只会产生一个scratch镜像，仅包含一个应用程序</strong></p><h1 id="docker-compose">Docker-Compose</h1><p>如果项目依赖更多的第三方软件，我们需要管理的容器就更加多，每个都要单独配置运行，指定网络。使用docker-compose把项目的多个服务集合到一起，一键运行。要把项目依赖的多个服务集合到一起，我们需要编写一个<code>docker-compose.yml</code>文件，描述依赖哪些服务</p><h3 id="wordpress安装">Wordpress安装</h3><p>在dockerhub在安装wordpress的时候，所需要的服务非常多，所以需要把项目依赖的多个服务集合到一起</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.1&#x27;</span><br><br><span class="hljs-attr">services:</span><br><br>  <span class="hljs-attr">wordpress:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">wordpress</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">8080</span><span class="hljs-string">:80</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">WORDPRESS_DB_HOST:</span> <span class="hljs-string">db</span><br>      <span class="hljs-attr">WORDPRESS_DB_USER:</span> <span class="hljs-string">exampleuser</span><br>      <span class="hljs-attr">WORDPRESS_DB_PASSWORD:</span> <span class="hljs-string">examplepass</span><br>      <span class="hljs-attr">WORDPRESS_DB_NAME:</span> <span class="hljs-string">exampledb</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">wordpress:/var/www/html</span><br><br>  <span class="hljs-attr">db:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:5.7</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_DATABASE:</span> <span class="hljs-string">exampledb</span><br>      <span class="hljs-attr">MYSQL_USER:</span> <span class="hljs-string">exampleuser</span><br>      <span class="hljs-attr">MYSQL_PASSWORD:</span> <span class="hljs-string">examplepass</span><br>      <span class="hljs-attr">MYSQL_RANDOM_ROOT_PASSWORD:</span> <span class="hljs-string">&#x27;1&#x27;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">db:/var/lib/mysql</span><br><br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-attr">wordpress:</span><br>  <span class="hljs-attr">db:</span><br><br></code></pre></td></tr></table></figure><p>首先编写一个：<code>docker-compose.yml</code></p><p>接着在docker-compose.ym==l文件所在的位置==执行：<code>docker-compose up</code>就可以了</p><p><strong>注意：执行完docker-composeup之后就已经生成容器并已经成功run起来了</strong></p>]]></content>
    
    
    <categories>
      
      <category>基础工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【深度学习】推荐系统基础知识</title>
    <link href="/2024/01/16/dl_rec/"/>
    <url>/2024/01/16/dl_rec/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="推荐系统学习资料">推荐系统学习资料</h1><ul><li><ahref="https://zhuanlan.zhihu.com/p/407871839">从零单排推荐系统文章汇总目录</a></li><li><a href="https://zhuanlan.zhihu.com/p/119248677">深度推荐系统王喆</a></li><li><ahref="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;__biz=MzI5NTU2ODQzMg==&amp;scene=1&amp;album_id=2893245558629466114&amp;count=3#wechat_redirect">推荐系统算法实战课程</a></li></ul><h1 id="推荐系统简介">推荐系统简介</h1><p>搜索弓|擎需要用户主动输入自己的意图，有时候，用户并不知道自己需要什么，有些需求、意愿，是用户自己都意识不到的。因为用户提不出需求，就"无所事事"，显然这是对宝贵流量的巨大浪费，不利于建立用户粘性。将自己拥有的、用户可能喜欢的内容主动展示给用户，从而留住用户花费更多的时间与金钱。这就是<strong>推荐系统</strong>。</p><p>学习推荐系统算法需要注意以下的关键要点：</p><ul><li>记忆性与拓展性</li><li>推荐系统的高维稀疏的类别特征</li><li>特征的Embedding</li><li>特征的交叉结构</li></ul><h2 id="推荐系统的例子">推荐系统的例子</h2><p>假设一个极简版的推荐系统中，也有两类角色:用户和物料。</p><ul><li>用户(User)就是推荐系统要服务的对象。用户也是推荐系统的重要贡献者。用户通过"大拇指投票"帮推荐系统分辨出内容、信息的真假优劣。</li><li>物料(Item)，用于统称要推荐出去的信息、内容。不同场景下，物料会有不同的内涵:电商推荐中,物料就是商品；内容推荐中，物料就是一篇文章、一首歌；社交推荐中，物料就是另一个人。</li></ul><p>建立推荐系统的步骤如下：</p><ol type="1"><li>第一步是<strong>给物料打标签</strong>。比如对一个视频《豆瓣评分9.3，最恐怖的喜剧电影：楚门的世界》，我们给它打上"电影、喜剧、真人秀、金凯瑞'这样的标签。</li><li>第二步，建立<strong>倒排索引</strong>，将所有物料组织起来，倒排索引类似一个HashMap,键是标签，值是一个列表，包含着被打上这个标签的所有视频。</li><li>第三步，推荐系统接到一个用户的推荐请求。推荐系统根据从请求中提取出来的用户ID，从<strong>数据库中检索</strong>出该用户的兴趣爱好。假设该用户过去看过10个视频，其中7个带有"喜剧"的标签，3个带有"足球"的标签，则提取出来的该用户的兴趣爱好就是{"喜剧":0.7, "足球": 0.3}，其中键表示用户感兴趣的标签，后面的数字表示用户对这个标签的喜好程度。</li><li>第四步，<strong>召回</strong>，拿用户感兴趣的每个标签去<strong>倒排索引中检索</strong>。假设"喜剧"这个标签对应的倒排链中包含A、B两个视频，"足球"标签对应的倒排链中包含C、D、E两个视频。汇总起来，推荐系统为该用户找到了5个他可能感兴趣的视频。这个过程叫作"召回"(Retrieval) ，查寻倒排索引只是其中一种实现方式。</li><li>第五步，推荐系统会猜测用户对这5个视频的喜爱程度，再按照喜爱程度降序排列，将用户最可能喜欢的视频排在最显眼的第一位,让用户一眼就能看到。这个过程叫作<strong>"排序" (Ranking)</strong>。至于如何猜测用户的喜爱程度，在这个极简版的推荐系统中，这里只使用一个简单的评价规则：<spanclass="math display">\[Score(u,g,v)=Like(u,g)\times Q(v)\]</span><ol type="1"><li>u表示发出请求的用户</li><li>g表示用户u喜欢的一个标签</li><li>v表示，在第四步中，根据标签g从倒排索引中提取出来的一个视频</li><li>Like(u,g)表示用户u对标签g的喜爱程度。比如在上面的例子中，Like(u,"喜剧")=0.7</li><li>Q(v)表示视频v的质量。可以由v的各种后验消费指标来表示，比如可以用点击率(CTR)来表示</li><li>Score(u, g, v)表示推荐系统猜测的用户u对视频v的喜爱程度。</li></ol></li><li>第六步推荐系统对排序结果进行截断，只保留前4个视频，返回给用户。</li><li>第七步，用户按照[B, C,A,D]的顺序看到了4个视频，点击并观看了视频B。用户行为，即"用户u点击视频B, A/C/D曝光未点击"，被记录进日志，发送给推荐系统。</li><li>第八步，推荐系统接收到了用户反馈，并据此更新用户的兴趣爱好。</li></ol><p>以上是比较简单的推荐系统的例子，具体的实现过程中可能会非常复杂，考虑的东西会非常多，因此具体实现上可能需要进一步的考虑。</p><h2 id="推广搜简介">推广搜简介</h2><p>含义：推荐、广告、搜索。<strong>用户需求表达方式：</strong>推荐、搜索<strong>。信息服务对象：</strong>推搜、广告</p><h3 id="相同点">相同点</h3><ul><li>功能架构相同：都遵循先召回再排序</li><li>数据架构相同：都遵循使用Lambda架构(后续会提到)</li><li>技术栈相同，面向的功能相同，都需要高度个性化设计(都十分依赖于用户的画像)</li></ul><h3 id="不同点">不同点</h3><ul><li><strong>推荐&amp;搜索</strong></li></ul><p>推荐和搜索的最大差异在于用户表达意图的方式不同，用户输入显式的查询语句来表明自己的意图<span class="math display">\[F_{search}(t|q,u)\]</span></p><ul><li>u表示当前用户，q表示用户输入的查询语句，t表示某一个候选物料</li><li>Fsearch表示搜索模型， 衡量物料t对用户u输入的查询q的匹配程度</li><li>用户信息u也是公式的输入条件。不同用户输入相同的查询语句q，得到的结果也是不一样的</li></ul><p>推荐中，用户无须显式表达其意图。推荐系统通过自己的长期观察，猜测用户意图，完成推荐<span class="math display">\[F_{recommend}(t|u)\]</span></p><ul><li>表示推荐模型，衡量物料t对用户u的匹配程度</li></ul><p>q表示物料对用户查询的匹配程度，搜索有显式的匹配程度，但是推荐没有，总结如下：</p><ul><li><p>搜索：查询语句与物料信息交叉</p></li><li><p>推荐：用户信息与物料信息交叉</p></li><li><p><strong>推搜&amp;广告</strong></p></li></ul><p>最终目标性：（优化指标）</p><ul><li>推搜是为了制造流量，给予用户最佳的使用体验</li><li>广告是为了变现流量，要兼顾用户、广告主、平台三方面的利益，参与方更多、更复杂，优化起来难度更高</li></ul><p>实现流程：</p><ul><li>推搜目标即刻完成，比如点击和播放</li><li>广告是深层次的转化，需要用户选择并下载APP，存在较大的延时反馈问题，成功转化的正样本越稀疏，建模难度越高。</li></ul><p>预测精度的要求：</p><ul><li>推荐与搜索对预测出来的CTR/CVR只要求"相对准确性"，即它们的预测精度能够将用户最喜欢的物料排在最前面，这就足够了</li><li>广告对预测精度要求"绝对准确性"。在模型的预测结果出来之后，广告还需要对其修正、校准。毕竟制作、投放广告还存在一定技术、财力上的门槛。</li></ul><h1 id="推荐系统模型架构">推荐系统模型架构</h1><p>根据划分角度不同，将分成“功能架构”和“数据架构”两个板块</p><h2 id="功能架构">功能架构</h2><p>为了应对海量的候选集合，现代大型推荐系统都采用由<strong>"召回→粗排→精排→重排"</strong>四个环节组成的分级推荐模式，在推荐链路中越靠前的环节，面对的候选集合越大，因此要采用技术较简单、精度稍逊、速度较快的算法，牺牲部分精度换速度；反之，链路靠后的环节，面对的候选集合较小，有条件采用技术较复杂、精度高、速度较慢的算法，牺牲部分速度换精度。</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240118142732765.png"alt="推荐功能的结构" /><figcaption aria-hidden="true">推荐功能的结构</figcaption></figure><figure><imgsrc="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGE5NDI3YTkxNzUzYmNjODhmNTdhNWY3YmYzZjQxNjNfYXlpcWFEZ3NIQkxob2JvakRPNUZOQkNvWldyRlVYYWFfVG9rZW46WlNuMWJwbHZBbzBBUjh4cXVqY2NnSkFsbkxiXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"alt="推荐系统的功能架构" /><figcaption aria-hidden="true">推荐系统的功能架构</figcaption></figure><h3 id="召回">召回</h3><p>召回模块的第一要务就是"快"，可以牺牲一部分精度，只要能找到与用户兴趣比较匹配的物料就好，而非最匹配的，因为后者是下游排序模块的目标。</p><p>召回模块主要依赖<strong>"离线计算+在线缓存"</strong>模式来实现对上百万候选集的快速筛选。上百万的候选物料在离线就处理好，处理结果被存入数据库并建立好索引，线上召回时，只花费一个在索引中的检索时间，时间开销非常小。</p><p>离线处理物料时肯定不知道将来要访问的用户是谁，召回模型在结构与特征上，都不能出现<strong>用户信息与物料信息的交叉</strong>。这个特点限制了召回模型的表达能力，也就限制了制约了召回模型的预测精度。</p><p>为了弥补精度上的不足，召回模块一般采用<strong>多路召回</strong>的方式，以数量弥补质量。每路召回只关注用户信息或物料信息的一个侧面，比如有的只负责召回当下最火爆的内容，有的只根据用户喜爱的"标签"进行召回，虽然单独一路召回的视角是片面的，但是多路召回的结果汇总起来，取长补短，查漏补缺，就能覆盖用户兴趣的方方面面。</p><p><strong>区分召回和排序：</strong></p><ul><li><p>召回是从一大堆物料中排除与用户兴趣八杆子打不着的，留下还比较合用户品味的。举个例子，召回好比经历过社会历练，无论哪种"不靠谱"，他都见识过。</p></li><li><p>精排是从一小拨儿还不错的物料中，精挑细选，优中选优，挑出对用户来说最好的物料。举个例子，精排好比还在校园中的乖学生，见过最不靠谱的人不过是借橡皮不还的同桌。</p></li></ul><h4 id="传统召回算法"><strong>传统召回算法</strong></h4><ul><li>基于物料属性的倒排索引</li><li>基于统计的协同过滤算法<ul><li>基于用户的协同过滤：给用户A找到与他相似爱好的用户B，把B喜欢的东西推荐给A</li><li>基于物料的协同过滤：用户A喜欢物料C，找到与A相似的其他物料D，把D推荐给A</li></ul></li><li>矩阵分解算法(Matrix Factorization, MF)</li></ul><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/(null)-20240116152608169.(null)"alt="矩阵分解算法图示例" /><figcaption aria-hidden="true">矩阵分解算法图示例</figcaption></figure><h4id="向量化召回统一建模框架"><strong>向量化召回统一建模框架</strong></h4><p>如何定义负样本、如何定义证样本、如何生成Embedding、如何定义优化目标</p><p>定义：将召回问题建模成向量空间中的近邻搜索问题</p><p>分类：两类实体QT，可以是物料-用户、用户-用户、物料-物料</p><p>方法流程：</p><ol type="1"><li>训练一个模型，并将QT映射到同一个向量空间</li><li>构建起索引向量数据库</li><li>对于传入的Q实例先进行Embedding 再进行近邻搜索</li></ol><p>建模方法：</p><ul><li>如何定义正样本（哪些q和t在向量空间中应该近）<ul><li>qt都是物料：时间间隔很近的用户行为序列交互过的物料认为很近，相似性</li><li>q是用户t是物料：用户交互过的物料认为是相近的，匹配性</li><li>qt都是用户：比如孪生网络，q是用户一半的交互历史，t是同一用户另一半的交互历史，同一性</li></ul></li><li>如何定义负样本（哪些q和t在向量空间中应该远）<ul><li><strong>负样本为王</strong>，负样本选择对模型很重要</li><li><strong>离线训练的数据分布应该与线上服务的数据分布保持一致</strong></li><li>注意 召回和排序候选集完全不同：<strong>召回</strong>要让模型见过最匹配也要见最不靠谱，因此<strong>召回的负样本主要依靠随机采样生成，不能（只）拿“曝光未点击”作为负样本</strong></li><li>注意EasyNegative问题，负样本要和q有细节差异，增加难度；<code>easy:hard=100:1</code></li></ul></li><li>如何将q和t映射成Embedding<ul><li><strong>排序鼓励特征交叉，召回要求解耦</strong></li><li>排序使用了大量的交叉统计特征，排序将用户特征、物料特征、交叉统计特征拼接</li><li>召回解耦，不用知道用户的请求提前计算好物料向量，避免计算交叉特征耗时</li></ul></li><li>如何定义优化目标和损失函数<ul><li>NCE Loss</li><li>Sampled Softmax Loss</li><li>Pairwise Loss</li></ul></li></ul><h3 id="精排">精排</h3><p>任务目标：精排的任务是从上游层层筛选出来的千余号还比较符合用户兴趣的物料中，<strong>精挑细选</strong>出百余个最合用户品味的物料。</p><p>设计重点：精排的设计重点是提升预测精度。所以不同于召回、粗排不允许用户信息与物料信息交叉，精排模型的发力<strong>重点就是让物料信息与用户信息更加充分地交叉</strong>，为此业界在精排引入了更多更复杂的<strong>交叉特征</strong>，</p><h4 id="特征交叉方法"><strong>特征交叉方法</strong></h4><ul><li>传统方法：FTRL</li><li>FM：引入了二阶特征交叉（手动二阶特征交叉）</li><li>Wide&amp;Deep：兼顾记忆与扩展</li><li>DeepFM ：融合二阶交叉（实现了自动二阶特征交叉）</li><li>DCN：能够指定任意显式交叉</li><li>Autolnt：基于Transformer作特征交叉</li></ul><h4 id="用户行为序列建模"><strong>用户行为序列建模</strong></h4><p>本质：将用户行为序列提炼并压缩成<strong>用户兴趣的Embedding</strong></p><ul><li>DIN：利用Attention，将当前的物料t作为用户历史序列的Query</li><li>双层Attention行为序列：第一层Attention历史行为序列内部的依赖关系；第二层是当前物料和历史行为序列</li><li>SIM：将“软过滤”变成“硬过滤”，相当于从长序列选择短序列进行DIN</li></ul><h3 id="粗排">粗排</h3><p>召回的精度不足，所以用数量弥补质量，倾向于召回更多物料，送往下游。精排为了提升预测精度，不断加大模型复杂度，而牺牲了模型的吞吐能力。如果让召回直接对接精排，笨重的精排无法面对召回送来的越来越多的候选物料，粗排接在召回后面，一般将召回的10000个结果再过滤掉9成，再交给精排重点考察。粗排夹在召回与精排之间，又是一个<strong>速度与精度折衷妥协</strong>的产物。</p><ul><li>一方面，由于候选集规模比召回小得多，相比召回，粗排模型可以接入更多特征，使用更复杂的结构。</li><li>另一方面，由于候选集比精排还大得多，粗排模型比精排又简单太多。比如主流粗排模型仍然依赖"离线计算+在线缓存"模式来处理候选物料，所以<strong>仍然不能使用用户信息与物料信息交叉的特征与结构</strong>。</li></ul><h4 id="基于改进的双塔模型">基于改进的双塔模型</h4><ul><li>召回需要向量数据库建立索引，粗排不需要索引</li><li>负样本的选择，可以拿“曝光未点击”当负样本</li><li>损失函数，粗排的损失函数需要考虑用户实际反馈，召回不需要</li><li>召回ANN快速搜索近邻使用点积实现交叉，粗排可以选择任意的交叉方式<ul><li>双塔结构的问题：细粒度信息在塔中被消耗，如何保留更多的塔中输出信息</li><li>动态调整输入信息，减少噪声信息的输入</li><li>重要的信息走捷径，ResNet</li></ul></li></ul><h4 id="基于知识蒸馏">基于知识蒸馏</h4><h3 id="重排">重排</h3><p>相似内容(比如相同话题、相同标签)会被粗排模型打上相近的分数，从而在结果集中排在相近的位置。如果将这样的排序结果直接呈现给用户，用户连看几条相似内容，很容易审美疲劳，从而伤害用户体验。所以，精排结果还需要经过重排。重排的主要目的不是为了过滤筛选，而是为了调整精排结果的顺序，<strong>将相似内容打散</strong>，保证用户在一屏之内看到的推荐结果，丰富而多样。</p><h4 id="基于启发式规则">基于启发式规则</h4><p><strong>滑动窗口打散法</strong></p><p>一种常见的打散规则叫做"滑窗打散"，即在一个长度为K的滑动窗口(SlidingWindow, SW)内,相似物料最多出现n次。</p><p>下面是一个例子</p><ul><li>初始时，所有物料按照精排打分从大到小排序；</li><li>在第1个滑窗内，物料2和3是相同类别，违反打散目标，物料4和3对调；</li><li>在第2个滑窗内，还是物料2和3违反打散目标，物料3和5对调；</li><li>在第3个滑窗内，每个类别只出现一次，满足打散目标，路过；</li><li>在第4个滑窗内，物料5和6违反打散目标，物料6和7对调；</li><li>如果滑动到最后一次窗口，还不满足打散目标，但是后面已经没有物料可对调了，不做处理。</li></ul><figure><imgsrc="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjA4NGYwOWRkZDU4ZGNiYThkNWQ5MzhjNjg4ZWM0YzlfbHY0dkwwZUtzTW9SQnFJM0ZZVXZ6d2phTUlEWVBjNHJfVG9rZW46V0FJemIxa0R5bzVwS0p4dzF2UGNHSm5Mbk9jXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>分桶打散法</strong></p><p>首先按照不同类别将排好序的物料放入按照<strong>某个指标划分的桶</strong>中，紧接着均匀地从每个桶中抽取对应的物料来保证物料不相似</p><figure><imgsrc="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=MTZjN2YxNmNjMTRhZGNmZGY1NjZkMjMwNDhjM2ZhYTlfYkpOU01rZ0lEWDRGQ0x1S3NxanptV0pyU0MwQjRjd1pfVG9rZW46VEUyOGJ3TjlHb1BKYzl4Mktxc2MzMFJUbmtiXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h4 id="基于贪心算法">基于贪心算法</h4><p><span class="math display">\[N e x t=\underset{t \in R \backslashS}{\operatorname{argmax}} \lambda \operatorname{Sim}_1(u, t)-(1-\lambda)\operatorname{Sim}_2(S, t)\]</span></p><ul><li>$$$$ 是全体精排结果, 也就是重排的全体候选集。</li><li>$<span class="math display">\[$ 是当前的重排结果集。当\]</span><span class="math display">\[ 的长度达到指定长度时, 重排结束,将 \]</span>$$ 展示给用户。</li><li><span class="math display">\[R \backslash \]</span>表示还未插入重排结果集的所有精排结果。</li><li><span class="math display">\[\operatorname{Sim}_1(u, t\]</span>代表当前候选物料 $<span class="math display">\[$ 与发起请求的用户\]</span>$$ 之间的相关性, 可以用精排打分表示。</li><li><span class="math display">\[\operatorname{Sim}_2(S, t\]</span>是当前物料 $<span class="math display">\[$ 与当前重排结果集合\]</span>$$ 的相似度。这个数值越小, 将加入 <spanclass="math inline">\(S\)</span>, 对重排结果多样性的提升越大。</li><li><span class="math display">\[\lambda \operatorname{Sim}_1(u,t)-(1-\lambda) \operatorname{Sim}_2(S, t\]</span> 代表将候选物料 $<spanclass="math display">\[$ 加入 \]</span><span class="math display">\[带来的边际收益, 是相关性与多样性的折中, \]</span>$$ 是组合的权重。</li></ul><p>其余的方法：基于行列式点过程、基于上下文感知等方法</p><h2 id="数据架构">数据架构</h2><p>除了上面介绍的功能架构，推荐系统中的模块还可以按照数据生产、计算、存储的不同方式进行划分，也就是推荐系统的数据架构。</p><p>数据类型：</p><ul><li>冷数据：存储在Hadoop分布式文件系统(Hadoop Distributed File System,HDFS)上的那部分日志数据</li><li>热数据：HDFS只支持批量读写的性质所限，还有许多用户行为未得及组成用户日志，或者未来得及落盘在HDFS上的数据</li></ul><p>为了应对互联网大数据系统的复杂性，Lambda架构应运而生。</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/(null)-20240116152608613.(null)"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li>将数据请求拆解为分别针对冷、热数据的两个子请求。</li><li>针对冷数据的请求，由<strong>"离线层"</strong>批量完成计算，其结果由<strong>"近线层"</strong>缓存并提供快速查询。</li><li>针对热数据的请求，由<strong>"在线层"</strong>基于流式算法进行处理。</li><li>汇总从冷、热数据分别获得的子结果，得到最终的计算结果。</li></ul><h3 id="离线层">离线层</h3><p>为了计算可以启动一个小时级的定时任务，每个小时都向前回溯一周的用户行为日志，统计这个时间窗口内每个视频V的曝光数与点击数。为了加速，我们可以定时跑另一个小时级的批量任务，统计每个小时内每个视频的曝光、点击总数，并保存结果。另外，这些小时级的中间结果也能够被其他上层计算任务所复用，避免重复计算。</p><p>以上这些<strong>定时扫描日志的批量计算任务</strong>，就构成了Lambda架构中的"离线层"。技术上，这些批量计算任务可以凭借Hadoop、Spark、Flink等大数据框架来完成，而多个任务之间的协同可以由Airflow来完成。</p><h3 id="近线层">近线层</h3><p>HDFS是一种擅长批量读写，但随机读写效率极低的存储介质，不利于线上快速读取。为了提高查询速度，我们将离线批量计算的结果导入Cassandra、Redis这样的"键~值" (Key-Value， KV)型数据库。这些<strong>起缓存、加速访问</strong>作用的KV数据库就构成了Lambda架构中的"近线层"。</p><h3 id="在线层">在线层</h3><p>因为HDFS只支持批量读写，所以用户行为从发生到被记录在HDFS上，之间存在着小时级别的延时。用户最新的行为都未能体现在离线批量计算的结果中。</p><p>"在线层"正是为了弥补上这块短板。这一层凭借Storm、Flink等流式计算框架，对接用户的行为数据流，<strong>不等数据落地，就直接对它们进行分析计算</strong>，计算结果也缓存在Redis这样支持随机读写的数据库中，方便线上查询。</p><h1 id="推荐系统的特征工程">推荐系统的特征工程</h1><p>好的特征工程能够将数据处理得更加适配模型，能够让模型发挥最大的性能</p><h2 id="特征工程的必要性">特征工程的必要性</h2><ul><li>DNN万能函数模拟器并不可靠，输入数据未经处理会影响DNN性能的发挥</li><li>DNN的自动化特征工程对于大量的数据存在耗时等问题</li></ul><h2 id="特征提取">特征提取</h2><p>这一部分会介绍如何对各类不同的特征提取的方法</p><h3 id="物料特征">物料特征</h3><ul><li><strong>物料自身属性</strong><ul><li>在视频推荐场景下，视频的作者、作者等级、作者粉丝数、投稿栏目、视频标题与简介、上传时间、时长、清晰度等信息，都属于物料属性。</li><li>在电商场景下，商品标题与简介、封面图片、所属商铺、商铺等级、品牌、价格、折扣、物料方式、上架时间等信息，都属于物料属性。</li><li>物料的唯一标识(temID)也是重要的特征<strong>（高维、稀疏）</strong>ItemID当成特征能够在物料侧提供最个性化的信息。</li></ul></li><li><strong>物料的类别与标签</strong></li></ul><p>所谓物料的静态画像，是指不依赖用户反馈，只通过分析物料内容就能获得的物料的<strong>类别、标签</strong>等信息。</p><ul><li><p>可以用"自然语言处理" (Natural Language Processing, NLP)算法，比如BERT[5]，分析物料的标题、摘要、评论等。如果是文章还可以分析正文，如果是视频还可以分析字幕。</p></li><li><p>我们可以用"计算机视觉" (ComputerVision, CV)算法，比如CNN模型[6]，分析物料的封面，或者视频的关键帧。内容分析的结果就构成了物料的静态画像。</p></li><li><p><strong>基于内容的Embedding</strong></p></li></ul><p>利用CNN或BERT之类的模型，从一篇文章、一个视频中提炼出几个标签，其结果是超级稀疏的。</p><p>这回拿模型的<strong>某一层的输出</strong>，当成物料特征，<strong>喂入上层模型</strong>。尽管这个向量不如那几个标签好理解，但是它有32位或64位那么长，里面蕴含的信息要比几个标签丰富一些。</p><ul><li><strong>物料的动态画像</strong></li></ul><p>物料的动态画像，指它们的后验统计数据，反映了物料的受欢迎程度，是物料侧最最重要的特征。物料的动态画像可以从以下两个维度来进行刻画:</p><ul><li><p>时间粒度:全生命周期、过去一周、过去1天、过去1小时</p></li><li><p>统计对象: CTR、平均播放进度、 平均消费时长、排名</p></li><li><p><strong>用户给物料反向标签</strong></p></li></ul><p>将消费过某个物料的用户身上的标签，传递<strong>积累到这个物料身上，丰富物料画像</strong>。</p><p>比如一篇关于某足球明星八卦绯闻的文章，由于该球星的名字出现频繁，NLP算法可能会给它打上"体育"标</p><p>签。但是后验数据显示，带"体育"标签的用户不太喜欢这篇文章，反而带"娱乐"标签的用户更喜欢，显然这</p><p>篇文章也应该被打上"娱乐"的标签。类似的，给物料打上诸如"文青喜欢的电影榜第3名"、或者"数码迷最喜</p><p>欢的手机"这样的反向标签，都包含了非常重要的信息，能够帮助提升模型性能。</p><h3 id="用户特征">用户特征</h3><ul><li><strong>用户的静态画像</strong></li></ul><p>静态画像就是人口属性(e.g.,性别、年龄、职业、籍贯)、用户安装的APP列表等比较稳定的数据信息。</p><p>由于互联网大厂的主打APP的存量老用户居多，行为丰富，能够提供足够的训练数据，因此在大厂的实践中还是非常喜欢拿UserID当特征的。</p><ul><li><strong>用户的动态画像</strong></li></ul><p>用户的动态画像就是从用户的历史行为中提取出来的他的兴趣爱好。</p><p>最简单直接的动态画像就是，将用户一段时间内用户交互过的物料的ItemID按时间顺序组成的集合。将这个集合扔进模型，让模型自动从中提取出用户兴趣。最简单的提取方式无非就是将每个ltemID先Embedding，再把多个Embedding聚合(也称"池化"，Pooling，比如采用加和或平均)成一个向量，这个向量就是用户兴趣的抽象表达。</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/(null)-20240116152608785.(null)"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>至于可以统计哪些指标来反映用户兴趣，我们可以从以下6个维度展开，做到不重不漏：</p><ul><li>用户粒度，可以是单个用户，也可以是一群用户。针对一个用户群体的统计，有利于新用户冷启。</li><li>时间粒度，比如最近的100次曝光，再比如过去1小时、1周、1月。</li><li>物料属性，比如视频的一二级类别、标签、作者，再比如商品的分类、品牌、店铺、价位。</li><li>动作类型，可以是正向的，比如点击、点赞、转发等，也可以是负向的，比如忽略、点踩。</li><li>统计对象，比如次数、时长、金额等。</li><li>统计方法，比如加和、求平均、计算各种比例等。</li></ul><p>通过以上6个维度的交叉，我们可以构造出一系列的统计指标来反映用户在各个时间跨度、各个维度上的兴趣</p><h3 id="交叉特征">交叉特征</h3><p>DNN并非万能，其交叉能力也有限；另一方面，手动交叉的特征犹如加工好的食材，个中信息更容易被模型消化吸收。因此，在推荐模型的深度学习时代，交叉特征依然大有可为，值得重视。</p><p>在具体交叉方式上，又有做<strong>"笛卡尔积"</strong>与做<strong>"内积"</strong>两种方式。</p><ul><li><strong>笛卡尔积交叉</strong></li></ul><p>笛卡尔交叉就是将两个Field内的Feature两两组合，组成一个新的Field。比如用户感兴趣的电影类别有{"动作片"、科幻片"}，而当前候选物料的标签是("施瓦辛格"、"终结者"、"机器人"}，这两个Field做笛卡尔交叉的结果就是{"动作片+施瓦辛格"，“动作片+终结者"，"动作片+机器人"，"科幻片+施瓦辛格"，科幻片+终结者"，"科幻片+机器人"}，显然"动作片+施瓦辛格"、"科幻片+机器人"都是非常强烈的信号，有助于模型判断用户与物料间的匹配程度。</p><ul><li><strong>内积交叉</strong></li></ul><p>点积，即选定一个画像维度(比如标签、分类)，将用户在这个维度上的兴趣，和物料在这个维度上的属性，想像成两个稀疏向量，这两个向量做点积结果反映出用户和物料在这个画像维度上的匹配程度。</p><p><strong>点积结果越大，说明用户与候选物料在这个维度上越匹配</strong>。</p><p>比如用户感兴趣的标签是Tagsuser ={"坦克": 0.8, "足球": 0.4， "二战":0.6, "台球": -0.3}，每个标签后面的数字表示用户对这个标签的喜爱程度，可以拿用户在这个标签上的后验指标来表示，而当前候选物料的标签是Tagsitem={"坦克": 1， "二战": 0.5，"一战": 0.8}。将Tagsuser与是Tagsitem'做点积，也就是将共同标签对应的分数相乘再相加，结果是1.3，表示用户与当前候选物料在"标签"这个维度上的匹配程度。</p><h3 id="偏差特征">偏差特征</h3><ul><li>无法做到绝对公平，没点击不代表不喜欢，点击的未必喜欢，偏差Bias</li></ul><figure><imgsrc="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=NDc4NmViNDYwODYxZTFmNmQzZmYyOTkyNjY4ZTI1NDFfelBIb0IxVUdYbWFmT3phcmx2QjJUU1ZlRFJDdXRlUlRfVG9rZW46VHRSbmJCV25sb2JUNnN4Y1BTT2Nab1BHbkdlXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li><strong>Above Click:</strong>只有在点击物料上方的未点击的物料才被当作负样本，没被点击的且不在点击上方的就不放进训练的集合中，就不当成训练样本</li></ul><figure><imgsrc="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=YTkyNjFmYTU2OTc1MjhhZjliYWMwNmVmZjNjMzk1MTBfV2wyaWRQWGV4MEMxSXBDam1UZlNNYnhVYTN4RTJKSEZfVG9rZW46UGNEVWJSWVU0b1FtMWF4MHpGVWNJNzlwbkVkXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li>训练的过程中，会将这个偏差特征不能和正常特征一起喂入DNN，否则会改变排序结果</li></ul><h2 id="数据特征处理">数据特征处理</h2><h3 id="处理缺失值">处理缺失值</h3><ul><li>训练模型来预测缺失值</li></ul><p>比如对于新用户，我们可以构建一个模型，利用比较容易获得的人口属性(比如性别、年龄等)预测新用户对某个内容分类、标签的喜爱程度(比如对某类内容的CTR)。再比如对于新物料，我们可以训练一个模型，利用物料的静态画像(比如分类、标签、品牌、价位)预测它的动态画像(CTR、平均观看时长、平均销售额等)。</p><h3 id="标准化处理">标准化处理</h3><p>标准化的目的是将不同量纲、不同取值范围的数值特征都压缩到同一个数值范围内，使它们彼此可比。最常用的标准化是z-score标准化</p><p><span class="math display">\[x^*=(x-\mu)/\sigma\]</span></p><ul><li>x是某条样本在特征F的原始取值。</li><li>μ、σ分别是特征F在训练数据集上的均值和标准差。</li><li>x*是某条样本在特征F的标准化结果，称为z-score。</li></ul><p>标准化数据</p><ul><li>目的：将不同量纲、不同取值范围的数值压缩到一个数值范围内</li><li>标准化z-score方法：<spanclass="math display">\[x^*=(x-\mu)/\sigma\]</span>分别是均值和标准差</li></ul><h3 id="数据平滑与消偏">数据平滑与消偏</h3><p>目标：<strong>克服小样本的负面影响</strong>，提高计算结果的置信区间</p><p>推荐系统中经常要计算各种比率作为特征，比如点击率、点赞率、购买率、复购率等。计算这些比率时，我们经常遇到的一个问题就是样本太少，导致计算结果不可信。比如计算一件商品，只被曝光了一次并被购买了，由此我们就说它的购买率是100%，从而认定它是爆款，应该大力推荐，显然这是站不住脚的。为克服小样本的负面影响，提高计算结果的置信水平，我们可以采用"威尔逊区间平滑"：</p><p><spanclass="math display">\[p^*=\frac{p+\frac{z^2}{2n}-z(\frac{p(1-p)}{n}+\frac{z^2}{4n^2})^{1/2}}{1+{2n}\frac{z^2}{n}}\]</span></p><ul><li>z是一个超参，代表对应某个置信水平的z-score。比如当我们希望计算结果有95%的置信水平时，z应该</li></ul><p>等于1.96。p是用简单方法计算出的比率。比如当p代表点击率时，就是拿点击样本数除以曝光样本数。</p><ul><li><spanclass="math display">\[p^*\]</span>是平滑后的比率。n是样本数量。</li></ul><h3 id="分桶离散化">分桶离散化</h3><p>在推荐模型中，使用类别特征具有能更好反映非线性关系、便于存储与计算等多方面优势，因此在实践中，我们更喜欢将<strong>实数特征离散成类别特征</strong>。</p><p>离散方法就是分桶，即将实数特征的值域划分为若干区间，又称为"桶"，看实数特征落进哪个桶，就以那个桶的桶号作为类别特征值。比如，某用户在最近一小时看了5个视频，如果用实数特征描述，特征是"最近1小时看的视频数"，特征值是5。而如果离散成类别特征，整个特征可以表示成"ast1hour_<em>0</em> _10"这个字符串，表示该用户在最近1小时看的视频数在0~10之间。</p><p>分桶有三种实现方式:</p><ul><li>等宽分桶:即将特征值域平均划分为了N等份,每份算一个桶。</li><li>等频分桶:将整个值域的N个分位数(Percentile)作为各桶的边界，保证落入各个桶的样本个数大致要相等。</li><li>模型分桶：对实数特征F分桶，。第1阶段，单独拿特征F与目标值拟合一棵简单的决策树。第2阶段才进行分桶，将某个特征中F的实数取值f喂进决策树，f最终落进的那个叶子节点的编号就是f的离散化结果。</li></ul><h2 id="类别特征的处理">类别特征的处理</h2><p>首先明确一下<strong>推荐系统的特征空间：高维、稀疏</strong>的特点</p><h3 id="增强类别特征表达">增强类别特征表达</h3><ul><li>Embedding自动学习并拓展内涵，学习<strong>隐语义</strong>拓展单个特征的内涵，扩展单个特征的内涵</li><li>多特征交叉，选择用户多个不同的<strong>特征</strong>进行交叉一次来增强特征的表达能力，比如“20岁”和“程序员”的特征交叉，“格子衬衫”作为推荐选择</li></ul><h3 id="类别特征的高维性">类别特征的高维性</h3><ul><li>数据位的很高，需要上百万的标签，多维特征交叉</li><li><strong>Parameter Server架构</strong>缓解高维数据的难度</li><li>分散了参数存储检索的压力，降低了带宽资源与时间开销</li></ul><h3 id="类别特征的稀疏">类别特征的稀疏</h3><ul><li>FTRL自适应调整学习率，常见的特征受训机会多，罕见特征受训机会少</li><li>DIN模型提出自适应调整正则系数</li></ul><h3 id="特征如何表征">特征如何<strong>表征</strong></h3><ul><li>建立字符串到数字的映射表，缺点在于需要更新维护且对于大规模而言比较难以负担</li></ul><figure><imgsrc="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=OTY4NDhmYTRiY2ViZGJjYWYxMDdjNWI0MTgwNDgyOWZfYjdCMmlkU2pKaHZNUEltNnBDTFBxTWQwTE5aaUVEZkZfVG9rZW46STBpMGJoa0lpb3k0SlR4M01Fa2NidWx5bnVkXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li>特征哈希Feature Hashing<ul><li>Feature Hashing负责将输入的字符串映射成一个[0,N)之间的整数，N是Embedding矩阵的总行数，映射得到的整数代表该类别特征的Embedding在Embedding矩阵中的行号。</li><li>FeatureHashing可以简单理解为，先计算输入的字符串的哈希值，再拿哈希值对Embedding矩阵行数N取余数。当然实际实现要更复杂一些，以减少发生"哈希冲突"(Hash Collision)的可能性。</li><li>只要Embedding的长度相同，若干Field可以共享一个FeatureHash模块与背后的Embedding矩阵。相比于让各个Field拥有独立的Embedding矩阵，这种共享方式对空间的利用率更高，是大型推荐模型的主流作法。</li></ul></li></ul><figure><imgsrc="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWZhZjNlODk0MTAzM2I3YWI5NTIxNTJiNDUzZjc2ZTJfSzkyalBacmxtRVYyOWNxalpubmZGdDY2MUhYbEJWYkFfVG9rZW46RDA1dWJpQmhRb25mVWZ4Y3BncGNqd1FWbjBkXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h1 id="推荐系统的embedding">推荐系统的Embedding</h1><h2 id="embedding的必要性"><strong>Embedding的必要性</strong></h2><p>对于推荐系统而言：<strong>记忆+拓展</strong></p><p><strong>记忆</strong>能够处理80%的需求，但是个性化太弱（评分）</p><ul><li>Logistic Regression能够很好的实现记忆功能，记住一些比较经典的关联标签</li><li>所有的模式，都依赖人工输入。所以在推荐模型的LR时代，特征程既需要创意，同时也是一项体力活。</li><li>LR本身并不能够发掘出新模式，它只负责评估各模式的重要性。这个重要性是通过大量的历史数据拟合得到的。</li><li>LR(评分卡)模型，强于记忆，但是弱于扩展。、中国顾客来了推饺子，美国客户来了推.火鸡，效果都不错，毕竟LR记性好。但是，当一个中国客户来了，你的推荐系统会给他推荐一只火鸡吗？如果你的推荐系统只有LR，只有记忆功能，答案是:不会。</li><li>因为&lt;中国人，火鸡&gt;毕竟属于小众模式，在历史样本罕有出现，LR的L1正则直接将打分置为0，从而被从评分卡中剔除。</li></ul><p><strong>拓展</strong>将细粒度变成粗粒度，借助深度学习的Embedding</p><ul><li>在训练LR模型的时候，每条样本除了将原来细粒度的概念&lt;春节，中国人，饺子&gt;和&lt;感恩节，美国人，火鸡&gt;作为特征，也将扩展后的&lt;节日，和节日相关的食物&gt;作为特征，一同喂入LR模型。</li><li>这样训练后的"评分卡"工作量大，劳神费力。比如饺子、火鸡这两个概念，还能不能从其他角度拆解，从而发现更多的相似性?这就要受到工程师的业务水平、理解能力、创意水平的制约。</li><li>使用<strong>Embedding就是很有必要</strong>的</li></ul><h2 id="共享独占embedding"><strong>共享/独占Embedding</strong></h2><h3 id="共享embedding">共享Embedding</h3><p>所谓共享Embedding，是指同一套Embedding要喂入模型的多个地方，发挥多个作用。共享Embedding的好处有二：</p><ul><li>能够缓解由于特征稀疏、数据不足所导致的训练不充分。</li><li>Embedding矩阵一般都很大， 复用能够节省存储空间。</li></ul><p>再比如，召回模型中的双塔模型例子，</p><ul><li>Item ID Embedding既是重要的物料特征，要喂入ltem Tower；</li><li>同时，用户行为序列作为最重要的用户侧特征，也是由一系列的ItemID组成， 因此ltem ID Embedding也要喂入User Tower。</li></ul><p>如果选择让喂入User Tower和Item Tower的Item IDEmbedding共享同一个Embedding矩阵,模型结构如图</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/(null)-20240116152609558.(null)"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="独占embedding">独占Embedding</h3><p>共享Embedding最大的优点，就是缓解因为数据不足而导致的稀疏特征训练不充分的问题。但是各互联网大厂最不缺的就是数据，这时共享Embedding的缺陷就暴露出来，即不同目标在训练同一套Embedding时可能相互干扰。</p><p>例子：APP的安装、 启动、卸载，对于要学习的APPEmbedding有着不同的要求。理想情况下，"安装"与"启动"两个Field要求APPEmbedding能够反映出APP为什么能够招人喜欢，而"卸载"这个Field要能够反映出APP为什么招人烦，所以大厂一般选择让"装/启/卸"三个Field各自拥有独立的Embedding矩阵。</p><p>更有甚者，大厂的推荐系统都是<strong>多目标</strong>的，比如要同时优化点击率、购买率、转发率、....等多个目标。有一些重要特征，在参与不同目标的建模时，也要使用不同的Embedding。</p><ul><li>不同的任务使用不同的Embedding的方法</li><li>如果在特征交叉的时候使用的是共享Embedding，会产生<strong>相互干扰</strong>的情况（不同需求要求不同Embedding）</li><li>FFM算法：每个特征在与不同特征交叉的时候，根据对方特征所属的Field要使用不同的Embedding</li><li>CAN算法：既要使用不同的Embedding进行特征交叉，但是又不想要太多的参数导致训练的难度增加</li></ul><h2 id="parameter-server训练框架">Parameter Server训练框架</h2><h3 id="传统的训练方式">传统的训练方式</h3><p>传统利用Hadoop/Spark的分布式训练方法忽略了<strong>高维稀疏特征空间，</strong>直接让master处理会参数量很大，传统的训练方式：</p><ol type="1"><li>将训练数据分散到所有Slave节点。</li><li>Master节点将模型的最新参数广播到所有Slave节点。</li><li>每个Slave节点收到最新的参数后，用本地训练数据，先前代再回代，计算出梯度并.上传至Master。</li><li>Master节点收集齐所有Slave节点发来的梯度后，平均之，再用平均后的梯度更新模型参数。</li><li>回到步骤1，开始下一轮训练。</li></ol><p>"高维稀疏的特征空间"，造成了两个困难:</p><ol type="1"><li>推荐系统的特征动辄上亿、上十亿，每个特征的Embedding是16位、32位甚至更长，这么大的参数量是一台Master所容纳不下的。</li><li>每轮训练中，Master节点都要将这么大的参数量广播到各Slave节点，每个Slave还要将相同大小的梯度回传，占据的带宽、造成的时延绝对达不到在线实时训练的需求。</li></ol><h3 id="ps训练方式">PS训练方式</h3><figure><imgsrc="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=OWZlZWYzYTc2NTRjYWVlYWY1MTFlMzY3MzQ4NTMyZWFfTkpFUzNkRUlxcG1KRmx1UHpxVHNsNmJsb1Jyb3RHSDFfVG9rZW46U1FXbmI4UWg0b3E4eDd4Y1NpOWN5OFFFbmdjXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>训练步骤：</p><figure><imgsrc="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=MzVjZGIwNGIwMWJjNGVlOGQ4ZTRlY2IzMjg2MTJhNGNfbWlFNEJSSlF2TUxyZkV2RHp0UHpIV1JqcHhYVXh2cjBfVG9rZW46UEVQYWI3NTF4b1ZvZ2h4QVB6a2N3S1hobkRkXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>PS训练模式是Data Parallelism(数据并行)和ModelParallelism(模型并行)的计算范式的结合，具体的训练流程见如下图：</p><figure><imgsrc="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=NWY4MzVlZmE0ZDc1YTRiNjNiNGFmYjg1YmJmNjJhNzhfUVpxTkMzQVJyZ2VEa3BiSnhHZDhSODdMWEV1YUtZT1VfVG9rZW46TnpRbGJ0OHZibzBvaWd4Z0RhYmNqY01VbkZmXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="ps并发策略">PS并发策略</h3><ul><li><strong>同步并发(BSP)</strong><ul><li><p>各Worker完成自己的本轮计算，将梯度汇报给Server，然后阻塞等待。</p></li><li><p>Server在收集齐所有Worker上报的梯度后，聚合梯度，用SGD算法更新自己负责的那部分模型参数。</p></li><li><p>Server通知各Worker解除阻塞。</p></li><li><p>Worker接到解除阻塞的通知，从Server拉取更新过的模型参数，开始下一轮训练。</p></li><li><p>这种模式的优点是，多个Worker节点更新Server，上的参数时不会发生冲突，所以分布式训练的效果赞同于单机训练的效果。缺点是，一轮迭代中，速度快的节点要停下来等待速度慢的节点，从而形成了"短板效应"，慢节点就能拖累整个集群的计算速度。</p></li><li><figure><imgsrc="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=YWZkM2ZmNTFlM2RiNTkyMmEzNjExYzM1NWViMzQ0OTFfY1pQcUF6SnJDOTNGTUk2ODB6RlNicnNTWnRRdmRFSGFfVG9rZW46SHd2RmJHTG1Lb1hwRHp4ZmRhWmNObGVxbmhkXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure></li></ul></li><li><strong>异步并发(ASP)</strong><ul><li><p>ASP在每台worker推送完自己的梯度之和，不用等待其他worker，就可以开始训练下一个batch的数据，没有短板效应</p></li><li><p>但是由于缺乏同步控制，ASP可 能发生"梯度失效" (StaleGradient)的问题，从而影响收敛速度。举一个极度简化的例子：</p></li><li><p>当前Server端 上模型参数的版本是<spanclass="math display">\[\theta_0\]</span>，有两个Worker节点，都从Server拉取<spanclass="math display">\[\theta_0\]</span>，同时开始一轮训练。</p></li><li><p>Worker1的速度比较快，很快训练完本地数据并向Server上报梯度g1。</p></li><li><p>Server收到g1后，根据SGD算法迭代一 步(步长为<spanclass="math display">\[\lambda\]</span>)，将Server端的参数值由<spanclass="math display">\[\theta_0\]</span>更新为<spanclass="math display">\[\theta_1=\theta_0-g_1\]</span>。</p></li><li><p>此时Worker 2才完成计算并向Server报了自己的梯度g2。</p></li><li><p>Server收到g2后，如果像<spanclass="math display">\[\theta_2=\theta_1-\lambdag_2\]</span>这样更新模型参数，反而可能损害收敛。这是因为g2是Worker2基于<spanclass="math display">\[\theta_0\]</span>计算得到的，而Server端的参数此时已经变成了<spanclass="math display">\[\theta_1\]</span>，g2已经失效。</p></li><li><figure><imgsrc="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=YTg1NzdmM2Q5ZDk5ZTQzODQyMGQ3Njc3ZThkODNmMmRfMVd1a1A4cGFOTkhtUVo5Q2pFRkdLc1BwSFhWbkZvRFpfVG9rZW46SDJ6Q2JpYUQ5b1BWSFp4MjZ0ZGNwUjkybktjXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure></li></ul></li></ul><p>得益于推荐系统中的<strong>特征超级稀疏</strong>的特点，在一轮迭代中，各个Worker节点的局部训练数据所包含的非零特征，相互重叠得并不严重。多个Worker节点同时更新同一个特征的参数的可能性非常小，所以Server端的冲突也就没有那么频繁和严重，ASP模式在推荐系统中依然比较常用的。</p><ul><li><strong>半同步半异步并发(SSP)</strong></li></ul><p>半同步半异步(Staleness Synchronous Parallel, SSP) 是BSP与ASP的折衷方案。SSP允许各Worker节点在一定迭代轮数之内保持异步。如果发现最快Worker节点与最慢Worker节点的迭代步数之差已经超过了允许的最大值，所有Worker都要停下来进行一次<strong>参数同步</strong>。SSP希望通过折衷，实现"计算效率"与"收敛精度"之间的平衡。</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/(null)-20240116152610714.(null)"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h1 id="冷启动">冷启动</h1><p>推荐系统的冷启问题是指：针对<strong>较少消费记录</strong>的新用户、新物料的推荐。声明一下,本章提到的新用户，既包括那些初次使用APP、没有任何历史行为的纯新用户，也包括那些虽然APP安装了很久、但偶尔使用的低活跃用户。新物料的定义也类似。</p><p>冷启是困扰推荐系统的一大难题。</p><ul><li>一方面, 冷启非常重要。对新用户而言, 现在互联网行业竞争激烈,拉新、获客成本居高不下, 好不容易拉来的新用户,如果模型承接做得不好而让其流失掉, 前面的努力也就白白浪费了;对新物料而言,新物料推荐不出去, 既会让用户失去新鲜感而加速流失,也会打击创作者的积极性, 不利于建立良好的内容生态。</li><li>另一方面, 冷启又相当困难。毕竟"巧妇难为无米之炊", 再强大的模型,没有信息喂进去, 也发挥不出什么作用。而且,很多经典的推荐算法从根本上就不支持新用户与新物料, 比如Item <spanclass="math display">\[2 \mathrm{Vec\]</span>对不曾在训练集中出现的物料就无法获得其Embedding,比如DIN/SIM要对用户历史行为序列做Attention,在新用户身上也就没有了用武之地。</li></ul><p>既然冷启是如此重要且艰巨,业界涌现出了许多方法来应对这一难题。其中不乏一些简单、经典的策略,比如:</p><ul><li>给新用户推荐全网最热门的物料。</li><li>不依赖消费记录, 重视使用基本属性（比如用户的性别与年龄,物料的分类与标签）。</li></ul><h2 id="代表算法">代表算法</h2><ol type="1"><li><p>Bandit算法</p><ol type="1"><li><p><strong>多臂老虎机问题：本质就是平衡探索和利用</strong></p></li><li><p>多臂老虎机问题与"冷启动"问题是非常相似的:</p></li><li><ul><li>对于新用户冷启动, 每个新用户就是一台老虎机,每个兴趣大类（比如：电影、音乐、军事、体育、......)就是老虎机的一个手柄。向该新用户展示某个兴趣类目下的物料,相当于拉动某一根手柄。用户的反馈（比如点击）犹如老虎机吐出的金币。我们希望通过有限次试探,使得到的用户正反馈最大化，也就摸清了用户兴趣，使用户获得了良好的初体验，增强APP对新用户的粘性。</li><li>对于新物料冷启动, 所有用户组成一台老虎机,候选新品池中的每个新物料相当于一根手柄。曝光某个新物料相当于拉动一次手柄。我们希望通过有限流量的试探,找到新品池中最优质的候选物料,犹如在多臂老虎机中找到那根能吐出最多金币的手柄。</li></ul></li><li><p>因此，我们可以借鉴MAB问题的成熟算法来解决推荐系统中的冷启动问题。</p></li><li><p>MAB问题最朴素、最初级的解法就是将N次尝试划分成"探索（Explore）"与"开发（Exploit）"先后两个阶段:</p></li><li><ul><li>先"探索", 也就是将每个手柄都拉动 $<span class="math display">\[$次。统计 \]</span>{R}(i<span class="math display">\[ 为拉动第\]</span><span class="math display">\[ 根手柄 \]</span>$$次得到的平均收益。</li><li>再"开发", 找到平均收益最大的那根手柄 <spanclass="math display">\[a_{\max }=\operatorname{argmax}_i\bar{R}(i)\]</span>，然后将剩余的机会全部用来拉动 <spanclass="math display">\[a_{\max \text { 。 }\]</span></li></ul></li><li><p><strong>Epsilon Greedy</strong></p></li><li><figure><imgsrc="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=NGQ4NDMwYWRiYjEzNmFiOWFlYWU0Njg4Nzc5NmYyMzNfcjFCdjlnVXBkQ3dDV01SeUJHR2NSdmdvYWw2WmNrV2ZfVG9rZW46Tk1JWmJ0ckZLb0lHRFV4NDk2bWN0ZnJ1bk5kXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure></li><li><p><strong>UCB算法，每次尝试都选择收益最高的</strong></p></li><li><figure><imgsrc="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=Yzk4YTNjNGYzM2U0ZjYxY2RlMGE5ZDRmY2QxNzg4MTlfSUVXcXRDVGNtNVpRWG5TbGtZa1JMVWZxTkRIcWczVTNfVG9rZW46UE9IUmJvd3F1b1JRWWV4eTRHQ2NYRURibmcyXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure></li><li><p>第 $$$$根手柄的收益上限，如公式所示。</p></li><li><p><span class="math display">\[U C B(i)=\bar{R}(i)+c \sqrt{\frac{2\log N}{n_i}}\]</span></p></li><li><ul><li><span class="math display">\[\bar{R}(i\]</span> 表示第$$$$根手柄的平均收益</li><li><span class="math display">\[\sqrt{\frac{2 \log N}{n_i}\]</span>表示第 $<span class="math display">\[$根手柄的收益的不确定性。\]</span><span class="math display">\[ 是到目前为止一共尝试的总次数,\]</span>n_<span class="math display">\[ 是其中拉动第 \]</span><spanclass="math display">\[根手柄的次数。可见, \]</span>n_<spanclass="math display">\[ 越小, 即第\]</span>$$根手柄尝试得越少，其收益的不确定性越高, 也就是潜力越大,尝试的机会也就应该增加。</li><li>$$$$ 表示"收益均值"与"收益潜力"之间的调节权重, 和Decay EpsilonGreedy一样, c也随时间衰减，后期"探索"应该降低，而主要以"开发"为主。</li></ul></li><li><p>从公式(8-1)可以看出, 一根手柄的收益上限高,只有两种可能性：</p></li><li><ul><li>要么是这根手柄的平均收益高。此时, 选择上限最高的手柄,就是在<strong>"开发"</strong>。</li><li>要么是这根手柄的收益潜力高。此时, 选择上限最高的手柄,就是在<strong>"探索"</strong>。</li></ul></li><li><figure><imgsrc="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=YzJjNWYwNDQ1ZGRjMDA4Y2M1YzQxOWJlZjI4YWFhNTBfb1gxQ1kxQ0lkek1nSVJpWnM2UDNqY2M2MXU5ZnRsSFdfVG9rZW46UjVMemJ5MklIb0JWVWd4MjdzR2NPTTlLbnFiXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure></li><li><p><strong>Bayesian Bandit</strong></p></li><li><p>基于Bayesian的MAB问题求解方法如下:</p></li><li><ul><li>假定第 $<span class="math display">\[$ 根手柄的平均收益遵循先验概率\]</span>p({R}(i)$$</li><li>经过若干次实验, 第 $<span class="math display">\[$根手柄收到一批反馈 \]</span>D_i={r_1, r_2, , r_{n_i}$$</li><li>根据Bayes公式, 第 $<span class="math display">\[$根手柄的平均收益的后验概率-    \]</span>p({R}(i) D_i) p(D_i {R}(i)) p({R}(i)$$</li><li>此时让我们选择手柄时,我们只需要从各手柄收益的后验概率中随机采样一个数字,然后选择采样数字最大的那根手柄去拉动即可。</li></ul></li><li><p>当各手柄的收益非 0 即 1 （这一点非常适用于推荐场景,比如点击与否）时,我们可以用Bernoulli分布来描述。而这个Bernoulli的均值（即每根手柄的平均收益）可以用Bernoulli分布的共轭分布Beta分布来描述，好处是先验分布与后验分布都遵循同样的形式，方便Bayes公式的计算。这种BayesianBandit算法被称为 Thompson Sampling, 可用于试探新用户的兴趣分布,如代码代码 8-3所示。</p></li><li><figure><imgsrc="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDUyYmY4NzU1MGI4NTU2MjA3M2JkNTA0MDY1MjE5MjRfWEtZUWhSbU9xaUw1VkRyT0VoOEo1RnJxa2ZwWDROZUlfVG9rZW46U1p3NGJFNFNpb2dkSzN4dzhrVGNTTTI2bk1kXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure></li><li><ul><li>将每个新用户设想成一台老虎机,假设一共有K个兴趣分类（比如：军事、历史、电影、音乐、......)，相当于每个新用户的老虎机有$$$$ 个手柄可选择。</li><li>第 2 行：向当前新用户展示第 <spanclass="math display">\[\mathrm{k\]</span>个兴趣分类的平均收益用Beta分布来描述, 涉及到两个参数 <spanclass="math display">\[\alpha_\]</span> 和 <spanclass="math display">\[\beta_\]</span> 。这里将 <spanclass="math display">\[\alpha_\]</span> 和 <spanclass="math display">\[\beta_\]</span> 都初始化为 1 ,Beta分布退化成平均分布</li><li>第7行：选择采样随机数最大的那个兴趣分类。三根手柄采样到的随机数分别为 [0.1,0.75,0.2]，所以应该选择第 2个手柄代表的兴趣分类。</li><li>第 8 行：将选中的兴趣分类 <span class="math display">\[c_\]</span>中优质物料推荐给新用户。至于如何获得一个兴趣分类下的优质物料,方法就多种多样了, 可以通过大数据统计, 也可以让运营团队人工管选。</li></ul></li></ol></li><li><p><strong>元学习(Meta</strong> <strong>Learning)</strong></p><ol type="1"><li><p>元学习介绍</p><ul><li><p>首先注意, 喂入Meta Learning的基本数据单位不再是一条条单独的样本,而是一个个<strong>"任务"（Task）</strong>。一个Task内部又包含两个数据集,一个训练集（元学习领域又称Support Set）, 一个测试集（元学习领域又称QuerySet）。</p></li><li><p>如图所示, 第一个Task是用于分类水果图片。训练Task 1时,将其中的训练集 (一批水果图片和标注) 喂入模板<spanclass="math display">\[ F_{\phi}\]</span>, 训练得到一个水果分类器 <spanclass="math display">\[f_{\theta_1^*}, \theta_1^\]</span>是训练得到的最优权重。这个步骤只用到单独一个 Task的数据,所以被称为"任务内学习"Within-Task Learning。</p></li><li><p>再将Task 1 中的测试集喂入训练好的模型<spanclass="math display">\[f_{\theta_1^*}\]</span>, 计算出在测试集上的损失<span class="math display">\[l_\]</span> 。</p></li><li><p>同理, 将Task 2 中的训练集 (交通工具的图片和标注) 喂入模板 <spanclass="math display">\[ F_{\phi}\]</span>, 训练得到一个交通工具分类器<span class="math display">\[f_{\theta^{2 *}\]</span> , <spanclass="math display">\[\theta_2^\]</span> 是训练得到的最优权重。再拿Task2 中的测试集喂入 <span class="math display">\[f_{\theta^{2 *}\]</span> ,计算得到测试集的损失 <span class="math display">\[l_\]</span>。</p></li><li><p>假设训练一个批次 (Batch) 有 $$$$ 个任务,总损失就是所有任务的测试集上的损失之和。这个步骤用到了一个Batch内所有任务的数据,所以被称为"跨任务学习"（Across-Task Learning）。</p></li><li><p><span class="math display">\[L_{\text {meta }}(\phi)=\sum_{n=1}^Nl_n=\sum_{n=1}^N L\left(D_n^{\text {test }} \mid\theta_n^*\right)\]</span></p></li><li><ul><li>L是所有任务共用的损失函数</li><li><span class="math display">\[l_\]</span> 是第 $$$$个任务在其测试集上的损失</li><li><span class="math display">\[D_n^{\text {test }\]</span> 是第 $$$$个任务中的测试集（即Query Set）</li><li><span class="math display">\[\theta_n^\]</span> 是第 $$$$个任务训练得到的最优参数</li></ul></li></ul></li><li><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/(null)-20240116152611540.(null)"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure></li><li><p><strong>MAML算法</strong></p><ul><li><p>Model-Agnostic Meta-Learning (MAML)是一类特殊的元学习,有两个特点:</p></li><li><p>模板配置 <span class="math display">\[\ph\]</span> 仅限于模型参数<span class="math display">\[\thet\]</span> 的初始值。</p></li><li><p>损失函数 <span class="math display">\[L_{\text {meta}}(\phi\]</span> <strong>对</strong> <spanclass="math display">\[\ph\]</span> <strong>可导,</strong> 从而可以通过SGD的方式求解出最优 <span class="math display">\[\ph\]</span> ,也就是最优的 <span class="math display">\[\thet\]</span> 初值。</p></li><li><p>提出MAML是为了解决"小样本训练"（Few-Shot Learning）的问题,也就是新任务没有足够多的数据将模型参数从头训练好。MAML的解决思路是:</p></li><li><p>通过若干组任务（比如Task 1 是分辨不同水果, Task 2是分辨不同的交通工具）, 学习出一套高质量的参数初值 <spanclass="math display">\[\ph\]</span></p></li><li><p>当面对一个新任务（比如分辨不同动物时）时, 由这段高质量的参数初值<span class="math display">\[\ph\]</span> 出发,只需要经过少量样本的迭代, 就能达到适合新任务的最优参数 <spanclass="math display">\[\theta^\]</span>,从而解决了新任务样本不足的问题。</p></li><li><p>具体解法上, 尽管理论上从初值 <spanclass="math display">\[\ph\]</span> 出发,需要经过多轮训练迭代才能得到最优参数 <spanclass="math display">\[\theta^\]</span> 。但是,从减少训练样本数的实际目标出发, 我们假设初值 <spanclass="math display">\[\ph\]</span> 只经过一次梯度下降就得到最优参数<span class="math display">\[\theta^\]</span>, 如公式所示。</p></li><li><p><span class="math display">\[\theta_n^*=\phi-\alpha\frac{\partial L\left(D_n^{\text {train }} \mid \phi\right)}{\partial\phi}\]</span></p></li><li><p><span class="math display">\[\ph\]</span>是所有任务共享的参数初值</p></li><li><p><span class="math display">\[\theta_n^\]</span> 是第 $<spanclass="math display">\[$ 个任务的最优模型参数, 假设由 \]</span>$$通过一次梯度下降就能得到</p></li><li><p>L是所有任务共享的损失函数</p></li><li><p><span class="math display">\[L\left(D_n^{\text {train }} \mid\phi\right\]</span> 是模型以初值 <spanclass="math display">\[\ph\]</span> 为参数, 在第 $<spanclass="math display">\[$ 个任务的训练集 \]</span>D_n^{$$上的损失</p></li><li><p><span class="math display">\[\alph\]</span> 是迭代步长</p></li></ul></li><li><p>如何作用于冷启动的推荐系统任务呢？</p><ul><li><p>我们可以得到将MAML应用于推荐场景所要做的第一个改进,就是修正其应用范围：</p></li><li><p>对于推荐模型的大部分参数, 包括DNN权重和常规特征的Embedding,新任务（即新用户/新物料）应该直接复用老任务（即老用户/老物料）已经训练好的，这样既能保证参数的质量，又能节省资源。所以,MAML完全没必要学习这些参数的最优初值。</p></li><li><p>每个新任务只有ID Embedding是这个任务独有的, 是无法复用老任务的,希望能够从一个最优初值出发只经过少量数据就快速迭代至最优状态。而这个最优的UserID Embedding初值, 或最优的Item ID Embedding的初值,是唯一需要MAML学习的模板配置。</p></li><li><p>优化目标改造</p></li><li><p>MAML在推荐场景下的唯一任务就是将最优的ID Embedding初值 <spanclass="math display">\[\ph\]</span> 学习出来,而在冷启的不同阶段发挥着不同作用。以新用户冷启为例:</p></li><li><p>第1个阶段是Cold-Start（为了和通篇所指的广义冷启相区别,我称之为"纯冷启"）：用户生平第一次向本推荐服务发出请求，预测程序在线上服务的模型的Embedding层找不到该用户UserID对应的 Embedding, 就拿 <span class="math display">\[\ph\]</span>代替喂进模型进行预测。此时, <span class="math display">\[\ph\]</span>直接影响了新用户的初体验。</p></li><li><p>第2个阶段是Warm-Up（热身）：第1个阶段的用户反馈回传至在线学习(Online Learning) 程序, 训练程序在Parameter Server中查不到新用户UserID对应的Embedding, 就拿 <span class="math display">\[\ph\]</span>当初值, 利用新用户的反馈数据, 通过一次梯度下降就得到了该新用户User IDEmbedding的最新值 <span class="math display">\[\theta^\]</span> 。 <spanclass="math display">\[\theta^\]</span> 被打到线上, 作为新的 User IDEmbedding, 为该用户的第"二"次（理想了一点,假设在线更新足够及时）请求服务。</p></li><li></li></ul></li></ol></li><li><p><strong>对比学习(Contrastive Learning)</strong></p><ol type="1"><li><p>对比学习属于<strong>自监督学习的一类</strong></p></li><li><p>一个完整的分类模型可以由"特征编码"（Encoding）与"分(Classification) 两阶段。</p></li><li><ul><li>特征编码（Encoding）阶段：一张图片可以由一个长度等于 <spanclass="math display">\[H \times W \times \]</span> 的大向量表示, 其中<span class="math display">\[H / W / \]</span>分别是图片的高/宽/通道个数（比如RGB三色可以理解为 3个通道）。其中单个维度的信息含量都有限,而且难免包含噪声。Encoder或是过滤掉原始输入中的噪声,或是将若干弱信息的原始特征交叉、聚合成一个强信息的特征, 从而将原来 <spanclass="math display">\[H \times W \times \]</span> 的原始特征压缩成一个$<span class="math display">\[$ 维的&quot;有效特征&quot;, 其中\]</span>K H W $$ 。"有效特征"虽然长度变短了,但是却保留了原始特征中绝大部分的信息, 是原始特征的"精华"。</li><li>分类 (Classification)阶段：将前一阶段提取出来的"有效特征"，经过简单映射，就得到了最终分类。</li></ul></li><li><p>常规机器学习中,"特征编码"与"分类"是由一个模型通过端到端学习来完成的。但是由于现在标注稀疏,我们只好将"特征编码"与"分类"物理拆分成两个独立的模型。</p></li><li><ul><li>"特征编码"阶段, 通过"自监督"（Self-Supervised Learning,SSL）方式来学习。所谓"自监督学习", 是指不依赖人工标注,通过挖掘未标注样本内部存在的结构、关联,将"特征编码"这个模块训练出来。传统的降噪自编码器（DenoisingAutoEncoder），Word2Vec和Transformer中通过句子的一部分预测另一部分,和这里要讲的对比学习, 都属于"自监督学习"的范畴。</li><li>"分类"阶段, 还是需要通过"<strong>监督" (Supervised)方式来学习</strong>。但是由于编码阶段提取出来的"有效特征"的长度已经大大缩短,所以“分类"模型只需要少量标注数据就能被充分训练,从而缓解了标注稀疏的问题。</li></ul></li><li><figure><imgsrc="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTIxZWNhOTQwOWY5Y2NkZGJhMmExZWM5YTI2NmQ2ZGZfVllFZlFtN2tlVlNScjVUZjZVdDdUSk94RkpIMFE1dUlfVG9rZW46SnpER2I1MGc4bzVzZFB4UkZQa2NEODQ4bjdiXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure></li><li><ul><li>我们有一张原始图片 $<spanclass="math display">\[$  尽管我们很容易知道这是一张狼犬的图片, 但是\]</span><span class="math display">\[没有被标注。模型并不知道,也无需知道 \]</span>$$ 的类别。</li><li>我们通过一些手段, 从原始图片衍生出多张与其相似的图片,这个过程被称为"数据增强"（Data Augmentation) 。比如中的数据增强,就是将原始图片 <span class="math display">\[P^{\prime \prime\]</span>黑白化"得到增强版图片 <span class="math display">\[P_{a u\]</span>。其他对于图片的数据增强方式还包括：旋转、镜像、剪裁等。</li><li>再从全体图片中随机抽取一张图片 <span class="math display">\[P_{ra\]</span> 。假设候选集足够庞大,我们不太可能再抽到同一类别的图片,比如中就抽到一张雪鸮的图片。当然模型同样无需知道其类别。</li><li>将原始图片 $<span class="math display">\[$ 、增强图片 \]</span>P_{au<span class="math display">\[ 和随机图片 \]</span>P_{r a<spanclass="math display">\[ , 都喂入Encoder进行提炼压缩,得到三者的&quot;有效特征&quot;向量 \]</span>V 、 <em>{a u<spanclass="math display">\[ 和 \]</span></em>{r a$$ 。</li><li>我们计算 <span class="math display">\[\boldsymbol{V\]</span> 与<span class="math display">\[\mathbf{V}_{a u\]</span> 之间的相似度 <spanclass="math display">\[s_{+}=\operatorname{Sim}\left(\mathbf{V},\mathbf{V}_{a u}\right)\]</span>, 模型的训练目标是最大化 <spanclass="math display">\[s_{+}\]</span>, 即原样本与其增强版在向量空间里,应该越近越好。</li><li>我们计算 <span class="math display">\[\mathbf{V\]</span> 与 <spanclass="math display">\[\mathbf{V}_{r a\]</span> 之间的相似度 <spanclass="math display">\[s_{-}=\operatorname{Sim}\left(\mathbf{V},\mathbf{V}_{r a}\right)\]</span>, 模型的训练目标是最小化 <spanclass="math display">\[s_{-}\]</span>,即原样本与随机抽取的其他样本在向量空间里, 应该越远越好。</li></ul></li><li><p>再将训练好的分类器用于小样本学习中</p></li><li><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/(null)-20240116152611886.(null)"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure></li><li><p>如何将<strong>对比学习用于推荐系统</strong></p><ul><li><p>推荐系统中的海量数据标注存在贫富差距的问题，就是所谓的<strong>二八法则</strong>，少数的物料或者用户拥有了大量的标注信息，但是大量的物料或者用户所拥有的标注信息很少</p></li><li><p>对比学习在推荐系统的主要作用就是<strong>“纠偏”</strong></p></li><li><p>通过"数据增强", 我们从少数用户/物料衍生出更多样本,放大少数群体在训练样本中的音量。</p></li><li><p>对比学习作为辅助任务,要让模型多见识一些平日里被其忽视的少数人群和小众物料。让平常听惯了"阳春白雪"的模型,也多多感受一下"下里巴人"。</p></li><li><p>因为在训练阶段与少数群体都"亲密接触"过了,被对比学习调教过的模型线上预测时,会少一份势利,对小众人群与物料友好一些。</p></li><li></li><li><p>既然明确了对比学习的目标是为了Debias, 那么训练时,我们必须注意以下两点</p></li><li><p>第一点, 参与对比学习的样本, 和参与主任务的样本,最好来自不同的样本空间</p><ul><li>主任务, 需要拟合用户与物料之间的真实互动,训练数据还是以曝光数据为主, 也就是以老用户、老物料为主。</li><li>对比学习, 既然是为了放大少数群体样本的影响力,其训练样本应该以鲜有曝光机会的少数人群和小众物料为主。比如,越少曝光的用户或物料, 他们的样本被衍生、增强得应该越多; 反之,就应该少增强或不增强。</li></ul></li><li><p>第二点, 主任务与对比学习任务之间, 必须共享参数。</p><ul><li>近年来给我的感觉, 参数共享、结构共享在推荐算法中,越来越不受待见。比如, 多任务场景下,流行让同一个特征对不同目标,拥有不同Embedding; 通篇都在讲参数独立性, 同一个特征与不同特征交叉时,都要使用不同的Embedding。</li><li>但是, 对于对比学习, 参数共享是必须的。否则,主模型与对比学习辅助模型, 各学各的, 主模型中的Bias依旧存在,对比学习学了个寂寞。</li><li><imgsrc="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=NTQwYzA5MTAxZTQzYjBkY2ZiZjNjN2QzMTUxMDA2YjlfWThoNmFJN2ROTFp2N0FtSlk1SGlUbE9ISlNhYkNrYmVfVG9rZW46WVdJUWJMNkFQb3k1R0F4VFU2ZGN4YnhCbnFyXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"title="fig:" alt="img" /></li></ul></li></ul></li><li><p>区分对比学习和向量化召回</p><ul><li>首先, 向量召回属于<strong>"有监督学习"</strong>。U2|召回中,用户与其点击过的物料在向量空间是相近的。在 121 召回中,被同一个用户点击过的物料在向量空间中是相近的。这些正样本都来源于用户反馈（标注）。反之,对比学习属于<strong>"自监督学习",</strong>不需要用户标注。用户与其增强版本, 物料与其增强版本,这些正样本都是我们根据一定规则制造出来的。</li><li>其次,向量召回重点<strong>关注的是负样本</strong>。大型推荐系统中的用户反馈源源不断,正样本从来都不是问题。反之, 对于对比学习,重点、难点恰恰是如何制造正样本。也就是给定用户或物料,如何"增强"出与其相似的用户或物料信息。因为推荐模型中的特征,以类别特征为主,高维、稀疏且相互关联（比如被一个用户点击过的多个物料之间可能存在时序、因果关系），简单粗暴地"增强"，反而降低了产生的正样本的可信度。因此,阅读将对比学习应用于推荐场景的文章, 重点是看其"数据增强"方法有何创新,其他方面如负样本策略、模型结构、损失设计往往都是向量召回中的常规套路，无甚新意。</li><li>最后, 向量<strong>化召回是主任务</strong>,比如替用户找到他喜欢的物料, 对推荐效果负直接责任。反之, 对比学习的目的,仅仅是为了纠正模型对小众用户、冷门物料这些少数派的偏见。对比学习作为辅助任务,只存在于训练阶段，并不上线，间接影响推荐效果。</li></ul></li></ol></li></ol><h1 id="推荐系统的多任务多场景">推荐系统的多任务多场景</h1><h2 id="多任务推荐">多任务推荐</h2><p>多任务建模(Multi-Task) ， 有时也被称为多目标建模(Multi-Objective)</p><ul><li>比如视频推荐场景下，我们推荐出去的结果，既想让用户点击，点击之后又希望观看的时间尽量长，还想让用户多多评论、转发。因此，需要同时建模点击率、观看时长、评论率和转发率这4个目标。</li><li>比如电商场景下，我们推荐出去的商品，既想让用户多多点击，还希望用户多多下单购买(术语叫转化)。因此，我们要同时建模三个目标:一件商品从曝光到点击的概率(点击率，CTR)、从点击到购买的概率(转化率,CVR)和从曝光到购买的概率(CTCVR)。</li></ul><p><strong>为什么不为每个目标单独建模?</strong></p><p>这么做太浪费资源，大厂的推荐模型本来就对内存、算力消耗巨大。如果每个目标单独建模，需要将内存、算力的消耗都乘上10，这笔预算恐怕很难批得下来。</p><p>其次，用户转化是一个链条，比如先点击，再加入购物车，最后购买。在这个链条越靠后的环节，价值越大，但是可用于训练的正样本也就越少，非常有必要将所有环节放在一起联合训练</p><p><strong>为什么不直接建模终极目标?</strong></p><p>以电商场景为例，用户最终没有购买(即未转化)，并不代表用户就一定不喜欢推荐结果，也很有可能是因为商品价格超出了这名用户的消费能力。如果只以提高CTCVR为唯一目标，APP推荐给这名用户的就都是在他消费能力之内的中低端商品。可能会暂时提高销售额，但是会带来两方面的危害:</p><ul><li>容易造成用户的审美疲劳，对用户的长期留存不利。</li><li>也失去给用户"种草"的机会。万一哪一天，用户狠下心来想剁手，APP却推荐不出来高端商品,</li></ul><p>也就白白浪费了一次提高销售额的机会。</p><h3 id="多任务方法">多任务方法</h3><h4 id="并发建模">并发建模</h4><p>这种模式下，每个目标独立建模，忽略了不同目标之间的因果关系。</p><ol type="1"><li>Share Bottom共享底层</li></ol><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/(null)-20240116152612199.(null)"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li>底层结构比如Embedding层和底层的DNN,为所有任务共享的。</li><li>每个任务有自己独立的"塔" 结构，SharedBottom的输出作为每个塔的输入。</li></ul><p>这种结构的优点是实现了多任务之间的"知识迁移"。比如，任务A的正样本多，任务B的正样本少。如果任务B单独训练，对"共享底层"的训练不会太充分。而联合任务A与B，数据丰富的任务A能够将"共享底层"训练到一个比较好的状态，让B在此基础上继续训练，事半功倍。</p><p>很多时候，不同任务之间的关系，并非我们想像的那般相辅相成。不同任务对底层共享参数的梯度方向存在分歧，虽说还不至于南辕北辙、相互拆台，但也做不到"心往一块想，劲往一处使"。</p><ol type="1"><li>Multi-gate Mixture-of-Experts</li></ol><p>沿着拆解共享部分的思路，Mixture-of-Experts (MoE)将"共享底层"拆分成若干小型DNN，<strong>每个DNN称为一个Expert</strong>，再由一个门控网络"(Gate) 控制每个Expert对某个任务的参与程度。</p><figure><imgsrc="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmM4ZTkxYjNjNDBlY2VjOWY5Mzk1ZDBiYjQ4MmI1NmZfTmxzWWpQOU5jckR3MHAyR1pTVjhodlV2dUt2TEJKbkZfVG9rZW46SG92WmJBOHJjb25Qc3V4N0RoRmNQTnNibnBoXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>MoE中第 $$$$ 个目标的预测值, 如下所示。</p><p><span class="math display">\[y_k=h_k\left(\sum_{i=1}^ng(\mathbf{x})_i \operatorname{Expert}_i(\mathbf{x})\right)\]</span></p><ul><li><span class="math display">\[\mathrm{x\]</span> 是输入的特征向量,<span class="math display">\[y_\]</span> 是根据计算出的第 <spanclass="math display">\[\mathrm{k\]</span> 个目标的预测值。</li><li>一共创建了n个Expert, Expert <span class="math display">\[t_\]</span>代表第 <span class="math display">\[\mathrm{i\]</span>个Expert的网络模型。</li><li><span class="math display">\[\mathrm{g\]</span> 代表门控模型, <spanclass="math display">\[g(\mathbf{x}\]</span> 将输入特征映射成一个 $<spanclass="math display">\[$ 维长的数组, \]</span>g()_<spanclass="math display">\[ 是其中的第 \]</span><spanclass="math display">\[ 位, 表示第 \]</span><spanclass="math display">\[ 个Expert的权重。具体实现上, \]</span>$$就是一个普通的多层全链接网络 (MLP), 其最后一层使用Softmax做激活函数,使各Expert的权重之和等于 1 。</li><li><span class="math display">\[h_\]</span> 代表第 $<spanclass="math display">\[$ 个任务的Tower结构（图 7-2中的Tower A和Tower B),喂入 \]</span>h_$$ 的是各个Expert输出的加权和。</li></ul><p>Multi-gate Mixture-of-Experts (MMoE) 在MoE的基础上, 进一步拆解,结构如图所示：</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/(null)-20240116152612493.(null)"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li>MoE中只有一个Gate, 替所有任务决定各Expert的权重。</li><li>MMoE中, 每个任务都有自己的Gate,衡量各Expert对于本任务的重要性。</li></ul><ol type="1"><li>Progressive Layered Extraction</li></ol><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/(null)-20240116152612659.(null)"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li>首先, 对模型的共享部分继续拆解。在MMoE中,所有Expert为所有任务所共享。而在PLE中, 将所有Exper划分为"任务独占"（Task Specific）和"任务共享"（TaskShared）两大类，前者只参与单一任务，后者参与所有任务。比如图7-5中,"Experts A"中的所有Experts, 只参与对任务A的建模。而建模任务A，是由"Experts A"与"Experts Shared"中的所有Experts共同参与的。</li><li>其次, MMoE中只有一层Experts,Experts之间的交互比较弱。而PLE中引入了多层Experts,Experts之间的交互层层递进、深化。</li></ul><p>PLE的第 $<span class="math display">\[$ 层要输出 \]</span>N+$$个向量, 如公式(7-3)所示</p><p><span class="math display">\[\left[\mathbf{x}_1^k, \ldots,\mathbf{x}_N^k, \mathbf{x}_s^k\right]\]</span></p><ul><li>$$$$ 是所有任务的个数</li><li><span class="math display">\[\mathbf{x}_t^k, t \in[1, \ldots,N\]</span> 表示第 $<span class="math display">\[$ 层对任务 \]</span>$$的建模结果</li><li><span class="math display">\[\mathbf{x}_s^\]</span> 表示第 $$$$层对共享信息的建模结果</li></ul><p>在第 <span class="math display">\[\mathrm{k\]</span> 层建模时,首先将下层的输出喂入本层的各Experts</p><p><span class="math display">\[\begin{aligned} &amp; EO_t^k=\left[E_{t, 1}^k\left(\mathbf{x}_t^{k-1}\right), \ldots, E_{t,m_t}^k\left(\mathbf{x}_t^{k-1}\right)\right], t \in[1, \ldots, N] \\&amp; E O_s^k=\left[E_{s, 1}^k\left(\mathbf{x}_s^{k-1}\right), \ldots,E_{s, m_s}^k\left(\mathbf{x}_s^{k-1}\right)\right]\end{aligned}\]</span></p><ul><li><span class="math display">\[\mathrm{x}_t^{k-1\]</span> 是第 <spanclass="math display">\[k-\]</span> 层对任务 $$$$ 的建模结果</li><li><span class="math display">\[E O_t^\]</span> 表示第 $<spanclass="math display">\[$ 层任务 \]</span>$$独占的那些Experts的输出向量的集合</li><li><span class="math display">\[E_{t, i}^\]</span> 代表第 $<spanclass="math display">\[$ 层任务 \]</span><span class="math display">\[独占的第 \]</span>$$ 个Expert</li><li><span class="math display">\[m_\]</span> 是任务 $$$$独占的所有Experts的个数</li><li><span class="math display">\[\mathbf{x}_s^{k-1} 、 E O_s^k 、 E_{s,i}^k 、 m_\]</span> 代表类似含意, 只不过是针对共享信息的</li></ul><p>最终参与第 $<span class="math display">\[$ 层任务 \]</span><spanclass="math display">\[ 建模的是 \]</span>E O_t^<spanclass="math display">\[ 和 \]</span>E O_s^<span class="math display">\[中的所有 \]</span>m_t+m_<span class="math display">\[个Experts。先计算这些Experts的权重, 如公式 \]</span>(7-5$$ 所示。</p><p><spanclass="math display">\[\mathbf{C}_t^k=G_t^k\left(\mathbf{x}_t^{k-1}\right)\in R^{m_t+m_s}\]</span></p><ul><li><span class="math display">\[G_t^\]</span> 是第 $<spanclass="math display">\[$ 层针对任务 \]</span>\mathrm{t$$ 的门控函数</li><li><span class="math display">\[\mathbf{C}_t^\]</span> 是一个长度为<span class="math display">\[m_t+m_\]</span> 的数组, 表示对参与第 $<spanclass="math display">\[$ 层任务 \]</span><span class="math display">\[建模的是 \]</span>E O_t^<span class="math display">\[ 和 \]</span>EO_s^$$ 中所有Experts的权重。</li></ul><p>然后, 将权重与Experts的输出加权加和, 得到第 $<spanclass="math display">\[$ 层对任务 \]</span>$$ 的建模结果 <spanclass="math inline">\(\mathbf{x}_t^k\)</span>, 如公式(7-6)所示,其中符号"||"表示将两个数组拼接一起。</p><p><span class="math display">\[\mathbf{x}_t^k=\sum_{i=1}^{m_t+m_s}\mathbf{C}_t^k[i] \times\left(E O_t^k \| E O_s^k\right)[i]\]</span></p><p>第 $<span class="math display">\[$ 层对共享信息 \]</span>_s^$$的建模, 与对某个特定目标的建模类似,只不过要让本层所有Experts参与其中。</p><p><span class="math display">\[\begin{aligned} \mathbf{C}_s^k &amp;=G_s^k\left(\mathbf{x}_s^{k-1}\right) \in R^{T E} \\ \mathbf{x}_s^k&amp; =\sum_{i=1}^{T E} \mathbf{C}_s^k[i] \times\left(E O_1^k\|\ldots\|E O_N^k \| E O_s^k\right)[i] \end{aligned}\]</span></p><h4 id="串行建模">串行建模</h4><p>串行建模主要用于电商场景。如同前面提到的，电商业务需要将三个概率CTR/CVR/CTCVR都预估清楚，在预测时，我们需要对尚未曝光的物料预测包括CVR在内的分数。这样一来，训练数据中的物料与<strong>预测时的物料集合存在明显差异</strong>，导致"样本选择误差"(Sample Selection Bias, SSB)，严重影响模型效果。</p><figure><imgsrc="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2VlZTY1OTEwN2ExYTBjZWQ5NTBkZWIzOGQyN2Y0NTJfWXI0WWQ0V0FpUHk2eHpZQ0hCVGlNaXVHcWVNRDEyeUFfVG9rZW46S1F3b2JBWGZZb2YwRUR4aDN4eWNxcTNWbjliXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li><strong>ESMM</strong></li></ol><p>为了克服以上样本选择偏差，阿里的Entire Space Multi- task Model (ESMM)的解决思路是:</p><ul><li>将CVR与CTR、CTCVR一样，都建模在"曝光样本空间"上(理论上，这些任务都应该建模在粗排结果集上，但是实现起来有难度，所以大家都约定俗成建模在"曝光样本"上了，其中的SSB就忽略不计了)。</li><li>但是,毕竟"曝光未点击"的样本不符合CVR的定义，因此CVR只能作为隐藏目标，在其他目标被优化的同时，被间接优化。</li></ul><figure><imgsrc="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=MDdjNjQxOTFlY2ZhMGNjYWExNWI2YjU0MDU2NzY3MGJfMkhoVXFMY0JXcXpjSGhWS3Z0bkRhNWs4SmFwVjkzVGtfVG9rZW46UUgwQ2JGamhybzVVbEt4S002NGNHOWhPbk9kXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li>整个模型由"CTR模块"与"CVR模块"组成, 喂入的都是曝光样本</li><li>图 7-7中的Embedding Layer、Field-wisePooling、MLP都是常规操作。值得注意的是, CTR模块与CVR模块的底层Embedding是共享的,有利于正例丰富的CTR任务向正例稀疏的CVR任务进行"知识迁移"。</li><li>在分别预测得到"曝光 <span class="math display">\[\rightarro\]</span>点击"概率 <span class="math inline">\(\mathrm{pCTR}\)</span>, 和"点击<span class="math display">\[\rightarro\]</span> 购买"概率pCVR后,ESMM根据条件概率公式, 得到"曝光 <spanclass="math display">\[\rightarro\]</span> 购买"概率 <spanclass="math display">\[p C T C V R=p C T R \times p C V \]</span>。</li><li>由于pCTR和pCTCVR都是建立在"曝光样本空间"上的，可以被直接优化，总损失函数如公式(7-9)所示。注意这里CVR没有被直接优化,而是作为 <span class="math display">\[\mathrm{PCTCVR\]</span>的组成部分被间接优化。而且CVR也是被全体"曝光数据"训练出来的,消除了训练与预测两阶段间的"样本选择偏差"。</li></ul><p><span class="math display">\[\begin{aligned} L\left(\mathbf{W}_{c tr}, \mathbf{W}_{c v r}\right) &amp; =\sum_{i=1}^N B C E\left(y_i, d nn_{c t r}\left(\mathbf{x}_i ; \mathbf{W}_{c t r}\right)\right) \\ &amp;+\sum_{i=1}^N B C E\left(z_i, d n n_{c t r}\left(\mathbf{x}_i ;\mathbf{W}_{c t r}\right) \times d n n_{c v r}\left(\mathbf{x}_i ;\mathbf{W}_{c v r}\right)\right) \end{aligned}\]</span></p><ul><li><span class="math display">\[\mathbf{x}_\]</span> 是第涤样本的特征,<span class="math display">\[y_\]</span> 代表第 $<spanclass="math display">\[$ 条样本是否点击, \]</span>z_<spanclass="math display">\[ 代表第 \]</span><span class="math display">\[条样本是否购买, \]</span>$$ 代表样本总数</li><li><span class="math display">\[d n n_{c t r\]</span> 和 <spanclass="math display">\[d n n_{c v r\]</span> 分别CTR模块与CVR模块, <spanclass="math display">\[\mathbf{W}_{c t r}, \mathbf{W}_{c v r\]</span>分别代表两模块中要学习的权重</li><li>BCE（Binary Cross Entropy）代表二阶交叉熵函数。</li></ul><ol type="1"><li><strong>ESM2</strong></li></ol><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/(null)-20240116152613215.(null)"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>ESM2要预测 4 个概率, 在图 7-10中从左至右分别是:</p><ul><li>"曝光 <span class="math display">\[\rightarro\]</span> 点击"的概率,CTR, 记为 <span class="math display">\[y_1=P(c=1 \mid v=1)\]</span>,其中 $<span class="math display">\[$ 表示曝光, \]</span>$$表示点击。</li><li>"点击 <span class="math display">\[\rightarro\]</span>直接行为"的概率, 记为 <span class="math display">\[y_2=P(a=1 \midc=1\]</span> 。其中 $$$$ 表示"直接行为" (Direct Action, DAction）,是指像"加入购物车"、"加入愿望清单"这样与购买强相关的行为。</li><li>"直接行为 <span class="math display">\[\rightarro\]</span>购买"的概率, 记为 <span class="math display">\[y_3=P(b=1 \mida=1)\]</span>, 其中 $$$$ 表示购买。</li><li>"其他行为 <span class="math display">\[\rightarro\]</span>购买"的概率, 记为 <span class="math display">\[y_4=P(b=1 \mida=0\]</span> 。</li></ul><p>基于以上 4 个概率, ESM2要优化三个目标。最简单的就是"曝光 <spanclass="math display">\[\rightarro\]</span> 点击", 损失函数如公式 <spanclass="math display">\[(7-10\]</span> 所示。</p><p><span class="math display">\[L o s s_1=\sum_{i=1}^N B C E\left(c_i,p_i^{c t r}\right)=\sum_{i=1}^N B C E\left(c_i, y_{1i}\right)\]</span></p><ul><li><span class="math display">\[c_\]</span> 代表第涤样本是否点击</li><li><span class="math display">\[p_i^{c t r}=y_{1 i\]</span>是模型预测的第 $$$$ 条样本的CTR</li><li>$$$$ 是所有样本数量, BCE代表二阶交叉熵损失函数</li></ul><p>第二个目标是"曝光 <span class="math display">\[\rightarro\]</span>直接行为", 如公式(7-11)和公式(7-12)所示。</p><p><span class="math display">\[\begin{aligned} p_i^{\text {ctavr }}=&amp; P\left(a_i=1 \mid v_i=1\right) \\ = &amp; P\left(a_i=1 \midc_i=1\right) \times P\left(c_i=1 \mid v_i=1\right) \\ = &amp; y_{2 i}y_{1 i} \\ &amp; \text { Loss }_2=\sum_{i=1}^N B C E\left(a_i,p_i^{\text {ctavr }}\right) \end{aligned}\]</span></p><ul><li><span class="math display">\[p_i^{c t a v r\]</span>代表模型预测出的第 $<span class="math display">\[$ 个样本&quot;曝光\]</span>$$ 直接行为"的概率</li><li><span class="math display">\[a_\]</span> 代表第 $$$$条样本发生了直接行为</li></ul><p>第三个目标是"曝光 <span class="math display">\[\rightarro\]</span>购买"，如公式(7-13) (7-15)所示。</p><p><span class="math display">\[\begin{gathered} p_i^{c vr}=P\left(b_i=1 \mid c_i=1\right) \\ =P\left(b_i=1 \mid a_i=0\right)\times P\left(a_i=0 \mid c_i=1\right)+P\left(b_i=1 \mid a_i=1\right)\times P\left(a_i=1 \mid c_i=1\right) \\ =y_{4 i}\left(1-y_{2i}\right)+y_{3 i} y_{2 i} \\ p_i^{\text {ctcvr }}=p_i^{c t r} \timesp_i^{c v r}=y_{1 i}\left(y_{4 i}\left(1-y_{2 i}\right)+y_{3 i} y_{2i}\right) \\ \operatorname{Loss}_3=\sum_{i=1}^N B C E\left(b_i, p_i^{c tc v r}\right) \end{gathered}\]</span></p><ul><li><span class="math display">\[p_i^{c v r\]</span> 代表模型预测出的第$<span class="math display">\[$ 条样本&quot;点击 \]</span>$$购买"的概率</li><li><span class="math display">\[p_i^{\text {ctcvr }\]</span>代表模型预测出的第 $<span class="math display">\[$ 条样本&quot;曝光\]</span>$$ 购买"的概率</li><li><span class="math display">\[b_\]</span> 代表第 $$$$条样本是否购买</li></ul><p>最终ESM2要优化的目标是三个目标的损失之和，其中 <spanclass="math display">\[w_1 、 w_2 、 w_\]</span>是三个用于调节损失权重的超参数。和ESMM一样, 这里CVR是作为隐藏目标,被间接优化。</p><p><span class="math display">\[\text { Loss }=w_1 \text { Loss }_1+w_2\text { Loss }_2+w_3 \text { Loss }_3\]</span></p><ol type="1"><li>除此之外还有例如<strong>ESCM2</strong>、<strong>知识迁移</strong>等等</li></ol><h2 id="多场景推荐">多场景推荐</h2><p>多场景推荐，关注的是指使用推荐服务的用户中，存在着<strong>差异明显的不同消费模式</strong>。</p><ul><li>同一个视频APP，"单列模式"让用户有"沉浸式"检验，每次只看到当前视频，看不到其他候选视频；而"双列模式"允许用户一次性看到多个候选视频，有更多选择自由。这两种产品模式下的用户行为模式，存在显著差异。</li><li>一个提供全球服务的APP,不同国家的用户的消费模式，明显不同。</li><li>同一个APP，不同生命周期的用户差异明显，需要推荐系统有不同的应对策略。对低活跃用户，推荐结果要以热门物料为主；</li></ul><p>注意多场景推荐与几个相关概念的异同:</p><ul><li><strong>多场景推荐vs.多任务/多目标推荐</strong>。多场景研究的是如何用一个模型将行为模式有明显差异的不同用户群体都服务好，而无论用户来自哪个群体，模型可能都要预测多个目标。所以，多场景与多目标是相互正交的两个维度</li><li><strong>多场景推荐vs.跨场景(跨域)推荐</strong>。一般来说，多场景推荐指的是用一套模型来服务所有用户，而跨场景推荐需要用不同模型来服务不同用户，而多个模型之间存在知识迁移。比如某公司已经有一款图文APP积累了大批活跃用户，现在该公司新推出了一款视频APP。</li></ul><h3 id="特征位置">特征位置</h3><p>要想模型能够识别出不同场景、不同用户群体并区别对待,首先要设计出"场景指示" (Scenario Indicator)特征。比如:</p><ul><li>"APP模式"能够区分用户请求是来自"单列模式"还是"双列模式"。</li><li>为了区分不同国家的用户，国籍、语言应当被纳为特征。</li><li>为了区分"低活用户"与"高活用户"。"近7天用户活跃天数"、"是否新注册用户"、"用户是否登陆"这些都应该被用作特征。</li></ul><p>但是仅仅设计出以上特征, 还是远远不够的。如何将这些特征加入模型,也大有讲究。本书前面曾经反复强调,"DNN是万能函数模拟器"的神话已经破灭。如果把"场景指示"特征加到DNN底部，让它们的信息"按部就班"层层上传,恐怕再重要的信息到达顶部时, 也不剩下多少了。另外,DNN的底层往往由许多Field Embedding拼接而成，动辄上千维是小意思。这时你再新加入一两个"场景指标"特征,"泯然众人矣"，恐怕也不会太奇怪。</p><p>为解决以上问题,业界常见的作法是将"场景指示"特征加到离最终目标近一点的地方。</p><ul><li>"场景指示"特征，通过一个非常浅的网络, 得到logit scene</li><li>其他对场景不敏感的特征，按照常规处理，经过比较复杂的网络，得到logitcommon</li></ul><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/(null)-20240116152613359.(null)"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>这样做, 使"场景指示"特征对最终预测结果的影响直接有力,避免自DNN底部层层上传带来的信息损失,更有机会将如此重要的先验知识贯彻到"顶"。</p><h3 id="模型结构">模型结构</h3><p>多场景推荐模型由两大部分组成:</p><ul><li>场景共享部分: 需要共享结构和参数来建模来建模多场景之间的共性,让数据丰富的场景将共享参数充分训练, 借此向数据稀少的场景迁移知识。</li><li>场景独立部分：各场景也需要独立的结构与参数,以建模该场景的特殊性。</li></ul><p>代表算法：</p><ol type="1"><li>Split&amp;Merge：将共享结构和各场景独有的结构串联起来</li></ol><figure><imgsrc="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=NmE5OTI2NmIwNDkxMDFjMGI3YjBkOWNkNzU5OTY0MjdfYzBJRGZrNzNmU2VrVEN1ZmRNOExKcFlyb2hldWF2amFfVG9rZW46TXRZQmJYOEY1b2dxdlp4Q3FNcmNPYTRKbnRjXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li><strong>HMoE</strong></li></ol><p>在普通"串联"结构的基础上, 阿里于2020年提出了HybridMixture-of-Experts（HMoE）结构。HMoE的理论假设是, 对某个样本,除了其所在场景的模型的打分, 其他场景的模型打分也有借鉴意义。所以,HMoE在"场景独立部分"引入了MoE结构,每个场景下的模型都相当于一个Expert。一条样本要经过多个Expert打分,再对各Expert的打分加权相加, 得到最终得分。</p><figure><imgsrc="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=NTk2YTAwMGY2MGU0ZmU3NmJmNjY5Mzc1ZjdkZmJhZjBfOU9PcnZUTng1TXQxWmVQVFJCV2JnYVo1d2N2NHIzR1NfVG9rZW46RHg4T2JPUGdNb1ZwMHp4ZEwwcWNtTWlYblVoXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li><strong>STAR</strong></li></ol><p>阿里于2021年提出STAR型结构, 突破了传统的串联模式,将"场景共享部分"与"场景独立部分"更紧密地"交织"在一起。计算过程如公式(7-37)所示,网络结构如图7-16所示。</p><p><span class="math display">\[\begin{aligned} y_p &amp; =D NN\left(\mathbf{x}_p ; \mathbf{W}_p^*\right) \\ \mathbf{W}_p^* &amp;=\left[\mathbf{W}_{p, 1}^*, \ldots, \mathbf{W}_{p, K}^*\right] \\\mathbf{W}_{p, i}^* &amp; =\mathbf{W}_{p, i} \otimes \mathbf{W}_i\end{aligned}\]</span></p><ul><li>第 $<span class="math display">\[$ 个场景的输入 $\mathbf{x}_p$,经过一个DNN结构, 得到第 \]</span><span class="math display">\[个场景的输出 \]</span>y_<span class="math display">\[ 。这个DNN的参数是\]</span>_p^$$ 。</li><li><span class="math display">\[\mathbf{W}_p^*=\left[\mathbf{W}_{p,1}^*, \ldots, \mathbf{W}_{p, K}^*\right\]</span> 是长度为 $<spanclass="math display">\[$ 的数组, \]</span>_{p, i}^<spanclass="math display">\[ 是DNN第 \]</span><span class="math display">\[层的权重, \]</span>$$ 是DNN的总层数。</li><li><span class="math display">\[\mathbf{W}_{p, i}^\]</span> 是由第$<span class="math display">\[$ 个场景独有结构的第 \]</span><spanclass="math display">\[ 层权重 \]</span><em>{p, i}<spanclass="math display">\[, 与共享结构的 \]</span><spanclass="math display">\[ 层权重 \]</span></em>{i}<spanclass="math display">\[，通过按位相乘 (用 \]</span>$$ 表示)得到。</li></ul><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/(null)-20240116152613918.(null)"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="模型参数">模型参数</h3><p>动态权重法</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/(null)-20240116152614074.(null)"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li>把"场景指示"（Scenario Indicator）特征 <spanclass="math display">\[\boldsymbol{z\]</span>，喂进"权重生成器"（WeightGenerator, WG，生成动态权重向量 <span class="math display">\[\mathbf{DW}=W G(\mathbf{z}\]</span> 。</li><li>再将 <span class="math display">\[\boldsymbol{D}\boldsymbol{W\]</span> 变形（Reshape）成一个合适形状的DNN, 记为 <spanclass="math display">\[F_{\mathrm{DW}\]</span> 或 <spanclass="math display">\[F_{W G(\mathbf{z})\]</span>。比如, 假设 <spanclass="math display">\[\boldsymbol{D} \boldsymbol{W\]</span>的长度是<span class="math display">\[640=32 \times 16+16 \times8\]</span>, 所以 <span class="math display">\[\boldsymbol{D}\boldsymbol{W\]</span> 可以变形为一个三层的MLP，每层的神经元个数分别为<span class="math display">\[[32,16,8\]</span>。</li><li>将这个根据"场景指示"特征动态生成的网络<spanclass="math display">\[F_{WG(\mathbf{z})}\]</span>，应用于在整个推荐模型的关键位置。</li></ul><p>大型推荐系统经常要同时解决<strong>"多场景+多目标"</strong>的推荐问题,即不仅一个模型要应对多个场景,而且在每个场景下还要同时预测多个目标。阿里于2022年提出M2M（Multi-scenarioMulti-task）结构，运用"动态权重"模式解决这一问题。</p><p>M2M整体上还是遵循了经典的MMoE结构, 只不过在两个关键位置, "评估多个Expert的重要性的Gate"与"各任务独有的Tower",采用了根据"场景指示"特征动态生成的权重, 以更好地适应不同场景的特点。</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/(null)-20240116152614240.(null)"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>深度学习</tag>
      
      <tag>推荐系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【深度学习】图神经网络</title>
    <link href="/2024/01/12/dl_gnn/"/>
    <url>/2024/01/12/dl_gnn/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="图神经网络">图神经网络</h1><p>GNN全称----图神经网络，它是一种直接作用于图结构上的神经网络。我们可以把图中的每一个节点<span class="math inline">\(V\)</span> 当作个体对象，而每一条边 <spanclass="math inline">\(E\)</span>当作个体与个体间的某种联系，所有节点组成的关系网就是最后的图 <spanclass="math inline">\(U\)</span></p><p>GNN的输入一般是每个节点的起始特征向量和表示节点间关系的邻接矩阵，有了这两个输入信息，接下来就是聚合操作了。所谓的聚合，其实就是将周边与节点V i ViVi 有关联的节点{V a , V b , . . . Va,Vb,...Va,Vb,...}加权到V iViVi上，当作一次特征更新。同理，对图中的每个节点进行聚合操作，更新所有图节点的特征。</p><p>GNN本质就是更新每个节点的特征，输入是特征，输出是特征，邻接矩阵不会变</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法题】LeetCode算法汇总</title>
    <link href="/2024/01/01/leetcode/"/>
    <url>/2024/01/01/leetcode/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="语言细节">语言细节</h1><p>vector的长度：</p><ul><li>C++：nums.size()</li><li>Python：len(nums)</li><li>GO：len(nums)</li></ul><p>初始化数组：</p><ul><li>C++：array[n]={0} 让所有元素都是0</li></ul><p>构造vector:</p><ul><li>C++：vector result(长度，元素)</li><li>Python：res = [float('inf')] * len(nums)</li><li>GO：=make([]int，n)</li></ul><p>for循环：</p><ul><li>C++：条件小括号+循环体中括号</li><li>Python：冒号且不需要小括号包条件</li><li>GO：循环体中括号，条件按照C++写但是不需要小括号</li></ul><h1 id="数组">数组</h1><h3 id="二分查找">二分查找</h3><p><strong>题目描述</strong></p><p>链接：<ahref="https://leetcode.cn/problems/binary-search/description/">https://leetcode.cn/problems/binary-search/description/</a></p><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回-1。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="hljs-section">输出: 4</span><br><span class="hljs-section">解释: 9 出现在 nums 中并且下标为 4</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="hljs-section">输出: -1</span><br><span class="hljs-section">解释: 2 不存在 nums 中因此返回 -1</span><br></code></pre></td></tr></table></figure><p><strong>思路</strong></p><p>题目表示的是有序数组，而且题目没有重复元素。在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是<strong>循环不变量</strong>规则</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>  <span class="hljs-comment"># 定义target在左闭右闭的区间里，[left, right]</span><br><br>        <span class="hljs-keyword">while</span> left &lt;= right:<br>            middle = left + (right - left) // <span class="hljs-number">2</span><br>            <br>            <span class="hljs-keyword">if</span> nums[middle] &gt; target:<br>                right = middle - <span class="hljs-number">1</span>  <span class="hljs-comment"># target在左区间，所以[left, middle - 1]</span><br>            <span class="hljs-keyword">elif</span> nums[middle] &lt; target:<br>                left = middle + <span class="hljs-number">1</span>  <span class="hljs-comment"># target在右区间，所以[middle + 1, right]</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> middle  <span class="hljs-comment"># 数组中找到目标值，直接返回下标</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>  <span class="hljs-comment"># 未找到目标值</span><br></code></pre></td></tr></table></figure><p>注意这里给出的题解法：当<code>left &lt;= right</code>的时候，以下的条件中全部都不取到等号<code>nums[middle] &gt; target nums[middle] &lt; target</code></p><p>需要注意的是：<code>right=nums.size()-1</code></p><p>C++版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)<br>        &#123;<br>            <span class="hljs-comment">// int middle = (left+right)/2; 这样写会溢出</span><br>            <span class="hljs-type">int</span> middle = left + ((right - left) / <span class="hljs-number">2</span>);<br>            <span class="hljs-keyword">if</span>(nums[middle]&gt;target)<br>            &#123;<br>                right = middle<span class="hljs-number">-1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[middle]&lt;target)<br>            &#123;<br>                left = middle+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> middle;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Go版本</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    right:=<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span><br>    left:=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> left&lt;=right&#123;<br>        middle:= left+(right-left)/<span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[middle]&lt;target&#123;<br>            left = middle+<span class="hljs-number">1</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[middle]&gt;target&#123;<br>            right = middle<span class="hljs-number">-1</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> middle<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="移除元素">移除元素</h3><p><ahref="https://leetcode.cn/problems/remove-element/description/">https://leetcode.cn/problems/remove-element/description/</a></p><p><strong>题目描述</strong></p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,2,3]</span>, val = 3<br>输出：2, nums = <span class="hljs-comment">[2,2]</span><br>解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = <span class="hljs-comment">[2,2,3,3]</span> 或 nums = <span class="hljs-comment">[2,2,0,0]</span>，也会被视作正确答案。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">0,1,2,2</span>,<span class="hljs-number">3,0,4,2</span>], val = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">5</span>, nums = [<span class="hljs-number">0,1,3,0</span>,<span class="hljs-number">4</span>]<br>解释：函数应该返回新的长度 <span class="hljs-number">5</span>, 并且 nums 中的前五个元素为 <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。<br></code></pre></td></tr></table></figure><p><strong>思路</strong></p><p>双指针法（快慢指针法）：<strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p><p>定义快慢指针</p><ul><li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li><li>慢指针：指向更新 新数组下标的位置</li></ul><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240111141316267.png" alt="双指针题解" style="zoom:67%;" /></p><p>C++版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-type">int</span> slowindex=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fastindex = <span class="hljs-number">0</span>; fastindex&lt;nums.<span class="hljs-built_in">size</span>();fastindex++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(val!=nums[fastindex])&#123;<br>                nums[slowindex] = nums[fastindex];<br>                slowindex++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slowindex;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>python版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeElement</span>(<span class="hljs-params">self, nums, val</span>):<br>        slowindex=<span class="hljs-number">0</span><br>        fastindex=<span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> fastindex&lt;<span class="hljs-built_in">len</span>(nums):<br>            <span class="hljs-keyword">if</span> val!=nums[fastindex]:<br>                nums[slowindex]=nums[fastindex]<br>                slowindex = slowindex+<span class="hljs-number">1</span><br>            fastindex+=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> slowindex        <br></code></pre></td></tr></table></figure><p>GO版本：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, val <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    slow:=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;<br>        <span class="hljs-keyword">if</span> nums[i]!=val&#123;<br>            nums[slow]=nums[i]<br>            slow++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="有序数组的平方">有序数组的平方</h3><p><ahref="https://leetcode.cn/problems/squares-of-a-sorted-array/">https://leetcode.cn/problems/squares-of-a-sorted-array/</a></p><p><strong>题目描述</strong></p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [-<span class="hljs-number">4</span>,-<span class="hljs-number">1,0,3,10</span>]<br>输出：[<span class="hljs-number">0,1,9,16</span>,<span class="hljs-number">100</span>]<br>解释：平方后，数组变为 [<span class="hljs-number">16,1,0,9</span>,<span class="hljs-number">100</span>]<br>排序后，数组变为 [<span class="hljs-number">0,1,9,16</span>,<span class="hljs-number">100</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [-<span class="hljs-number">7</span>,-<span class="hljs-number">3,2,3,11</span>]<br>输出：[<span class="hljs-number">4,9,9,49</span>,<span class="hljs-number">121</span>]<br></code></pre></td></tr></table></figure><p><strong>思路</strong></p><p>双指针法，首尾遍历比较并存储</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240111144022821.png"alt="双指针遍历存储" /><figcaption aria-hidden="true">双指针遍历存储</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(nums.size(),<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> j = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> k =j;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ;i&lt;=j;)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i]*nums[i]&gt;nums[j]*nums[j])&#123;<br>                result[k--]= nums[i]*nums[i];<br>                i++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                result[k--]= nums[j]*nums[j];<br>                j--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Python:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sortedSquares</span>(<span class="hljs-params">self, nums</span>):<br>        l, r, i = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span><br>        res = [<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)] * <span class="hljs-built_in">len</span>(nums) <span class="hljs-comment"># 需要提前定义列表，存放结果</span><br>        <span class="hljs-keyword">while</span> l&lt;=r :<br>            <span class="hljs-keyword">if</span> nums[l]*nums[l] &lt; nums[r]*nums[r] :<br>                res[i--]=nums[r]*nums[r]<br>                r--<br>            <span class="hljs-keyword">else</span>:<br>                res[i--]=nums[l]*nums[l]<br>                l++<br>        <span class="hljs-keyword">return</span> <br></code></pre></td></tr></table></figure><p>GO:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortedSquares</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>n := <span class="hljs-built_in">len</span>(nums)<br>i, j, k := <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>, n<span class="hljs-number">-1</span><br>ans := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br><span class="hljs-keyword">for</span> i &lt;= j &#123;<br>lm, rm := nums[i]*nums[i], nums[j]*nums[j]<br><span class="hljs-keyword">if</span> lm &gt; rm &#123;<br>ans[k] = lm<br>i++<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>ans[k] = rm<br>j--<br>&#125;<br>k--<br>&#125;<br><span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="长度最小的子数组">长度最小的子数组</h3><p><ahref="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">https://leetcode.cn/problems/minimum-size-subarray-sum/description/</a></p><p><strong>题目描述</strong></p><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数<code>target</code> <strong>。</strong></p><p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的<strong>连续子数组</strong><code>[numsl, numsl+1, ..., numsr-1, numsr]</code>，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回<code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：target = 7, nums = <span class="hljs-comment">[2,3,1,2,4,3]</span><br>输出：2<br>解释：子数组 <span class="hljs-comment">[4,3]</span> 是该条件下的长度最小的子数组。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：<span class="hljs-keyword">target</span> = <span class="hljs-number">4</span>, nums = [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：target = <span class="hljs-number">11</span>, nums = [<span class="hljs-number">1,1,1,1</span>,<span class="hljs-number">1,1,1,1</span>]<br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>思路</strong></p><p>滑动窗口法</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240111153940915.png" alt="滑动窗口法" style="zoom:67%;" /></p><p>滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动本题中实现滑动窗口，主要确定如下三点：</p><ul><li>窗口内是什么？</li><li>如何移动窗口的起始位置？</li><li>如何移动窗口的结束位置？</li></ul><p>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> s, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = INT32_MAX;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口数值之和</span><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口起始位置</span><br>        <span class="hljs-type">int</span> subLength = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口的长度</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j++) &#123;<br>            sum += nums[j];<br>            <span class="hljs-comment">// 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件</span><br>            <span class="hljs-keyword">while</span> (sum &gt;= s) &#123;<br>                subLength = (j - i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 取子序列的长度</span><br>                result = result &lt; subLength ? result : subLength;<br>                sum -= nums[i++]; <span class="hljs-comment">// 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span><br>        <span class="hljs-keyword">return</span> result == INT32_MAX ? <span class="hljs-number">0</span> : result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="螺旋矩阵">螺旋矩阵</h3><p><ahref="https://leetcode.cn/problems/spiral-matrix-ii/">https://leetcode.cn/problems/spiral-matrix-ii/</a></p><p><strong>题目描述</strong></p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240111155904466.png" alt="螺旋矩阵" style="zoom:67%;" /></p><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到<code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的<code>n x n</code> 正方形矩阵 <code>matrix</code></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">[[1,2,3],[8,9,4],[7,6,5]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><p>思路：大模拟循环遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generateMatrix</span>(<span class="hljs-type">int</span> n) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">result</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>));<br>        <span class="hljs-type">int</span> is=<span class="hljs-number">0</span>,ie=n<span class="hljs-number">-1</span>,js=<span class="hljs-number">0</span>,je=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(is&lt;=ie&amp;&amp;js&lt;=je)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=js;j&lt;=je;j++)<br>            &#123;<br>                result[is][j] = k++;<br>            &#125;<br>            is++;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =is;i&lt;=ie;i++)<br>            &#123;<br>                result[i][je] = k++;<br>            &#125;<br>            je--;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=je;j&gt;=js;j--)<br>            &#123;<br>                result[ie][j] = k++;<br>            &#125;<br>            ie--;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=ie;i&gt;=is;i--)<br>            &#123;<br>                result[i][js] = k++;<br>            &#125;<br>            js++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="快速排序">快速排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">part</span><span class="hljs-params">(<span class="hljs-type">int</span>* r, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> hight)</span>  <span class="hljs-comment">//划分函数</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i = low, j = hight, pivot = r[low]; <span class="hljs-comment">//基准元素</span><br><span class="hljs-keyword">while</span> (i &lt; j)<br>&#123;<br><span class="hljs-keyword">while</span> (i&lt;j &amp;&amp; r[j]&gt;pivot) <span class="hljs-comment">//从右向左开始找一个 小于等于 pivot的数值</span><br>&#123;<br>j--;<br>&#125;<br><span class="hljs-keyword">if</span> (i &lt; j)<br>&#123;<br><span class="hljs-built_in">swap</span>(r[i++], r[j]);  <span class="hljs-comment">//r[i]和r[j]交换后 i 向右移动一位</span><br>&#125;<br><span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; r[i] &lt;= pivot) <span class="hljs-comment">//从左向右开始找一个 大于 pivot的数值</span><br>&#123;<br>i++;<br>&#125;<br><span class="hljs-keyword">if</span> (i &lt; j)<br>&#123;<br><span class="hljs-built_in">swap</span>(r[i], r[j--]);  <span class="hljs-comment">//r[i]和r[j]交换后 i 向左移动一位</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> i;  <span class="hljs-comment">//返回最终划分完成后基准元素所在的位置</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Quicksort</span><span class="hljs-params">(<span class="hljs-type">int</span>* r, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> hight)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> mid;<br><span class="hljs-keyword">if</span> (low &lt; hight)<br>&#123;<br>mid = <span class="hljs-built_in">part</span>(r, low, hight);  <span class="hljs-comment">// 返回基准元素位置</span><br><span class="hljs-built_in">Quicksort</span>(r, low, mid - <span class="hljs-number">1</span>); <span class="hljs-comment">// 左区间递归快速排序</span><br><span class="hljs-built_in">Quicksort</span>(r, mid+<span class="hljs-number">1</span>, hight); <span class="hljs-comment">// 右区间递归快速排序</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数组中的第k大元素">数组中的第K大元素</h3><p><ahref="https://leetcode.cn/problems/xx4gT2/description/">https://leetcode.cn/problems/xx4gT2/description/</a></p><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第<code>**k**</code> 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code>个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [3,2,1,5,6,4] 和 k = 2</span><br><span class="hljs-section">输出: 5</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: [<span class="hljs-number">3,2,3,1</span>,<span class="hljs-number">2,4,5,5</span>,<span class="hljs-number">6</span>] 和 k = <span class="hljs-number">4</span><br>输出: <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>重点快速排序</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span>&#123;<br>        <span class="hljs-type">int</span> key = nums[low];<br>        <span class="hljs-keyword">while</span>(low&lt; high)&#123;<br>            <span class="hljs-keyword">while</span>(low&lt;high &amp;&amp; nums[high]&gt;= key) high--;<br>            nums[low] = nums[high];<br>            <span class="hljs-keyword">while</span>(low&lt;high&amp;&amp; nums[low]&lt;=key) low++;<br>            nums[high] = nums[low];<br>        &#125;<br>        nums[low] = key;<br>        <span class="hljs-keyword">return</span> low;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(low&gt;=high) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> mid = <span class="hljs-built_in">partition</span>(nums, low, high);<br>        <span class="hljs-built_in">quicksort</span>(nums, low, mid<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">quicksort</span>(nums, mid+<span class="hljs-number">1</span>, high);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">quicksort</span>(nums, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> nums[n-k];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>堆排序算法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BuildHeap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-type">int</span> p = i, c=<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(c&lt;=n)&#123;<br>            <span class="hljs-keyword">if</span>(c&lt;n &amp;&amp; arr[c]&gt;arr[c+<span class="hljs-number">1</span>]) c++;<br>            <span class="hljs-keyword">if</span>(arr[p]&gt;arr[c])&#123;<br>                <span class="hljs-built_in">swap</span>(arr[p], arr[c]);<br>                p = c;<br>            &#125;<br>            c = <span class="hljs-number">2</span>*c+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Heapsort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span></span>&#123;<br>        <span class="hljs-comment">//建立一个堆</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=arr.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span><span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-built_in">BuildHeap</span>(arr, i,arr.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=arr.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; i&gt;<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-built_in">swap</span>(arr[<span class="hljs-number">0</span>], arr[i]);<br>            <span class="hljs-built_in">BuildHeap</span>(arr,<span class="hljs-number">0</span>,i<span class="hljs-number">-1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">Heapsort</span>(nums);<br>        <span class="hljs-keyword">return</span> nums[k<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="哈希表">哈希表</h1><p><strong>一般哈希表都是用来快速判断一个元素是否出现集合里</strong></p><p>只需要初始化把所有元素都存在哈希表里，在查询的时候通过索引直接就可以知道元素在不在这哈希表里了</p><p>建立索引：哈希函数</p><h3 id="有效的字母异位词">有效的字母异位词</h3><p><ahref="https://leetcode.cn/problems/valid-anagram/description/">https://leetcode.cn/problems/valid-anagram/description/</a></p><p><strong>题目描述</strong></p><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s的字母异位词。</p><p>示例 1: 输入: s = "anagram", t = "nagaram" 输出: true</p><p>示例 2: 输入: s = "rat", t = "car" 输出: false</p><p><strong>思路</strong></p><p>暴力的方法可能时间复杂度会很高</p><p>判断有没有异位词的本质就是查看当前的字母是不是有出现过，那么思路就是选择<strong>哈希表</strong></p><p>定义一个数组叫做record用来上记录字符串s里字符出现的次数。</p><p>需要把字符映射到数组也就是哈希表的索引下标上，<strong>因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。</strong></p><p>再遍历 字符串s的时候，<strong>只需要将 s[i] - ‘a’ 所在的元素做+1操作即可，并不需要记住字符a的ASCII，只要求出一个相对数值就可以了。</strong>这样就将字符串s中字符出现的次数，统计出来了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> record[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">// 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了</span><br>            record[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; t.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            record[t[i] - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (record[i] != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// record数组所有元素都为零0，说明字符串s和t是字母异位词</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="两个数组的交集">两个数组的交集</h3><p><ahref="https://leetcode.cn/problems/intersection-of-two-arrays/description/">https://leetcode.cn/problems/intersection-of-two-arrays/description/</a></p><p>题目描述</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1,2,2,1]</span>, nums2 = <span class="hljs-comment">[2,2]</span><br>输出：<span class="hljs-comment">[2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[4,9,5]</span>, nums2 = <span class="hljs-comment">[9,4,9,8,4]</span><br>输出：<span class="hljs-comment">[9,4]</span><br>解释：<span class="hljs-comment">[4,9]</span> 也是可通过的<br></code></pre></td></tr></table></figure><p>思路</p><p>使用哈希表存储，但是用<code>set(unordered_set)</code></p><p>std::set和std::multiset底层实现都是红黑树，std::unordered_set的底层实现是哈希表，使用unordered_set读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; result_set; <span class="hljs-comment">// 存放结果，之所以用set是为了给结果集去重</span><br>        <span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums_set</span><span class="hljs-params">(nums1.begin(), nums1.end())</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums2) &#123;<br>            <span class="hljs-comment">// 发现nums2的元素 在nums_set里又出现过</span><br>            <span class="hljs-keyword">if</span> (nums_set.<span class="hljs-built_in">find</span>(num) != nums_set.<span class="hljs-built_in">end</span>()) &#123;<br>                result_set.<span class="hljs-built_in">insert</span>(num);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(result_set.<span class="hljs-built_in">begin</span>(), result_set.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="快乐数">快乐数</h3><p><ahref="https://leetcode.cn/problems/happy-number/description/">https://leetcode.cn/problems/happy-number/description/</a></p><p>题目描述</p><p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p><p><strong>「快乐数」</strong> 定义为：</p><ul><li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li><li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong>但始终变不到 1。</li><li>如果这个过程 <strong>结果为</strong> 1，那么这个数就是快乐数。</li></ul><p>如果 <code>n</code> 是 <em>快乐数</em> 就返回 <code>true</code>；不是，则返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">输入：n = 19<br>输出：<span class="hljs-literal">true</span><br>解释：<br>1*<span class="hljs-number">*2</span> + 9*<span class="hljs-number">*2</span> = 82<br>8*<span class="hljs-number">*2</span> + 2*<span class="hljs-number">*2</span> = 68<br>6*<span class="hljs-number">*2</span> + 8*<span class="hljs-number">*2</span> = 100<br>1*<span class="hljs-number">*2</span> + 0*<span class="hljs-number">*2</span> + 0*<span class="hljs-number">*2</span> = 1<br></code></pre></td></tr></table></figure><p>思路：</p><p>注意，题目中提到一个点是<strong>无限循环</strong>，说明计算的结果<strong>sum是有限</strong>的只需要在哈希表中将这部分的结果存储进去，并每次比较是不是<strong>出现1</strong>如果是那么就是快乐数，否则就不是快乐数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n)&#123;<br>            sum+=(n%<span class="hljs-number">10</span>)*(n%<span class="hljs-number">10</span>);<br>            n/=<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">//首先建立哈希表来存储是不是出现了无限循环的结果</span><br>        unordered_set&lt;<span class="hljs-type">int</span>&gt;sum_set;<br>        <span class="hljs-comment">//无限循环 直到出现1或者无限循环且不是快乐数</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            n=<span class="hljs-built_in">getSum</span>(n);<br>            <span class="hljs-keyword">if</span>(sum_set.<span class="hljs-built_in">find</span>(n)!=sum_set.<span class="hljs-built_in">end</span>())&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                sum_set.<span class="hljs-built_in">insert</span>(n);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="两数之和">两数之和</h3><p>题目描述</p><p><ahref="https://leetcode.cn/problems/two-sum/submissions/495021134/">https://leetcode.cn/problems/two-sum/submissions/495021134/</a></p><p>给定一个整数数组 <code>nums</code> 和一个整数目标值<code>target</code>，请你在该数组中找出 <strong>和为目标值</strong><em><code>target</code></em> 的那 <strong>两个</strong>整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，<strong>数组中同一个元素在答案里不能重复出现</strong>。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br>解释：因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> == 9 ，返回 <span class="hljs-comment">[0, 1]</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,4]</span>, target = 6<br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,3]</span>, target = 6<br>输出：<span class="hljs-comment">[0,1]</span><br></code></pre></td></tr></table></figure><p>思路：</p><p>构建一个哈希表，然后遍历一遍就行了在哈希表中找n-a的值是否存在，但是最大的问题是<strong>数组中同一个元素在答案里不能重复出现</strong>，所以不能简单考虑unordered_set</p><p>这里提供一种新的思路，就是用unordered_map来存储数组中的数据内容和下标的数值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        std::unordered_map &lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">// 遍历当前元素，并在map中寻找是否有匹配的key</span><br>            <span class="hljs-keyword">auto</span> iter = map.<span class="hljs-built_in">find</span>(target - nums[i]); <br>            <span class="hljs-keyword">if</span>(iter != map.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-keyword">return</span> &#123;iter-&gt;second, i&#125;;<br>            &#125;<br>            <span class="hljs-comment">// 如果没找到匹配对，就把访问过的元素和下标加入到map中</span><br>            map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(nums[i], i)); <br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="四数相加">四数相加</h3><p><ahref="https://leetcode.cn/problems/4sum-ii/description/">https://leetcode.cn/problems/4sum-ii/description/</a></p><p>给你四个整数数组<code>nums1</code>、<code>nums2</code>、<code>nums3</code> 和<code>nums4</code> ，数组长度都是 <code>n</code> ，请你计算有多少个元组<code>(i, j, k, l)</code> 能满足：</p><ul><li><code>0 &lt;= i, j, k, l &lt; n</code></li><li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li></ul><p><strong>示例 1：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>], <span class="hljs-symbol">nums3</span> = [<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>], <span class="hljs-symbol">nums4</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">2</span><br>解释：<br>两个元组如下：<br><span class="hljs-number">1.</span> <span class="hljs-comment">(0, 0, 0, 1)</span> -&gt; <span class="hljs-symbol">nums1</span>[<span class="hljs-number">0</span>] + <span class="hljs-symbol">nums2</span>[<span class="hljs-number">0</span>] + <span class="hljs-symbol">nums3</span>[<span class="hljs-number">0</span>] + <span class="hljs-symbol">nums4</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span> + <span class="hljs-comment">(-2)</span> + <span class="hljs-comment">(-1)</span> + <span class="hljs-number">2</span> = <span class="hljs-number">0</span><br><span class="hljs-number">2.</span> <span class="hljs-comment">(1, 1, 0, 0)</span> -&gt; <span class="hljs-symbol">nums1</span>[<span class="hljs-number">1</span>] + <span class="hljs-symbol">nums2</span>[<span class="hljs-number">1</span>] + <span class="hljs-symbol">nums3</span>[<span class="hljs-number">0</span>] + <span class="hljs-symbol">nums4</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span> + <span class="hljs-comment">(-1)</span> + <span class="hljs-comment">(-1)</span> + <span class="hljs-number">0</span> = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">0</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">0</span>], <span class="hljs-symbol">nums3</span> = [<span class="hljs-number">0</span>], <span class="hljs-symbol">nums4</span> = [<span class="hljs-number">0</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>思路</p><ol type="1"><li>首先定义 一个unordered_map，key放a和b两数之和，value放a和b两数之和<strong>出现的次数</strong>。</li><li>遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。</li><li>定义int变量count，用来统计 a+b+c+d = 0 出现的次数。</li><li>在遍历大C和大D数组，找到如果 0-(c+d)在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。</li><li>最后返回统计值 count 就可以了</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums3, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums4)</span> </span>&#123;<br>        std::unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;nm;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums1.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;nums2.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-type">int</span> s = nums1[i]+nums2[j];<br>                nm[s]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums3.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;nums4.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(nm.<span class="hljs-built_in">find</span>(<span class="hljs-number">0</span>-nums3[i]-nums4[j])!=nm.<span class="hljs-built_in">end</span>())&#123;<br>                    res+=nm[<span class="hljs-number">0</span>-(nums3[i]+nums4[j])];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="赎金信">赎金信</h3><p><ahref="https://leetcode.cn/problems/ransom-note/description/">https://leetcode.cn/problems/ransom-note/description/</a></p><p>给你两个字符串：<code>ransomNote</code> 和 <code>magazine</code>，判断 <code>ransomNote</code> 能不能由 <code>magazine</code>里面的字符构成。</p><p>如果可以，返回 <code>true</code> ；否则返回 <code>false</code> 。</p><p><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code>中使用一次。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">ransomNote</span> = <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-attr">magazine</span> = <span class="hljs-string">&quot;b&quot;</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">ransomNote</span> = <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-attr">magazine</span> = <span class="hljs-string">&quot;ab&quot;</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>思路：</p><p>用哈希表unordered_map来存储次数，对于ransomNote来减去次数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canConstruct</span><span class="hljs-params">(string ransomNote, string magazine)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;umap;<br>        <span class="hljs-keyword">if</span>(ransomNote.<span class="hljs-built_in">size</span>()&gt;magazine.<span class="hljs-built_in">size</span>())&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;magazine.<span class="hljs-built_in">size</span>();i++)&#123;<br>            umap[magazine[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;ransomNote.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(umap.<span class="hljs-built_in">find</span>(ransomNote[i]-<span class="hljs-string">&#x27;a&#x27;</span>)!=umap.<span class="hljs-built_in">end</span>())&#123;<br>                umap[ransomNote[i]-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br>                <span class="hljs-keyword">if</span>(umap[ransomNote[i]-<span class="hljs-string">&#x27;a&#x27;</span>]&lt;<span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="三数之和">三数之和</h3><p><ahref="https://leetcode.cn/problems/3sum/description/">https://leetcode.cn/problems/3sum/description/</a></p><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组<code>[nums[i], nums[j], nums[k]]</code> 满足<code>i != j</code>、<code>i != k</code> 且 <code>j != k</code>，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p><p>你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[-1,0,1,2,-1,-4]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[-1,-1,2]</span>,<span class="hljs-comment">[-1,0,1]</span>]</span><br>解释：<br>nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> + nums<span class="hljs-comment">[2]</span> = (-1) + 0 + 1 = 0 。<br>nums<span class="hljs-comment">[1]</span> + nums<span class="hljs-comment">[2]</span> + nums<span class="hljs-comment">[4]</span> = 0 + 1 + (-1) = 0 。<br>nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[3]</span> + nums<span class="hljs-comment">[4]</span> = (-1) + 2 + (-1) = 0 。<br>不同的三元组是 <span class="hljs-comment">[-1,0,1]</span> 和 <span class="hljs-comment">[-1,-1,2]</span> 。<br></code></pre></td></tr></table></figure><p>思路</p><p><strong>其实这道题目使用哈希法并不十分合适</strong>，因为在去重的操作中有很多细节需要注意，在面试中很难直接写出没有bug的代码，而且使用哈希法在使用两层for循环的时候，能做的剪枝操作很有限，虽然时间复杂度是O(n^2)</p><p>这道题可以用双指针法求解</p><p>拿这个nums数组来举例，首先将数组排序，然后有一层for循环，<strong>i从下标0的地方开始，同时定一个下标left定义在i+1的位置上，定义下标right 在数组结尾的位置上</strong>。</p><p>依然还是在数组中找到 abc 使得a + b +c =0，我们这里相当于 a =nums[i]，b = nums[left]，c = nums[right]。</p><p>接下来如何移动left 和right呢， 如果nums[i] + nums[left] + nums[right]&gt; 0 就说明<strong>此时三数之和大了</strong>，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。</p><p>如果 nums[i] + nums[left] + nums[right] &lt; 0 说明 此时三数之和小了，<strong>left就向右移动，才能让三数之和大一些，直到left与right相遇为止</strong>。</p><p>还有一个难度就是不能有重复的结果，需要做一次去重的操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-comment">// 找出a + b + c = 0</span><br>        <span class="hljs-comment">// a = nums[i], b = nums[left], c = nums[right]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">// 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span><br>            <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br>          <span class="hljs-comment">// 正确去重a方法</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> left = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (right &gt; left) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="hljs-number">0</span>) right--;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="hljs-number">0</span>) left++;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    result.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);<br>                    <span class="hljs-comment">// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span><br>                    <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) right--;<br>                    <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) left++;<br>                  <span class="hljs-comment">// 找到答案时，双指针同时收缩</span><br>                    right--;<br>                    left++;<br>                &#125;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="双指针">双指针</h1><h3 id="移除元素-1">移除元素</h3><p><ahref="https://leetcode.cn/problems/remove-element/description/">https://leetcode.cn/problems/remove-element/description/</a></p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,2,3]</span>, val = 3<br>输出：2, nums = <span class="hljs-comment">[2,2]</span><br>解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = <span class="hljs-comment">[2,2,3,3]</span> 或 nums = <span class="hljs-comment">[2,2,0,0]</span>，也会被视作正确答案。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">0,1,2,2</span>,<span class="hljs-number">3,0,4,2</span>], val = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">5</span>, nums = [<span class="hljs-number">0,1,3,0</span>,<span class="hljs-number">4</span>]<br>解释：函数应该返回新的长度 <span class="hljs-number">5</span>, 并且 nums 中的前五个元素为 <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。<br></code></pre></td></tr></table></figure><p>思路：</p><p>使用快慢指针来实现两个指针之间的移动，对于找到了和val数值一样的就进行替换</p><h3 id="反转字符串">反转字符串</h3><p><ahref="https://leetcode.cn/problems/reverse-string/description/">https://leetcode.cn/problems/reverse-string/description/</a></p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = [<span class="hljs-string">&quot;h&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;o&quot;</span>]<br>输出：[<span class="hljs-string">&quot;o&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;h&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = [<span class="hljs-string">&quot;H&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;h&quot;</span>]<br>输出：[<span class="hljs-string">&quot;h&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;H&quot;</span>]<br></code></pre></td></tr></table></figure><p>思路：</p><p>采用两个指针之间互相交换，首尾交换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; s)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, b = s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;a&lt;b;)&#123;<br>            <span class="hljs-type">char</span> tmp;<br>            tmp=s[a];<br>            s[a]=s[b];<br>            s[b]=tmp;<br>            a++;<br>            b--;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="反转字符串中的单词">反转字符串中的单词</h3><p><ahref="https://leetcode.cn/problems/reverse-words-in-a-string/description/">https://leetcode.cn/problems/reverse-words-in-a-string/description/</a></p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;the sky is blue&quot;</span><br>输出：<span class="hljs-string">&quot;blue is sky the&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;  hello world  &quot;</span><br>输出：<span class="hljs-string">&quot;world hello&quot;</span><br>解释：反转后的字符串中不能存在前导空格和尾随空格。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a good   example&quot;</span><br>输出：<span class="hljs-string">&quot;example good a&quot;</span><br>解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。<br></code></pre></td></tr></table></figure><p>思路：</p><p>首先对字符串中额外的空格进行删除</p><p>字符串进行全局的逆序</p><p>再根据空格作为一个单独字母的节点进行分格分别进行逆序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(s[i]==s[i<span class="hljs-number">-1</span>]&amp;&amp;s[i]==<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>()+i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">0</span>&amp;&amp;s[s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>            s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>()+s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">0</span>&amp;&amp;s[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>            s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>());<br>        &#125;<br><br>        <span class="hljs-comment">//完成全局的交换</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j=s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&lt;j;i++,j--)&#123;<br>            <span class="hljs-type">char</span> tmp;<br>            tmp = s[i];<br>            s[i] = s[j];<br>            s[j] = tmp;<br>        &#125;<br>        cout&lt;&lt;s;<br>        <span class="hljs-comment">//进行局部的交换</span><br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(j&lt;=s.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">if</span>(s[j]==<span class="hljs-string">&#x27; &#x27;</span>||j==s.<span class="hljs-built_in">size</span>())&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k =i, q =j<span class="hljs-number">-1</span>;k&lt;q;k++,q--)&#123;<br>                    <span class="hljs-type">char</span> tmp;<br>                    tmp = s[k];<br>                    s[k] = s[q];<br>                    s[q] = tmp;<br>                &#125;<br>                i=j+<span class="hljs-number">1</span>;<br>                j=i+<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                j++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="反转链表">反转链表</h3><p><ahref="https://leetcode.cn/problems/reverse-linked-list/description/">https://leetcode.cn/problems/reverse-linked-list/description/</a></p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240118151406885.png" alt="image-20240118151406885" style="zoom:67%;" /></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span><br>输出：<span class="hljs-string">[5,4,3,2,1]</span><br></code></pre></td></tr></table></figure><p>思路：本质上就是利用了两个链表指针实现对元素的转向</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* temp;<br>        ListNode* cur = head;<br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            temp = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="删除链表的倒数第n个结点">删除链表的倒数第N个结点</h3><p><ahref="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/</a></p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240118152000575.png" alt="image-20240118152000575" style="zoom:67%;" /></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5</span>], n = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">1,2,3,5</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1]</span>, n = 1<br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p>思路：</p><p>遍历，用两个指针分别来记录</p><p>如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummyHead-&gt;next = head;<br>        ListNode* slow = dummyHead;<br>        ListNode* fast = dummyHead;<br>        <span class="hljs-keyword">while</span>(n-- &amp;&amp; fast != <span class="hljs-literal">NULL</span>) &#123;<br>            fast = fast-&gt;next;<br>        &#125;<br>        fast = fast-&gt;next; <span class="hljs-comment">// fast再提前走一步，因为需要让slow指向删除节点的上一个节点</span><br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">NULL</span>) &#123;<br>            fast = fast-&gt;next;<br>            slow = slow-&gt;next;<br>        &#125;<br>        slow-&gt;next = slow-&gt;next-&gt;next; <br>        <br>        <span class="hljs-comment">// ListNode *tmp = slow-&gt;next;  C++释放内存的逻辑</span><br>        <span class="hljs-comment">// slow-&gt;next = tmp-&gt;next;</span><br>        <span class="hljs-comment">// delete nth;</span><br>        <br>        <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="链表相交">链表相交</h3><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code>，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回<code>null</code> 。</p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须<strong>保持其原始结构</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240119195217619.png" alt="链表相交图" style="zoom:80%;" /></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：intersectVal = <span class="hljs-number">8</span>, listA = [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>], listB = [<span class="hljs-number">5,0,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">2</span>, skipB = <span class="hljs-number">3</span><br>输出：Intersected at &#x27;<span class="hljs-number">8</span>&#x27;<br>解释：相交节点的值为 <span class="hljs-number">8</span> （注意，如果两个链表相交则不能为 <span class="hljs-number">0</span>）。<br>从各自的表头开始算起，链表 <span class="hljs-keyword">A</span> 为 [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>]，链表 B 为 [<span class="hljs-number">5,0,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]。<br>在 <span class="hljs-keyword">A</span> 中，相交节点前有 <span class="hljs-number">2</span> 个节点；在 B 中，相交节点前有 <span class="hljs-number">3</span> 个节点。<br></code></pre></td></tr></table></figure><p>思路：</p><p>简单来说，就是求两个链表交点节点的<strong>指针</strong>，注意返回的是结点的指针，不是对应的数值，同时注意这里比较的是<strong>相同的指针不是数值相同</strong>，因此直接比较指针是不是相同就可以了</p><p>由于题目说的相交的结构如图所示，如果存在相交的指针位置，只可能出现在后面只需要考虑利用双指针从相差的数值位开始遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode* curA = headA;<br>        ListNode* curB = headB;<br>        <span class="hljs-type">int</span> lenA = <span class="hljs-number">0</span>, lenB = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(curA != <span class="hljs-literal">NULL</span>)&#123;<br>            lenA++;<br>            curA = curA -&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(curB != <span class="hljs-literal">NULL</span>)&#123;<br>            lenB++;<br>            curB = curB -&gt;next;<br>        &#125;<br>        curA = headA;<br>        curB = headB;<br>        <span class="hljs-keyword">if</span>(lenB&gt; lenA)&#123;<br>            <span class="hljs-built_in">swap</span>(lenA,lenB);<br>            <span class="hljs-built_in">swap</span>(curA, curB);<br>        &#125;<br><br>        <span class="hljs-type">int</span> gap = lenA - lenB;<br>        <span class="hljs-keyword">while</span>(gap--)&#123;<br>            curA =  curA-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(curA!=<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">if</span>(curA == curB)&#123;<br>                <span class="hljs-keyword">return</span> curA;<br>            &#125;<br>            curA = curA-&gt;next;<br>            curB = curB-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="环形链表">环形链表</h3><p><ahref="https://leetcode.cn/problems/linked-list-cycle-ii/description/">https://leetcode.cn/problems/linked-list-cycle-ii/description/</a></p><p>判断是否是有还存在，如果有那么返回开始入环的第一个节点的下标</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240119200331204.png" alt="环形链表" style="zoom:50%;" /></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [3,2,0,-4], pos = 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。<br></code></pre></td></tr></table></figure><p>思路：</p><p>这道题用快慢指针的思路，就是慢指针每次只走一步，快指针每次走两步，如果在到达null之前出现快慢指针指向了同一个地方，说明这个<strong>链表有环存在</strong>，那么怎么判断下标的位置呢？</p><p>具体的证明过程：</p><figure><imgsrc="../../../../../Library/Application%20Support/typora-user-images/image-20240119200838486.png"alt="环形链表" /><figcaption aria-hidden="true">环形链表</figcaption></figure><p>相遇时slow指针走过的节点数为: <code>x + y</code>，fast指针走过的节点数：<code>x + y + n (y + z)</code>，n为fast指针在环内走了n圈才遇到slow指针，（y+z）为 一圈内节点的个数A。</p><p>因为fast指针是一步走两个节点，slow指针一步走一个节点， 所以fast指针走过的节点数 = slow指针走过的节点数 * 2：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">(<span class="hljs-name">x</span> + y) * <span class="hljs-number">2</span> = x + y + n (<span class="hljs-name">y</span> + z)<br></code></pre></td></tr></table></figure><p>两边消掉一个（x+y）: <code>x + y = n (y + z)</code></p><p>因为要找环形的入口，那么要求的是x，因为x表示 头结点到环形入口节点的的距离。</p><p>所以要求x ，将x单独放在左面：<code>x = n (y + z) - y</code> ,</p><p>再从n(y+z)中提出一个（y+z）来，整理公式之后为如下公式：<code>x = (n - 1) (y + z) + z</code>注意这里n一定是大于等于1的，因为fast指针至少要多走一圈才能相遇slow指针</p><p>所以可以得到的规律是：<strong>从头结点出发一个指针，从相遇节点也出发一个指针，这两个指针每次只走一个节点，那么当这两个指针相遇的时候就是 环形入口的节点</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode* fast = head;<br>        ListNode* slow = head;<br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">NULL</span>&amp;&amp; fast-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>            <span class="hljs-comment">//说明找到了</span><br>            <span class="hljs-keyword">if</span>(slow==fast)&#123;<br>                ListNode* index1 = fast;<br>                ListNode* index2 = head;<br>                <span class="hljs-keyword">while</span>(index1!=index2)&#123;<br>                    index1 = index1-&gt;next;<br>                    index2 = index2 -&gt;next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> index2;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="接雨水">接雨水</h3><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code>的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>示例 1：</strong></p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/rainwatertrap.png"alt="接雨水" /><figcaption aria-hidden="true">接雨水</figcaption></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：height = [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>]<br>输出：<span class="hljs-number">6</span><br>解释：上面是由数组 [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>] 表示的高度图，在这种情况下，可以接 <span class="hljs-number">6</span> 个单位的雨水（蓝色部分表示雨水）。 <br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：height = <span class="hljs-string">[4,2,0,3,2,5]</span><br>输出：<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p>思路：</p><p>找到最大的左边和最大的右边并相减</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(height.<span class="hljs-built_in">size</span>()&lt;=<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxLeft</span><span class="hljs-params">(height.size(), <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxRight</span><span class="hljs-params">(height.size(), <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> size = maxRight.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">//记录每个柱子左边柱子的最大高度</span><br>        maxLeft[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;size;i++)&#123;<br>            maxLeft[i] = <span class="hljs-built_in">max</span>(height[i],maxLeft[i<span class="hljs-number">-1</span>]);<br>        &#125;<br>        <span class="hljs-comment">//记录每个柱子右边柱子的最大高度</span><br>        maxRight[size<span class="hljs-number">-1</span>] = height[size<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=size<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            maxRight[i] = <span class="hljs-built_in">max</span>(height[i],maxRight[i+<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>            <span class="hljs-type">int</span> count = <span class="hljs-built_in">min</span>(maxLeft[i], maxRight[i])-height[i];<br>            <span class="hljs-keyword">if</span>(count &gt; <span class="hljs-number">0</span>) sum+=count;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="柱形图中的最大矩形">柱形图中的最大矩形</h3><p><ahref="https://leetcode.cn/problems/largest-rectangle-in-histogram/description/">https://leetcode.cn/problems/largest-rectangle-in-histogram/description/</a></p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240129144103735.png" alt="最大矩形问题" style="zoom:67%;" /></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：heights = <span class="hljs-string">[2,1,5,6,2,3]</span><br>输出：<span class="hljs-number">10</span><br>解释：最大的矩形为图中红色区域，面积为 <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minLeft</span><span class="hljs-params">(heights.size())</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minRight</span><span class="hljs-params">(heights.size())</span></span>;<br>        <span class="hljs-type">int</span> size = heights.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-comment">//记录每个柱子左边第一个小于该柱子的下标</span><br>        minLeft[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;size;i++)&#123;<br>            <span class="hljs-type">int</span> t= i<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span>(t&gt;=<span class="hljs-number">0</span>&amp;&amp;heights[t]&gt;=heights[i]) t=minLeft[t];<br>            minLeft[i]=t;<br>        &#125;<br>        <span class="hljs-comment">//记录每个柱右边第一个小于该柱子的下标</span><br>        minRight[size<span class="hljs-number">-1</span>]=size;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=size <span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-type">int</span> t=i+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(t&lt;size&amp;&amp;heights[t]&gt;=heights[i]) t=minRight[t];<br>            minRight[i]=t;<br>        &#125;<br><br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>            <span class="hljs-type">int</span> sum=heights[i]*(minRight[i]-minLeft[i]<span class="hljs-number">-1</span>);<br>            res = <span class="hljs-built_in">max</span>(sum,res);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二叉树">二叉树</h1><h3 id="构建二叉搜索树并中序遍历">构建二叉搜索树并中序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span>&#123;<br>  <span class="hljs-type">int</span> val;<br>  TreeNode* left;<br>  TreeNode* right;<br>  <span class="hljs-built_in">TreeNode</span>(): <span class="hljs-built_in">val</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>  <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> val): <span class="hljs-built_in">val</span>(val), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>)()<br>&#125;;<br><br><span class="hljs-function">TreeNode* <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; nums)</span></span>&#123;<br>  TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[<span class="hljs-number">0</span>]);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>    TreeNode* n = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[i]);<br>    TreeNode* cur = root;<br>    <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)&#123;<br>      <span class="hljs-keyword">if</span>(nums[i]&lt;cur-&gt;val)&#123;<br>        <span class="hljs-keyword">if</span>(cur-&gt;left==<span class="hljs-literal">nullptr</span>)&#123;cur-&gt;left = n; <span class="hljs-keyword">break</span>;&#125;<br>        <span class="hljs-keyword">else</span>(cur = cur-&gt;left;)<br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(cur-&gt;right==<span class="hljs-literal">nullptr</span>)&#123;cur-&gt;right = n; <span class="hljs-keyword">break</span>;&#125;<br>        <span class="hljs-keyword">else</span>(cur = cur-&gt;right;)<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-built_in">inorder</span>(root-&gt;left);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,root-&gt;val);<br>  <span class="hljs-built_in">inorder</span>(root-&gt;right);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  vector&lt;<span class="hljs-type">int</span>&gt; nums=(&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;);<br>  TreeNode* st = <span class="hljs-built_in">search</span>(nums);<br>  <span class="hljs-built_in">inorder</span>(root);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="验证二叉搜索树">验证二叉搜索树</h3><p>思路：对这个树进行中序遍历放进一个数组中如果是从大到小的顺序，那么就认为是二叉搜索树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; nums;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">inorder</span>(root-&gt;left);<br>        nums.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">inorder</span>(root-&gt;right);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">inorder</span>(root);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &lt;= nums[i - <span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="二叉搜索树中第k小的元素">二叉搜索树中第K小的元素</h3><p>思路：一样的思路，将二叉搜索树进行存储进一个一维的数组中，然后输出第k-1个元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; nums;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">inorder</span>(root-&gt;left);<br>        nums.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">inorder</span>(root-&gt;right);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">inorder</span>(root);<br>        <span class="hljs-keyword">return</span> nums[k<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="从前序和中序遍历构造二叉树">从前序和中序遍历构造二叉树</h3><p>本质上就是利用中序找到每个子串的内容</p><p>利用前序放入对应的元素，每次都从中取出一个第一个放进结果序列中</p><p>对于 <strong>后序列+中序</strong>的思路也是一样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">//内部实现</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, <span class="hljs-type">int</span> ps, <span class="hljs-type">int</span> pe, <span class="hljs-type">int</span> is, <span class="hljs-type">int</span> ie)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(ps &gt;= pe || is &gt;= ie)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>      <span class="hljs-comment">//找到第一个元素就是前序遍历的第一个元素</span><br>        TreeNode* r = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[ps]);<br>       <span class="hljs-comment">//find inorder partition</span><br>      <span class="hljs-comment">//找到中序遍历中的处于位置中间的那个元素</span><br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">for</span>(i = is; i &lt; ie; i++)&#123;<br>            <span class="hljs-keyword">if</span>(inorder[i] == preorder[ps])&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        r-&gt;left = <span class="hljs-built_in">build</span>(preorder, inorder, ps + <span class="hljs-number">1</span>, ps + <span class="hljs-number">1</span> + (i - is), is, i);<br>        r-&gt;right = <span class="hljs-built_in">build</span>(preorder, inorder, ps + <span class="hljs-number">1</span> + i - is, pe, i + <span class="hljs-number">1</span>, ie);<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>  <span class="hljs-comment">//最外层的调用</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(preorder, inorder, <span class="hljs-number">0</span>, preorder.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>, inorder.<span class="hljs-built_in">size</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="深搜回溯">深搜回溯</h1><p><strong>深度优先搜索的三部曲：</strong></p><ol type="1"><li>确定搜索函数的返回值以及搜索函数的参数分别是什么</li><li>确定每次找到叶子结点的终止条件</li><li>确定for单层搜索的逻辑，包含push,backtracking,pop</li></ol><p>别忘了最开始的初始化步骤</p><h3 id="组合问题">组合问题</h3><p><ahref="https://leetcode.cn/problems/combinations/description/">https://leetcode.cn/problems/combinations/description/</a></p><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围<code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：n = 4, k = 2<br>输出：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,4]</span>,</span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">1</span>, k = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><p>思路，使用深度优先搜索算法进行处理</p><ul><li>首先要区分private和public这两个部分分别做的内容，private主要就是写出回溯的函数主体并且可能需要的数据结构</li><li>public中就对函数进行跳用以及数据结构的使用</li><li>第一步就是确定函数的类型和返回，这里用了一个 <code>startindex</code>用来存储下一次进行选择的位置点这样能够避免重复</li><li>同时函数的返回类型是二位的向量结构</li><li>同时定义终止条件和单层循环的内容</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt;path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> startindex)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>()==k)&#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startindex;i&lt;=n;i++)&#123;<br>            path.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">backtracking</span>(n,k,i+<span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)&#123;<br>        <span class="hljs-built_in">backtracking</span>(n,k,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="组合问题iii">组合问题III</h3><p><ahref="https://leetcode.cn/problems/combination-sum-iii/submissions/496823507/">https://leetcode.cn/problems/combination-sum-iii/submissions/496823507/</a></p><p>找出所有相加之和为 <code>n</code> 的 <code>k</code>个数的组合，且满足下列条件：</p><ul><li>只使用数字1到9</li><li>每个数字 <strong>最多使用一次</strong></li></ul><p>返回 <em>所有可能的有效组合的列表</em>。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><p><strong>示例:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: k = <span class="hljs-number">3</span>, n = <span class="hljs-number">7</span><br>输出: <span class="hljs-string">[[1,2,4]]</span><br>解释:<br><span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">4</span> = <span class="hljs-number">7</span><br>没有其他符合的组合了。<br></code></pre></td></tr></table></figure><p>思路：简单的深度优先搜索，但需要注意的是可以适当采用<strong>减枝操作和必要的时候添加sum变量进行记录</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtacking</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n,<span class="hljs-type">int</span> startindex, <span class="hljs-type">int</span> sum)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>()==k)&#123;<br>            <span class="hljs-keyword">if</span>(sum == n) result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i= startindex;i&lt;=<span class="hljs-number">9</span>;i++)&#123;<br>            sum+=i;<br>            path.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">backtacking</span>(k,n,i+<span class="hljs-number">1</span>,sum);<br>            sum-=i;<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum3</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-built_in">backtacking</span>(k,n,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>为了优化可以做一个剪枝操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (sum &gt; targetSum) &#123; <span class="hljs-comment">// 剪枝操作</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="电话号码组合问题">电话号码组合问题</h3><p>给定一个仅包含数字 <code>2-9</code>的字符串，返回所有它能表示的字母组合。答案可以按<strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1不对应任何字母。</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240119211247536.png" alt="电话号码的按键" style="zoom:50%;" /></p><p><strong>示例 ：</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入：<span class="hljs-keyword">digits</span> = <span class="hljs-string">&quot;23&quot;</span><br>输出：[<span class="hljs-string">&quot;ad&quot;</span>,<span class="hljs-string">&quot;ae&quot;</span>,<span class="hljs-string">&quot;af&quot;</span>,<span class="hljs-string">&quot;bd&quot;</span>,<span class="hljs-string">&quot;be&quot;</span>,<span class="hljs-string">&quot;bf&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>,<span class="hljs-string">&quot;ce&quot;</span>,<span class="hljs-string">&quot;cf&quot;</span>]<br></code></pre></td></tr></table></figure><p>这道题需要注意的地方是，首先第一步做好map字符的映射</p><p>第二步最关键是要写清楚回溯函数的参数可能包含index，就是第几位置的字符，同时需要区分backtracking函数的for循环的内容是相当于横向的遍历，而函数体内部的实现是纵向的遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">const</span> string letterMap[<span class="hljs-number">10</span>] = &#123;<br>        <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// 0</span><br>        <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// 1</span><br>        <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-comment">// 2</span><br>        <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-comment">// 3</span><br>        <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-comment">// 4</span><br>        <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-comment">// 5</span><br>        <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-comment">// 6</span><br>        <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-comment">// 7</span><br>        <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-comment">// 8</span><br>        <span class="hljs-string">&quot;wxyz&quot;</span>, <span class="hljs-comment">// 9</span><br>    &#125;;<br>    vector&lt;string&gt; result;<br>    string s;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">const</span> string digits,<span class="hljs-type">int</span> index, string s)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(digits.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(index==digits.<span class="hljs-built_in">size</span>())&#123;<br>            result.<span class="hljs-built_in">push_back</span>(s);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> digit = digits[index]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>        string letters = letterMap[digit];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i= <span class="hljs-number">0</span>;i&lt;letters.<span class="hljs-built_in">size</span>();i++)&#123;<br>            s.<span class="hljs-built_in">push_back</span>(letters[i]);<br>            <span class="hljs-built_in">backtracking</span>(digits, index+<span class="hljs-number">1</span>, s);<br>            s.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>&#123;<br>        <span class="hljs-built_in">backtracking</span>(digits,<span class="hljs-number">0</span>,<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="组合总和">组合总和</h3><p><ahref="https://leetcode.cn/problems/combination-sum/">https://leetcode.cn/problems/combination-sum/</a></p><p>给你一个 <strong>无重复元素</strong> 的整数数组<code>candidates</code> 和一个目标整数 <code>target</code> ，找出<code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按<strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以<strong>无限制重复被选取</strong>。如果至少一个数字的被选数量不同，则两种组合是不同的。</p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于<code>150</code> 个。</p><p><strong>示例 ：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：candidates = [2,3,6,7], target = 7<br>输出：[[2,2,3],[7]]<br>解释：<br>2 和<span class="hljs-number"> 3 </span>可以形成一组候选，2 +<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 7 </span>。注意<span class="hljs-number"> 2 </span>可以使用多次。<br>7 也是一个候选，<span class="hljs-number"> 7 </span>=<span class="hljs-number"> 7 </span>。<br>仅有这两种组合。<br></code></pre></td></tr></table></figure><p>思路：</p><p>题目最关键的点在于能重复使用元素但是不能<strong>重复元素的组合不能被重复输出</strong></p><p>因此需要调整startindex的开始的位置是在<code>backtracking(candidates,target,sum,i);</code>注意，这个时候从i开始保证还能用到自己的元素重复使用，还有<strong>最重要的<code>sort(candidates.begin(), candidates.end()); // 需要排序</code></strong></p><p>排序之后能够很好的进行剪枝，将一些加了之后元素大于目标的删掉直接跳过</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startindex)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(sum==target)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=startindex;i&lt;candidates.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(sum&gt;target)&#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            sum+=candidates[i];<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            <span class="hljs-built_in">backtracking</span>(candidates,target,sum,i);<br>            sum-=candidates[i];<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 需要排序</span><br>        <span class="hljs-built_in">backtracking</span>(candidates, target, <span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="组合总和ii">组合总和II</h3><p><ahref="https://leetcode.cn/problems/combination-sum-ii/description/">https://leetcode.cn/problems/combination-sum-ii/description/</a></p><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数<code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为<code>target</code> 的组合。</p><p><code>candidates</code>中的每个数字在每个组合中<strong>只能使用</strong> <strong>一次</strong>。</p><p><strong>注意：</strong>解集不能包含重复的组合。</p><p><strong>示例 :</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: candidates = <span class="hljs-comment">[10,1,2,7,6,1,5]</span>, target = 8,<br>输出:<br><span class="hljs-comment">[</span><br><span class="hljs-comment"><span class="hljs-comment">[1,1,6]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[1,2,5]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[1,7]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[2,6]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><p>思路：</p><p>这个地方最大的困难在于每个数字在每个组合中只能使用一次，同时集合中的元素存在重复的元素，那么这个时候有一个问题是如何才能<strong>对元素进行去重处理</strong>呢，就是让每个元素只能被使用一次</p><p>去重的操作就在于<code>vector&lt;bool&gt; used(candidates.size(),false);         sort(candidates.begin(), candidates.end());</code></p><p>首先需要在<code>backtracking</code>中定一个continue，这个地方是为了筛选不是重复的部分，那么如何区分开是否是同一个数组中重复的元素而不是重复利用的元素呢？</p><ul><li><code>i&gt;0&amp;&amp;candidates[i]==candidates[i-1]</code>这个地方表明了对元素相邻之间进行比较</li><li><code>used[i-1]==false</code>如果这个地方是false，那么说明这个元素是同一层的元素(同一个数组中的元素)</li><li>注意<code>i&lt;candidates.size()&amp;&amp;sum + candidates[i] &lt;= target</code>为了避免出现超出时间限制的情况</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startindex, vector&lt;<span class="hljs-type">bool</span>&gt;used)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(sum==target)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i= startindex;i&lt;candidates.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;candidates[i]==candidates[i<span class="hljs-number">-1</span>]&amp;&amp;used[i<span class="hljs-number">-1</span>]==<span class="hljs-literal">false</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            sum+=candidates[i];<br>            used[i]=<span class="hljs-literal">true</span>;<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            <span class="hljs-built_in">backtracking</span>(candidates, target, sum, i+<span class="hljs-number">1</span>, used);<br>            used[i]=<span class="hljs-literal">false</span>;<br>            path.<span class="hljs-built_in">pop_back</span>();<br>            sum-=candidates[i];<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum2</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(candidates.size(),<span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">backtracking</span>(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, used);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="分割回文串">分割回文串</h3><p><ahref="https://leetcode.cn/problems/palindrome-partitioning/description/">https://leetcode.cn/problems/palindrome-partitioning/description/</a></p><p>给你一个字符串 <code>s</code>，请你将 <code>s</code>分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回<code>s</code> 所有可能的分割方案。</p><p><strong>回文串</strong> 是正着读和反着读都一样的字符串。</p><p><strong>示例：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;aab&quot;</span><br>输出：[[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>],[<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>]]<br></code></pre></td></tr></table></figure><p>思路：</p><ul><li>首先给出回文字符的判断方法：首尾指针来回比较</li><li>回溯算法中最关键的点在于<code>startindex</code>的使用，利用这个来移动<code>s.substr(startindex, i-startindex+1)</code>来截取并筛选出相应的字符串的值进行回文比较</li><li>回溯的终止条件是<code>startindex&gt;=s.size()</code>如果超出了范围那么久说明到终点了</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; res;<br>    vector&lt;string&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ishuiwen</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start,j = end;i&lt;j;i++,j--)&#123;<br>            <span class="hljs-keyword">if</span>(s[i]!=s[j])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> startindex)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(startindex&gt;=s.<span class="hljs-built_in">size</span>())&#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=startindex;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">ishuiwen</span>(s,startindex,i))&#123;<br>                string str = s.<span class="hljs-built_in">substr</span>(startindex, i-startindex+<span class="hljs-number">1</span>);<br>                path.<span class="hljs-built_in">push_back</span>(str);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-built_in">backtracking</span>(s,i+<span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) &#123;<br>        <span class="hljs-built_in">backtracking</span>(s,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="复原ip地址">复原IP地址</h3><p><ahref="https://leetcode.cn/problems/restore-ip-addresses/description/">https://leetcode.cn/problems/restore-ip-addresses/description/</a></p><p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于<code>0</code> 到 <code>255</code> 之间组成，且不能含有前导<code>0</code>），整数之间用 <code>'.'</code> 分隔。</p><ul><li>例如：<code>"0.1.2.201"</code> 和<code>"192.168.1.1"</code> 是<strong>有效</strong> IP 地址，但是<code>"0.011.255.245"</code>、<code>"192.168.1.312"</code> 和<code>"192.168@1.1"</code> 是 <strong>无效</strong> IP 地址。</li></ul><p>给定一个只包含数字的字符串 <code>s</code> ，用以表示一个 IP地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在<code>s</code> 中插入 <code>'.'</code> 来形成。你 <strong>不能</strong>重新排序或删除 <code>s</code> 中的任何数字。你可以按<strong>任何</strong> 顺序返回答案。</p><p><strong>示例 ：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;25525511135&quot;</span><br>输出：[<span class="hljs-string">&quot;255.255.11.135&quot;</span>,<span class="hljs-string">&quot;255.255.111.35&quot;</span>]<br></code></pre></td></tr></table></figure><p>思路：</p><ul><li>回溯三部曲第一步：如何确定函数的类型以及参数呢？首先参数肯定包含了s、开始的位置(因为要一直往后移动并选择)、以及一个标记用于是否已经有三个点</li><li>写好判断是否合法的函数，这里比较多的陷阱需要注意</li><li>注意，当放进去3个点之后别忘了判断最后一位是否满足合法性的要求，容易忽略最后一位的情况</li><li>注意字符串的插入 <code>s.inset(n,'.')</code> 和删除<code>s.erase(n)</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; res;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isvalid</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(start&gt;end)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s[start]==<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;start!=end)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;=end;i++)&#123;<br>            <span class="hljs-keyword">if</span> (s[i] &gt; <span class="hljs-string">&#x27;9&#x27;</span> || s[i] &lt; <span class="hljs-string">&#x27;0&#x27;</span>) &#123; <span class="hljs-comment">// 遇到非数字字符不合法</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            num=num*<span class="hljs-number">10</span>+(s[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>            <span class="hljs-keyword">if</span>(num&gt;<span class="hljs-number">255</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> startindex, <span class="hljs-type">int</span> pointnum)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(pointnum==<span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isvalid</span>(s, startindex, s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)) &#123;<br>                res.<span class="hljs-built_in">push_back</span>(s);<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=startindex;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isvalid</span>(s,startindex,i))&#123;<br>                s.<span class="hljs-built_in">insert</span>(s.<span class="hljs-built_in">begin</span>()+i+<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;.&#x27;</span>);<br>                pointnum++;<br>                <span class="hljs-built_in">backtracking</span>(s,i+<span class="hljs-number">2</span>,pointnum);<br>                pointnum--;<br>                s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>()+i+<span class="hljs-number">1</span>);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-built_in">backtracking</span>(s,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="子集">子集</h3><p><ahref="https://leetcode.cn/problems/subsets/description/">https://leetcode.cn/problems/subsets/description/</a></p><p>给你一个整数数组 <code>nums</code> ，数组中的元素<strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按<strong>任意顺序</strong> 返回解集。</p><p><strong>示例：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[]</span>,<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[2]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[1,2,3]</span>]</span><br></code></pre></td></tr></table></figure><p>思路：</p><p>这道题比较简单，就是简单的遍历就可以了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> startindex)</span></span>&#123;<br>        res.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=startindex;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtracking</span>(nums,i+<span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">backtracking</span>(nums,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="子集ii">子集II</h3><p><ahref="https://leetcode.cn/problems/subsets-ii/description/">https://leetcode.cn/problems/subsets-ii/description/</a></p><p>给你一个整数数组 <code>nums</code>，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按<strong>任意顺序</strong> 排列。</p><p><strong>示例：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,2]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[]</span>,<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[1,2,2]</span>,<span class="hljs-comment">[2]</span>,<span class="hljs-comment">[2,2]</span>]</span><br></code></pre></td></tr></table></figure><p>注意：</p><p>凡是涉及到去重的操作，都需要优先进行排序操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; nums, <span class="hljs-type">int</span> startindex, vector&lt;<span class="hljs-type">bool</span>&gt; used)</span></span>&#123;<br>        res.<span class="hljs-built_in">push_back</span>(path);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=startindex;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i]==nums[i<span class="hljs-number">-1</span>]&amp;&amp;used[i<span class="hljs-number">-1</span>]==<span class="hljs-literal">false</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            used[i]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">backtracking</span>(nums,i+<span class="hljs-number">1</span>,used);<br>            used[i]=<span class="hljs-literal">false</span>;<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsetsWithDup</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(nums.size(),<span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 去重需要排序</span><br>        <span class="hljs-built_in">backtracking</span>(nums,<span class="hljs-number">0</span>,used);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="非递减子序列">非递减子序列</h3><p><ahref="https://leetcode.cn/problems/non-decreasing-subsequences/description/">https://leetcode.cn/problems/non-decreasing-subsequences/description/</a></p><p>给你一个整数数组 <code>nums</code>，找出并返回所有该数组中不同的递增子序列，递增子序列中<strong>至少有两个元素</strong> 。你可以按 <strong>任意顺序</strong>返回答案。数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[4,6,7,7]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[4,6]</span>,<span class="hljs-comment">[4,6,7]</span>,<span class="hljs-comment">[4,6,7,7]</span>,<span class="hljs-comment">[4,7]</span>,<span class="hljs-comment">[4,7,7]</span>,<span class="hljs-comment">[6,7]</span>,<span class="hljs-comment">[6,7,7]</span>,<span class="hljs-comment">[7,7]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[4,4]]</span><br></code></pre></td></tr></table></figure><p>思路：</p><p>首先这道题不需要去重同时也不需要提前进行排序</p><p>但是需要对同一层的元素进行去重操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> startindex)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>        &#125;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; uset;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =startindex;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span> ((!path.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &lt; path.<span class="hljs-built_in">back</span>())<br>                    || uset.<span class="hljs-built_in">find</span>(nums[i]) != uset.<span class="hljs-built_in">end</span>()) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            uset.<span class="hljs-built_in">insert</span>(nums[i]);<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtracking</span>(nums,i+<span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">findSubsequences</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">backtracking</span>(nums,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="全排列">全排列</h3><p><ahref="https://leetcode.cn/problems/permutations/description/">https://leetcode.cn/problems/permutations/description/</a></p><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其<em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong>返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[0,1],[1,0]]</span><br></code></pre></td></tr></table></figure><p>思路：</p><p>要求解全排列，因此回溯退出的条件是当<strong>path的长度和nums的长度一样</strong>的时候就达到了退出的条件</p><p>因为这道题<strong>没有重复</strong>的元素，求解全排列需要每次都从0开始选择，因此难点在于<strong>如何标记出已经选择过</strong>的元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>()==nums.<span class="hljs-built_in">size</span>())&#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(used[i]==<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            used[i]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">backtracking</span>(nums,used);<br>            used[i]=<span class="hljs-literal">false</span>;<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(nums.size(),<span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">backtracking</span>(nums,used);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="全排列ii">全排列II</h3><p><ahref="https://leetcode.cn/problems/permutations-ii/">https://leetcode.cn/problems/permutations-ii/</a></p><p>给定一个可包含重复数字的序列 <code>nums</code>，<strong><em>按任意顺序</em></strong> 返回所有不重复的全排列。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1,2]</span><br>输出：<br><span class="hljs-comment">[<span class="hljs-comment">[1,1,2]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[1,2,1]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[2,1,1]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure><p>思路：</p><p>首先这个全排列有重复的元素，因此需要有去重的操作，既然涉及到去重那需要重新排序，同时需要跳过重复的元素</p><p>第二步，既然是全排列，那么需要标记重复选择的元素并选择跳过</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>()==nums.<span class="hljs-built_in">size</span>())&#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i]==nums[i<span class="hljs-number">-1</span>]&amp;&amp;used[i<span class="hljs-number">-1</span>]==<span class="hljs-literal">false</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(used[i]==<span class="hljs-literal">false</span>)&#123;<br>                used[i]=<span class="hljs-literal">true</span>;<br>                path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                <span class="hljs-built_in">backtracking</span>(nums, used);<br>                path.<span class="hljs-built_in">pop_back</span>();<br>                used[i]=<span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permuteUnique</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(nums.size(),<span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">backtracking</span>(nums,used);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="重新安排行程">重新安排行程</h3><p><ahref="https://leetcode.cn/problems/reconstruct-itinerary/description/">https://leetcode.cn/problems/reconstruct-itinerary/description/</a></p><p>给你一份航线列表 <code>tickets</code> ，其中<code>tickets[i] = [fromi, toi]</code>表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。所有这些机票都属于一个从<code>JFK</code>（肯尼迪国际机场）出发的先生，所以该行程必须从<code>JFK</code>开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。</p><ul><li>例如，行程 <code>["JFK", "LGA"]</code> 与<code>["JFK", "LGB"]</code> 相比就更小，排序更靠前。</li></ul><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240122123926323.png" alt="安排行程" style="zoom: 67%;" /></p><p>思路：</p><p>【困难】</p><ul><li><p>首先第一步：确定终止条件，遇到的机场个数，如果达到了（航班数量+1）</p></li><li><p>记录航班的数量，使用<code>unordered_map&lt;string, map&lt;string, int&gt;&gt; targets;</code>来记录航班的映射关系，我定义为全局变量。</p><p>当然把参数放进函数里传进去也是可以的，我是尽量控制函数里参数的长度。参数里还需要ticketNum，表示有多少个航班</p></li><li><p>回溯的过程中，如何遍历一个机场所对应的所有机场呢？</p><p>这里刚刚说过，在选择映射函数的时候，不能选择<code>unordered_map&lt;string, multiset&lt;string&gt;&gt; targets</code>，因为一旦有元素增删multiset的迭代器就会失效，当然可能有牛逼的容器删除元素迭代器不会失效，这里就不在讨论了。</p><p><strong>可以说本题既要找到一个对数据进行排序的容器，而且还要容易增删元素，迭代器还不能失效</strong>。</p><p>所以我选择了<code>unordered_map&lt;string, map&lt;string, int&gt;&gt; targets</code>来做机场之间的映射</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; res;<br>    unordered_map&lt;string, map&lt;string, <span class="hljs-type">int</span>&gt;&gt; targets;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> ticketnum, vector&lt;string&gt;&amp; res)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>()==ticketnum+<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(pair&lt;<span class="hljs-type">const</span> string, <span class="hljs-type">int</span>&gt;&amp; target: targets[res[res.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>]])&#123;<br>            <span class="hljs-keyword">if</span>(target.second&gt;<span class="hljs-number">0</span>)&#123;<br>                res.<span class="hljs-built_in">push_back</span>(target.first);<br>                target.second--;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">backtracking</span>(ticketnum, res)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                res.<span class="hljs-built_in">pop_back</span>();<br>                target.second++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findItinerary</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> vector&lt;string&gt;&amp; vec: tickets)&#123;<br>            targets[vec[<span class="hljs-number">0</span>]][vec[<span class="hljs-number">1</span>]]++;<br>        &#125;<br>        res.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;JFK&quot;</span>);<br>        <span class="hljs-built_in">backtracking</span>(tickets.<span class="hljs-built_in">size</span>(), res);<br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="n皇后">N皇后</h3><p><ahref="https://leetcode.cn/problems/n-queens/description/">https://leetcode.cn/problems/n-queens/description/</a></p><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code>个皇后放置在 <code>n×n</code>的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n皇后问题</strong> 的解决方案。</p><p>每一种解法包含一个不同的 <strong>n 皇后问题</strong>的棋子放置方案，该方案中 <code>'Q'</code> 和 <code>'.'</code>分别代表了皇后和空位。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：n = <span class="hljs-number">4</span><br>输出：[[<span class="hljs-string">&quot;.Q..&quot;</span>,<span class="hljs-string">&quot;...Q&quot;</span>,<span class="hljs-string">&quot;Q...&quot;</span>,<span class="hljs-string">&quot;..Q.&quot;</span>],[<span class="hljs-string">&quot;..Q.&quot;</span>,<span class="hljs-string">&quot;Q...&quot;</span>,<span class="hljs-string">&quot;...Q&quot;</span>,<span class="hljs-string">&quot;.Q..&quot;</span>]]<br>解释：如上图所示，<span class="hljs-number">4</span> 皇后问题存在两个不同的解法。<br></code></pre></td></tr></table></figure><p>思路：</p><p>这道题关键在于<strong>用好数据结构</strong>和写好<strong>合法性的判断</strong></p><p>关键在于定义好<code>chessboard</code>第二步是把合法性位置判断写好</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; res;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isvalid</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, vector&lt;string&gt;&amp; chessboard,<span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-comment">//检查列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(chessboard[row][j]==<span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//检查行</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(chessboard[i][col]==<span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//检查对角线45</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>; i &gt;=<span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i--, j--) &#123;<br>        <span class="hljs-keyword">if</span> (chessboard[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//检查对角线135</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = row<span class="hljs-number">-1</span>,j=col+<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>&amp;&amp;j&lt;n;i--,j++)&#123;<br>            <span class="hljs-keyword">if</span>(chessboard[i][j]==<span class="hljs-string">&#x27;Q&#x27;</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;string&gt;&amp; chessboard, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(row==n)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(chessboard);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> col = <span class="hljs-number">0</span>;col&lt;n;col++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isvalid</span>(row,col,chessboard,n))&#123;<br>                chessboard[row][col]=<span class="hljs-string">&#x27;Q&#x27;</span>;<br>                <span class="hljs-built_in">backtracking</span>(chessboard,row+<span class="hljs-number">1</span>,n);<br>                chessboard[row][col]=<span class="hljs-string">&#x27;.&#x27;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">chessboard</span><span class="hljs-params">(n, std::string(n, <span class="hljs-string">&#x27;.&#x27;</span>))</span></span>;<br>        <span class="hljs-built_in">backtracking</span>(chessboard,<span class="hljs-number">0</span>,n);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解数独">解数独</h3><p>编写一个程序，通过填充空格来解决数独问题。</p><p>数独的解法需 <strong>遵循如下规则</strong>：</p><ol type="1"><li>数字 <code>1-9</code> 在每一行只能出现一次。</li><li>数字 <code>1-9</code> 在每一列只能出现一次。</li><li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code>宫内只能出现一次。（请参考示例图）</li></ol><p>数独部分空格内已填入了数字，空白格用 <code>'.'</code> 表示。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>],[<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],[<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>]]<br>输出：[[<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>],[<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>],[<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>],[<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],[<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>],[<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>],[<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>],[<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>]]<br></code></pre></td></tr></table></figure><p>思路：</p><p>深度优先搜索，加上<strong>合法性判断</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isvalid</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">char</span> a)</span></span>&#123;<br>        <span class="hljs-comment">//行遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">9</span>;j++)&#123;<br>            <span class="hljs-keyword">if</span>(board[row][j]==a) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//列遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(board[i][col]==a) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//方框内判断：关键找到起始的方框对角</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i= (row/<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>;i&lt;(row/<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>+<span class="hljs-number">3</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=(col/<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>; j&lt;(col/<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>+<span class="hljs-number">3</span>;j++)&#123;<br>                <span class="hljs-keyword">if</span>(board[i][j]==a) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;board.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(board[i][j]==<span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> a=<span class="hljs-string">&#x27;1&#x27;</span>;a&lt;=<span class="hljs-string">&#x27;9&#x27;</span>;a++)&#123;<br>                        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isvalid</span>(board,i,j,a))&#123;<br>                            board[i][j]=a;<br>                            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">backtracking</span>(board)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                            board[i][j]=<span class="hljs-string">&#x27;.&#x27;</span>;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-built_in">backtracking</span>(board);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="贪心算法">贪心算法</h1><h3 id="分发饼干">分发饼干</h3><p><ahref="https://leetcode.cn/problems/assign-cookies/description/">https://leetcode.cn/problems/assign-cookies/description/</a></p><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子<code>i</code>，都有一个胃口值<code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干<code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果<code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code>分配给孩子 <code>i</code>，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p><strong>示例 :</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: g = [1,2,3], s = [1,1]</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: </span><br>你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。<br>虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。<br>所以你应该输出1。<br></code></pre></td></tr></table></figure><p><strong>示例 :</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: g = [1,2], s = [1,2,3]</span><br><span class="hljs-section">输出: 2</span><br><span class="hljs-section">解释: </span><br>你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。<br>你拥有的饼干数量和尺寸都足以让所有孩子满足。<br>所以你应该输出2.<br></code></pre></td></tr></table></figure><p>思路：</p><p><strong>这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩</strong>。</p><p>可以尝试使用贪心策略，先将饼干数组和小孩数组排序。</p><p>然后从后向前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足小孩数量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; g, vector&lt;<span class="hljs-type">int</span>&gt;&amp; s)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(),s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(g.<span class="hljs-built_in">begin</span>(),g.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> index=s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> num= <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=g.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(index&gt;=<span class="hljs-number">0</span>&amp;&amp;s[index]&gt;=g[i])&#123;<br>                num++;<br>                index--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="摆动序列">摆动序列</h3><p><ahref="https://leetcode.cn/problems/wiggle-subsequence/description/">https://leetcode.cn/problems/wiggle-subsequence/description/</a></p><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为<strong>摆动序列。</strong>第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p><ul><li>例如， <code>[1, 7, 4, 9, 2, 5]</code> 是一个<strong>摆动序列</strong> ，因为差值 <code>(6, -3, 5, -7, 3)</code>是正负交替出现的。</li></ul><p>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 中作为<strong>摆动序列</strong> 的 <strong>最长子序列的长度</strong></p><p><strong>示例 ：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,7,4,9,2,5]<br>输出：6<br>解释：整个序列均为摆动序列，各元素之间的差值为 (6, <span class="hljs-string">-3</span>, 5, <span class="hljs-string">-7</span>, 3) <br></code></pre></td></tr></table></figure><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,17,5,10,13,15,10,5,16,8]<br>输出：7<br>解释：这个序列包含几个长度为 7 摆动序列。<br>其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, <span class="hljs-string">-7</span>, 3, <span class="hljs-string">-3</span>, 6, <span class="hljs-string">-8</span>) <br></code></pre></td></tr></table></figure><p>思路：</p><p><strong>本题异常情况的本质，就是要考虑平坡</strong>，平坡分两种，一个是 上下中间有平坡，一个是单调有平坡，如图</p><p>同时需要注意的是在判断条件语句的时候，<strong>不能简单的用判断相乘法小于0作为判断，因为存在平坡的情况</strong></p><figure><imgsrc="../../../../../Library/Application%20Support/typora-user-images/image-20240123150641735.png"alt="异常情况需要考虑" /><figcaption aria-hidden="true">异常情况需要考虑</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()&lt;=<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>        &#125;<br>        <span class="hljs-type">int</span> num=<span class="hljs-number">1</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; differ;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            differ.<span class="hljs-built_in">push_back</span>(nums[i]-nums[i<span class="hljs-number">-1</span>]);<br>        &#125;<br>        <span class="hljs-type">int</span> preDiff=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;differ.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>((preDiff&lt;=<span class="hljs-number">0</span>&amp;&amp; differ[i]&gt;<span class="hljs-number">0</span>)||(differ[i]&lt;<span class="hljs-number">0</span>&amp;&amp;preDiff&gt;=<span class="hljs-number">0</span>))&#123;<br>                num++;<br>                preDiff = differ[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="最大子数组和">最大子数组和</h3><p><ahref="https://leetcode.cn/problems/maximum-subarray/description/">https://leetcode.cn/problems/maximum-subarray/description/</a></p><p>给你一个整数数组 <code>nums</code>，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分。</p><p><strong>示例：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]<br>输出：6<br>解释：连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6 。<br></code></pre></td></tr></table></figure><p>思路：</p><p>这道题使用的是局部的最优贪心的思路，如果遇到让总的值小于0，那么久立刻让总的值变成0，那么下一轮就从头开始记了，同时max会每一轮进行判断是否有比当前的最大值大，如果有那么就进行替换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = INT32_MIN;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            count+=nums[i];<br>            <span class="hljs-keyword">if</span>(count&gt;res)&#123;<br>                res = count;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(count&lt;=<span class="hljs-number">0</span>) count = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="买卖股票的最佳时机">买卖股票的最佳时机</h3><p><ahref="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/</a></p><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code>表示某支股票第 <code>i</code>天的价格。在每一天，你可以决定是否购买和/或出售股票。你在任何时候<strong>最多</strong> 只能持有 <strong>一股</strong>股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p><p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：prices = [7,1,5,3,6,4]<br>输出：7<br>解释：在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 3 </span>天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 =<span class="hljs-number"> 5 </span>-<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 4 </span>。<br>     随后，在第<span class="hljs-number"> 4 </span>天（股票价格 = 3）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 =<span class="hljs-number"> 6 </span>-<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 3 </span>。<br>     总利润为<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 7 </span>。<br></code></pre></td></tr></table></figure><p>思路：</p><p><strong>把利润分解为每天为单位的维度，而不是从 0 天到第 3天整体去考虑！</strong></p><p>那么根据 prices可以得到每天的利润序列：<code>(prices[i] - prices[i - 1]).....(prices[1] - prices[0])</code></p><p>相当于是每天的利润之差和0的比较，只选择为正的值，负数的情况直接忽略</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;prices.<span class="hljs-built_in">size</span>();i++)&#123;<br>            res+=<span class="hljs-built_in">max</span>(prices[i]-prices[i<span class="hljs-number">-1</span>],<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="动态规划">动态规划</h1><p>状态转移公式（递推公式）是很重要，但动规不仅仅只有递推公式。</p><p><strong>对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！</strong></p><ol type="1"><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><p><strong>注意：动态规划的问题一般只会输出最后的一个结果，不会输出比如中间的路径等相关的值</strong></p><h3 id="斐波那契数列">斐波那契数列</h3><p><ahref="https://leetcode.cn/problems/fibonacci-number/">https://leetcode.cn/problems/fibonacci-number/</a></p><p><strong>斐波那契数</strong> （通常用 <code>F(n)</code>表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由<code>0</code> 和 <code>1</code>开始，后面的每一项数字都是前面两项数字的和。也就是：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span> = <span class="hljs-number">0</span>，<span class="hljs-built_in">F</span>(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-title">F</span><span class="hljs-params">(n)</span></span> = <span class="hljs-built_in">F</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">F</span>(n - <span class="hljs-number">2</span>)，其中 n &gt; <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>给定 <code>n</code> ，请计算 <code>F(n)</code> 。</p><p><strong>示例：</strong></p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl">输入：<span class="hljs-variable">n</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">1</span><br>解释：<span class="hljs-function"><span class="hljs-title">F</span>(<span class="hljs-number">2</span>) = <span class="hljs-title">F</span>(<span class="hljs-number">1</span>) + <span class="hljs-title">F</span>(<span class="hljs-number">0</span>) = <span class="hljs-number">1</span> + <span class="hljs-number">0</span> = <span class="hljs-number">1</span></span><br></code></pre></td></tr></table></figure><p>思路：</p><p>因为这道题给出了递推公式：<code>F(n) = F(n - 1) + F(n - 2)</code></p><p>动规五部曲：</p><p>这里我们要用一个一维dp数组来保存递归的结果</p><ol type="1"><li><p>确定dp数组以及下标的含义：dp[i]的定义为：第i个数的斐波那契数值是dp[i]</p></li><li><p>确定递推公式<code>F(n) = F(n - 1) + F(n - 2)</code></p></li><li><p>dp数组如何初始化</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">dp[0] = 0;<br>dp[1] = 1;<br></code></pre></td></tr></table></figure></li><li><p>确定遍历顺序</p><p>从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i- 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的</p></li><li><p>举例推导dp数组</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">dp</span>(n+<span class="hljs-number">1</span>);<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>            dp[i]=dp[i<span class="hljs-number">-1</span>]+dp[i<span class="hljs-number">-2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="爬楼梯">爬楼梯</h3><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。每次你可以爬<code>1</code> 或 <code>2</code>个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 2<br>输出：2<br>解释：有两种方法可以爬到楼顶。<br>1.<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶<br>2.<span class="hljs-number"> 2 </span>阶<br></code></pre></td></tr></table></figure><p>思路：</p><p>动态规划简单题，递推公式：<code>dp[i] = dp[i-2]+dp[i-1];</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>]=<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=n;i++)&#123;<br>            dp[i] = dp[i<span class="hljs-number">-2</span>]+dp[i<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="最小费用爬楼梯">最小费用爬楼梯</h3><p><ahref="https://leetcode.cn/problems/min-cost-climbing-stairs/description/">https://leetcode.cn/problems/min-cost-climbing-stairs/description/</a></p><p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code>是从楼梯第 <code>i</code>个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。你可以选择从下标为<code>0</code> 或下标为 <code>1</code>的台阶开始爬楼梯。请你计算并返回达到楼梯顶部的最低花费。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：cost = [10,15,20]<br>输出：15<br>解释：你将从下标为<span class="hljs-number"> 1 </span>的台阶开始。<br>- 支付<span class="hljs-number"> 15 </span>，向上爬两个台阶，到达楼梯顶部。<br>总花费为<span class="hljs-number"> 15 </span>。<br></code></pre></td></tr></table></figure><p>思路：</p><p>动态规划<strong>可以有两个途径得到dp[i]，一个是dp[i-1]一个是dp[i-2]</strong>。</p><p>dp[i - 1] 跳到 dp[i] 需要花费<code>dp[i - 1] + cost[i - 1]</code>。</p><p>dp[i - 2] 跳到 dp[i] 需要花费<code>dp[i - 2] + cost[i - 2]</code>。</p><p>那么究竟是选从dp[i - 1]跳还是从dp[i - 2]跳呢？</p><p>一定是选最小的，所以<code>dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])</code>;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = cost.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>]= <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>            dp[i]=<span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>]+cost[i<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-2</span>]+cost[i<span class="hljs-number">-2</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="不同路径">不同路径</h3><p>一个机器人位于一个 <code>m x n</code> 网格的左上角（起始点在下图中标记为 “Start”）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish” ）。问总共有多少条不同的路径？</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240128142408271.png" alt="机器人路径问题" style="zoom:67%;" /></p><p>思路：</p><p>简单的动态规划问题，只需要保证每次迭代都从上面和左边进行叠加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            dp[<span class="hljs-number">0</span>][i]=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;n;j++)&#123;<br>                dp[i][j]=dp[i<span class="hljs-number">-1</span>][j]+dp[i][j<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="不同路径ii">不同路径II</h3><p><ahref="https://leetcode.cn/problems/unique-paths-ii/description/">https://leetcode.cn/problems/unique-paths-ii/description/</a></p><p>一个机器人位于一个 <code>m x n</code> 网格的左上角（起始点在下图中标记为 “Start”）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用<code>1</code> 和 <code>0</code> 来表示。</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240128143004648.png" alt="障碍物的机器人路径" style="zoom: 50%;" /></p><p>思路：</p><p>和上一题的思路一样，都是需要遍历路径就行，但是这里加入了一个新的数组用来存储有障碍物的位置，因此需要额外进行标记<code>&amp;&amp;obstacleGrid[i][0]==0</code>的信息，同时遇到障碍物就不改变对应的值，直接<code>continue</code>就好</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">dp</span>(obstacleGrid.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;obstacleGrid.<span class="hljs-built_in">size</span>()&amp;&amp;obstacleGrid[i][<span class="hljs-number">0</span>]==<span class="hljs-number">0</span>;i++) dp[i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()&amp;&amp;obstacleGrid[<span class="hljs-number">0</span>][i]==<span class="hljs-number">0</span>;i++) dp[<span class="hljs-number">0</span>][i]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;obstacleGrid.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(obstacleGrid[i][j]==<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>                dp[i][j]=dp[i<span class="hljs-number">-1</span>][j]+dp[i][j<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[obstacleGrid.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>][obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="整数拆分">整数拆分</h3><p><ahref="https://leetcode.cn/problems/integer-break/description/">https://leetcode.cn/problems/integer-break/description/</a></p><p>给定一个正整数 <code>n</code> ，将其拆分为 <code>k</code> 个<strong>正整数</strong> 的和（ <code>k &gt;= 2</code>），并使这些整数的乘积最大化。返回 <em>你可以获得的最大乘积</em> 。</p><p><strong>示例 :</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: n = 2<br>输出: 1<br>解释:<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 1 </span>+ 1,<span class="hljs-number"> 1 </span>×<span class="hljs-number"> 1 </span>= 1。<br></code></pre></td></tr></table></figure><p>思路：</p><p>给出递推公式一个是<code>j * (i - j)</code>直接相乘。一个是<code>j * dp[i - j]</code>，相当于是拆分<code>(i - j)</code>，在遍历j的过程中其实都计算过了。那么从1遍历j，比较<code>(i - j) * j和dp[i - j] * j</code>取最大的。递推公式：<code>dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j))</code>；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n ; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i / <span class="hljs-number">2</span>; j++) &#123;<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i], <span class="hljs-built_in">max</span>((i - j) * j, dp[i - j] * j));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="香槟塔问题">香槟塔问题</h3><p>我们把玻璃杯摆成金字塔的形状，其中 <strong>第一层</strong> 有<code>1</code> 个玻璃杯， <strong>第二层</strong> 有 <code>2</code>个，依次类推到第 100 层，每个玻璃杯 (250ml) 将盛有香槟。</p><p>从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上）</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240310153527352.png" alt="香槟塔问题" style="zoom:50%;" /></p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">示例 1</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">输入</span><span class="hljs-punctuation">:</span> <span class="hljs-string">poured(倾倒香槟总杯数) = 1, query_glass(杯子的位置数) = 1, query_row(行数) = 1</span><br><span class="hljs-attribute">输出</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0.00000</span><br><span class="hljs-attribute">解释</span><span class="hljs-punctuation">:</span> <span class="hljs-string">我们在顶层（下标是（0，0））倒了一杯香槟后，没有溢出，因此所有在顶层以下的玻璃杯都是空的。</span><br><br><span class="hljs-attribute">示例 2</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">输入</span><span class="hljs-punctuation">:</span> <span class="hljs-string">poured(倾倒香槟总杯数) = 2, query_glass(杯子的位置数) = 1, query_row(行数) = 1</span><br><span class="hljs-attribute">输出</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0.50000</span><br><span class="hljs-attribute">解释</span><span class="hljs-punctuation">:</span> <span class="hljs-string">我们在顶层（下标是（0，0）倒了两杯香槟后，有一杯量的香槟将从顶层溢出，位于（1，0）的玻璃杯和（1，1）的玻璃杯平分了这一杯香槟，所以每个玻璃杯有一半的香槟。</span><br></code></pre></td></tr></table></figure><p>思路：</p><p>线性DP，令 <code>poured</code> 为<code>k</code>，<code>query_row</code> 和 <code>query_glass</code>分别为 <em>n</em> 和 <em>m</em></p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240310153733207.png" alt="思路题解" style="zoom:50%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">champagneTower</span><span class="hljs-params">(<span class="hljs-type">int</span> poured, <span class="hljs-type">int</span> query_row, <span class="hljs-type">int</span> query_glass)</span> </span>&#123;<br>        <span class="hljs-type">double</span> dp[<span class="hljs-number">110</span>][<span class="hljs-number">110</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]= (<span class="hljs-type">double</span>) poured;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;=query_row;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;=i;j++)&#123;<br>                <span class="hljs-keyword">if</span>(dp[i][j]&gt;<span class="hljs-number">1</span>)&#123;<br>                    dp[i+<span class="hljs-number">1</span>][j]+=(dp[i][j]<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;<br>                    dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]+=(dp[i][j]<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;<br>                    dp[i][j] = <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[query_row][query_glass];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="最大正方形">最大正方形</h3><p>在一个由 <code>'0'</code> 和 <code>'1'</code>组成的二维矩阵内，找到只包含 <code>'1'</code>的最大正方形，并返回其面积。</p><p><strong>示例 1：</strong></p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240310155051578.png" alt="image-20240310155051578" style="zoom:50%;" /></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：matrix = [[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>]]<br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：matrix = [[<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>]]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>思路：</p><p>难点在于不是矩形而是正方形</p><p>动态规划的思路是分别去比较和左侧左上方格中的元素的比值选择出最大的</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240310155150041.png" alt="动态规划思路" style="zoom:50%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximalSquare</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(matrix.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>||matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>        <span class="hljs-type">int</span> maxsize = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> rows = matrix.<span class="hljs-built_in">size</span>(), colums = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(rows, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(colums));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i= <span class="hljs-number">0</span>;i&lt;rows;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;colums;j++)&#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][j]==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>||j==<span class="hljs-number">0</span>)&#123;dp[i][j]=<span class="hljs-number">1</span>;&#125;<br>                    <span class="hljs-keyword">else</span>&#123;<br>                        dp[i][j] = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]),dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])+<span class="hljs-number">1</span>;<br>                    &#125;<br>                    maxsize = <span class="hljs-built_in">max</span>(maxsize, dp[i][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxsize* maxsize;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="戳气球">戳气球</h3><p>有 <code>n</code> 个气球，编号为<code>0</code> 到<code>n - 1</code>，每个气球上都标有一个数字，这些数字存在数组<code>nums</code> 中。</p><p>现在要求你戳破所有的气球。戳破第 <code>i</code> 个气球，你可以获得<code>nums[i - 1] * nums[i] * nums[i + 1]</code> 枚硬币。 这里的<code>i - 1</code> 和 <code>i + 1</code> 代表和 <code>i</code>相邻的两个气球的序号。如果 <code>i - 1</code>或 <code>i + 1</code>超出了数组的边界，那么就当它是一个数字为 <code>1</code> 的气球。</p><p>求所能获得硬币的最大数量。</p><p><strong>示例 1：</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">输入：nums = [3,1,5,8]<br>输出：167<br>解释：<br>nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []<br>coins =  3<span class="hljs-number">*1</span><span class="hljs-number">*5</span>    +   3<span class="hljs-number">*5</span><span class="hljs-number">*8</span>   +  1<span class="hljs-number">*3</span><span class="hljs-number">*8</span>  + 1<span class="hljs-number">*8</span><span class="hljs-number">*1</span> = 167<br></code></pre></td></tr></table></figure><p>思路：</p><p>这道题是一个区间DP的题目，下面的解题思路</p><p><ahref="https://leetcode.cn/problems/burst-balloons/solutions/337630/zhe-ge-cai-pu-zi-ji-zai-jia-ye-neng-zuo-guan-jian-/?envType=featured-list&amp;envId=2cktkvj%3FenvType%3Dfeatured-list&amp;envId=2cktkvj">https://leetcode.cn/problems/burst-balloons/solutions/337630/zhe-ge-cai-pu-zi-ji-zai-jia-ye-neng-zuo-guan-jian-/?envType=featured-list&amp;envId=2cktkvj%3FenvType%3Dfeatured-list&amp;envId=2cktkvj</a></p><p>关键点在于</p><p>DP的状态转移方程只和i和j位置的数字相关，分治的思想，分别划分为两个区间进行遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; rec;<br>    vector&lt;<span class="hljs-type">int</span>&gt; val;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(left&gt;=right<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(rec[left][right]!=<span class="hljs-number">-1</span>)&#123;<span class="hljs-keyword">return</span> rec[left][right];&#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=left+<span class="hljs-number">1</span>;i&lt;right;i++)&#123;<br>            <span class="hljs-type">int</span> sum = val[left]*val[i]* val[right];<br>            sum+=<span class="hljs-built_in">solve</span>(left,i)+<span class="hljs-built_in">solve</span>(i, right);<br>            rec[left][right] = <span class="hljs-built_in">max</span>(rec[left][right], sum);<br>        &#125;<br>        <span class="hljs-keyword">return</span> rec[left][right];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxCoins</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        n = nums.<span class="hljs-built_in">size</span>();<br>        val.<span class="hljs-built_in">resize</span>(n+<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            val[i] = nums[i<span class="hljs-number">-1</span>];<br>        &#125;<br>        val[<span class="hljs-number">0</span>] = val[n+<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        rec.<span class="hljs-built_in">resize</span>(n+<span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">2</span>, <span class="hljs-number">-1</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">solve</span>(<span class="hljs-number">0</span>, n+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="背包问题解题框架">背包问题解题框架</h3><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240129124938997.png"alt="背包问题的基本分类关系" /><figcaption aria-hidden="true">背包问题的基本分类关系</figcaption></figure><h4 id="背包">0-1背包</h4><p><code>dp[j]</code>为容量为<code>j</code>的背包所背的最大价值，那么如何推导<code>dp[j]</code>呢？<code>dp[j]</code>可以通过<code>dp[j - weight[i]]</code>推导出来，<code>dp[j - weight[i]]</code>表示容量为<code>j - weight[i]</code>的背包所背的最大价值。</p><p><code>dp[j - weight[i]] + value[i]</code> 表示 容量为 <code>j</code>- 物品i重量 的背包 加上物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）</p><p>此时dp[j]有两个选择，一个是取自己<code>dp[j]</code> 相当于二维dp数组中的<code>dp[i-1][j]</code>，即不放物品i，一个是取<code>dp[j - weight[i]] + value[i]</code>，即放物品i，指定是取最大的，毕竟是求最大价值，</p><p><strong>递推公式：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br></code></pre></td></tr></table></figure><p><strong>初始化：</strong></p><p>全部初始化为0</p><p><strong>遍历顺序：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>整体的代码结构是</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_1_wei_bag_problem</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; weight = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>    vector&lt;<span class="hljs-type">int</span>&gt; value = &#123;<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br>    <span class="hljs-type">int</span> bagWeight = <span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(bagWeight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="完全背包问题">完全背包问题</h4><p>有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i]。<strong>每件物品都有无限个（也就是可以放入背包多次）</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p><strong>完全背包和01背包问题唯一不同的地方就是，每种物品有无限件</strong>。</p><p>在代码层面的区别在于背包遍历的时候是从头开始到尾遍历，<code>int j = weight[i]; j &lt;= bagWeight; j++</code>，因为所有的背包内部都是无限的</p><p>1、先遍历物品再遍历背包</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_CompletePack</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; weight = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>    vector&lt;<span class="hljs-type">int</span>&gt; value = &#123;<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br>    <span class="hljs-type">int</span> bagWeight = <span class="hljs-number">4</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(bagWeight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = weight[i]; j &lt;= bagWeight; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、先遍历背包再遍历物品</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagWeight; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">if</span> (j - weight[i] &gt;= <span class="hljs-number">0</span>) dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分割等和子集">分割等和子集</h3><p><ahref="https://leetcode.cn/problems/partition-equal-subset-sum/description/">https://leetcode.cn/problems/partition-equal-subset-sum/description/</a></p><p>给你一个<strong>只包含正整数</strong>的<strong>非空</strong> 数组<code>nums</code>。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等<strong>示例：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,5,11,5]</span><br>输出：true<br>解释：数组可以分割成 <span class="hljs-comment">[1, 5, 5]</span> 和 <span class="hljs-comment">[11]</span> <br></code></pre></td></tr></table></figure><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>]<br>输出：<span class="hljs-literal">false</span><br>解释：数组不能分割成两个元素和相等的子集。<br></code></pre></td></tr></table></figure><p>思路：因为这个地方只需要写出是否能够划分，而不是具体的划分结果，因此可以考虑利用动态规划的方法来进行写，可以利用背包法来进行求解，具体步骤：</p><ol type="1"><li>首先判断数组的和是否为偶数，是的话那么背包的大小就是总和取一半，不是的话就直接返回false</li><li>0-1背包问题，大小是总和的一半，每个物品的价值是数的大小</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum =<span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">10001</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            sum+=nums[i];<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(sum%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> target = sum/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=target; j&gt;=nums[i];j--)&#123;<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j],dp[j-nums[i]]+nums[i]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(dp[target]==target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="最后一块石头的重量">最后一块石头的重量</h3><p><ahref="https://leetcode.cn/problems/last-stone-weight-ii/description/">https://leetcode.cn/problems/last-stone-weight-ii/description/</a></p><p>有一堆石头，用整数数组 <code>stones</code> 表示。其中<code>stones[i]</code> 表示第 <code>i</code>块石头的重量。每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为<code>x</code> 和 <code>y</code>，且<code>x &lt;= y</code>。那么粉碎的可能结果如下：</p><ul><li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li><li>如果 <code>x != y</code>，那么重量为 <code>x</code>的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为<code>y-x</code>。</li></ul><p>最后，<strong>最多只会剩下一块</strong> 石头。返回此石头<strong>最小的可能重量</strong> 。如果没有石头剩下，就返回<code>0</code>。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：stones = <span class="hljs-comment">[2,7,4,1,8,1]</span><br>输出：1<br>解释：<br>组合 2 和 4，得到 2，所以数组转化为 <span class="hljs-comment">[2,7,1,8,1]</span>，<br>组合 7 和 8，得到 1，所以数组转化为 <span class="hljs-comment">[2,1,1,1]</span>，<br>组合 2 和 1，得到 1，所以数组转化为 <span class="hljs-comment">[1,1,1]</span>，<br>组合 1 和 1，得到 0，所以数组转化为 <span class="hljs-comment">[1]</span>，这就是最优值。<br></code></pre></td></tr></table></figure><p>思路：</p><p>本题其实就是尽量让石头分成重量相同的两堆，相撞之后剩下的石头最小，<strong>这样就化解成01背包问题了</strong>本题物品的重量为stones[i]，物品的价值也为stones[i]。对应着01背包里的物品重量weight[i]和物品价值value[i]。</p><p>这道题的关键在于如何将这堆石头<strong>尽可能平均的划分成两堆</strong>（只有这样才能让剩下的石头的重量最小），大小就是总和除以2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lastStoneWeightII</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; stones)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">15001</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>; i&lt;stones.<span class="hljs-built_in">size</span>();i++)&#123;<br>            sum+=stones[i];<br>        &#125;<br>        <span class="hljs-type">int</span> target = sum/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;stones.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j= target;j&gt;=stones[i];j--)&#123;<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-stones[i]]+stones[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum - dp[target]- dp[target];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="目标和">目标和</h3><p><ahref="https://leetcode.cn/problems/target-sum/description/">https://leetcode.cn/problems/target-sum/description/</a></p><p>给你一个非负整数数组 <code>nums</code> 和一个整数 <code>target</code>。</p><p>向数组中的每个整数前添加 <code>'+'</code> 或 <code>'-'</code>，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p><ul><li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加<code>'+'</code> ，在 <code>1</code> 之前添加 <code>'-'</code>，然后串联起来得到表达式 <code>"+2-1"</code> 。</li></ul><p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同<strong>表达式</strong> 的数目。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,1,1,1,1], target = 3<br>输出：5<br>解释：一共有<span class="hljs-number"> 5 </span>种方法让最终目标和为<span class="hljs-number"> 3 </span>。<br>-1 +<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3<br>+1 -<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3<br>+1 +<span class="hljs-number"> 1 </span>-<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3<br>+1 +<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>-<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3<br>+1 +<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>-<span class="hljs-number"> 1 </span>= 3<br></code></pre></td></tr></table></figure><p>假设加法的总和为x，那么减法对应的总和就是sum - x。</p><p>所以我们要求的是 x - (sum - x) = target</p><p>x = (target + sum) / 2</p><p><strong>此时问题就转化为，装满容量为x的背包，有几种方法</strong>。</p><p>这里的x，就是bagSize，也就是我们后面要求的背包容量。</p><p>大家看到(target + sum) / 2 应该担心计算的过程中向下取整有没有影响</p><p>动态规划：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++) sum+=nums[i];<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(target)&gt;sum) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>((target+sum)%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> bagsize = (target+sum)/<span class="hljs-number">2</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(bagsize+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=bagsize;j&gt;=nums[i];j--)&#123;<br>                dp[j]+=dp[j-nums[i]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[bagsize];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="一和零">一和零</h3><p><ahref="https://leetcode.cn/problems/ones-and-zeroes/description/">https://leetcode.cn/problems/ones-and-zeroes/description/</a></p><p>给你一个二进制字符串数组 <code>strs</code> 和两个整数 <code>m</code>和 <code>n</code> 。</p><p>请你找出并返回 <code>strs</code> 的最大子集的长度，该子集中<strong>最多</strong> 有 <code>m</code> 个 <code>0</code> 和<code>n</code> 个 <code>1</code> 。</p><p>如果 <code>x</code> 的所有元素也是 <code>y</code> 的元素，集合<code>x</code> 是集合 <code>y</code> 的 <strong>子集</strong> 。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：strs = [<span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-string">&quot;0001&quot;</span>, <span class="hljs-string">&quot;111001&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>], m = <span class="hljs-number">5</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">4</span><br>解释：最多有 <span class="hljs-number">5</span> 个 <span class="hljs-number">0</span> 和 <span class="hljs-number">3</span> 个 <span class="hljs-number">1</span> 的最大子集是 &#123;<span class="hljs-string">&quot;10&quot;</span>,<span class="hljs-string">&quot;0001&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>&#125; ，因此答案是 <span class="hljs-number">4</span> 。<br>其他满足题意但较小的子集包括 &#123;<span class="hljs-string">&quot;0001&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>&#125; 和 &#123;<span class="hljs-string">&quot;10&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>&#125; 。&#123;<span class="hljs-string">&quot;111001&quot;</span>&#125; 不满足题意，因为它含 <span class="hljs-number">4</span> 个 <span class="hljs-number">1</span> ，大于 <span class="hljs-built_in">n</span> 的值 <span class="hljs-number">3</span> <br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMaxForm</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(string str: strs)&#123;<br>            <span class="hljs-type">int</span> onenum=<span class="hljs-number">0</span>, zeronum=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c :str)&#123;<br>                <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;0&#x27;</span>)zeronum++;<br>                <span class="hljs-keyword">else</span> onenum++;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=m;i&gt;=zeronum;i--)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=n; j&gt;=onenum; j--)&#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i-zeronum][j- onenum]+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="零钱兑换ii">零钱兑换II</h3><p><ahref="https://leetcode.cn/problems/coin-change-ii/description/">https://leetcode.cn/problems/coin-change-ii/description/</a></p><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数<code>amount</code> 表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回<code>0</code> 。</p><p>假设每一种面额的硬币有无限个。</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：amount = 5, coins = [1, 2, 5]<br>输出：4<br>解释：有四种方式可以凑成总金额：<br>5=5<br>5=2<span class="hljs-string">+2</span><span class="hljs-string">+1</span><br>5=2<span class="hljs-string">+1</span><span class="hljs-string">+1</span><span class="hljs-string">+1</span><br>5=1<span class="hljs-string">+1</span><span class="hljs-string">+1</span><span class="hljs-string">+1</span><span class="hljs-string">+1</span><br></code></pre></td></tr></table></figure><p>思路：</p><p>完全背包问题</p><p>注意在用完全背包问题的时候，遍历背包这个地方是从++开始，就是从coins[i]开始遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;coins.<span class="hljs-built_in">size</span>();i++)&#123;<span class="hljs-comment">//遍历物品</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = coins[i];j&lt;=amount;j++)&#123; <span class="hljs-comment">//遍历背包</span><br>                dp[j]+=dp[j-coins[i]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="组合总结iv">组合总结IV</h3><p><ahref="https://leetcode.cn/problems/combination-sum-iv/description/">https://leetcode.cn/problems/combination-sum-iv/description/</a></p><p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code>，和一个目标整数 <code>target</code> 。请你从 <code>nums</code>中找出并返回总和为 <code>target</code> 的元素组合的个数。</p><p>题目数据保证答案符合 32 位整数范围。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">4</span><br>输出：<span class="hljs-number">7</span><br>解释：<br>所有可能的组合为：<br>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)<br>请注意，顺序不同的序列被视作不同的组合。<br></code></pre></td></tr></table></figure><p>思路：</p><p>题目中说这个问题每个元素可以被用好多次，因此想到完全背包问题</p><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p><p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p><p>本题中的结果是需要考虑到不同数字之间的排列顺序的，所以这个地方要用到排列，先背包再物品</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">combinationSum4</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(target+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=target;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;nums.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(i-nums[j]&gt;=<span class="hljs-number">0</span> &amp;&amp; dp[i]&lt;INT_MAX-dp[i-nums[j]])&#123;<br>                    dp[i]+=dp[i-nums[j]];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="零钱兑换">零钱兑换</h3><p><ahref="https://leetcode.cn/problems/coin-change/description/">https://leetcode.cn/problems/coin-change/description/</a></p><p>给你一个整数数组 <code>coins</code>，表示不同面额的硬币；以及一个整数 <code>amount</code>，表示总金额。计算并返回可以凑成总金额所需的<strong>最少的硬币个数</strong>如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code></p><p>你可以认为每种硬币的数量是无限的。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：coins = [1, 2, 5], amount = 11<br>输出：3 <br>解释：11 =<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 5 </span>+ 1<br></code></pre></td></tr></table></figure><p>确定dp数组以及下标的含义，<strong>dp[j]：凑足总额为j所需钱币的最少个数为dp[j]</strong></p><p>确定递推公式，凑足总额为<code>j - coins[i]</code>的最少个数为<code>dp[j - coins[i]]</code>，那么只需要加上一个钱币<code>coins[i]</code>即<code>dp[j - coins[i]] + 1</code>就是<code>dp[j]</code>（考虑coins[i]）</p><p>所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的。</p><p>递推公式：<code>dp[j] = min(dp[j - coins[i]] + 1, dp[j]);</code></p><p>完全背包问题，且不是排列问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, INT_MAX)</span></span>;<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;coins.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j =coins[i];j&lt; amount;j++)&#123;<br>                <span class="hljs-keyword">if</span>(dp[j-coins[i]]!=INT_MAX)&#123;<br>                    dp[j] = <span class="hljs-built_in">min</span>(dp[j], dp[j-coins[i]]+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(dp[amount]==INT_MAX) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="完全平方数">完全平方数</h3><p><ahref="https://leetcode.cn/problems/perfect-squares/">https://leetcode.cn/problems/perfect-squares/</a></p><p>给你一个整数 <code>n</code> ，返回 <em>和为 <code>n</code>的完全平方数的最少数量</em> 。</p><p><strong>完全平方数</strong>是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code>和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code>不是。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 12<br>输出：3 <br>解释：12 =<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 4 </span>+ 4<br></code></pre></td></tr></table></figure><p>思路：</p><p>完全背包问题，注意这个地方求解的是最小数量，因此初始化的时候是用INT_MAX来进行初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>, INT_MAX)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i*i&lt;=n;i++)&#123; <br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i*i; j&lt;=n; j++)&#123;<br>                dp[j]= <span class="hljs-built_in">min</span>(dp[j], dp[j-i*i]+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="打家劫舍">打家劫舍</h3><p><ahref="https://leetcode.cn/problems/house-robber/description/">https://leetcode.cn/problems/house-robber/description/</a></p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>不触动警报装置的情况下</strong>，一夜之内能够偷窃到的最高金额。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[1,2,3,1]<br>输出：4<br>解释：偷窃<span class="hljs-number"> 1 </span>号房屋 (金额 = 1) ，然后偷窃<span class="hljs-number"> 3 </span>号房屋 (金额 = 3)。<br>     偷窃到的最高金额 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 4 </span>。<br></code></pre></td></tr></table></figure><p>思路：</p><p>当前房屋偷与不偷取决于 前一个房屋和前两个房屋是否被偷了。</p><p>递推公式为：dp[i]取最大值，即dp[i] = max(dp[i - 2] + nums[i], dp[i -1]);</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size())</span></span>;<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">1</span>],nums[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            dp[i]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-2</span>]+nums[i], dp[i<span class="hljs-number">-1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="打家劫舍ii">打家劫舍II</h3><p><ahref="https://leetcode.cn/problems/house-robber-ii/description/">https://leetcode.cn/problems/house-robber-ii/description/</a></p><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都<strong>围成一圈</strong>，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>在不触动警报装置的情况下</strong>，今晚能够偷窃到的最高金额。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2,3,2]<br>输出：3<br>解释：你不能先偷窃<span class="hljs-number"> 1 </span>号房屋（金额 = 2），然后偷窃<span class="hljs-number"> 3 </span>号房屋（金额 = 2）, 因为他们是相邻的。<br></code></pre></td></tr></table></figure><p>思路：</p><p>如果是一个环的情况，那么需要考虑的是如何转换，既然是首尾相连的情况，那么注意的是分成两种情况，第一种是指考虑开头和倒数第二个，第二种是指考虑第二个到最后一个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> res1 = <span class="hljs-built_in">robrange</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span>);<br>        <span class="hljs-type">int</span> res2 = <span class="hljs-built_in">robrange</span>(nums, <span class="hljs-number">1</span>, nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(res1, res2);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">robrange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(end==start) <span class="hljs-keyword">return</span> nums[start];<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size())</span></span>;<br>        dp[start] = nums[start];<br>        dp[start+<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[start], nums[start+<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =start+<span class="hljs-number">2</span>;i&lt;=end;i++)&#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-2</span>]+nums[i], dp[i<span class="hljs-number">-1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[end];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="买卖股票的最佳时机-1">买卖股票的最佳时机</h3><p><ahref="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/</a></p><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素<code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在<strong>未来的某一个不同的日子</strong>卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回<code>0</code> 。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出，最大利润 = 6-1 =<span class="hljs-number"> 5 </span>。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br></code></pre></td></tr></table></figure><p>思路：</p><p>贪心</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    <span class="hljs-type">int</span> low = INT_MAX;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;prices.<span class="hljs-built_in">size</span>(); i++)&#123;<br>    low = <span class="hljs-built_in">min</span>(low, prices[i]);<br>    res = <span class="hljs-built_in">max</span>(res, prices[i]-low);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>动态规划</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><h3 id="乘积最大子数组">乘积最大子数组</h3><p><ahref="https://leetcode.cn/problems/maximum-product-subarray/description/">https://leetcode.cn/problems/maximum-product-subarray/description/</a></p><p>给你一个整数数组 <code>nums</code>，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><p>测试用例的答案是一个 <strong>32-位</strong> 整数。</p><p><strong>子数组</strong> 是数组的连续子序列。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [2,3,-2,4]</span><br><span class="hljs-section">输出: 6</span><br><span class="hljs-section">解释: 子数组 [2,3] 有最大乘积 6。</span><br></code></pre></td></tr></table></figure><p>思路：</p><p>因为是乘积的问题，所以会存在如果某个值特别小或者是特别大再负负得正之后仍然会出现最大的情况，因此我们在用动态规划记录的时候不仅要记录最大值还需要记录最小值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxp</span><span class="hljs-params">(nums)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minp</span><span class="hljs-params">(nums)</span></span>;<br>        <span class="hljs-type">int</span> res = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            maxp[i]=<span class="hljs-built_in">max</span>(maxp[i<span class="hljs-number">-1</span>]*nums[i], <span class="hljs-built_in">max</span>(nums[i], minp[i<span class="hljs-number">-1</span>]*nums[i]));<br>            res = <span class="hljs-built_in">max</span>(maxp[i], res);<br>            minp[i]=<span class="hljs-built_in">min</span>(minp[i<span class="hljs-number">-1</span>]*nums[i], <span class="hljs-built_in">min</span>(nums[i], maxp[i<span class="hljs-number">-1</span>]*nums[i]));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="最长有效括号">最长有效括号</h3><p><ahref="https://leetcode.cn/problems/longest-valid-parentheses/description/">https://leetcode.cn/problems/longest-valid-parentheses/description/</a></p><p>给你一个只包含 <code>'('</code> 和 <code>')'</code>的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(()&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：最长有效括号子串是 <span class="hljs-string">&quot;()&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;)()())&quot;</span><br>输出：<span class="hljs-number">4</span><br>解释：最长有效括号子串是 <span class="hljs-string">&quot;()()&quot;</span><br></code></pre></td></tr></table></figure><p>思路：</p><p>动态规划，分两类进行讨论，分别考虑最后结尾的元素是不是')'再分成两类进行讨论</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240310163130082.png"alt="image-20240310163130082" /><figcaption aria-hidden="true">image-20240310163130082</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> maxans = <span class="hljs-number">0</span>, n = s.<span class="hljs-built_in">length</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">dp</span>(n,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(s[i<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                    dp[i] = (i &gt;= <span class="hljs-number">2</span> ? dp[i - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>) + <span class="hljs-number">2</span>;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i-dp[i<span class="hljs-number">-1</span>]&gt;<span class="hljs-number">0</span> &amp;&amp; s[i-dp[i<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                    dp[i] = dp[i<span class="hljs-number">-1</span>]+((i-dp[i<span class="hljs-number">-1</span>])&gt;=<span class="hljs-number">2</span>?dp[i-dp[i<span class="hljs-number">-1</span>]<span class="hljs-number">-2</span>]:<span class="hljs-number">0</span>)+<span class="hljs-number">2</span>;<br>                &#125;<br>                maxans = <span class="hljs-built_in">max</span>(maxans, dp[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="最长连续递增序列">最长连续递增序列</h3><p>https://leetcode.cn/problems/longest-continuous-increasing-subsequence/</p><p>给定一个未经排序的整数数组，找到最长且<strong>连续递增的子序列</strong>，并返回该序列的长度。</p><p><strong>连续递增的子序列</strong> 可以由两个下标 <code>l</code> 和<code>r</code>（<code>l &lt; r</code>）确定，如果对于每个<code>l &lt;= i &lt; r</code>，都有<code>nums[i] &lt; nums[i + 1]</code> ，那么子序列<code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code>就是连续递增子序列。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,3,5,4,7]</span><br>输出：3<br>解释：最长连续递增序列是 <span class="hljs-comment">[1,3,5]</span>, 长度为3。<br>尽管 <span class="hljs-comment">[1,3,5,7]</span> 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 <br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,2,2,2,2]</span><br>输出：1<br>解释：最长连续递增序列是 <span class="hljs-comment">[2]</span>, 长度为1。<br></code></pre></td></tr></table></figure><p>思路：</p><p>简单的遍历模拟并用dp数组来存储到目前为止的最长递增序列的长度，本质上也是一种贪心</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLengthOfLCIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(),<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">int</span> s =<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">1</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i<span class="hljs-number">-1</span>]&lt;nums[i])&#123;dp[i] = dp[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;&#125;<br>            s = <span class="hljs-built_in">max</span>(s,dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="无重复字符的最长子串">无重复字符的最长子串</h3><p><ahref="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/</a></p><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的<strong>最长子串</strong>的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure><p>思路：</p><p>滑动窗口法，用一个left来记录对应的左侧没有出现重复的元素，一直进行erase()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">size</span>();<br>        std::unordered_set&lt;<span class="hljs-type">char</span>&gt; lookup;<br>        <span class="hljs-type">int</span> maxstr = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">while</span>(lookup.<span class="hljs-built_in">find</span>(s[i])!=lookup.<span class="hljs-built_in">end</span>())&#123;<br>                lookup.<span class="hljs-built_in">erase</span>(s[left]);<br>                left++;<br>            &#125;<br>            maxstr = <span class="hljs-built_in">max</span>(maxstr, i-left+<span class="hljs-number">1</span>);<br>            lookup.<span class="hljs-built_in">insert</span>(s[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxstr;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="最长递增子序列">最长递增子序列</h3><p><ahref="https://leetcode.cn/problems/longest-increasing-subsequence/description/">https://leetcode.cn/problems/longest-increasing-subsequence/description/</a></p><p>给你一个整数数组 <code>nums</code>，找到其中最长严格递增子序列的长度。</p><p><strong>子序列</strong>是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code>是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">10,9,2,5</span>,<span class="hljs-number">3,7,101,18</span>]<br>输出：<span class="hljs-number">4</span><br>解释：最长递增子序列是 [<span class="hljs-number">2,3,7,101</span>]，因此长度为 <span class="hljs-number">4</span> 。<br></code></pre></td></tr></table></figure><p>思路：</p><p>既然涉及到非连续的子序列，那么在处理的时候就需要用两个指针来标记两个位置遍历</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> lengthOfLIS(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-built_in">int</span>&gt; dp(nums.<span class="hljs-built_in">size</span>(),<span class="hljs-number">0</span>);<br>        for(<span class="hljs-built_in">int</span> i =<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            dp[i]=<span class="hljs-number">1</span>;<br>            for(<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[j]&lt;nums[i])&#123;<br>                    dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j]+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *max_element(dp.begin(), dp.<span class="hljs-keyword">end</span>());;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="最长重复子数组">最长重复子数组</h3><p><ahref="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/">https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/</a></p><p>给两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，返回<em>两个数组中 <strong>公共的</strong> 、长度最长的子数组的长度</em>。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1,2,3,2,1]</span>, nums2 = <span class="hljs-comment">[3,2,1,4,7]</span><br>输出：3<br>解释：长度最长的公共子数组是 <span class="hljs-comment">[3,2,1]</span> 。<br></code></pre></td></tr></table></figure><p>思路：</p><p>在比较i，j对的时候，当然希望能够利用到前面的i-1和j-1的结果，因此用二维的动态规划来提示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(nums1.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(nums2.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i= nums1.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j= nums2.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br>                dp[i][j] = nums1[i]==nums2[j]?dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>                ans = <span class="hljs-built_in">max</span>(ans, dp[i][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="回文子串">回文子串</h3><p><ahref="https://leetcode.cn/problems/palindromic-substrings/description/">https://leetcode.cn/problems/palindromic-substrings/description/</a></p><p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中<strong>回文子串</strong> 的数目。</p><p><strong>回文字符串</strong> 是正着读和倒过来读一样的字符串。</p><p><strong>子字符串</strong> 是字符串中的由连续字符组成的一个序列。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：三个回文子串: <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;aaa&quot;</span><br>输出：<span class="hljs-number">6</span><br>解释：<span class="hljs-number">6</span>个回文子串: <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;aaa&quot;</span><br></code></pre></td></tr></table></figure><p>思路：</p><p>计算有多少个回文子串的最朴素方法就是枚举出所有的回文子串，而枚举出所有的回文字串又有两种思路，分别是：</p><ul><li><p>枚举出所有的子串，然后再判断这些子串是否是回文；</p></li><li><p>枚举每一个可能的回文中心，然后用两个指针分别向左右两边拓展，当两个指针指向的元素相同的时候就拓展，否则停止拓展。</p></li></ul><p>因此我们这里可以用中心拓展法来解决这个问题</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240310190137229.png" alt="中心拓展问题" style="zoom:50%;" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>(), ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>;i++)&#123;<br>            <span class="hljs-type">int</span> l = i/<span class="hljs-number">2</span>, r=i/<span class="hljs-number">2</span>+i%<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">while</span>(l&gt;=<span class="hljs-number">0</span> &amp;&amp; r&lt;n &amp;&amp; s[l]==s[r])&#123;<br>                --l;<br>                ++r;<br>                ++ans;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="最长公共子序列">最长公共子序列</h3><p><ahref="https://leetcode.cn/problems/longest-common-subsequence/">https://leetcode.cn/problems/longest-common-subsequence/</a></p><p>给定两个字符串 <code>text1</code> 和<code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong>的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code>。一个字符串的 <strong>子序列</strong>是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">text1</span> = <span class="hljs-string">&quot;abcde&quot;</span>, <span class="hljs-attr">text2</span> = <span class="hljs-string">&quot;ace&quot;</span> <br>输出：<span class="hljs-number">3</span>  <br>解释：最长公共子序列是 <span class="hljs-string">&quot;ace&quot;</span> ，它的长度为 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">text1</span> = <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-attr">text2</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：最长公共子序列是 <span class="hljs-string">&quot;abc&quot;</span> ，它的长度为 <span class="hljs-number">3</span> <br></code></pre></td></tr></table></figure><p>思路：</p><p>使用动态规划进行求解，其中dp的<strong>二维数组</strong>中记录的元素是:i和:j范围内的最大的公共子序列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = text1.<span class="hljs-built_in">length</span>(), n = text2.<span class="hljs-built_in">length</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            <span class="hljs-type">char</span> c1 = text1.<span class="hljs-built_in">at</span>(i<span class="hljs-number">-1</span>);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; j++)&#123;<br>                <span class="hljs-type">char</span> c2 = text2.<span class="hljs-built_in">at</span>(j<span class="hljs-number">-1</span>);<br>                <span class="hljs-keyword">if</span>(c1==c2)&#123;<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="编辑距离">编辑距离</h3><p><ahref="https://leetcode.cn/problems/edit-distance/description/">https://leetcode.cn/problems/edit-distance/description/</a></p><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将<code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em>。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p><strong>示例 1：</strong></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xl">输入：word1 = <span class="hljs-string">&quot;horse&quot;</span>, word2 = <span class="hljs-string">&quot;ros&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：<br><span class="hljs-function"><span class="hljs-title">horse</span> -&gt;</span> rorse (将 <span class="hljs-string">&#x27;h&#x27;</span> 替换为 <span class="hljs-string">&#x27;r&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">rorse</span> -&gt;</span> rose (删除 <span class="hljs-string">&#x27;r&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">rose</span> -&gt;</span> ros (删除 <span class="hljs-string">&#x27;e&#x27;</span>)<br></code></pre></td></tr></table></figure><p>思路：</p><p>题目给定了两个单词，设为 A 和 B，这样我们就能够六种操作方法。</p><p>但我们可以发现，如果我们有单词 A 和单词 B：</p><p>对单词 A 删除一个字符和对单词 B 插入一个字符是等价的。例如当单词 A 为doge，单词 B 为 dog 时，我们既可以删除单词 A 的最后一个字符e，得到相同的 dog，也可以在单词 B 末尾添加一个字符 e，得到相同的doge；</p><p>同理，对单词 B 删除一个字符和对单词 A 插入一个字符也是等价的；</p><p>对单词 A 替换一个字符和对单词 B 替换一个字符是等价的。例如当单词 A 为bat，单词 B 为 cat 时，我们修改单词 A 的第一个字母 b -&gt; c，和修改单词B 的第一个字母 c -&gt; b 是等价的。</p><p>这样以来，本质不同的操作实际上只有三种：</p><p>在单词 A 中插入一个字符；</p><p>在单词 B 中插入一个字符；</p><p>修改单词 A 的一个字符。</p><p>我们用 <code>D[i][j]</code> 表示 <code>A</code> 的前 <code>i</code>个字母和 <code>B</code> 的前 <code>j</code> 个字母之间的编辑距离。</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240310191703835.png" alt="编辑距离题解" style="zoom:50%;" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = word1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> m = word2.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-comment">//其中有一个子字符串为空字符串</span><br>        <span class="hljs-keyword">if</span> (n*m==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> n+m;<br><br>        <span class="hljs-comment">//DP数组</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m+<span class="hljs-number">1</span>));<br><br>        <span class="hljs-comment">//边界状态初始化</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;n+<span class="hljs-number">1</span>;i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j =<span class="hljs-number">0</span>;j&lt;m+<span class="hljs-number">1</span>;j++)&#123;<br>            dp[<span class="hljs-number">0</span>][j] = j;<br>        &#125;<br><br>        <span class="hljs-comment">//循环计算DP</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n+<span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;m+<span class="hljs-number">1</span>; j++)&#123;<br>                <span class="hljs-type">int</span> left = dp[i<span class="hljs-number">-1</span>][j]+<span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> down = dp[i][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> left_down = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>                <span class="hljs-keyword">if</span>(word1[i<span class="hljs-number">-1</span>]!=word2[j<span class="hljs-number">-1</span>]) left_down +=<span class="hljs-number">1</span>;<br>                dp[i][j] = <span class="hljs-built_in">min</span>(left, <span class="hljs-built_in">min</span>(down, left_down));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][m];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="正则表达式匹配">正则表达式匹配</h3><p><ahref="https://leetcode.cn/problems/regular-expression-matching/description/">https://leetcode.cn/problems/regular-expression-matching/description/</a></p><p>给你一个字符串 <code>s</code> 和一个字符规律<code>p</code>，请你来实现一个支持 <code>'.'</code> 和 <code>'*'</code>的正则表达式匹配。</p><ul><li><code>'.'</code> 匹配任意单个字符</li><li><code>'*'</code> 匹配零个或多个前面的那一个元素</li></ul><p>所谓匹配，是要涵盖 <strong>整个</strong> 字符串<code>s</code>的，而不是部分字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-attr">p</span> = <span class="hljs-string">&quot;a&quot;</span><br>输出：<span class="hljs-literal">false</span><br>解释：<span class="hljs-string">&quot;a&quot;</span> 无法匹配 <span class="hljs-string">&quot;aa&quot;</span> 整个字符串。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：s = <span class="hljs-string">&quot;aa&quot;</span>, p = <span class="hljs-string">&quot;a*&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：因为 <span class="hljs-string">&#x27;*&#x27;</span> 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 <span class="hljs-string">&#x27;a&#x27;</span>。因此，字符串 <span class="hljs-string">&quot;aa&quot;</span> 可被视为 <span class="hljs-string">&#x27;a&#x27;</span> 重复了一次。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：s = <span class="hljs-string">&quot;ab&quot;</span>, p = <span class="hljs-string">&quot;.*&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：<span class="hljs-string">&quot;.*&quot;</span> 表示可匹配零个或多个（<span class="hljs-string">&#x27;*&#x27;</span>）任意字符（<span class="hljs-string">&#x27;.&#x27;</span>）。<br></code></pre></td></tr></table></figure><p>思路：</p><ol type="1"><li><strong>定义状态：</strong> 创建一个二维数组 <code>dp</code>，其中<code>dp[i][j]</code> 表示 <code>s</code> 的前 <code>i</code> 个字符与<code>p</code> 的前 <code>j</code> 个字符是否匹配。</li><li><strong>初始化：</strong><ol type="1"><li><code>dp[0][0]</code> 为<code>true</code>，因为两个空字符串是匹配的。</li><li>初始化 <code>dp[0][j]</code>，处理模式 <code>p</code> 的前<code>j</code> 个字符与空字符串 <code>s</code> 的匹配情况。这通常依赖于<code>'*'</code> 字符，因为 <code>'*'</code> 可以表示重复前面的字符 0次。</li></ol></li><li><strong>状态转移方程：</strong><ol type="1"><li>当 <code>s[i-1] == p[j-1]</code> 或 <code>p[j-1] == '.'</code>时，<code>dp[i][j] = dp[i-1][j-1]</code>。</li><li>当 <code>p[j-1] == '*'</code> 时，需要分两种情况考虑：<ul><li>如果 <code>p[j-2]</code> 不匹配 <code>s[i-1]</code>，则<code>'*'</code> 表示它前面的字符出现 0次，<code>dp[i][j] = dp[i][j-2]</code>。</li><li>如果 <code>p[j-2]</code> 匹配<code>s[i-1]</code>，则存在多种可能性（<code>'*'</code>表示前面的字符出现 0 次、1次或多次），<code>dp[i][j] = dp[i][j-2] || dp[i][j-1] || dp[i-1][j]</code>。</li></ul></li></ol></li><li><strong>循环顺序：</strong> 从左到右，从上到下遍历 <code>dp</code>数组。</li><li><strong>返回结果：</strong> <code>dp[len(s)][len(p)]</code> 表示整个<code>s</code> 和 <code>p</code> 是否匹配</li></ol><h1 id="栈队列单调栈">栈&amp;队列&amp;单调栈</h1><h3 id="有效括号">有效括号</h3><p><ahref="https://leetcode.cn/problems/valid-parentheses/description/">https://leetcode.cn/problems/valid-parentheses/description/</a></p><p>给定一个只包括<code>'('</code>，<code>')'</code>，<code>'&#123;'</code>，<code>'&#125;'</code>，<code>'['</code>，<code>']'</code>的字符串 <code>s</code> ，判断字符串是否有效。</p><ol type="1"><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;()&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>思路：简单的判断栈</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ismatch</span><span class="hljs-params">(<span class="hljs-type">char</span> a, <span class="hljs-type">char</span> b)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>((a==<span class="hljs-string">&#x27;)&#x27;</span>&amp;&amp;b==<span class="hljs-string">&#x27;(&#x27;</span>)||(a==<span class="hljs-string">&#x27;&#125;&#x27;</span>&amp;&amp;b==<span class="hljs-string">&#x27;&#123;&#x27;</span>)||(a==<span class="hljs-string">&#x27;]&#x27;</span>&amp;&amp;b==<span class="hljs-string">&#x27;[&#x27;</span>))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">char</span>&gt;st;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;)&#x27;</span>||s[i]==<span class="hljs-string">&#x27;&#125;&#x27;</span>||s[i]==<span class="hljs-string">&#x27;]&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(!st.<span class="hljs-built_in">empty</span>()&amp;&amp;<span class="hljs-built_in">ismatch</span>(s[i],st.<span class="hljs-built_in">top</span>()))&#123;<br>                    st.<span class="hljs-built_in">pop</span>();<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                st.<span class="hljs-built_in">push</span>(s[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="删除相邻重复">删除相邻重复</h3><p><strong>示例：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：<span class="hljs-string">&quot;abbaca&quot;</span><br>输出：<span class="hljs-string">&quot;ca&quot;</span><br>解释：<br>例如，在 <span class="hljs-string">&quot;abbaca&quot;</span> 中，我们可以删除 <span class="hljs-string">&quot;bb&quot;</span> 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 <span class="hljs-string">&quot;aaca&quot;</span>，其中又只有 <span class="hljs-string">&quot;aa&quot;</span> 可以执行重复项删除操作，所以最后的字符串为 <span class="hljs-string">&quot;ca&quot;</span>。<br></code></pre></td></tr></table></figure><p><ahref="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/">https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">char</span>&gt;st;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c:s)&#123;<br>            <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">empty</span>()||c!=st.<span class="hljs-built_in">top</span>())&#123;<br>                st.<span class="hljs-built_in">push</span>(c);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        string res=<span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>())&#123;<br>            res+=st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">//注意这个地方需要反转一下字符串</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="逆波兰表达式求值">逆波兰表达式求值</h3><p><ahref="https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/">https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/</a></p><p>给你一个字符串数组 <code>tokens</code> ，表示一个根据 <ahref="https://baike.baidu.com/item/逆波兰式/128437">逆波兰表示法</a>表示的算术表达式。请你计算该表达式。返回一个表示表达式值的整数。</p><p><strong>示例 1：</strong></p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">输入：<span class="hljs-built_in">tokens</span> = [<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;+&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;*&quot;</span>]<br>输出：<span class="hljs-number">9</span><br>解释：该算式转化为常见的中缀算术表达式为：((<span class="hljs-number">2</span> + <span class="hljs-number">1</span>) * <span class="hljs-number">3</span>) = <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">输入：<span class="hljs-built_in">tokens</span> = [<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;13&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;/&quot;</span>,<span class="hljs-string">&quot;+&quot;</span>]<br>输出：<span class="hljs-number">6</span><br>解释：该算式转化为常见的中缀算术表达式为：(<span class="hljs-number">4</span> + (<span class="hljs-number">13</span> / <span class="hljs-number">5</span>)) = <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>思路：</p><p>利用栈的思想模拟运算的过程，按照tokens的顺序将数字放进栈中，遇到运算符那么就拿出栈中的数字，运算结束之后再放进栈中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt;st;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;tokens.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(tokens[i]!=<span class="hljs-string">&quot;/&quot;</span>&amp;&amp;tokens[i]!=<span class="hljs-string">&quot;+&quot;</span>&amp;&amp;tokens[i]!=<span class="hljs-string">&quot;-&quot;</span>&amp;&amp;tokens[i]!=<span class="hljs-string">&quot;*&quot;</span>)&#123;<br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">stoi</span>(tokens[i]));<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-type">int</span> num1 = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-type">int</span> num2 = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (tokens[i] == <span class="hljs-string">&quot;+&quot;</span>) st.<span class="hljs-built_in">push</span>(num2 + num1);<br>                <span class="hljs-keyword">if</span> (tokens[i] == <span class="hljs-string">&quot;-&quot;</span>) st.<span class="hljs-built_in">push</span>(num2 - num1);<br>                <span class="hljs-keyword">if</span> (tokens[i] == <span class="hljs-string">&quot;*&quot;</span>) st.<span class="hljs-built_in">push</span>(num2 * num1);<br>                <span class="hljs-keyword">if</span> (tokens[i] == <span class="hljs-string">&quot;/&quot;</span>) st.<span class="hljs-built_in">push</span>(num2 / num1);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> result = st.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="前k个高频元素">前K个高频元素</h3><p><ahref="https://leetcode.cn/problems/top-k-frequent-elements/description/">https://leetcode.cn/problems/top-k-frequent-elements/description/</a></p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code>，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按<strong>任意顺序</strong> 返回答案。</p><p><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: nums = <span class="hljs-comment">[1,1,1,2,2,3]</span>, k = 2<br>输出: <span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240206140055727.png" alt="前k个高频元素的思路图" style="zoom:50%;" /></p><p>这道题目主要涉及到如下三块内容：</p><ol type="1"><li>要统计元素出现频率</li><li>对频率排序</li><li>找出前K个高频元素</li></ol><p>首先统计元素出现的频率，这一类的问题可以使用map来进行统计。</p><p>然后是对频率进行排序，这里我们可以使用一种容器适配器就是<strong>优先级队列</strong></p><p>优先级队列内部元素是自动依照元素的权值排列。那么它是如何有序排列的呢？</p><p>缺省情况下priority_queue利用max-heap（大顶堆）完成对元素的排序，这个大顶堆是以vector为表现形式的completebinary tree（完全二叉树）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">mycomparison</span>&#123;<br>        <span class="hljs-keyword">public</span>:<br>            <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; rhs)</span></span>&#123;<br>                <span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br>            &#125;<br>    &#125;;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">//统计元素出现的频率</span><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            map[nums[i]]++;<br>        &#125;<br><br>        <span class="hljs-comment">//对频率进行排序</span><br>        <span class="hljs-comment">//定义一个小顶堆，大小为k</span><br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, mycomparison&gt; pri_que;<br><br>        <span class="hljs-comment">//用固定大小为k的小顶堆，扫面所有频率的数值</span><br>        <span class="hljs-keyword">for</span>(unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator it=map.<span class="hljs-built_in">begin</span>(); it!=map.<span class="hljs-built_in">end</span>(); it++)&#123;<br>            pri_que.<span class="hljs-built_in">push</span>(*it);<br>            <span class="hljs-keyword">if</span>(pri_que.<span class="hljs-built_in">size</span>()&gt;k)&#123;<br>                pri_que.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//找出前面k个高频元素，因为小顶堆先弹出的是最小的，所以倒序输出到数组</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(k)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=k<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            res[i]=pri_que.<span class="hljs-built_in">top</span>().first;<br>            pri_que.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="每日温度">每日温度</h3><p>给定一个整数数组 <code>temperatures</code>，表示每天的温度，返回一个数组 <code>answer</code> ，其中<code>answer[i]</code> 是指对于第 <code>i</code>天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用<code>0</code> 来代替。</p><p><strong>示例 1:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: temperatures = [<span class="hljs-number">73,74,75,71</span>,<span class="hljs-number">69,72,76,73</span>]<br>输出: [<span class="hljs-number">1,1,4,2</span>,<span class="hljs-number">1,1,0,0</span>]<br></code></pre></td></tr></table></figure><p>思路：</p><p>可以选择使用<strong>单调栈的方法</strong>来求解，具体的思路是设置一个栈，遍历数组的时候和栈顶元素进行比较，小于栈顶元素的时候就需要将当前元素放入栈中</p><p>首先这道题必须有一个向量数组来存储对应位置的元素的值，<code>vector&lt;int&gt; res(temperatures.size(),0)</code>方便修改对应的元素</p><p>如果大于当前的栈顶元素的值，那么就要进行比较<code>while</code>循环，只要还是大于当前栈顶的元素都需要对栈顶的元素进行<code>pop()</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; temperatures)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(temperatures.size(),<span class="hljs-number">0</span>)</span></span>;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;temperatures.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(temperatures[i]&lt;=temperatures[st.<span class="hljs-built_in">top</span>()])&#123;<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()&amp;&amp; temperatures[i]&gt;temperatures[st.<span class="hljs-built_in">top</span>()])&#123;<br>                    res[st.<span class="hljs-built_in">top</span>()]=i-st.<span class="hljs-built_in">top</span>();<br>                    st.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="图论">图论</h1><h3 id="深度优先搜索理论">深度优先搜索理论</h3><p>深度优先搜索和回溯的思路大体上是一样的</p><ul><li>搜索方向，是认准一个方向搜，直到碰壁之后再换方向</li><li>换方向是撤销原路径，改为节点链接的下一个路径，回溯的过程。</li></ul><p>就地递归函数的下面，例如如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(参数)</span> </span>&#123;<br>    处理节点<br>    <span class="hljs-built_in">dfs</span>(图，选择的节点); <span class="hljs-comment">// 递归</span><br>    回溯，撤销处理结果<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到回溯操作就在递归函数的下面，递归和回溯是相辅相成的</p><p>深度优先搜索的三部曲：</p><ol type="1"><li><p><strong>确认递归函数，参数</strong></p><p>深搜需要二维数组数组结构保存所有路径，需要一维数组保存单一路径，这种保存结果的数组，我们可以定义一个全局变量，避免让我们的函数参数过多。</p></li><li><p><strong>确认终止条件</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (终止条件) &#123;<br>    存放结果;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>终止添加不仅是结束本层递归，同时也是我们收获结果的时候。</p></li><li><p><strong>处理目前搜索节点出发的路径</strong></p></li></ol><p>一般这里就是一个for循环的操作，去遍历 目前搜索节点所能到的所有节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (选择：本节点所连接的其他节点) &#123;<br>    处理节点;<br>    <span class="hljs-built_in">dfs</span>(图，选择的节点); <span class="hljs-comment">// 递归</span><br>    回溯，撤销处理结果<br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240224164602244.png"alt="回溯，撤销处理的结果" /><figcaption aria-hidden="true">回溯，撤销处理的结果</figcaption></figure><h3 id="广度优先搜索理论">广度优先搜索理论</h3><p>广搜的搜索方式就适合于解决两个点之间的最短路径问题。</p><p>因为广搜是从起点出发，以起始点为中心一圈一圈进行搜索，一旦遇到终点，记录之前走过的节点就是一条最短路。</p><p>广度优先搜索代码模版：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>  <span class="hljs-comment">// 定义队列</span><br>  queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;que;<br>  que.<span class="hljs-built_in">push</span>(&#123;x,y&#125;);<br>  visited[x][y] = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>    pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cur = que.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">//选择队列中第一个元素</span><br>    que.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 从队列中取出元素</span><br>    <span class="hljs-type">int</span> curx = cur.first;<br>    <span class="hljs-type">int</span> cury = cur.second;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>      <span class="hljs-type">int</span> nextx = curx+dir[i][<span class="hljs-number">0</span>];<br>      <span class="hljs-type">int</span> nexty = cury+dir[i][<span class="hljs-number">1</span>];<br>      <span class="hljs-keyword">if</span>(nextx&lt;<span class="hljs-number">0</span> || nextx&gt;=grid.<span class="hljs-built_in">size</span>() ||nexty&lt;<span class="hljs-number">0</span>||nexty&gt;=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;<br>      <span class="hljs-keyword">if</span>(!visited[nextx][nexty])&#123;<br>        que.<span class="hljs-built_in">push</span>(&#123;nextx,nexty&#125;);<br>        visited[nextx][nexty] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//立刻标记，避免重复访问</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="所有可能的路径">所有可能的路径</h3><p><ahref="https://leetcode.cn/problems/all-paths-from-source-to-target/description/">https://leetcode.cn/problems/all-paths-from-source-to-target/description/</a></p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240129130942760.png" alt="图路径遍历" style="zoom:50%;" /></p><p>给你一个有 <code>n</code> 个节点的<strong>有向无环图（DAG）</strong>，请你找出所有从节点 <code>0</code>到节点 <code>n-1</code>的路径并输出（<strong>不要求按特定顺序</strong>） <code>graph[i]</code>是一个从节点 <code>i</code> 可以访问的所有节点的列表（即从节点<code>i</code> 到节点 <code>graph[i][j]</code>存在一条有向边）。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：graph = <span class="hljs-string">[[1,2],[3],[3],[]]</span><br>输出：<span class="hljs-string">[[0,1,3],[0,2,3]]</span><br>解释：有两条路径 <span class="hljs-number">0</span> -&gt; <span class="hljs-number">1</span> -&gt; <span class="hljs-number">3</span> 和 <span class="hljs-number">0</span> -&gt; <span class="hljs-number">2</span> -&gt; <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>思路：</p><p>深度优先搜索</p><p>注意在用dfs做题的时候需要初始化<code>path.push_back(0)</code>每一次都需要初始化输入这个数值起点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> x)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(x == graph.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;graph[x].<span class="hljs-built_in">size</span>();i++)&#123;<br>            path.<span class="hljs-built_in">push_back</span>(graph[x][i]);<br>            <span class="hljs-built_in">dfs</span>(graph,graph[x][i]);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">allPathsSourceTarget</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph) &#123;<br>        path.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">dfs</span>(graph, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="岛屿数量">岛屿数量</h3><p><ahref="https://leetcode.cn/problems/number-of-islands/description/">https://leetcode.cn/problems/number-of-islands/description/</a></p><p>给你一个由 <code>'1'</code>（陆地）和<code>'0'</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p><strong>示例 ：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：grid = [<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>]<br>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>深度优先搜索版本：</p><p>思路在于利用dfs来对岛屿中的数量进行标记是否能visited，必须是联通的才能继续标记为<code>res++</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] =&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<span class="hljs-comment">//四个方向</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>        <span class="hljs-type">int</span> nextx = x +dir[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> nexty = y +dir[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(nextx&lt;<span class="hljs-number">0</span>||nexty&gt;grid.<span class="hljs-built_in">size</span>()||nexty&lt;<span class="hljs-number">0</span>||nexty&gt;grid[<span class="hljs-number">0</span>].size) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty]==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>          visited[nextx][nexty] = <span class="hljs-literal">true</span>;<br>          <span class="hljs-built_in">dfs</span>(grid, visited, nextx, nexty);<br>        &#125;<br>      &#125;<br>    &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span></span>&#123;<br>    <span class="hljs-type">int</span> n = grid.<span class="hljs-built_in">size</span>(), m = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; visited = vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt; n;i++)&#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>        <span class="hljs-keyword">if</span>(!visited[i][j]&amp;&amp;grid[i][j]==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>          visited[i][j]=<span class="hljs-literal">true</span>;<br>          res++;<br>          <span class="hljs-built_in">dfs</span>(grid, visited, i, j);<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>广度优先搜索版本</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>      queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;que;<br>      que.<span class="hljs-built_in">push</span>(&#123;x,y&#125;);<br>      visited[x][y] = <span class="hljs-literal">true</span>;<br>      <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>        pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cur = que.<span class="hljs-built_in">front</span>();<br>        que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> curx = cur.first;<br>        <span class="hljs-type">int</span> cury = cur.second;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>          <span class="hljs-type">int</span> nextx = curx+dir[i][<span class="hljs-number">0</span>];<br>          <span class="hljs-type">int</span> nexty = cury+dir[i][<span class="hljs-number">1</span>];<br>          <span class="hljs-keyword">if</span>(nextx&lt;<span class="hljs-number">0</span>||nextx&gt;grid.<span class="hljs-built_in">size</span>()||nexty&lt;<span class="hljs-number">0</span>||nextt&gt;grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;<br>          <span class="hljs-keyword">if</span>(!visited[nextx][nexty]&amp;&amp;grid[nextx][nexty]==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>            que.<span class="hljs-built_in">push</span>(&#123;nextx,nexty&#125;);<br>            visited[nextx][nexty] = <span class="hljs-literal">true</span>;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = grid.<span class="hljs-built_in">size</span>(), m = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>      vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; visited = vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br>      <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>          <span class="hljs-keyword">if</span>(!visited[i][j]&amp;&amp;gird[i][j]==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>            res++;<br>            <span class="hljs-built_in">bfs</span>(grid, visited, i, j);<br>          &#125;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="岛屿的最大面积">岛屿的最大面积</h3><p><ahref="https://leetcode.cn/problems/max-area-of-island/description/">https://leetcode.cn/problems/max-area-of-island/description/</a></p><p>给你一个大小为 <code>m x n</code> 的二进制矩阵 <code>grid</code>。</p><p><strong>岛屿</strong> 是由一些相邻的 <code>1</code> (代表土地)构成的组合，这里的「相邻」要求两个 <code>1</code> 必须在<strong>水平或者竖直的四个方向上</strong> 相邻。你可以假设<code>grid</code> 的四个边缘都被 <code>0</code>（代表水）包围着。</p><p>岛屿的面积是岛上值为 <code>1</code> 的单元格的数目。</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240224172315611.png"alt="岛屿的最大数量" /><figcaption aria-hidden="true">岛屿的最大数量</figcaption></figure><p>深度优先搜索算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> count;<br>    <span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>            <span class="hljs-type">int</span> nextx = x+dir[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> nexty = y+dir[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(nextx&lt;<span class="hljs-number">0</span>||nextx&gt;=grid.<span class="hljs-built_in">size</span>()||nexty&lt;<span class="hljs-number">0</span>||nexty&gt;=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(!visited[nextx][nexty]&amp;&amp; grid[nextx][nexty]==<span class="hljs-number">1</span>)&#123;<br>                visited[nextx][nexty]=<span class="hljs-literal">true</span>;<br>                count++;<br>                <span class="hljs-built_in">dfs</span>(grid, visited, nextx, nexty);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = grid.<span class="hljs-built_in">size</span>(), m=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; visited = vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>                <span class="hljs-keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    count = <span class="hljs-number">1</span>;<br>                    visited[i][j] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-built_in">dfs</span>(grid, visited, i, j);<br>                    res = <span class="hljs-built_in">max</span>(res, count);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>广度优先搜索</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>        queue&lt;<span class="hljs-type">int</span>&gt; que;<br>        que.<span class="hljs-built_in">push</span>(x);<br>        que.<span class="hljs-built_in">push</span>(y);<br>        visited[x][y]=<span class="hljs-literal">true</span>;<br>        count++;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> xx = que.<span class="hljs-built_in">front</span>();que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> yy = que.<span class="hljs-built_in">front</span>();que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>                <span class="hljs-type">int</span> nextx = xx+dir[i][<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> nexty = yy+dir[i][<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(nextx&lt;<span class="hljs-number">0</span>||nextx&gt;=grid.<span class="hljs-built_in">size</span>()||nexty&lt;<span class="hljs-number">0</span>||nexty&gt;=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(!visited[nextx][nexty]&amp;&amp; grid[nextx][nexty]==<span class="hljs-number">1</span>)&#123;<br>                    count++;<br>                    visited[nextx][nexty]=<span class="hljs-literal">true</span>;<br>                    que.<span class="hljs-built_in">push</span>(nextx);<br>                    que.<span class="hljs-built_in">push</span>(nexty);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n= grid.<span class="hljs-built_in">size</span>(), m=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;visited = vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>                <span class="hljs-keyword">if</span>(!visited[i][j]&amp;&amp;grid[i][j]==<span class="hljs-number">1</span>)&#123;<br>                    count =<span class="hljs-number">0</span>;<br>                    <span class="hljs-built_in">bfs</span>(grid, visited, i, j);<br>                    res = <span class="hljs-built_in">max</span>(res , count);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="飞地的数量">飞地的数量</h3><p><ahref="https://leetcode.cn/problems/number-of-enclaves/description/">https://leetcode.cn/problems/number-of-enclaves/description/</a></p><p>给你一个大小为 <code>m x n</code> 的二进制矩阵 <code>grid</code>，其中 <code>0</code> 表示一个海洋单元格、<code>1</code>表示一个陆地单元格。一次 <strong>移动</strong>是指从一个陆地单元格走到另一个相邻（<strong>上、下、左、右</strong>）的陆地单元格或跨过<code>grid</code> 的边界。返回网格中 <strong>无法</strong>在任意次数的移动中离开网格边界的陆地单元格的数量。</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240224222001801.png" alt="飞地的数量" style="zoom:67%;" /></p><p>思路：</p><p>利用dfs或者是bfs的方法先把边界周围的岛屿全部去除为0</p><p>然后再对剩下的进行计数，每出现一块地就增加一个计数单位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-type">int</span> count;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>        grid[x][y] =<span class="hljs-number">0</span>;<br>        count++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i= <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>            <span class="hljs-type">int</span> nextx = x +dir[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> nexty = y +dir[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(nextx&lt;<span class="hljs-number">0</span>||nextx&gt;=grid.<span class="hljs-built_in">size</span>()||nexty&lt;<span class="hljs-number">0</span>||nexty&gt;=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(grid[nextx][nexty]==<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-built_in">dfs</span>(grid, nextx, nexty);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numEnclaves</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = grid.<span class="hljs-built_in">size</span>(), m=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(grid[i][<span class="hljs-number">0</span>]==<span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(grid, i, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span>(grid[i][m<span class="hljs-number">-1</span>]==<span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(grid, i, m<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            <span class="hljs-keyword">if</span>(grid[<span class="hljs-number">0</span>][j]==<span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(grid, <span class="hljs-number">0</span>, j);<br>            <span class="hljs-keyword">if</span>(grid[n<span class="hljs-number">-1</span>][j]==<span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(grid, n<span class="hljs-number">-1</span>, j);<br>        &#125;<br><br>        count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(grid, i, j);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="被围绕的区域">被围绕的区域</h3><p><ahref="https://leetcode.cn/problems/surrounded-regions/description/">https://leetcode.cn/problems/surrounded-regions/description/</a></p><p>给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符<code>'X'</code> 和 <code>'O'</code> ，找到所有被 <code>'X'</code>围绕的区域，并将这些区域里所有的 <code>'O'</code> 用 <code>'X'</code>填充。</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240224230446459.png" alt="被围绕的区域" style="zoom: 50%;" /></p><p>思路：</p><p>利用深度优先搜索的方法先将边界的联通区域全部设置为A，中间的部分不动，完全设置完成之后再进行逐一的赋值调整</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240224230638690.png"alt="基本的思路调整" /><figcaption aria-hidden="true">基本的思路调整</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>        board[x][y]=<span class="hljs-string">&#x27;A&#x27;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>            <span class="hljs-type">int</span> nextx = x+dir[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> nexty = y+dir[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(nextx&lt;<span class="hljs-number">0</span>||nextx&gt;=board.<span class="hljs-built_in">size</span>()||nexty&lt;<span class="hljs-number">0</span>||nexty&gt;=board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(board[nextx][nexty]==<span class="hljs-string">&#x27;X&#x27;</span>||board[nextx][nexty]==<span class="hljs-string">&#x27;A&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">dfs</span>(board, nextx, nexty);<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n= board.<span class="hljs-built_in">size</span>(), m=board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(board[i][<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;O&#x27;</span>) <span class="hljs-built_in">dfs</span>(board, i,<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span>(board[i][m<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;O&#x27;</span>) <span class="hljs-built_in">dfs</span>(board, i, m<span class="hljs-number">-1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            <span class="hljs-keyword">if</span>(board[<span class="hljs-number">0</span>][j]==<span class="hljs-string">&#x27;O&#x27;</span>) <span class="hljs-built_in">dfs</span>(board, <span class="hljs-number">0</span>, j);<br>            <span class="hljs-keyword">if</span>(board[n<span class="hljs-number">-1</span>][j]==<span class="hljs-string">&#x27;O&#x27;</span>) <span class="hljs-built_in">dfs</span>(board, n<span class="hljs-number">-1</span>, j);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>; i&lt;n ;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>                <span class="hljs-keyword">if</span>(board[i][j]==<span class="hljs-string">&#x27;O&#x27;</span>) board[i][j]=<span class="hljs-string">&#x27;X&#x27;</span>;;<br>                <span class="hljs-keyword">if</span>(board[i][j]==<span class="hljs-string">&#x27;A&#x27;</span>) board[i][j]=<span class="hljs-string">&#x27;O&#x27;</span>;<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="太平洋大西洋水流问题">太平洋大西洋水流问题</h3><p><ahref="https://leetcode.cn/problems/pacific-atlantic-water-flow/description/">https://leetcode.cn/problems/pacific-atlantic-water-flow/description/</a></p><p>有一个 <code>m × n</code> 的矩形岛屿，与 <strong>太平洋</strong> 和<strong>大西洋</strong> 相邻。 <strong>“太平洋”</strong>处于大陆的左边界和上边界，而 <strong>“大西洋”</strong>处于大陆的右边界和下边界。</p><p>这个岛被分割成一个由若干方形单元格组成的网格。给定一个<code>m x n</code> 的整数矩阵 <code>heights</code> ，<code>heights[r][c]</code> 表示坐标 <code>(r, c)</code> 上单元格<strong>高于海平面的高度</strong> 。</p><p>岛上雨水较多，如果相邻单元格的高度 <strong>小于或等于</strong>当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。</p><p>返回网格坐标 <code>result</code> 的 <strong>2D 列表</strong> ，其中<code>result[i] = [ri, ci]</code> 表示雨水从单元格 <code>(ri, ci)</code>流动 <strong>既可流向太平洋也可流向大西洋</strong> 。</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240224230907817.png" alt="太平洋大西洋水流问题" style="zoom:50%;" /></p><p>思路：</p><p>这道题本质上是在考虑连通图能不能到太平洋和大西洋，给出两个函数，dfs是对每一个点能够到的位置进行标记，isResult是遍历每一个节点是不是能够通过联通到达太平洋和大西洋</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; heights, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (visited[x][y]) <span class="hljs-keyword">return</span>;<br>        visited[x][y] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>            <span class="hljs-type">int</span> nextx = x+dir[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> nexty = y+dir[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(nextx&lt;<span class="hljs-number">0</span>||nextx&gt;=heights.<span class="hljs-built_in">size</span>()||nexty&lt;<span class="hljs-number">0</span>||nexty&gt;=heights[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (heights[x][y] &lt; heights[nextx][nexty]) <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-built_in">dfs</span>(heights, visited, nextx, nexty);<br><br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isResult</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; heights, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; visited =vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;(heights.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(heights[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>));<br>        <span class="hljs-comment">// dfs选择当前这个点能到达的全部点</span><br>        <span class="hljs-built_in">dfs</span>(heights, visited, x, y);<br>        <span class="hljs-type">bool</span> isPacific = <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">bool</span> isAtlantic = <span class="hljs-literal">false</span>; <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;heights[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();j++)&#123;<br>            <span class="hljs-keyword">if</span>(visited[<span class="hljs-number">0</span>][j])&#123;<br>                isPacific = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;heights.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(visited[i][<span class="hljs-number">0</span>])&#123;<br>                isPacific = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;heights[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();j++)&#123;<br>            <span class="hljs-keyword">if</span>(visited[heights.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>][j])&#123;<br>                isAtlantic = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;heights.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(visited[i][heights[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>])&#123;<br>                isAtlantic = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (isAtlantic &amp;&amp; isPacific) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pacificAtlantic</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; heights) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-comment">// 遍历每一个点，看是否能同时到达太平洋和大西洋 </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; heights.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; heights[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isResult</span>(heights, i, j)) result.<span class="hljs-built_in">push_back</span>(&#123;i, j&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="最大人工岛">最大人工岛</h3><p><ahref="https://leetcode.cn/problems/making-a-large-island/description/">https://leetcode.cn/problems/making-a-large-island/description/</a></p><p>给你一个大小为 <code>n x n</code> 二进制矩阵 <code>grid</code>。<strong>最多</strong> 只能将一格 <code>0</code> 变成 <code>1</code>。</p><p>返回执行此操作后，<code>grid</code> 中最大的岛屿面积是多少？</p><p><strong>岛屿</strong> 由一组上、下、左、右四个方向相连的<code>1</code> 形成。</p><p><strong>示例 1:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: grid = <span class="hljs-string">[[1, 0], [0, 1]]</span><br>输出: <span class="hljs-number">3</span><br>解释: 将一格<span class="hljs-number">0</span>变成<span class="hljs-number">1</span>，最终连通两个小岛得到面积为 <span class="hljs-number">3</span> 的岛屿。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: grid = <span class="hljs-string">[[1, 1], [1, 0]]</span><br>输出: <span class="hljs-number">4</span><br>解释: 将一格<span class="hljs-number">0</span>变成<span class="hljs-number">1</span>，岛屿的面积扩大为 <span class="hljs-number">4</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: grid = <span class="hljs-string">[[1, 1], [1, 1]]</span><br>输出: <span class="hljs-number">4</span><br>解释: 没有<span class="hljs-number">0</span>可以让我们变成<span class="hljs-number">1</span>，面积依然为 <span class="hljs-number">4</span>。<br></code></pre></td></tr></table></figure><p>思路：</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240225105223461.png"alt="最大人工岛编号" /><figcaption aria-hidden="true">最大人工岛编号</figcaption></figure><p>当完成编号之后，第二步骤就是对每个没有编号的节点进行相邻岛屿的面积遍历增加</p><p>注意这一步完成之后要对每个不同岛屿的面积数量进行记录，这个地方<strong>可以用map来进行记录</strong></p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240225105326511.png"alt="最大人工岛第二步遍历节点" /><figcaption aria-hidden="true">最大人工岛第二步遍历节点</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> count;<br>    <span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-comment">//第一步dfs对地图已经有的岛屿数量进行标记</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp;grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> mark)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(visited[x][y]||grid[x][y]==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        visited[x][y]=<span class="hljs-literal">true</span>;<br>        grid[x][y] = mark;<br>        count++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>            <span class="hljs-type">int</span> nextx = x+dir[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> nexty = y + dir[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(nextx&lt;<span class="hljs-number">0</span>||nextx&gt;=grid.<span class="hljs-built_in">size</span>()||nexty&lt;<span class="hljs-number">0</span>||nexty&gt;=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">dfs</span>(grid, visited, nextx, nexty, mark);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n =grid.<span class="hljs-built_in">size</span>(), m=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; visited = vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;gridNum;<br>        <span class="hljs-type">int</span> mark = <span class="hljs-number">2</span>; <span class="hljs-comment">//对每个岛屿进行编号</span><br>        <span class="hljs-type">bool</span> isALLgrid = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">0</span>) isALLgrid = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">if</span>(!visited[i][j]&amp;&amp;grid[i][j]==<span class="hljs-number">1</span>)&#123;<br>                    count = <span class="hljs-number">0</span>;<br>                    <span class="hljs-built_in">dfs</span>(grid, visited, i, j, mark);<br>                    gridNum[mark] = count; <span class="hljs-comment">//利用map来对所有岛屿的信息进行编号并记录</span><br>                    mark++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (isALLgrid) <span class="hljs-keyword">return</span> n*m; <span class="hljs-comment">// 如果全部是岛屿的情况，那么这个时候就不需要增加新的面积</span><br><br>        <span class="hljs-comment">//以下的逻辑是对需要增添岛屿的情况进行记录</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; visitedGrid; <span class="hljs-comment">//标记访问过的岛屿</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>                <span class="hljs-type">int</span> count =<span class="hljs-number">1</span>;<br>                visitedGrid.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">//每次都需要将这个已经访问过的岛屿进行清除</span><br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;k++)&#123;<br>                        <span class="hljs-type">int</span> neari = i+dir[k][<span class="hljs-number">0</span>];<br>                        <span class="hljs-type">int</span> nearj = j+dir[k][<span class="hljs-number">1</span>];<br>                        <span class="hljs-keyword">if</span>(neari&lt;<span class="hljs-number">0</span>||nearj&lt;<span class="hljs-number">0</span>||neari&gt;=grid.<span class="hljs-built_in">size</span>()||nearj&gt;=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;<br>                        <span class="hljs-keyword">if</span>(visitedGrid.<span class="hljs-built_in">count</span>(grid[neari][nearj])) <span class="hljs-keyword">continue</span>;<br>                        count+=gridNum[grid[neari][nearj]];<br>                        visitedGrid.<span class="hljs-built_in">insert</span>(grid[neari][nearj]);<br>                    &#125;<br>                &#125;<br>                res = <span class="hljs-built_in">max</span>(res, count);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="单词接龙">单词接龙</h3><p><ahref="https://leetcode.cn/problems/word-ladder/description/">https://leetcode.cn/problems/word-ladder/description/</a></p><p>字典 <code>wordList</code> 中从单词 <code>beginWord</code> 和<code>endWord</code> 的 <strong>转换序列</strong>是一个按下述规格形成的序列<code>beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk</code>：</p><ul><li>每一对相邻的单词只差一个字母。</li><li>对于 <code>1 &lt;= i &lt;= k</code> 时，每个 <code>si</code> 都在<code>wordList</code> 中。注意， <code>beginWord</code> 不需要在<code>wordList</code> 中。</li><li><code>sk == endWord</code></li></ul><p>给你两个单词 <code>beginWord</code> 和 <code>endWord</code>和一个字典 <code>wordList</code> ，返回 <em>从 <code>beginWord</code> 到<code>endWord</code> 的 <strong>最短转换序列</strong> 中的<strong>单词数目</strong></em> 。如果不存在这样的转换序列，返回<code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：beginWord = <span class="hljs-string">&quot;hit&quot;</span>, endWord = <span class="hljs-string">&quot;cog&quot;</span>, wordList = [<span class="hljs-string">&quot;hot&quot;</span>,<span class="hljs-string">&quot;dot&quot;</span>,<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;lot&quot;</span>,<span class="hljs-string">&quot;log&quot;</span>,<span class="hljs-string">&quot;cog&quot;</span>]<br>输出：<span class="hljs-number">5</span><br>解释：一个最短转换序列是 <span class="hljs-string">&quot;hit&quot;</span> -&gt; <span class="hljs-string">&quot;hot&quot;</span> -&gt; <span class="hljs-string">&quot;dot&quot;</span> -&gt; <span class="hljs-string">&quot;dog&quot;</span> -&gt; <span class="hljs-string">&quot;cog&quot;</span>, 返回它的长度 <span class="hljs-number">5</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang">输入：<span class="hljs-keyword">begin</span>Word = <span class="hljs-string">&quot;hit&quot;</span>, <span class="hljs-keyword">end</span>Word = <span class="hljs-string">&quot;cog&quot;</span>, wordList = [<span class="hljs-string">&quot;hot&quot;</span>,<span class="hljs-string">&quot;dot&quot;</span>,<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;lot&quot;</span>,<span class="hljs-string">&quot;log&quot;</span>]<br>输出：<span class="hljs-number">0</span><br>解释：<span class="hljs-keyword">end</span>Word <span class="hljs-string">&quot;cog&quot;</span> 不在字典中，所以无法进行转换。<br></code></pre></td></tr></table></figure><p>思路：</p><p>这道题要解决两个问题：</p><ul><li>图中的线是如何连在一起的</li><li>起点和终点的最短路径长度</li></ul><p>首先题目中并没有给出点与点之间的连线，而是要我们自己去连，条件是字符只能差一个，所以判断点与点之间的关系，要自己判断是不是差一个字符，如果差一个字符，那就是有链接。</p><p>然后就是求起点和终点的最短路径长度，<strong>这里无向图求最短路，广搜最为合适，广搜只要搜到了终点，那么一定是最短的路径</strong>。因为广搜就是以起点中心向四周扩散的搜索。</p><p><strong>本题如果用深搜，会比较麻烦，要在到达终点的不同路径中选则一条最短路</strong>。而广搜只要达到终点，一定是最短路。</p><p><strong>广度优先搜索一定是能找到最短路径</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ladderLength</span><span class="hljs-params">(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)</span> </span>&#123;<br>        <span class="hljs-comment">//将vector转化成unordered_set提高查询速度</span><br>        <span class="hljs-function">unordered_set&lt;string&gt; <span class="hljs-title">wordSet</span><span class="hljs-params">(wordList.begin(), wordList.end())</span></span>;<br>        <span class="hljs-comment">// 如果endWorld没有在worldSet里面出现，直接返回0</span><br>        <span class="hljs-keyword">if</span>(wordSet.<span class="hljs-built_in">find</span>(endWord)==wordSet.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        unordered_map&lt;string, <span class="hljs-type">int</span>&gt;visitMap;<br>        queue&lt;string&gt; que;<br>        que.<span class="hljs-built_in">push</span>(beginWord);<br>        visitMap.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;string, <span class="hljs-type">int</span>&gt;(beginWord, <span class="hljs-number">1</span>)); <span class="hljs-comment">//map是用于记录路径的长度</span><br><br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>            string word = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> path = visitMap[word]; <span class="hljs-comment">//这个word的路径长度</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;word.<span class="hljs-built_in">size</span>();i++)&#123;<br>                string newWord = word;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">26</span>;j++)&#123;<br>                    newWord[i]=j+<span class="hljs-string">&#x27;a&#x27;</span>;<br>                    <span class="hljs-keyword">if</span>(newWord ==endWord) <span class="hljs-keyword">return</span> path+<span class="hljs-number">1</span>;<br><br>                    <span class="hljs-keyword">if</span>(wordSet.<span class="hljs-built_in">find</span>(newWord)!=wordSet.<span class="hljs-built_in">end</span>()&amp;&amp; visitMap.<span class="hljs-built_in">find</span>(newWord)==visitMap.<span class="hljs-built_in">end</span>())&#123;<br>                        visitMap.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;string, <span class="hljs-type">int</span>&gt;(newWord, path+<span class="hljs-number">1</span>));<br>                        que.<span class="hljs-built_in">push</span>(newWord);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="钥匙和房间">钥匙和房间</h3><p><ahref="https://leetcode.cn/problems/keys-and-rooms/description/">https://leetcode.cn/problems/keys-and-rooms/description/</a></p><p>有 <code>n</code> 个房间，房间按从 <code>0</code> 到<code>n - 1</code> 编号。最初，除 <code>0</code>号房间外的其余所有房间都被锁住。你的目标是进入所有的房间。然而，你不能在没有获得钥匙的时候进入锁住的房间。</p><p>当你进入一个房间，你可能会在里面找到一套不同的钥匙，每把钥匙上都有对应的房间号，即表示钥匙可以打开的房间。你可以拿上所有钥匙去解锁其他房间。</p><p>给你一个数组 <code>rooms</code> 其中 <code>rooms[i]</code> 是你进入<code>i</code> 号房间可以获得的钥匙集合。如果能进入<strong>所有</strong> 房间返回 <code>true</code>，否则返回<code>false</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：rooms = <span class="hljs-string">[[1],[2],[3],[]]</span><br>输出：<span class="hljs-literal">true</span><br>解释：<br>我们从 <span class="hljs-number">0</span> 号房间开始，拿到钥匙 <span class="hljs-number">1</span>。<br>之后我们去 <span class="hljs-number">1</span> 号房间，拿到钥匙 <span class="hljs-number">2</span>。<br>然后我们去 <span class="hljs-number">2</span> 号房间，拿到钥匙 <span class="hljs-number">3</span>。<br>最后我们去了 <span class="hljs-number">3</span> 号房间。<br>由于我们能够进入每个房间，我们返回 <span class="hljs-literal">true</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：rooms = <span class="hljs-string">[[1,3],[3,0,1],[2],[0]]</span><br>输出：<span class="hljs-literal">false</span><br>解释：我们不能进入 <span class="hljs-number">2</span> 号房间。<br></code></pre></td></tr></table></figure><p>思路：</p><p>这是在找一个有向图，如果出现有孤立的问题那么就不能开门进入，一定要全部连通，除此之外还需要注意的是这个是一个有向图的问题，还需要注意方向</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240225115054788.png" alt="有向量但不连通" style="zoom:50%;" /></p><p>因此需要用DFS来求解</p><p>其实本质上就是在利用深度优先搜索来进行遍历查找，如果能找到的话那么就进行标记，最后再进行筛选</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; rooms, <span class="hljs-type">int</span> key, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(visited[key]) <span class="hljs-keyword">return</span>;<br>        visited[key] = <span class="hljs-literal">true</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; keys = rooms[key];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> key :keys)&#123;<br>            <span class="hljs-built_in">dfs</span>(rooms, key, visited);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canVisitAllRooms</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; rooms)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(rooms.size(),<span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">dfs</span>(rooms, <span class="hljs-number">0</span>, visited);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:visited)&#123;<br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="岛屿的周长">岛屿的周长</h3><p><ahref="https://leetcode.cn/problems/island-perimeter/description/">https://leetcode.cn/problems/island-perimeter/description/</a></p><p>给定一个 <code>row x col</code> 的二维网格地图 <code>grid</code>，其中：<code>grid[i][j] = 1</code> 表示陆地，<code>grid[i][j] = 0</code> 表示水域。网格中的格子<strong>水平和垂直</strong>方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p><p>岛屿中没有“湖”（“湖”指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1的正方形。网格为长方形，且宽度和高度均不超过 100。计算这个岛屿的周长。</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240225120135322.png" alt="岛屿的周长" style="zoom:50%;" /></p><p>思路：</p><p>遍历每一个空格，遇到岛屿，计算其上下左右的情况，遇到水域或者出界的情况，就可以计算边了。</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240225120230954.png" alt="岛屿的周长题解法" style="zoom:50%;" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">islandPerimeter</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;grid.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;k++)&#123;<br>                        <span class="hljs-type">int</span> x= i+dir[k][<span class="hljs-number">0</span>];<br>                        <span class="hljs-type">int</span> y = j+dir[k][<span class="hljs-number">1</span>];<br>                        <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>||y&lt;<span class="hljs-number">0</span>||x&gt;=grid.<span class="hljs-built_in">size</span>()||y&gt;=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()||grid[x][y]==<span class="hljs-number">0</span>)&#123;<br>                            res++;<br>                        &#125; <br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="并查集理论基础">并查集理论基础</h3><p>并查集常用来解决连通性问题。当我们需要判断两个元素是否在同一个集合里的时候，我们就要想到用并查集，并查集主要有两个功能：</p><ul><li>将两个元素添加到一个集合中。</li><li>判断两个元素在不在同一个集合</li></ul><h4 id="基础理论知识">基础理论知识</h4><p><strong>将两条边加入并查集</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 将v，u 这条边加入并查集</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u); <span class="hljs-comment">// 寻找u的根</span><br>    v = <span class="hljs-built_in">find</span>(v); <span class="hljs-comment">// 寻找v的根</span><br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span><br>    father[v] = u;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>判断两个边是不是在同一个集合中寻根</strong></p><p>给出A元素，就可以通过 father[A] = B，father[B] = C，找到根为 C。</p><p>给出B元素，就可以通过 father[B] = C，找到根也为为 C，说明 A 和 B是在同一个集合里。大家会想第一段代码里find函数是如何实现的呢？其实就是通过数组下标找到数组元素，一层一层寻根过程，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 并查集里寻根的过程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == father[u]) <span class="hljs-keyword">return</span> u; <span class="hljs-comment">// 如果根就是自己，直接返回</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(father[u]); <span class="hljs-comment">// 如果根不是自己，就根据数组下标一层一层向下找</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 并查集初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        father[i] = i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们如何判断两个元素是否在同一个集合里，如果通过 find函数 找到两个元素属于同一个根的话，那么这两个元素就是同一个集合，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 判断 u 和 v是否找到同一个根</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">return</span> u == v;<br>&#125;<br></code></pre></td></tr></table></figure><p>路径压缩就一行代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 并查集里寻根的过程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == father[u]) <span class="hljs-keyword">return</span> u;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> father[u] = <span class="hljs-built_in">find</span>(father[u]); <span class="hljs-comment">// 路径压缩</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码在C++中，可以用三元表达式来精简一下，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> u == father[u] ? u : father[u] = <span class="hljs-built_in">find</span>(father[u]);<br>&#125;<br></code></pre></td></tr></table></figure><p>join 函数里的这段代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">u = <span class="hljs-built_in">find</span>(u); <span class="hljs-comment">// 寻找u的根</span><br>v = <span class="hljs-built_in">find</span>(v); <span class="hljs-comment">// 寻找v的根</span><br><span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span><br></code></pre></td></tr></table></figure><p>与 isSame 函数的实现是不是重复了？ 如果抽象一下呢，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 判断 u 和 v是否找到同一个根</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">return</span> u == v;<br>&#125;<br><br><span class="hljs-comment">// 将v-&gt;u 这条边加入并查集</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (isSame) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span><br>    father[v] = u;<br><br></code></pre></td></tr></table></figure><p>这样写可以吗？ 好像看出去没问题，而且代码更精简了。</p><p><strong>其实这么写是有问题的</strong>，在join函数中 我们需要寻找 u 和v 的根，然后再进行连线在一起，而不是直接 用 u 和 v 连线在一起。</p><h4 id="整体代码模版"><strong>整体代码模版</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> n =<span class="hljs-number">1005</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt; father = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>);<br><span class="hljs-comment">// 并查集初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>father[i]=i;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 并查集的寻根过程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>  <span class="hljs-keyword">return</span> u == father[u]? u:father[u]=<span class="hljs-built_in">find</span>(father[u]);<br>&#125;<br><br><span class="hljs-comment">// 判uv是不是同一个根</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span></span>&#123;<br>  u=<span class="hljs-built_in">find</span>(u);<br>  v=<span class="hljs-built_in">find</span>(v);<br>  <span class="hljs-keyword">return</span> u==v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span></span>&#123;<br>  u=<span class="hljs-built_in">find</span>(u);<br>  v=<span class="hljs-built_in">find</span>(v);<br>  <span class="hljs-comment">//如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span><br>  <span class="hljs-keyword">if</span>(u==v) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-comment">//否则就将其中一个当成另一个的父亲节点</span><br>  father[v]=u;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="寻找图中是否存在路径">寻找图中是否存在路径</h3><p><ahref="https://leetcode.cn/problems/find-if-path-exists-in-graph/description/">https://leetcode.cn/problems/find-if-path-exists-in-graph/description/</a></p><p>有一个具有 <code>n</code> 个顶点的 <strong>双向</strong>图，其中每个顶点标记从 <code>0</code> 到 <code>n - 1</code>（包含<code>0</code> 和 <code>n - 1</code>）。图中的边用一个二维整数数组<code>edges</code> 表示，其中 <code>edges[i] = [ui, vi]</code> 表示顶点<code>ui</code> 和顶点 <code>vi</code> 之间的双向边。 每个顶点对由<strong>最多一条</strong> 边连接，并且没有顶点存在与自身相连的边。</p><p>请你确定是否存在从顶点 <code>source</code> 开始，到顶点<code>destination</code> 结束的 <strong>有效路径</strong> 。给你数组<code>edges</code> 和整数 <code>n</code>、<code>source</code> 和<code>destination</code>，如果从 <code>source</code> 到<code>destination</code> 存在 <strong>有效路径</strong> ，则返回<code>true</code>，否则返回 <code>false</code> 。</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240225121723461.png" alt="寻找有效路径" style="zoom:50%;" /></p><p>思路：</p><p>简单的并查集实践，一般这种只需要你返回<strong>是否能连通的就可以用并查集来求解</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> n=<span class="hljs-number">200005</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; father = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">//并查集初始化</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            father[i] = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//并查集里面的寻根过程</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(u==father[u]) <span class="hljs-keyword">return</span> u;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> father[u] = <span class="hljs-built_in">find</span>((father[u]));<br>    &#125;<br>    <span class="hljs-comment">//判断是不是在同一个根上</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span></span>&#123;<br>        u = <span class="hljs-built_in">find</span>(u);<br>        v = <span class="hljs-built_in">find</span>(v);<br>        <span class="hljs-keyword">return</span> u==v;<br>    &#125;<br>    <span class="hljs-comment">//将新的内容加入到并查集中</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>        u = <span class="hljs-built_in">find</span>(u); <span class="hljs-comment">// 寻找u的根</span><br>        v = <span class="hljs-built_in">find</span>(v); <span class="hljs-comment">// 寻找v的根</span><br>        <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span><br>        father[v] = u;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">validPath</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges, <span class="hljs-type">int</span> source, <span class="hljs-type">int</span> destination)</span> </span>&#123;<br>        <span class="hljs-built_in">init</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;edges.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-built_in">join</span>(edges[i][<span class="hljs-number">0</span>],edges[i][<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSame</span>(source, destination);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="冗余连接">冗余连接</h3><p><ahref="https://leetcode.cn/problems/redundant-connection/description/">https://leetcode.cn/problems/redundant-connection/description/</a></p><p>树可以看成是一个连通且 <strong>无环</strong> 的 <strong>无向</strong>图。</p><p>给定往一棵 <code>n</code> 个节点 (节点值 <code>1～n</code>)的树中添加一条边后的图。添加的边的两个顶点包含在 <code>1</code> 到<code>n</code>中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为<code>n</code> 的二维数组 <code>edges</code>，<code>edges[i] = [ai, bi]</code> 表示图中在 <code>ai</code> 和<code>bi</code> 之间存在一条边。</p><p>请找出一条可以删去的边，删除后可使得剩余部分是一个有着 <code>n</code>个节点的树。如果有多个答案，则返回数组 <code>edges</code>中最后出现的那个。</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240225123025333.png" alt="冗余连接图解" style="zoom:50%;" /></p><p>思路：</p><p>那么我们就可以从前向后遍历每一条边（因为优先让前面的边连上），边的两个节点如果不在同一个集合，就加入集合（即：同一个根节点）。</p><p>如果边的两个节点已经出现在同一个集合里，说明着边的两个节点已经连在一起了，再加入这条边一定就出现环了</p><p>已经判断 节点A 和 节点B 在在同一个集合（同一个根），如果将 节点A 和节点B 连在一起就一定会出现环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> n =<span class="hljs-number">1005</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; father = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            father[i]=i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(u==father[u]) <span class="hljs-keyword">return</span> u;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> father[u] = <span class="hljs-built_in">find</span>(father[u]);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span></span>&#123;<br>        u = <span class="hljs-built_in">find</span>(u);<br>        v = <span class="hljs-built_in">find</span>(v);<br>        <span class="hljs-keyword">return</span> u==v;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span></span>&#123;<br>        u = <span class="hljs-built_in">find</span>(u);<br>        v = <span class="hljs-built_in">find</span>(v);<br>        <span class="hljs-keyword">if</span>(u==v) <span class="hljs-keyword">return</span>;<br>        father[v]=u;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findRedundantConnection</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>        <span class="hljs-built_in">init</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;edges.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isSame</span>(edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">1</span>])) <span class="hljs-keyword">return</span> edges[i];<br>            <span class="hljs-keyword">else</span> (<span class="hljs-built_in">join</span>(edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">1</span>]));<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="冗余连接ii">冗余连接II</h3><p><ahref="https://leetcode.cn/problems/redundant-connection-ii/description/">https://leetcode.cn/problems/redundant-connection-ii/description/</a></p><p>在本问题中，有根树指满足以下条件的 <strong>有向</strong>图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。</p><p>输入一个有向图，该图由一个有着 <code>n</code>个节点（节点值不重复，从 <code>1</code> 到<code>n</code>）的树及一条附加的有向边构成。附加的边包含在<code>1</code> 到 <code>n</code>中的两个不同顶点间，这条附加的边不属于树中已存在的边。</p><p>结果图是一个以边组成的二维数组 <code>edges</code> 。 每个元素是一对<code>[ui, vi]</code>，用以表示 <strong>有向</strong> 图中连接顶点<code>ui</code> 和顶点 <code>vi</code> 的边，其中 <code>ui</code> 是<code>vi</code> 的一个父节点。</p><p>返回一条能删除的边，使得剩下的图是有 <code>n</code>个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240225123828659.png" alt="冗余连接2的题目解释" style="zoom:50%;" /></p><p>思路：</p><p>题目中的表述中提到<strong>该图由一个有着N个节点 (节点值不重复1, 2,..., N)的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。这说明题目中的图原本是是一棵树，只不过在不增加节点的情况下多加了一条边！</strong></p><p>那么可能的情况有：</p><ul><li>图中的树存在入度为2的节点</li><li>图中存在一个环</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">1010</span>;<br>    <span class="hljs-type">int</span> father[N];<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            father[i]=i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(father[u]==u) <span class="hljs-keyword">return</span> u;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> father[u]=<span class="hljs-built_in">find</span>(father[u]);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span></span>&#123;<br>        u = <span class="hljs-built_in">find</span>(u);<br>        v = <span class="hljs-built_in">find</span>(v);<br>        <span class="hljs-keyword">if</span>(u==v) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">else</span> father[v] = u;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span></span>&#123;<br>        u=<span class="hljs-built_in">find</span>(u);<br>        v = <span class="hljs-built_in">find</span>(v);<br>        <span class="hljs-keyword">return</span> u==v;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getRemoveEdge</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span></span>&#123;<br>        <span class="hljs-built_in">init</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">same</span>(edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">1</span>]))&#123; <span class="hljs-comment">//这个表示有环的情况，需要进行删除</span><br>                <span class="hljs-keyword">return</span> edges[i];<br>            &#125;<br>            <span class="hljs-built_in">join</span>(edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>    <span class="hljs-comment">// 删掉一条边之后判断是不是树</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isTree</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges, <span class="hljs-type">int</span> deleteEdges)</span></span>&#123;<br>        <span class="hljs-built_in">init</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i==deleteEdges) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">same</span>(edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">1</span>])) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//出现环了因此不是树</span><br>            <span class="hljs-built_in">join</span>(edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findRedundantDirectedConnection</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>        <span class="hljs-type">int</span> inDegree[N]=&#123;<span class="hljs-number">0</span>&#125;;<br>        n = edges.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            inDegree[edges[i][<span class="hljs-number">1</span>]]++;<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; vec; <span class="hljs-comment">//记录入度为2的边</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(inDegree[edges[i][<span class="hljs-number">1</span>]]==<span class="hljs-number">2</span>)&#123;<br>                vec.<span class="hljs-built_in">push_back</span>(i);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//如果有入度为2的节点，那么就需要删除</span><br>        <span class="hljs-keyword">if</span>(vec.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isTree</span>(edges, vec[<span class="hljs-number">0</span>]))&#123;<br>                <span class="hljs-keyword">return</span> edges[vec[<span class="hljs-number">0</span>]];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> edges[vec[<span class="hljs-number">1</span>]];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getRemoveEdge</span>(edges);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【后端开发】Golang协程与Channel</title>
    <link href="/2023/12/19/develop_goroutine/"/>
    <url>/2023/12/19/develop_goroutine/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="golang进阶">Golang进阶</h1><p>这一部分主要介绍golang中的并发，并发是 golang 的优势之一，使用关键字go 可以很方便的开启一个<strong>协程</strong>. go 语言中，常常用<strong>go</strong>、<strong>chan</strong>、<strong>select</strong> 及<strong>sync库</strong>完成并发操作，处理<strong>同步</strong>、<strong>异步</strong>、<strong>阻塞</strong>、<strong>非阻塞</strong>任务</p><p>go 语言的并发编程，以下是需要了解的基础知识点</p><ul><li><strong>阻塞</strong>:阻塞是进程(也可以是线程、协程)的状态之一（新建、就绪、运行、阻塞、终止).指的是当数据未准备就绪，这个进程(线程、协程)一直等待，这就是阻塞.</li><li><strong>非阻塞</strong>:当数据为准备就绪，该进程(线程、协程)不等待可以继续执行，这就是非阻塞.</li><li><strong>同步</strong>:在发起一个调用时，在没有得到结果之前，这个调用就不返回，这个调用过程一直在等待.这是同步.</li><li><strong>异步</strong>:在发起调用后，就立刻返回了，这次调用过程就结束了.等到有结果了被调用方主动通知调用者结果. 这是异步</li><li><strong>goroutine</strong>: 通过关键字 go 即可创建一个协程.</li><li><strong>chan :</strong> golang中用于并发的通道，用于协程的通信.</li></ul><h2 id="goroutine协程">Goroutine协程</h2><p>协程并发，coroutine，也叫轻量级线程。</p><p>与传统的系统级线程和进程相比，协程最大的优势在于“轻量级”。可以轻松创建上万个而不会导致系统资源衰竭。</p><p>一个线程中可以有任意多个协程，但某一时刻只能有一个协程在运行，<strong>多个协程分享该线程分配到的计算机资源</strong>。</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231207223749991-20231219211513985.png" alt="传统的线程调度方式" style="zoom:80%;" /></p><p>存在切换成本，存储当前的线程的状态</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231207223845618.png"alt="CPU切换造成的时间消耗" /><figcaption aria-hidden="true">CPU切换造成的时间消耗</figcaption></figure><p>在协程中，调用一个任务就像调用一个函数一样，消耗的系统资源最少！但能达到进程、线程并发相同的效果。</p><p>在一次并发任务中，进程、线程、协程均可以实现。从系统资源消耗的角度出发来看，进程相当多，线程次之，协程最少</p><h3 id="goroutine基本模型">Goroutine基本模型</h3><p>线程数量越多会导致切换成本越大越容易造成浪费</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231210220547247.png" alt="CPU管理协程的具体细节" style="zoom:67%;" /></p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231210220633895.png" alt="早期调度器的方式" style="zoom:67%;" /></p><p>老式调度器的缺点：</p><ul><li>创建、销毁、调度G都需要每个M获取锁，这就形成了<strong>激烈的锁竞争</strong></li><li>M转移G会造成<strong>延迟和额外的系统负载</strong></li><li>系统调用(CPU在M之间的切换)导致频繁的线程阻塞和取消阻塞操作<strong>增加了系统开销</strong></li></ul><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231210221404383.png" alt="调度器设计的准则" style="zoom:67%;" /></p><h3 id="goroutine的定义">Goroutine的定义</h3><p>goroutine是Go语言并行设计的核心，有人称之为go程。Goroutine从量级上看很像协程，它比线程更小，十几个goroutine可能体现在底层就是五六个线程，Go语言内部帮你实现了这些goroutine之间的内存共享。执行goroutine只需极少的栈内存(大概是4~5KB)，当然会根据相应的数据伸缩。也正因为如此，可同时运行成千上万个并发任务。goroutine比thread更易用、更高效、更轻便。</p><p>一般情况下，一个普通计算机跑几十个线程就有点负载过大了，但是同样的机器却可以轻松地让成百上千个goroutine进行资源竞争。</p><h3 id="创建goroutine">创建Goroutine</h3><p>只需在函数调⽤语句前添加 <strong>go</strong>关键字，就可创建并发执⾏单元。在并发编程中，我们通常想将一个过程切分成几块，然后让每个goroutine各自负责一块工作，当一个程序启动时，主函数在一个单独的goroutine中运行，我们叫它maingoroutine。</p><p>示例代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newTask</span><span class="hljs-params">()</span></span> &#123;<br>    i := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        i++<br>        fmt.Printf(<span class="hljs-string">&quot;new goroutine: i = %d\n&quot;</span>, i)<br>        time.Sleep(<span class="hljs-number">1</span>*time.Second) <span class="hljs-comment">//延时1s</span><br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//创建一个 goroutine，启动另外一个任务</span><br>    <span class="hljs-keyword">go</span> newTask()<br>    i := <span class="hljs-number">0</span><br>    <span class="hljs-comment">//main goroutine 循环打印</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        i++<br>        fmt.Printf(<span class="hljs-string">&quot;main goroutine: i = %d\n&quot;</span>, i)<br>        time.Sleep(<span class="hljs-number">1</span> * time.Second) <span class="hljs-comment">//延时1s</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">main Goroutine: i=1<br>new Goroutine: i =2<br>new Goroutine: i =3<br>main Goroutine: i=2<br>main Goroutine: i=3<br>new Goroutine: i =4<br>new Goroutine: i =5<br></code></pre></td></tr></table></figure><h3 id="goroutine特性">Goroutine特性</h3><p><strong>主goroutine退出后，其它的工作goroutine也会自动退出：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newTask</span><span class="hljs-params">()</span></span> &#123;<br>    i := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        i++<br>        fmt.Printf(<span class="hljs-string">&quot;new goroutine: i = %d\n&quot;</span>, i)<br>        time.Sleep(<span class="hljs-number">1</span> * time.Second) <span class="hljs-comment">//延时1s</span><br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//创建一个 goroutine，启动另外一个任务</span><br>    <span class="hljs-keyword">go</span> newTask()<br> <br>    fmt.Println(<span class="hljs-string">&quot;main goroutine exit&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231219213501210.png" alt="主进程结束那么其余的goroutine结束" style="zoom:67%;" /></p><h3 id="goexit函数">Goexit函数</h3><p>调用 runtime.Goexit() 将立即终止当前 goroutine执⾏，调度器确保所有已注册 defer 延迟调用被执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;runtime&quot;</span><br>)<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;A.defer&quot;</span>)<br> <br>        <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;B.defer&quot;</span>)<br>            runtime.Goexit() <span class="hljs-comment">// 终止当前 goroutine, import &quot;runtime&quot;</span><br>            fmt.Println(<span class="hljs-string">&quot;B&quot;</span>) <span class="hljs-comment">// 不会执行</span><br>        &#125;()<br> <br>        fmt.Println(<span class="hljs-string">&quot;A&quot;</span>) <span class="hljs-comment">// 不会执行</span><br>    &#125;()       <span class="hljs-comment">//不要忘记()</span><br> <br>    <span class="hljs-comment">//死循环，目的不让主goroutine结束</span><br>    <span class="hljs-keyword">for</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231219214022511.png" alt="image-20231219214022511" style="zoom:67%;" /></p><p>对于goroutine的形式没办法拿到协程返回的值，从而阻塞了两个协程之间的通信，因此有必要研究如何让两个协程进行通信的机制因此这个地方引入了</p><h2 id="channel管道">Channel管道</h2><p>channel是Go语言中的一个<strong>核心类型</strong>，可以把它看成管道。并发核心单元通过它就可以发送或者接收数据进行通讯</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231213150125899.png" alt="go语言之间的goroutine通信机制" style="zoom:80%;" /></p><p>channel是一个数据类型，主要用来解决go程的同步问题以及go程之间数据共享（数据传递）的问题。引⽤类型channel可用于<strong>多个 goroutine通讯。其内部实现了同步，确保并发安全</strong>。</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231213150927632.png"alt="基于channel的同步并发安全" /><figcaption aria-hidden="true">基于channel的同步并发安全</figcaption></figure><p>这个channel在这个位置就已经隐含表示了先后执行的关系</p><ul><li>如果main.go在运行的时候如果找不到channel返回的值，那么就会channel让main.go产生阻塞，</li><li>同理对于另一边的sub.go也是一样，如果没有另一个goroutine来接受发出的channel数据，那么就会一直处于等待接受的状态产生阻塞，</li><li><strong>相当于首先得握上手才能继续执行进程</strong></li></ul><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231213151022873.png" alt="主goroutine发生阻塞" style="zoom:67%;" /></p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231213151129109.png" alt="子进程发生阻塞" style="zoom:67%;" /></p><h3 id="定义channel基本语法">定义channel基本语法</h3><p>定义一个channel时，也需要定义发送到channel的值的类型。channel可以使用内置的<strong>make()函数</strong>来创建：</p><p><strong>chan</strong>是创建channel所需使用的关键字。Type代表指定channel收发数据的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Type)  <span class="hljs-comment">//等价于make(chan Type, 0)</span><br><span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Type, capacity)<br></code></pre></td></tr></table></figure><p>当 参数<code>capacity= 0</code> 时，channel是<strong>无缓冲阻塞</strong>读写的；当<code>capacity &gt; 0</code>时，channel <strong>有缓冲非阻塞的</strong>，直到写满capacity个元素才阻塞写入。</p><p>channel非常像生活中的管道，一边可以存放东西，另一边可以取出东西。channel通过操作符<code>&lt;-</code>来接收和发送数据，<strong>发送和接收</strong>数据语法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">channel &lt;- value      <span class="hljs-comment">//发送value到channel</span><br>&lt;-channel             <span class="hljs-comment">//接收并将其丢弃</span><br>x := &lt;-channel        <span class="hljs-comment">//从channel中接收数据，并赋值给x</span><br>x, ok := &lt;-channel    <span class="hljs-comment">//功能同上，同时检查通道是否已关闭或者是否为空</span><br></code></pre></td></tr></table></figure><p>默认情况下，channel接收和发送数据都是阻塞的，除非另一端已经准备好，这样就使得goroutine同步变的更加的简单，而<strong>不需要显式的lock。</strong></p><p>示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br> <br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;子go程结束&quot;</span>)<br> <br>        fmt.Println(<span class="hljs-string">&quot;子go程正在运行……&quot;</span>)<br> <br>        c &lt;- <span class="hljs-number">666</span> <span class="hljs-comment">//666发送到c</span><br>    &#125;()<br> <br>    num := &lt;-c <span class="hljs-comment">//从c中接收数据，并赋值给num</span><br> <br>    fmt.Println(<span class="hljs-string">&quot;num = &quot;</span>, num)<br>    fmt.Println(<span class="hljs-string">&quot;main go程结束&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">goroutine 正在运行...<br>goroutine结束<br>num =  666<br>main goroutine 结束...<br></code></pre></td></tr></table></figure><p>分析：</p><ul><li>首先第一步会需要子进程将666放进channel中才不会发生阻塞，同时主进程会在<code>num := &lt;-c</code>的位置进行等待channel中传入数据</li><li>当channel中出现了数据之后，那么下一步就是从中选择数据并进行赋值</li><li>最后结束</li></ul><h3 id="channel的无缓冲阻塞">channel的无缓冲阻塞</h3><p>无缓冲的通道（unbufferedchannel）是指在接收前没有能力保存任何数据值的通道。</p><p>这种类型的通道要求发送goroutine和接收goroutine同时准备好，才能完成发送和接收操作。否则，通道会导致先执行发送或接收操作的goroutine 阻塞等待。</p><p><strong>阻塞：</strong>由于某种原因数据没有到达，当前go程（线程）持续处于等待状态，直到条件满足，才解除阻塞。</p><p><strong>同步：</strong>在两个或多个go程（线程）间，保持数据内容一致性的机制。</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231213151511356.png"alt="无缓冲的channel同步" /><figcaption aria-hidden="true">无缓冲的channel同步</figcaption></figure><p>如果两个goroutine存在利用channel通信的情况，两个goroutine之间存在相互的消息传递，那么在无缓冲的情况下，存在隐含的先后同步关系，必须接收方到达了channel之后消息发送方才会持续发送消息并往下运行</p><ul><li>在第 1 步，两个 goroutine都到达通道，但哪个都没有开始执行发送或者接收。</li><li>在第 2 步，左侧的 goroutine将它的手伸进了通道，这模拟了向通道发送数据的行为。这时，这个 goroutine会在通道中被锁住，直到交换完成。</li><li>在第 3 步，右侧的 goroutine将它的手放入通道，这模拟了从通道里接收数据。这个 goroutine一样也会在通道中被锁住，直到交换完成。</li><li>在第 4 步和第 5 步，进行交换，并最终，在第 6 步，两个 goroutine都将它们的手从通道里拿出来，这模拟了被锁住的 goroutine 得到释放。两个goroutine 现在都可以去做其他事情了。</li></ul><p>无缓冲的channel创建格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Type)   <span class="hljs-comment">//等价于make(chan Type, 0)</span><br></code></pre></td></tr></table></figure><p>如果<strong>没有指定缓冲区容量</strong>，那么该通道就是同步的，因此会阻塞到发送者准备好发送和接收者准备好接收。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">//创建无缓冲的通道 c </span><br> <br>    <span class="hljs-comment">//内置函数 len 返回未被读取的缓冲元素数量，cap 返回缓冲区大小</span><br>    fmt.Printf(<span class="hljs-string">&quot;len(c)=%d, cap(c)=%d\n&quot;</span>, <span class="hljs-built_in">len</span>(c), <span class="hljs-built_in">cap</span>(c))<br> <br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;子go程结束&quot;</span>)<br> <br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br>            c &lt;- i<br>            fmt.Printf(<span class="hljs-string">&quot;子go程正在运行[%d]: len(c)=%d, cap(c)=%d\n&quot;</span>, i, <span class="hljs-built_in">len</span>(c), <span class="hljs-built_in">cap</span>(c))<br>        &#125;<br>    &#125;()<br> <br>    time.Sleep(<span class="hljs-number">2</span> * time.Second) <span class="hljs-comment">//延时2s</span><br> <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br>        num := &lt;-c <span class="hljs-comment">//从c中接收数据，并赋值给num</span><br>        fmt.Println(<span class="hljs-string">&quot;num = &quot;</span>, num)<br>    &#125;<br> <br>    fmt.Println(<span class="hljs-string">&quot;main进程结束&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>那么运行的结果是：</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231219220132461.png" alt="无缓冲channel的运行结果" style="zoom:67%;" /></p><p>分析：</p><ul><li>本质上会出现阻塞，如果没有及时把数据拿出</li><li>因此必须是其中一个放进去数据，另一个拿出数据才能能让进程执行下去，本质上保证了同步的进行</li></ul><h3 id="channel的有缓冲阻塞">channel的有缓冲阻塞</h3><blockquote><p><strong>本质上是生产者消费者模型 消息队列模型</strong></p></blockquote><p>这种类型的通道并不强制要求 goroutine之间必须同时完成发送和接收。通道会阻塞发送和接收动作的条件也不同。</p><p>只有通道中没有要接收的值时，接收动作才会阻塞。只有通道没有可用缓冲区容纳被发送的值时，发送动作才会阻塞。</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231219220401111.png"alt="有缓冲的通道在channe之间同步数据" /><figcaptionaria-hidden="true">有缓冲的通道在channe之间同步数据</figcaption></figure><ul><li>在第 1 步，右侧的 goroutine 正在从通道接收一个值。</li><li>在第 2 步，右侧的这个 goroutine独立完成了接收值的动作，而左侧的goroutine 正在发送一个新值到通道里。</li><li>在第 3 步，左侧的goroutine 还在向通道发送新值，而右侧的 goroutine正在从通道接收另外一个值。这个步骤里的两个操作<strong>既不是同步的，也不会互相阻塞</strong>。</li><li>最后，在第 4步，所有的发送和接收都完成，而通道里还有几个值，也有一些空间可以存更多的值。</li></ul><p><strong>有缓冲的channel创建格式：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Type, capacity)<br></code></pre></td></tr></table></figure><p>如果给定了一个缓冲区容量，通道就是异步的。只要缓冲区有未使用空间用于发送数据，或还包含可以接收的数据，那么其通信就会无阻塞地进行。</p><p><strong>函数 len(ch)求取缓冲区中剩余元素个数， cap(ch)求取缓冲区元素容量大小</strong></p><p>示例代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span>  <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> ,<span class="hljs-number">3</span>) <span class="hljs-comment">//带有缓冲的channel</span><br><br><span class="hljs-comment">//查看当前的channel中的缓冲的容量大小</span><br><span class="hljs-comment">//len表示的是元素数量 cap表示的是缓冲的容量大小</span><br>fmt.Println(<span class="hljs-string">&quot;len(c) = &quot;</span>, <span class="hljs-built_in">len</span>(c), <span class="hljs-string">&quot;, cap(c)&quot;</span>, <span class="hljs-built_in">cap</span>(c))<br><br><span class="hljs-comment">//定义一个子goroutine</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;sub goroutine结束&quot;</span>)<br><br><span class="hljs-comment">// for i := 0; i&lt;3; i++&#123;</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">4</span>; i++&#123;<span class="hljs-comment">// 这种情况就会出现阻塞，因为超过了缓冲的容量</span><br>c &lt;- i<br>fmt.Println(<span class="hljs-string">&quot;sub goroutine 正在运行: len(c) = &quot;</span>, <span class="hljs-built_in">len</span>(c), <span class="hljs-string">&quot;, cap(c) =  &quot;</span>, <span class="hljs-built_in">cap</span>(c),<span class="hljs-string">&quot; 发送的元素是= &quot;</span>,i)<br>&#125;<br>&#125;()<br><br>time.Sleep(<span class="hljs-number">1</span>*time.Second)<br><br><span class="hljs-comment">//有缓存的话就不会出现阻塞的情况</span><br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">3</span>;i++&#123;<br>num := &lt;-c <span class="hljs-comment">//从c中接受数据并赋值给num</span><br>fmt.Println(<span class="hljs-string">&quot;num = &quot;</span>, num)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;main 结束&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231219220650672.png"alt="有缓冲通道的运行结果" /><figcaption aria-hidden="true">有缓冲通道的运行结果</figcaption></figure><h3 id="关闭channel">关闭Channel</h3><p>没有更多的值需要发送到channel的话，那么让接收者也能及时知道没有多余的值可接收将是有用的，因为接收者可以停止不必要的接收等待。这可以通过内置的<code>close</code>函数来关闭channel实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>) <span class="hljs-comment">//channel要通过make来触发，如果是nil channel 会发生阻塞</span><br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;sub finished ...&quot;</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++&#123;<br>c &lt;- i<br><span class="hljs-comment">// close(c)</span><br><span class="hljs-comment">//如果向已经关闭的channel发送数据就会出现panic的错误</span><br>&#125;<br><span class="hljs-comment">// close 关闭一个channel</span><br><span class="hljs-built_in">close</span>(c)<br><span class="hljs-comment">//如果去掉关闭channel这个开关，那么会出现死锁的情况，就是main的进程数据都在等待塞数据</span><br>&#125;()<br><br><span class="hljs-keyword">for</span>&#123;<br><span class="hljs-comment">//如果ok为ture 那么channel没有关闭, 如果为false 那么已经被关闭</span><br><span class="hljs-keyword">if</span> data, ok := &lt;-c; ok&#123;<br>fmt.Println(data)<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br><br>fmt.Println(<span class="hljs-string">&quot;Main finished ...&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出的结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">/* 输出的值go run channel4.go<br>0<br>1<br>2<br>3<br>4<br>Main finished ...<br>sub finished ... */<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>channel不像文件一样需要经常去关闭，只有当你确实没有任何发送数据了，或者你想显式的结束range循环之类的，才去关闭channel；</li><li>如果向已经关闭的channel发送数据就会出现panic的错误</li><li>关闭channel后，可以继续从channel接收数据；</li><li>如果ok为ture 那么channel没有关闭, 如果为false 那么已经被关闭</li><li>对于nil channel，无论收发都会被阻塞。</li></ul><h3 id="range操作channel">Range操作channel</h3><p>可以使用 <strong>range</strong> 来迭代不断操作channel：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br> <br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>            c &lt;- i<br>        &#125;<br>        <span class="hljs-built_in">close</span>(c)<br>    &#125;()<br> <br>    <span class="hljs-keyword">for</span> data := <span class="hljs-keyword">range</span> c &#123;<br>        fmt.Println(data)<br>    &#125;<br>    fmt.Println(<span class="hljs-string">&quot;Finished&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li><p>利用range进行简写</p></li><li><p>利用range不断迭代从channel中操作数据</p></li></ul><h3 id="单向channel">单向Channel</h3><p>默认情况下，通道channel是双向的，也就是，既可以往里面发送数据也可以同里面接收数据。</p><p>但是，我们经常见一个通道作为参数进行传递而只希望对方是单向使用的，要么只让它发送数据，要么只让它接收数据，这时候我们可以指定通道的方向。</p><p>单向channel的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ch1 <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>       <span class="hljs-comment">// ch1是一个正常的channel，是双向的</span><br><span class="hljs-keyword">var</span> ch2 <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">float64</span> <span class="hljs-comment">// ch2是单向channel，只用于写float64数据</span><br><span class="hljs-keyword">var</span> ch3 &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>     <span class="hljs-comment">// ch3是单向channel，只用于读int数据</span><br></code></pre></td></tr></table></figure><p>可以将 channel 隐式转换为单向队列，只收或只发，不能将单向 channel转换为普通 channel：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">3</span>)<br><span class="hljs-keyword">var</span> send <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span> = c <span class="hljs-comment">// send-only</span><br><span class="hljs-keyword">var</span> recv &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> = c <span class="hljs-comment">// receive-only</span><br>send &lt;- <span class="hljs-number">1</span><br><span class="hljs-comment">//&lt;-send //invalid operation: &lt;-send (receive from send-only type chan&lt;- int)</span><br>&lt;-recv<br><span class="hljs-comment">//recv &lt;- 2 //invalid operation: recv &lt;- 2 (send to receive-only type &lt;-chan int)</span><br> <br><span class="hljs-comment">//不能将单向 channel 转换为普通 channel</span><br>d1 := (<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)(send) <span class="hljs-comment">//cannot convert send (type chan&lt;- int) to type chan int</span><br>d2 := (<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)(recv) <span class="hljs-comment">//cannot convert recv (type &lt;-chan int) to type chan int</span><br></code></pre></td></tr></table></figure><p>单向channel的示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//   chan&lt;- //只写</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">counter</span><span class="hljs-params">(out <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(out)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>        out &lt;- i <span class="hljs-comment">//如果对方不读 会阻塞</span><br>    &#125;<br>&#125;<br> <br><span class="hljs-comment">//   &lt;-chan //只读</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printer</span><span class="hljs-params">(in &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> num := <span class="hljs-keyword">range</span> in &#123;<br>        fmt.Println(num)<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>) <span class="hljs-comment">//   chan   //读写</span><br> <br>    <span class="hljs-keyword">go</span> counter(c) <span class="hljs-comment">//生产者</span><br>    printer(c)    <span class="hljs-comment">//消费者</span><br> <br>    fmt.Println(<span class="hljs-string">&quot;done&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="channel的select">Channel的Select</h2><h3 id="select基本定义">Select基本定义</h3><p>Go里面提供了一个关键字select，通过select可以监听channel上的数据流动。每个case表示监控不同的条件.通过select来进行控制。</p><p>select有比较多的限制，其中最大的一条限制就是每个<strong>case语句里必须是一个IO操作</strong>，大致的结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;- chan1:<br>    <span class="hljs-comment">// 如果chan1成功读到数据，则进行该case处理语句</span><br><span class="hljs-keyword">case</span> chan2 &lt;- <span class="hljs-number">1</span>:<br>    <span class="hljs-comment">// 如果成功向chan2写入数据，则进行该case处理语句</span><br><span class="hljs-keyword">default</span>:<br>    <span class="hljs-comment">// 如果上面都没有成功，则进入default处理流程</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在一个select语句中，Go语言会按顺序<strong>从头至尾</strong>评估每一个发送和接收的语句。如果其中的<strong>任意一语句可以继续执行</strong>(即没有被阻塞)，那么就从那些可以执行的语句中任意选择一条来使用。</p><p>如果<strong>没有任意一条语句可以执行</strong>(即所有的通道都被阻塞)，那么有两种可能的情况：</p><ol type="1"><li>如果给出了default语句，那么就会执行default语句，同时程序的执行会从select语句后的语句中恢复</li><li>如果没有default语句，那么select语句将被阻塞，直到至少有一个通信可以进行下去</li></ol><p>下面是<strong>示例代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">(c, quit <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>    x, y := <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> c &lt;- x:<br>            x, y = y, x+y<br>        <span class="hljs-keyword">case</span> &lt;-quit:<br>            fmt.Println(<span class="hljs-string">&quot;quit&quot;</span>)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    quit := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br> <br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++ &#123;<br>            fmt.Println(&lt;-c)<br>        &#125;<br>        quit &lt;- <span class="hljs-number">0</span><br>    &#125;()<br> <br>    fibonacci(c, quit)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行的结果：</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231220211918321.png" alt="执行的结果" style="zoom:70%;" /></p><h3 id="交替打印数字字母">交替打印数字字母</h3><p>需求：反复打印数字1字母a-&gt;1a2b3c4d5e...依次类推</p><p>思路：选择两个goroutine来实现这部分的内容，产生阻塞的条件是一个进程需要取数，一个goroutine需要存数来进行阻塞</p><p>示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">26</span>; i++ &#123;<br>&lt;-c<br>fmt.Println(<span class="hljs-type">string</span>(<span class="hljs-number">96</span> + i))<br>c &lt;- <span class="hljs-number">0</span><br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">26</span>; i++ &#123;<br>fmt.Println(i)<br>c &lt;- <span class="hljs-number">0</span><br>&lt;-c<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印的结果是：</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231220214320935.png" alt="数字字母交替打印" style="zoom:70%;" /></p>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【后端开发】Golang语法基础</title>
    <link href="/2023/11/27/develop_go_basic/"/>
    <url>/2023/11/27/develop_go_basic/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><hr /><h1 id="golang基础">Golang基础</h1><p>参考学习资料：</p><ul><li><ahref="https://www.bilibili.com/video/BV1gf4y1r79E/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click">8小时转职Golang工程师</a></li><li><a href="https://gfw.go101.org/">Go语言101</a></li><li><ahref="https://golang.design/go-questions/">Go程序员面试笔试宝典</a></li></ul><h2 id="golang简介">Golang简介</h2><h3 id="go语言的优势">go语言的优势</h3><ol type="1"><li><strong>部署简单</strong><ul><li>可以直接编译成机器码可执行</li><li>不依赖其他库</li><li>直接运行即可部署</li></ul></li><li><strong>静态类型语言</strong><ul><li>编译的时候就能查出来大多数的问题</li></ul></li><li><strong>语言层面的并发</strong><ul><li>能够成分利用多核</li></ul></li><li><strong>强大的标准库</strong><ul><li>runtime系统调度机制</li><li>丰富的标准库</li></ul></li><li><strong>简单易学</strong><ul><li>25个关键字，内嵌C语法支持</li><li>面向对象的特征，能够跨平台</li><li>go语言<strong>没有异常</strong>，全部都用ERROR来表示</li></ul></li></ol><h3 id="go应用方向">go应用方向</h3><ol type="1"><li><strong>云计算基础设施建设</strong><ul><li>Docker, kubernetes</li><li>Consul, cloudflare CDN</li></ul></li><li><strong>基础后端软件</strong>：tide, influxdb, cockroachdb</li><li><strong>微服务</strong>：go-kit, micro</li><li><strong>互联网基础设施</strong>： 以太坊，hyperledger</li></ol><hr /><h2 id="go的环境安装">Go的环境安装</h2><h3 id="下载官网">下载官网</h3><p>go的官网下载网站，选择合适的系统版本进行安装<ahref="https://go.dev/dl/">https://go.dev/dl/</a></p><h3 id="安装步骤">安装步骤</h3><ol type="1"><li><p>下载安装包并按照安装包的指引下载相关的内容</p></li><li><p>对于Mac系统会直接配置好环境变量，根据官网的安装手册进行安装 <ahref="https://go.dev/doc/install">https://go.dev/doc/install</a></p></li><li><p>测试GO的版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go version<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231127204733470.png" alt="go version" style="zoom: 67%;" /></p></li><li><p>测试GO的环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go <span class="hljs-built_in">env</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231127204804150.png" alt="go env" style="zoom: 50%;" /></p></li></ol><h2 id="go环境变量">GO环境变量</h2><h3 id="goroot路径">GOROOT路径</h3><p>GOROOT 表示的是安装包所在的位置，一般不需要修改</p><h3 id="gopath路径">GOPATH路径</h3><p>GOPATH表示的是运行文件所在的位置，表示的是workspace的文件位置，GOPATH是我们的工作空间，保存go项目代码和第三方依赖包<strong>GOPATH</strong>可以设置多个，其中，第一个将会是默认的包目录，使用go get 下载的包都会在第一个path中的src目录下，使用 goinstall时，在哪个GOPATH中找到了这个包，就会在哪个GOPATH下的bin目录生成可执行文件</p><p>修改GOPATH的路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> GOPATH=<span class="hljs-string">&quot;/Users/lihaibin/workspace/golang&quot;</span><br></code></pre></td></tr></table></figure><p>将文件查找的路径设置为GOROOT和GOPATH的并集合</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$GOROOT</span>/bin:<span class="hljs-variable">$GOPATH</span>/bin<br></code></pre></td></tr></table></figure><p>将两个部分并在一起之后，就能从两个地方开始寻找定义的包</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203140236053.png"alt="查找文件的路径顺序" /><figcaption aria-hidden="true">查找文件的路径顺序</figcaption></figure><p>首先会从GOROOT进行搜索，接着从GOPATH进行搜索。</p><p>GOPATH是开发时的工作目录。用于：</p><ol type="1"><li>保存编译后的二进制文件。</li><li><code>go get</code>和<code>go install</code>命令会下载go代码到GOPATH。</li><li>import包时的搜索路径</li></ol><p>使用GOPATH时，GO会在以下目录中搜索包：</p><ol type="1"><li><code>GOROOT/src</code>：该目录保存了Go标准库代码。</li><li><code>GOPATH/src</code>：该目录保存了应用自身的代码和第三方依赖的代码。</li></ol><p><strong>GOPATH的弊端</strong></p><p>在 GOPATH 的 <code>$GOPATH/src</code> 下进行 <code>.go</code>文件或源代码的存储，我们可以称其为 GOPATH的模式，这个模式拥有一些弊端.</p><ul><li><p><strong>无版本控制概念.</strong>在执行<code>go get</code>的时候，你无法传达任何的版本信息的期望，也就是说你也无法知道自己当前更新的是哪一个版本，也无法通过指定来拉取自己所期望的具体版本。</p></li><li><p><strong>无法同步一致第三方版本号.</strong> 在运行 Go应用程序的时候，你无法保证其它人与你所期望依赖的第三方库是相同的版本，也就是说在项目依赖库的管理上，你无法保证所有人的依赖版本都一致。</p></li><li><p><strong>无法指定当前项目引用的第三方版本号.</strong> 你没办法处理v1、v2、v3 等等不同版本的引用问题，因为 GOPATH模式下的导入路径都是一样的，都是<code>github.com/foo/bar</code>。</p></li></ul><h3 id="goproxy设置">GOPROXY设置</h3><p>这个环境变量主要是用于设置 <strong>Go 模块代理（Go moduleproxy）,其作用是用于使 Go在后续拉取模块版本时直接通过镜像站点来快速拉取</strong>。</p><p>GOPROXY的默认值是：<code>https://proxy.golang.org,direct</code>，<code>proxy.golang.org</code>国内访问不了,需要设置国内的代理</p><ul><li>阿里云 https://mirrors.aliyun.com/goproxy/</li><li>七牛云 https://goproxy.cn,direct</li></ul><p>并通过以下的命令进行设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go <span class="hljs-built_in">env</span> -w GOPROXY=https://goproxy.cn,direct<br></code></pre></td></tr></table></figure><p>GOPROXY 的值是一个以英文逗号 “,” 分割的 Go模块代理列表，允许设置多个模块代理，假设你不想使用，也可以将其设置为“off” ，这将会禁止 Go 在后续操作中使用任何 Go 模块代理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go <span class="hljs-built_in">env</span> -w GOPROXY=https://goproxy.cn,https://mirrors.aliyun.com/goproxy/,direct<br></code></pre></td></tr></table></figure><h3 id="go111module">GO111MODULE</h3><p>GO111MODULE 有三个值：off, on和auto（默认值）。</p><ul><li>GO111MODULE=off，go命令行将不会支持module功能，寻找依赖包的方式将会沿用旧版本那种通过vendor目录或者GOPATH模式来查找。</li><li>GO111MODULE=on，go命令行会使用modules，而一点也不会去GOPATH目录下查找。</li><li>GO111MODULE=auto，默认值，go命令行将会根据当前目录来决定是否启用module功能。这种情况下可以分为两种情形：当前目录在GOPATH/src之外且该目录包含go.mod文件当前文件在包含go.mod文件的目录下面。</li></ul><p>执行以下命令开启go mod管理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go <span class="hljs-built_in">env</span> -w GO111MODULE=on<br></code></pre></td></tr></table></figure><p>Go mod操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go mod init github.com/hub/project<br></code></pre></td></tr></table></figure><h2 id="go基本语法">Go基本语法</h2><h3 id="如何编译并运行一个go文件">如何编译并运行一个Go文件</h3><p>对于已经写好的go文件，这里以hello.go作为例子，直接使用以下语句进行编译并运行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> run hello.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><p>或者将编译和运行两个过程分开，先编译后运行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> build hello.<span class="hljs-keyword">go</span><br>./ hello<br></code></pre></td></tr></table></figure><h3 id="写一个hello.go">写一个hello.go</h3><p>首先给出基本框架</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span>(<br><span class="hljs-string">&quot;fmt&quot;</span>,<br>  <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  fmt.Println(<span class="hljs-string">&quot;hello world!&quot;</span>)<br>  time.Sleep(<span class="hljs-number">1</span>*time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><p>程序的第一行声明了名为main的package。<strong>一个package会包含一个或多个.go源代码文件。每一个源文件都是以package开头。</strong>比如我们的例子里是packagemain。这行声明语句表示该文件是属于哪一个package。</p><ul><li>第一行代码<strong>packagemain</strong>定义了包名。你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：packagemain。package main表示一个可独立执行的程序，每个 Go应用程序都包含一个名为 main 的包。</li><li>下一行<strong>import "fmt"</strong>告诉 Go 编译器这个程序需要使用fmt 包（的函数，或其他元素），fmt 包实现了格式化IO（输入/输出）的函数</li><li><code>.</code>和没有<code>.</code>导入包的区别，如果一开始引入的时候有<code>.</code>那么就不需要指定哪个包的来调用函数，否则需要再调用函数的时候指定对应的包<code>package</code></li><li>下一行func main()是程序开始执行的函数。main函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有init() 函数则会先执行该函数）。</li></ul><blockquote><p>一个程序的<code>main</code>入口函数必须不带任何输入参数和返回结果。而且go语言的语法，定义函数的时候，<strong>‘{’必须和函数名在同一行，不能另起一行</strong></p></blockquote><h3 id="变量的声明">变量的声明</h3><p>声明变量的一般形式是使用 var 关键字</p><h4 id="第一种声明">第一种声明：</h4><p>指定变量类型，声明后若不赋值，使用<strong>默认值0</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> v_name v_type<br>v_name = value<br><span class="hljs-keyword">package</span> main<br><br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">var</span> a <span class="hljs-type">int</span><br>        fmt.Printf(<span class="hljs-string">&quot; = %d\n&quot;</span>, a)<br>&#125;<br><br><br>$<span class="hljs-keyword">go</span> run test.<span class="hljs-keyword">go</span><br>a = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="第二种声明">第二种声明：</h4><p>根据值自行判定变量类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> v_name = value<br></code></pre></td></tr></table></figure><h4 id="第三种声明">第三种声明：</h4><p>省略var, 注意:=左侧的变量不应该是已经声明过的，就是:=只能用于没有被声明的变量赋值上，否则会编译错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">v_name := value<br><br><br><span class="hljs-comment">// 例如</span><br><span class="hljs-keyword">var</span> a <span class="hljs-type">int</span> = <span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-number">10</span><br>c : = <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>几种声明类型的对比</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">//第一种 使用默认值</span><br>        <span class="hljs-keyword">var</span> a <span class="hljs-type">int</span><br>        fmt.Printf(<span class="hljs-string">&quot;a = %d\n&quot;</span>, a)<br><br><br>        <span class="hljs-comment">//第二种</span><br>        <span class="hljs-keyword">var</span> b <span class="hljs-type">int</span> = <span class="hljs-number">10</span><br>        fmt.Printf(<span class="hljs-string">&quot;b = %d\n&quot;</span>, b)<br><br><br>        <span class="hljs-comment">//第三种 省略后面的数据类型,自动匹配类型</span><br>        <span class="hljs-keyword">var</span> c = <span class="hljs-number">20</span><br>        fmt.Printf(<span class="hljs-string">&quot;c = %d\n&quot;</span>, c)<br><br><br>        <span class="hljs-comment">//第四种 省略var关键字</span><br>        d := <span class="hljs-number">3.14</span><br>        fmt.Printf(<span class="hljs-string">&quot;d = %f\n&quot;</span>, d)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="全局变量声明">全局变量声明</h4><p>和一般的定义变量的方式一样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x, y <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> c, d <span class="hljs-type">int</span> = <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">var</span> e, f = <span class="hljs-number">123</span>, <span class="hljs-string">&quot;lihaibin&quot;</span><br></code></pre></td></tr></table></figure><p>特殊的定义全局变量的方式，而且<strong>:=的定义方式不能够用于定义全局变量</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">var</span> ( <span class="hljs-comment">//这种分解的写法,一般用于声明全局变量</span><br>        a <span class="hljs-type">int</span><br>        b <span class="hljs-type">bool</span><br>)<br><br><span class="hljs-comment">//这种不带声明格式的只能在函数体内声明</span><br><span class="hljs-comment">//g, h := 123, &quot;需要在func函数体内实现&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;&#125;<br></code></pre></td></tr></table></figure><h4 id="多变量声明">多变量声明</h4><p>:=不能用于已经被初始化之后的变量的赋值，如果对于_的情况是不具备可读性，相当于忽略</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        g, h := <span class="hljs-number">123</span>, <span class="hljs-string">&quot;需要在func函数体内实现&quot;</span><br>        fmt.Println(x, y, a, b, c, d, e, f, g, h)<br><br>        <span class="hljs-comment">//不能对g变量再次做初始化声明</span><br>        <span class="hljs-comment">//g := 400</span><br><br>        _, value := <span class="hljs-number">7</span>, <span class="hljs-number">5</span>  <span class="hljs-comment">//实际上7的赋值被废弃，变量 _  不具备读特性</span><br>        <span class="hljs-comment">//fmt.Println(_) //_变量的是读不出来的</span><br>        fmt.Println(value) <span class="hljs-comment">//5</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="常量">常量</h3><h4 id="常量的声明方式">常量的声明方式</h4><p>常量是一个简单值的标识符，在程序运行时，<strong>不会被修改的量</strong>。常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。</p><p>常量的定义格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> identifier [<span class="hljs-keyword">type</span>] = value<br><span class="hljs-keyword">const</span> b <span class="hljs-type">string</span> = <span class="hljs-string">&quot;abc&quot;</span><br></code></pre></td></tr></table></figure><p>隐式定义类型方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> b = <span class="hljs-string">&quot;abc&quot;</span><br></code></pre></td></tr></table></figure><p>多重赋值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> a, b, c = <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;str&quot;</span> <span class="hljs-comment">//多重赋值</span><br></code></pre></td></tr></table></figure><p>枚举类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    Unknown = <span class="hljs-number">0</span><br>    Female = <span class="hljs-number">1</span><br>    Male = <span class="hljs-number">2</span><br>)<br></code></pre></td></tr></table></figure><p>常量可以用len(), cap(),unsafe.Sizeof()常量计算表达式的值。常量表达式中，函数必须是内置函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;unsafe&quot;</span><br><span class="hljs-keyword">const</span> (<br>    a = <span class="hljs-string">&quot;abc&quot;</span><br>    b = <span class="hljs-built_in">len</span>(a)<br>    c = unsafe.Sizeof(a)<br>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">println</span>(a, b, c)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为：abc, 3, 16</p><blockquote><p>unsafe.Sizeof(a) = 16</p><p>字符串类型在 go 里是个结构,包含指向底层数组的指针和长度,这两部分每部分都是 8个字节，所以字符串类型大小为 16 个字节。</p></blockquote><h4 id="常量中的iota标识符">常量中的iota标识符</h4><p>在 golang中，一个方便的习惯就是使用<code>iota</code>标示符，简化了常量用于增长数字的定义。</p><p>下面的代码中，当第一行赋值了iota之后，那么相当于初始化位置是0，后面的依次增加是1，2</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    CategoryBooks = <span class="hljs-literal">iota</span> <span class="hljs-comment">// 0</span><br>    CategoryHealth       <span class="hljs-comment">// 1</span><br>    CategoryClothing     <span class="hljs-comment">// 2</span><br>)<br></code></pre></td></tr></table></figure><p>如果对<code>iota</code>进行运算，其实相当于是选择当前的行作为iota的取值进行运算，如果中间不对运算加以改变，那么会一直持续按照当前的运算规则执行下去</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br><span class="hljs-comment">//关键字 iota</span><br><span class="hljs-comment">/* BEIJING=0</span><br><span class="hljs-comment">SHANGHAI=1</span><br><span class="hljs-comment">SHENGZHENG=2 */</span><br>BEIJING = <span class="hljs-number">10</span> * <span class="hljs-literal">iota</span> <span class="hljs-comment">// 默认为0 输出0</span><br>SHANGHAI  <span class="hljs-comment">//输出10</span><br>HANGZHOU <span class="hljs-comment">//输出20</span><br>)<br></code></pre></td></tr></table></figure><p>同样的在同一个const中去定义不同的<code>iota</code>的计算方式也可以，<code>iota</code>的取值就是选择当前的行，从哪个地方开始改变，那么就改成不同的计算方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br><span class="hljs-comment">//这个iota的值表示的是和行数有关的数值，因此计算的时候用行来表示</span><br>a, b = <span class="hljs-literal">iota</span> + <span class="hljs-number">1</span>, <span class="hljs-literal">iota</span> + <span class="hljs-number">2</span> <span class="hljs-comment">//每次新开一个关于iota的计算 那么后续全部会跟着这个计算方式下去</span><br>c, d<br>e, f<br>g, h = <span class="hljs-literal">iota</span> * <span class="hljs-number">2</span>, <span class="hljs-literal">iota</span> * <span class="hljs-number">3</span><br><span class="hljs-comment">//iota只能在const之中使用</span><br>i, k<br>)<br></code></pre></td></tr></table></figure><p>以下是输出的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">a= 1 b= 2 c= 2 d= 3 e= 3 f= 4 g= 6 h= 9 i= 8 k= 12<br></code></pre></td></tr></table></figure><h3 id="函数">函数</h3><h4 id="基本函数的定义">基本函数的定义</h4><p>多个返回值初始化设置了函数的形参之后，初始值是0</p><p>go每次设置一个变量值之后都有初始值，如果是数据就是0，如果是字符串那么就是空，防止出现一些野指针的情况</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(x, y <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">string</span>) &#123;<br>   <span class="hljs-keyword">return</span> y, x<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   a, b := swap(<span class="hljs-string">&quot;Mahesh&quot;</span>, <span class="hljs-string">&quot;Kumar&quot;</span>)<br>   fmt.Println(a, b)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出的结果是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">Kumar Mahesh<br></code></pre></td></tr></table></figure><h4 id="import和init">import和init</h4><p>所有被导入的包都加载完毕了，就会开始对main包中的包级常量和变量进行初始化，执行main包中的init函数，最后执行main函数。下图详细地解释了整个执行过程：</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231202121630297.png"alt="init的调用顺序" /><figcaption aria-hidden="true">init的调用顺序</figcaption></figure><p>分别建不同的文件夹对应的就是package的名字，相应的在.go文件内部声明package的名字</p><p>main 函数只能在package main中</p><p><strong>注意：</strong>在包中设置接口的时候，函数名称<strong>必须第一个字母是大写，如果是小写的话将无法识别</strong></p><ul><li>如果函数名第一个是大写就是对外开放的函数，认为是public</li><li>如果函数名第一个是小写的话就认为是私有的函数，认为是private</li></ul><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203140110880.png" alt="接口函数大小写的区别" style="zoom:67%;" /></p><p>init函数的调用过程，首先会对包中的init进行初始化再进行调用接口</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203140412429.png" alt="init()调用顺序和过程" style="zoom:67%;" /></p><p>如果你导入了包比如lib1，但是没有使用这个包里面的接口函数，仍然会报错</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203141038750.png" alt="导入包但是没有使用接口函数" style="zoom:67%;" /></p><p>以下是一个import包的例子，首先定义两个不同包以及对应的接口函数和初始化函数的实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> InitLib1<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;lib1&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> InitLib2<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;lib2&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;GolangTraining/InitLib1&quot;</span><br>    <span class="hljs-string">&quot;GolangTraining/InitLib2&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;libmain init&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;libmian main&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>"GolangTraining/InitLib1""GolangTraining/InitLib2"</code>是两个包的地址，go会默认从GOROOT和GOPATH两个默认的位置进行寻找，首先要保证地址的正确性</p><p>代码的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">lib1<br>lib2<br>libmain init<br>libmian main<br></code></pre></td></tr></table></figure><h4 id="匿名导包方式">匿名导包方式</h4><p>如果我不想调用lib1的函数接口，但是想使用lib1的init()函数怎么办呢，如果这个时候直接导入了包但是不调用接口，就会出现上述的错误</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203141038750.png" alt="导入包但是没有使用接口函数" style="zoom:70%;" /></p><p>在导入的包前面加上下划线来认为这个包是匿名的，这样就能知进行init操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span>(<br><span class="hljs-string">&quot;fmt&quot;</span><br>_<span class="hljs-string">&quot;lib2&quot;</span><br>)<br></code></pre></td></tr></table></figure><p>那么这个时候就只会调用<code>init()</code>函数同时不会出错</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203141336299.png"alt="只调用init()函数" /><figcaption aria-hidden="true">只调用init()函数</figcaption></figure><p>除了能够匿名导包之外，还能给新导入的包起个别的名字，比如叫mylib作为新的别名</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203141500041.png" alt="给导入的包换个名字" style="zoom:67%;" /></p><p>或者直接使用<code>·</code>来进行调用</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203141620428.png" alt="换别名进行导包" style="zoom:67%;" /></p><p>最好别使用这种，如果两个包的函数名称一样那么可能会导致<strong>出现歧义的情况</strong></p><h4 id="函数值传递">函数值传递</h4><p>函数如果使用参数，该变量可称为函数的形参。</p><p><strong>形参</strong>就像定义在函数体内的<strong>局部变量</strong>。调用函数，可以通过两种方式来传递参数：<strong>值传递和指针传递</strong></p><p>值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。<strong>默认情况下，Go语言使用的是值传递</strong>，即在调用过程中不会影响到实际参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* 定义相互交换值的函数 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>   <span class="hljs-keyword">var</span> temp <span class="hljs-type">int</span><br><br><br>   temp = x <span class="hljs-comment">/* 保存 x 的值 */</span><br>   x = y    <span class="hljs-comment">/* 将 y 值赋给 x */</span><br>   y = temp <span class="hljs-comment">/* 将 temp 值赋给 y*/</span><br><br><br>   <span class="hljs-keyword">return</span> temp;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，让我们使用值传递来调用 swap() 函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">/* 定义局部变量 */</span><br>   <span class="hljs-keyword">var</span> a <span class="hljs-type">int</span> = <span class="hljs-number">100</span><br>   <span class="hljs-keyword">var</span> b <span class="hljs-type">int</span> = <span class="hljs-number">200</span><br><br><br>   fmt.Printf(<span class="hljs-string">&quot;交换前 a 的值为 : %d\n&quot;</span>, a )<br>   fmt.Printf(<span class="hljs-string">&quot;交换前 b 的值为 : %d\n&quot;</span>, b )<br><br><br>   <span class="hljs-comment">/* 通过调用函数来交换值 */</span><br>   swap(a, b)<br><br><br>   fmt.Printf(<span class="hljs-string">&quot;交换后 a 的值 : %d\n&quot;</span>, a )<br>   fmt.Printf(<span class="hljs-string">&quot;交换后 b 的值 : %d\n&quot;</span>, b )<br>&#125;<br><br><br><span class="hljs-comment">/* 定义相互交换值的函数 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>   <span class="hljs-keyword">var</span> temp <span class="hljs-type">int</span><br><br><br>   temp = x <span class="hljs-comment">/* 保存 x 的值 */</span><br>   x = y    <span class="hljs-comment">/* 将 y 值赋给 x */</span><br>   y = temp <span class="hljs-comment">/* 将 temp 值赋给 y*/</span><br><br><br>   <span class="hljs-keyword">return</span> temp;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行的结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">交换前 a 的值为 : 100<br>交换前 b 的值为 : 200<br>交换后 a 的值 : 100<br>交换后 b 的值 : 200<br></code></pre></td></tr></table></figure><h3 id="go指针">GO指针</h3><p>和C++以及C中的是一样的，对go中的指针定义的时候 *int传递变量的地址&amp;</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203171319969.png" alt="指针和引用的传递例子" style="zoom:67%;" /></p><p>在对一个指针赋值的时候，传递的是某一个变量的地址，就是传递这个变量的引用，引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p><h3 id="defer">defer</h3><p>defer语句被用于预定对一个函数的调用。可以把这类被defer语句调用的函数称为<strong>延迟函数</strong>，主要作用：</p><ul><li>释放占用的资源</li><li>捕捉处理异常</li><li>输出日志</li></ul><p>如果一个函数中有多个defer语句，它们会以<strong>LIFO（后进先出）</strong>的顺序执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Demo</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;1&quot;</span>)<br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;2&quot;</span>)<br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;3&quot;</span>)<br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;4&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>Demo()<br>&#125;<br></code></pre></td></tr></table></figure><p>输出的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">4<br>3<br>2<br>1<br></code></pre></td></tr></table></figure><h3 id="数组与切片">数组与切片</h3><p>Go 语言切片 <code>slice</code> 是对数组的抽象</p><h4 id="静态数组">静态数组</h4><p>通过这种方式进行初始化数组以及进行切片操作，通过range关键字进行遍历数组，并给出index和value进行给出不同的下标和数值</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203174817927.png" alt="初始化数组并进行切片操作" style="zoom:67%;" /></p><p>固定数组传递的是一个值拷贝</p><h4 id="动态数组-slice"><strong>动态数组 slice</strong></h4><p>切片不需要说明长度</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment">声明切片之后的长度是3，同时初始化的值是1，2，3</span><br><span class="hljs-comment">*/</span><br>slice1 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>s := arr[:]<br><span class="hljs-comment">//但是这个时候就只会重新赋予空间并复制0</span><br>slice1 = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">4</span>)<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">声明slice是切片,但是没有分配空间</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">var</span> slice2 []<span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><p>也可以指定容量，其中<code>capacity</code>为可选参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">make</span>([]T, length, capacity)<br></code></pre></td></tr></table></figure><p>将arr中从下标startIndex到<strong>endIndex-1</strong>下的元素创建为一个新的切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">s := arr[startIndex:endIndex]<br></code></pre></td></tr></table></figure><p>缺省endIndex时将表示一直到arr的最后一个元素，缺省startIndex时将表示从arr的第一个元素开始</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">s := arr[startIndex:]<br>s := arr[:endIndex]<br></code></pre></td></tr></table></figure><p>通过切片s初始化切片s1</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">s1 := s[startIndex:endIndex]<br></code></pre></td></tr></table></figure><p>通过内置函数 <code>make()</code>初始化切片s,<code>[]int</code>标识为其元素类型为int的切片</p><p>同时动态数组传递的过程中的参数形式是一致的，能够适配所有的slice参数类型，但是对于</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203205827787.png" alt="动态数组传递引用同时不会因为长度不一样而改变形参" style="zoom:67%;" /></p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203205839072.png" alt="动态数组的初始化和打印" style="zoom:67%;" /></p><p>这里面的下划线表示的是<strong>不需要考虑</strong>的index的数值，可以忽略，这里是关于切片slice的声明和打印</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//声明切片之后的长度是3，同时初始化的值是1，2，3</span><br>slice1 :=[]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br><span class="hljs-comment">//%v表示的是打印出全部的表示信息</span><br>fmt.Printf(<span class="hljs-string">&quot;len = %d, slice =%v\n&quot;</span>, <span class="hljs-built_in">len</span>(slice1),slice1)<br>&#125;<br></code></pre></td></tr></table></figure><p>打印的结果是</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203210558440.png" alt="输出的结果" style="zoom:67%;" /></p><p>声明slice但是不一定声明了空间，因此需要注意的是声明的同时并给出空间大小，同时没办法中途增加空间</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span>  <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">/* </span><br><span class="hljs-comment">声明切片之后的长度是3，同时初始化的值是1，2，3</span><br><span class="hljs-comment"> */</span><br>slice1 :=[]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br><span class="hljs-comment">//%v表示的是打印出全部的表示信息</span><br>fmt.Printf(<span class="hljs-string">&quot;len = %d, slice =%v\n&quot;</span>, <span class="hljs-built_in">len</span>(slice1),slice1)<br><span class="hljs-comment">//直接对没有赋予空间的位置修改会出现位置越界</span><br><span class="hljs-comment">//slice1[3]=999</span><br>slice1 = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">4</span>)<br><span class="hljs-comment">//但是这个时候就只会重新赋予空间并复制0</span><br>fmt.Printf(<span class="hljs-string">&quot;len = %d, slice =%v\n&quot;</span>, <span class="hljs-built_in">len</span>(slice1),slice1)<br><span class="hljs-comment">/* </span><br><span class="hljs-comment">声明slice是切片,但是没有分配空间</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> slice2 []<span class="hljs-type">int</span><br>fmt.Printf(<span class="hljs-string">&quot;len = %d, slice =%v\n&quot;</span>, <span class="hljs-built_in">len</span>(slice2),slice2)<br><span class="hljs-comment">//slice2[0]=2 //直接赋予数值会出现错误，越界</span><br>slice2 = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">3</span>)<br><span class="hljs-comment">//开辟空间，但是默认值都是0</span><br>fmt.Printf(<span class="hljs-string">&quot;len = %d, slice =%v\n&quot;</span>, <span class="hljs-built_in">len</span>(slice2),slice2)<br>slice2[<span class="hljs-number">0</span>]=<span class="hljs-number">1000</span><br>fmt.Printf(<span class="hljs-string">&quot;len = %d, slice =%v\n&quot;</span>, <span class="hljs-built_in">len</span>(slice2),slice2)<br><span class="hljs-comment">//此时就修改成功</span><br><span class="hljs-comment">/*  </span><br><span class="hljs-comment">声明slice类型，同时分配空间</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">var</span> slice3 =<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">5</span>)<br>fmt.Printf(<span class="hljs-string">&quot;len = %d, slice =%v\n&quot;</span>, <span class="hljs-built_in">len</span>(slice3),slice3)<br><br><br></code></pre></td></tr></table></figure><p>判断一个切片是不是空的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* </span><br><span class="hljs-comment">判断一个slice切片是不是为0</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">if</span> slice1 == <span class="hljs-literal">nil</span>&#123;<br>fmt.Println(<span class="hljs-string">&quot;slice1 is null&quot;</span>)<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>fmt.Println(<span class="hljs-string">&quot;slice1 is not null&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意if-else的格式有要求，<code>&#123;</code>必须是出现在else和if紧接着的位置，不能换行写</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203211744713.png" alt="判断当前的动态数组是不是空的" style="zoom:67%;" /></p><h4 id="append和copy">append()和copy()</h4><p>如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203213134825.png" alt="追加元素的操作显示" style="zoom:67%;" /></p><p><strong>注意，如果append超过了当前的空间，那么slice就会继续增加空间，增加的大小是cap的大小增加</strong></p><p>拷贝copy()操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* 创建切片 numbers1 是之前切片的两倍容量*/</span><br>   numbers1 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(numbers), (<span class="hljs-built_in">cap</span>(numbers))*<span class="hljs-number">2</span>)<br><br><br>   <span class="hljs-comment">/* 拷贝 numbers 的内容到 numbers1 */</span><br>   <span class="hljs-built_in">copy</span>(numbers1,numbers)<br>   printSlice(numbers1)  <br></code></pre></td></tr></table></figure><p>关于切片的截取操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* </span><br><span class="hljs-comment">切片的截取 </span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">var</span> slice6 = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">3</span>)<br>slice6[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span><br>slice6[<span class="hljs-number">2</span>]=<span class="hljs-number">33</span><br>fmt.Printf(<span class="hljs-string">&quot;len = %d, cap = %d, slice =%v\n&quot;</span>, <span class="hljs-built_in">len</span>(slice6), <span class="hljs-built_in">cap</span>(slice6), slice6)<br><span class="hljs-comment">//截取的过程中是左闭右开</span><br>s1:=slice6[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]<br><span class="hljs-comment">// s1:=slice6[:]//表示截取全部</span><br>fmt.Println(s1)<br><span class="hljs-comment">//注意此时的s1的地址和slice6的位置一样了</span><br><br><span class="hljs-comment">//copy</span><br><span class="hljs-keyword">var</span> s2 = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">3</span>)<br><span class="hljs-built_in">copy</span>(s2,slice6)<br>fmt.Println(s2)<span class="hljs-comment">// 只会从头开始截取s2长度的，如果长了那么就是0，</span><br><span class="hljs-comment">//否则就是选择slice6中相同长度的元素，从左到右边</span><br></code></pre></td></tr></table></figure><h3 id="map">map</h3><p>map和slice类似，只不过是数据结构不同，下面是map的一些声明方式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//第一种声明</span><br>    <span class="hljs-keyword">var</span> test1 <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span><br>    <span class="hljs-comment">//在使用map前，需要先make，make的作用就是给map分配数据空间</span><br>    test1 = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>, <span class="hljs-number">10</span>) <br>    test1[<span class="hljs-string">&quot;one&quot;</span>] = <span class="hljs-string">&quot;php&quot;</span><br>    test1[<span class="hljs-string">&quot;two&quot;</span>] = <span class="hljs-string">&quot;golang&quot;</span><br>    test1[<span class="hljs-string">&quot;three&quot;</span>] = <span class="hljs-string">&quot;java&quot;</span><br>    fmt.Println(test1) <span class="hljs-comment">//map[two:golang three:java one:php]</span><br><br><br>    <span class="hljs-comment">//第二种声明</span><br>    test2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)<br>    test2[<span class="hljs-string">&quot;one&quot;</span>] = <span class="hljs-string">&quot;php&quot;</span><br>    test2[<span class="hljs-string">&quot;two&quot;</span>] = <span class="hljs-string">&quot;golang&quot;</span><br>    test2[<span class="hljs-string">&quot;three&quot;</span>] = <span class="hljs-string">&quot;java&quot;</span><br>    fmt.Println(test2) <span class="hljs-comment">//map[one:php two:golang three:java]</span><br><br>    <span class="hljs-comment">//第三种声明</span><br>    test3 := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<br>        <span class="hljs-string">&quot;one&quot;</span> : <span class="hljs-string">&quot;php&quot;</span>,<br>        <span class="hljs-string">&quot;two&quot;</span> : <span class="hljs-string">&quot;golang&quot;</span>,<br>        <span class="hljs-string">&quot;three&quot;</span> : <span class="hljs-string">&quot;java&quot;</span>,<br>    &#125;<br>    fmt.Println(test3) <span class="hljs-comment">//map[one:php two:golang three:java]</span><br><br><br>    <br>    language := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)<br>    language[<span class="hljs-string">&quot;php&quot;</span>] = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>, <span class="hljs-number">2</span>)<br>    language[<span class="hljs-string">&quot;php&quot;</span>][<span class="hljs-string">&quot;id&quot;</span>] = <span class="hljs-string">&quot;1&quot;</span><br>    language[<span class="hljs-string">&quot;php&quot;</span>][<span class="hljs-string">&quot;desc&quot;</span>] = <span class="hljs-string">&quot;php是世界上最美的语言&quot;</span><br>    language[<span class="hljs-string">&quot;golang&quot;</span>] = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>, <span class="hljs-number">2</span>)<br>    language[<span class="hljs-string">&quot;golang&quot;</span>][<span class="hljs-string">&quot;id&quot;</span>] = <span class="hljs-string">&quot;2&quot;</span><br>    language[<span class="hljs-string">&quot;golang&quot;</span>][<span class="hljs-string">&quot;desc&quot;</span>] = <span class="hljs-string">&quot;golang抗并发非常good&quot;</span><br>    <br>    fmt.Println(language) <span class="hljs-comment">//map[php:map[id:1 desc:php是世界上最美的语言] golang:map[id:2 desc:golang抗并发非常good]]</span><br><br><br>    <span class="hljs-comment">//增删改查</span><br>    <span class="hljs-comment">// val, key := language[&quot;php&quot;]  //查找是否有php这个子元素</span><br>    <span class="hljs-comment">// if key &#123;</span><br>    <span class="hljs-comment">//     fmt.Printf(&quot;%v&quot;, val)</span><br>    <span class="hljs-comment">// &#125; else &#123;</span><br>    <span class="hljs-comment">//     fmt.Printf(&quot;no&quot;);</span><br>    <span class="hljs-comment">// &#125;</span><br><br>    <span class="hljs-comment">//language[&quot;php&quot;][&quot;id&quot;] = &quot;3&quot; //修改了php子元素的id值</span><br>    <span class="hljs-comment">//language[&quot;php&quot;][&quot;nickname&quot;] = &quot;啪啪啪&quot; //增加php元素里的nickname值</span><br>    <span class="hljs-comment">//delete(language, &quot;php&quot;)  //删除了php子元素</span><br>    fmt.Println(language)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="面向对象结构体">面向对象结构体</h3><h4 id="定义一个结构体">定义一个结构体</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//定义一个结构体</span><br><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>    name <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>分别定义不同的拷贝和引用的函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t T)</span></span> method1() &#123;<br>    t.name = <span class="hljs-string">&quot;new name1&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span></span> method2() &#123;<br>    t.name = <span class="hljs-string">&quot;new name2&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>结果是使用值拷贝的输出的name没有改变，只有使用引用的才发生了改变</p><p>关于结构体定义的细节，内部的成员变量和结构体本身的大小写就是蕴含了是不是私有和公有的关系，大写标识公有，小写表示私有</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 如果这个类如果是大写，那么其他的Package也能够访问</span><br><span class="hljs-keyword">type</span> Human <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span> <span class="hljs-comment">//其中变量名称表示大写说明是能够对外界可见的public</span><br>Age  <span class="hljs-type">int</span><br><span class="hljs-comment">//如果是小写那么就是private的属性</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于结构体内部的成员函数，必须是传递了引用的地址才能够修改，否则就是默认的值传递</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Human)</span></span> GetName() &#123;<br>fmt.Println(this.Name)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Human)</span></span> SetName(newname <span class="hljs-type">string</span>) &#123;<br><span class="hljs-comment">//只有是引用地址的传递的时候才是能够修改的</span><br>this.Name = newname<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this Human)</span></span> SetName1(newname <span class="hljs-type">string</span>) &#123;<br><span class="hljs-comment">//默认是值传递</span><br>this.Name = newname<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="类的继承性">类的继承性</h4><p>如果新定义的类继承了某个类，那么只需要在内部写上所继承的类的名称，同时这里没有C++中的公有保护等其他类型的继承，公有私有的设定保持一致</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Superman <span class="hljs-keyword">struct</span> &#123;<br>Human <span class="hljs-comment">//表示Superman继承了Human，同时这里没有C++中的公有保护等其他类型的继承</span><br><span class="hljs-comment">//在子类中重新增加变量</span><br>Level <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对继承类中的方法重写，同样传递的还是引用和指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 对于父类方法进行重写</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Superman)</span></span> GetName() &#123;<br>fmt.Println(this.Name)<br>fmt.Println(this.Level)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>重新定义新的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 子类中的新方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Superman)</span></span> LevelUp() &#123;<br>fmt.Println(<span class="hljs-string">&quot;level up&quot;</span>)<br>this.Level = this.Level + <span class="hljs-number">1</span><br>fmt.Println(this)<br>&#125;<br></code></pre></td></tr></table></figure><p>关于主函数中的调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>human := Human&#123;Name: <span class="hljs-string">&quot;zhang&quot;</span>, Age: <span class="hljs-number">99</span>&#125;<br>human.SetName1(<span class="hljs-string">&quot;li&quot;</span>)<br>fmt.Println(human) <span class="hljs-comment">//&#123;zhang 99&#125;</span><br>human.SetName(<span class="hljs-string">&quot;li&quot;</span>)<br>fmt.Println(human) <span class="hljs-comment">//&#123;li 99&#125;</span><br>human.GetName()<br>fmt.Println(<span class="hljs-string">&quot;-------------&quot;</span>)<br>superman := Superman&#123;Human&#123;<span class="hljs-string">&quot;li4&quot;</span>, <span class="hljs-number">18</span>&#125;, <span class="hljs-number">99</span>&#125;<br><span class="hljs-comment">//父类方法的重写</span><br>superman.GetName()<br><span class="hljs-comment">//子类新方法</span><br>superman.LevelUp()<br><span class="hljs-comment">/* level up</span><br><span class="hljs-comment">&amp;&#123;&#123;li4 18&#125; 100&#125; */</span><br><span class="hljs-comment">//父类方法原封不动</span><br>superman.SetName(<span class="hljs-string">&quot;wang5&quot;</span>)<br>fmt.Println(superman) <span class="hljs-comment">//&#123;&#123;wang5 18&#125; 100&#125;</span><br><br>fmt.Println(<span class="hljs-string">&quot;+++++++++++++&quot;</span>)<br><span class="hljs-comment">//第二种继承类对象的声明</span><br><span class="hljs-keyword">var</span> super Superman<br>super.Name = <span class="hljs-string">&quot;zhangmazi&quot;</span><br>super.Level = <span class="hljs-number">100</span><br>super.Age = <span class="hljs-number">19</span><br>fmt.Println(super)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="interface与类型断言">Interface与类型断言</h3><p>在继承和多态上，一系列家族定义的接口，<strong>每个子类能够重写方法</strong>，实现同一个方法有多个接口表现形式</p><h4 id="类的多态性">类的多态性</h4><p>本质上利用interface来实现类的多态性</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 本质是一个指针多态</span><br><span class="hljs-keyword">type</span> Animal <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">//给出接口包含的多态的函数</span><br>Sleep()<br>GetColor() <span class="hljs-type">string</span><br>GetType() <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">// 定义一个具体的类</span><br><span class="hljs-keyword">type</span> Cat <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">/*如果继承一个接口interface 那么就不需要直接写出来继承，</span><br><span class="hljs-comment">只需要进行实现就可以认为继承了这个接口inerface</span><br><span class="hljs-comment">*/</span><br>color <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">// 第二个多态的类</span><br><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">//同样需要进行继承这个interface</span><br>color <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>那怎么认为这个cat继承了这个animal类呢？只需要对animal中的所有函数重写即可认为是继承了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* 必须要完全重写所有的接口才能认为是多态满足 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Cat)</span></span> Sleep() &#123;<br>fmt.Println(<span class="hljs-string">&quot;cat sleep...&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Cat)</span></span> GetColor() <span class="hljs-type">string</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;the cat color is %v\n&quot;</span>, this.color)<br><span class="hljs-keyword">return</span> this.color<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Cat)</span></span> GetType() <span class="hljs-type">string</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;the type is cat\n&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Cat&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>同理对于dog也是一样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Dog)</span></span> Sleep() &#123;<br>fmt.Println(<span class="hljs-string">&quot;dog sleep...&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Dog)</span></span> GetColor() <span class="hljs-type">string</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;the dog color is %v\n&quot;</span>, this.color)<br><span class="hljs-keyword">return</span> this.color<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Dog)</span></span> GetType() <span class="hljs-type">string</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;the type is dog\n&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Dog&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>主函数中如何实现不同的多态调用呢？注意哦，这个地方传递的是继承类的引用进去来实现多态</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">showanimal</span><span class="hljs-params">(animal Animal)</span></span> &#123;<br>animal.Sleep()<br><span class="hljs-comment">// fmt.Println(&quot;color = &quot;,animal.GetColor())</span><br><span class="hljs-comment">// fmt.Println(&quot;type = &quot;,animal.GetType())</span><br>animal.GetType()<br>animal.GetColor()<br>&#125;<br><br><br>cat := Cat&#123;<span class="hljs-string">&quot;Green&quot;</span>&#125;<br>dog := Dog&#123;<span class="hljs-string">&quot;Yellow&quot;</span>&#125;<br><br><span class="hljs-comment">//通过传递指针和引用来实现多态性</span><br>showanimal(&amp;cat)<br>showanimal(&amp;dog)<br></code></pre></td></tr></table></figure><h4 id="万能类型interface">万能类型interface</h4><p>golang中的所有程序都实现了interface{}的接口，这意味着，所有的类型如string,int,int64甚至是自定义的struct类型都就此拥有了<code>interface&#123;&#125;</code>的接口，这种做法和java中的Object类型比较类似。那么在一个数据通过<code>func funcName(interface&#123;&#125;)</code>的方式传进来的时候，也就意味着这个参数被自动的转为<code>interface&#123;&#125;</code>的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">funcName</span><span class="hljs-params">(a <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">string</span> &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(a)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>interface&#123;&#125;</code>相当于是一个万能的数据类型，适用于对任何的函数的参数传递中的使用</p><ul><li>直接断言使用</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-keyword">interface</span>&#123;&#125;<br>fmt.Println(<span class="hljs-string">&quot;Where are you,Jonny?&quot;</span>, a.(<span class="hljs-type">string</span>))<br></code></pre></td></tr></table></figure><p>如果断言失败一般会导致panic的发生。所以为了防止panic的发生，我们需要在断言前进行一定的判断</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">value, ok := a.(<span class="hljs-type">string</span>)<br></code></pre></td></tr></table></figure><p>如果断言失败，<strong>那么ok的值将会是false,但是如果断言成功ok的值将会是true</strong>，同时value将会得到所期待的正确的值。</p><h5 id="interface的例子">interface{}的例子</h5><p>定义一个断言类型的函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunc</span><span class="hljs-params">(arg <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;myfunc is called...&quot;</span>)<br>fmt.Println(arg)<br><br><span class="hljs-comment">//interface&#123;&#125;如何确定类型是什么呢？</span><br><br><span class="hljs-comment">//类型断言机制 用于判断是什么类型</span><br>value, ok := arg.(<span class="hljs-type">string</span>)<br><span class="hljs-keyword">if</span> !ok &#123;<br>fmt.Println(<span class="hljs-string">&quot;arg is not a string&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;the value is %T\n&quot;</span>, arg) <span class="hljs-comment">//the value is main.Book</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;arg is string type,is = &quot;</span>, value)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主函数的调用关系如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Book <span class="hljs-keyword">struct</span> &#123;<br>auth <span class="hljs-type">string</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>book := Book&#123;<span class="hljs-string">&quot;golang&quot;</span>&#125;<br>myFunc(book) <span class="hljs-comment">//&#123;golang&#125;</span><br>myFunc(<span class="hljs-number">100</span>)  <span class="hljs-comment">//100</span><br>myFunc(<span class="hljs-string">&quot;goland&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出的内容是：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#输出的值</span><br>myfunc is called...<br>&#123;golang&#125;<br>arg is not a string<br>the value is main.Book<br>myfunc is called...<br>100<br>arg is not a string<br>the value is int<br>myfunc is called...<br>goland<br></code></pre></td></tr></table></figure><h3 id="reflect反射">Reflect反射</h3><p>在讲反射之前，先来看看Golang关于类型设计的一些原则</p><ul><li>变量包括（type, value）两部分</li><li>type 包括 <code>static type</code>和<code>concrete type</code>.简单来说<code>static type</code>是你在编码是看见的类型(如int、string)，<code>concrete type</code>是<code>runtime</code>系统看见的类型</li><li>类型断言能否成功，取决于变量的<code>concrete type</code>，而不是<code>static type</code>.因此，一个<code>reader</code>变量如果它的<code>concrete type</code>也实现了<code>write</code>方法的话，它也可以被类型断言为<code>writer</code>.</li></ul><p><code>反射</code>，就是建立在类型之上的，Golang的指定类型的变量的类型是静态的（也就是指定int、string这些的变量，它的type是statictype），在创建变量的时候就已经确定，<strong>反射主要与Golang的interface类型相关</strong>（它的type是concretetype），<strong>只有interface类型才有反射一说</strong></p><p>在Golang的实现中，每个<code>interface</code>变量都有一个对应<code>pair</code>，pair中记录了实际变量的值和类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">(value, <span class="hljs-keyword">type</span>)<br></code></pre></td></tr></table></figure><p>value是实际变量值，type是实际变量的类型。一个<code>interface&#123;&#125;</code>类型的变量包含了2个指针，一个指针指向值的<strong>类型<code>concrete type</code></strong>，另外一个指针指向<strong>实际的值对应<code>value</code></strong></p><h4 id="reflect的基本功能">reflect的基本功能</h4><p><strong>reflect的反射类型对象：TypeOf和ValueOf</strong></p><p>那么在Golang的reflect反射包中有什么样的方式可以让我们直接获取到变量内部的信息呢？它提供了两种类型（或者说两个方法）让我们可以很容易的访问接口变量内容，分别是<code>reflect.ValueOf()</code>和 <code>reflect.TypeOf()</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// ValueOf returns a new Value initialized to the concrete value</span><br><span class="hljs-comment">// stored in the interface i.  ValueOf(nil) returns the zero </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ValueOf</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> Value &#123;...&#125;<br><br><span class="hljs-comment">//ValueOf用来获取输入参数接口中的数据的值，如果接口为空则返回0</span><br><br><br><span class="hljs-comment">// TypeOf returns the reflection Type that represents the dynamic type of i.</span><br><span class="hljs-comment">// If i is a nil interface value, TypeOf returns nil.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TypeOf</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> Type &#123;...&#125;<br><br><span class="hljs-comment">//TypeOf用来动态获取输入参数接口中的值的类型，如果接口为空则返回nil</span><br></code></pre></td></tr></table></figure><p><code>reflect.TypeOf()</code>是获取pair中的type，<code>reflect.ValueOf()</code>获取pair中的value，示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> num <span class="hljs-type">float64</span> = <span class="hljs-number">1.2345</span><br><br>    fmt.Println(<span class="hljs-string">&quot;type: &quot;</span>, reflect.TypeOf(num))<br>    fmt.Println(<span class="hljs-string">&quot;value: &quot;</span>, reflect.ValueOf(num))<br>&#125;<br><br>运行结果:<br><span class="hljs-keyword">type</span>:  <span class="hljs-type">float64</span><br>value:  <span class="hljs-number">1.2345</span><br></code></pre></td></tr></table></figure><p>说明：</p><ol type="1"><li><strong>reflect.TypeOf：</strong>直接给到了我们想要的type类型，如float64、int、各种pointer、struct等等真实的类型</li><li><strong>reflect.ValueOf：</strong>直接给到了我们想要的具体的值，如1.2345这个具体数值，或者类似&amp;{1"Allen.Wu" 25} 这样的结构体struct的值</li><li>反射可以将“接口类型变量”转换为“反射类型对象”，反射类型指的是<code>reflect.Type</code>和<code>reflect.Value这</code>两种</li></ol><h4 id="reflet例子1">reflet例子1:</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reflectNum</span><span class="hljs-params">(arg <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;type:&quot;</span>, reflect.TypeOf(arg))<br>fmt.Println(<span class="hljs-string">&quot;value:&quot;</span>, reflect.ValueOf(arg))<br>&#125;<br></code></pre></td></tr></table></figure><p>主函数的调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> num <span class="hljs-type">float64</span> = <span class="hljs-number">1.2345</span><br>reflectNum(num)<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，在使用反射之前需要引入<strong>reflect的包</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> num <span class="hljs-type">float64</span> = <span class="hljs-number">1.2345</span><br><br>    pointer := reflect.ValueOf(&amp;num)<br>    value := reflect.ValueOf(num)<br><br>    <span class="hljs-comment">// 可以理解为“强制转换”，但是需要注意的时候，转换的时候，如果转换的类型不完全符合，则直接panic</span><br>    <span class="hljs-comment">// Golang 对类型要求非常严格，类型一定要完全符合</span><br>    <span class="hljs-comment">// 如下两个，一个是*float64，一个是float64，如果弄混，则会panic</span><br>    convertPointer := pointer.Interface().(*<span class="hljs-type">float64</span>)<br>    convertValue := value.Interface().(<span class="hljs-type">float64</span>)<br><br>    fmt.Println(convertPointer)<br>    fmt.Println(convertValue)<br>&#125;<br><br>运行结果：<br><span class="hljs-number">0xc42000e238</span><br><span class="hljs-number">1.2345</span><br></code></pre></td></tr></table></figure><h4 id="reflet例子2">reflet例子2:</h4><ul><li><p>首先定义一个类以及关于这个类的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>Id   <span class="hljs-type">int</span><br>Name <span class="hljs-type">string</span><br>Age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this User)</span></span> Call() &#123; <span class="hljs-comment">//为什么这个地方返回类型不是*</span><br>fmt.Println(<span class="hljs-string">&quot;user is called ..&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, this)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>再定义一个利用反射选择类中值和方法的函数</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DoFiledAndMethod</span><span class="hljs-params">(input <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-comment">//获取输入的类型type</span><br>inputType := reflect.TypeOf(input)<br>fmt.Println(<span class="hljs-string">&quot;input type is: &quot;</span>, inputType.Name())<br><span class="hljs-comment">//output: input type is:  User</span><br><br><span class="hljs-comment">//获取input的value</span><br>inputValue := reflect.ValueOf(input)<br>fmt.Println(<span class="hljs-string">&quot;input value is: &quot;</span>, inputValue)<br><span class="hljs-comment">//output: input value is:  &#123;1 eric 19&#125;</span><br><br><span class="hljs-comment">//通过type获取其中的字段</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">1、获取interface中的reflect的type, 通过type得到numfield，进行遍历</span><br><span class="hljs-comment">2、得到每个filed，就是数据类型</span><br><span class="hljs-comment">3、通过filed中有一个interface()方法得到对应的value</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; inputType.NumField(); i++ &#123;<br>field := inputType.Field(i)<br><span class="hljs-comment">// value:=inputType.Field&#123;i&#125;.interface()</span><br>value := inputValue.Field(i).Interface()<br><span class="hljs-comment">// fmt.Println(field) //&#123;Id  int  0 [0] false&#125;、&#123;Name  string  8 [1] false&#125;</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">每个field表示的就是一行的元素内容，其中Name表示了这一行的变量名， Type表示的是这一行的类型</span><br><span class="hljs-comment">通过value单独存在field里面，根据索引值寻找通过Interface()调用</span><br><span class="hljs-comment">*/</span><br>fmt.Printf(<span class="hljs-string">&quot;%s: %v = %v\n&quot;</span>, field.Name, field.Type, value)<br><br>&#125;<br><br><span class="hljs-comment">/* 如何遍历选择方法呢</span><br><span class="hljs-comment">也是根据inputType来进行划分</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; inputType.NumMethod(); i++ &#123;<br>m := inputType.Method(i)<br>fmt.Printf(<span class="hljs-string">&quot;%s: %v\n&quot;</span>, m.Name, m.Type)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意点：</p><ol type="1"><li><strong>reflect.TypeOf</strong>(input)得到类型</li><li><strong>reflect.ValueOf</strong>(input)得到对应的值</li><li><strong>reflect.TypeOf</strong>(input).<strong>NumField()</strong>的方法是获得interface()中的所有的字段</li><li>如果选择字段中的类型： <strong>inputType.Field(i) =reflect.TypeOf(input).Field(i)</strong></li><li>如果选择字段中的值：<strong>inputType.Field(i) =reflect.TypeOf(input).Field(i).Interface()</strong></li><li>如果想便利interface中的方法：<strong>reflect.TypeOf</strong>(input).<strong>NumMethod()</strong>，其中具体的方法是：<strong>reflect.TypeOf(input).Method(i)</strong></li></ol><p>通过运行结果可以得知获取未知类型的interface的所属方法（函数）的步骤为：</p><ol type="1"><li>先获取interface的reflect.Type，然后通过NumMethod进行遍历</li><li>再分别通过reflect.Type的Method获取对应的真实的方法（函数）</li><li>最后对结果取其Name和Type得知具体的方法名</li><li>也就是说反射可以将“反射类型对象”再重新转换为“接口类型变量”</li><li>struct 或者 struct 的嵌套都是一样的判断处理方式</li></ol><h4id="通过reflect.value设置实际变量的值">通过reflect.Value设置实际变量的值</h4><p>reflect.Value是通过reflect.ValueOf(X)获得的，只有当X是指针的时候，才可以通过reflec.Value修改实际变量X的值，即：要修改反射类型的对象就一定要保证其值是“addressable”的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-keyword">var</span> num <span class="hljs-type">float64</span> = <span class="hljs-number">1.2345</span><br>    fmt.Println(<span class="hljs-string">&quot;old value of pointer:&quot;</span>, num)<br><br>    <span class="hljs-comment">// 通过reflect.ValueOf获取num中的reflect.Value，注意，参数必须是指针才能修改其值</span><br>    pointer := reflect.ValueOf(&amp;num)<br>    newValue := pointer.Elem()<br><br>    fmt.Println(<span class="hljs-string">&quot;type of pointer:&quot;</span>, newValue.Type())<br>    fmt.Println(<span class="hljs-string">&quot;settability of pointer:&quot;</span>, newValue.CanSet())<br><br>    <span class="hljs-comment">// 重新赋值</span><br>    newValue.SetFloat(<span class="hljs-number">77</span>)<br>    fmt.Println(<span class="hljs-string">&quot;new value of pointer:&quot;</span>, num)<br><br>    <span class="hljs-comment">////////////////////</span><br>    <span class="hljs-comment">// 如果reflect.ValueOf的参数不是指针，会如何？</span><br>    pointer = reflect.ValueOf(num)<br>    <span class="hljs-comment">//newValue = pointer.Elem() // 如果非指针，这里直接panic，“panic: reflect: call of reflect.Value.Elem on float64 Value”</span><br>&#125;<br><br>运行结果：<br>old value of pointer: <span class="hljs-number">1.2345</span><br><span class="hljs-keyword">type</span> of pointer: <span class="hljs-type">float64</span><br>settability of pointer: <span class="hljs-literal">true</span><br><span class="hljs-built_in">new</span> value of pointer: <span class="hljs-number">77</span><br></code></pre></td></tr></table></figure><ol type="1"><li>需要传入的参数是*float64这个指针，然后可以通过pointer.Elem()去获取所指向的Value，<strong>注意一定要是指针</strong>。</li><li>如果传入的参数不是指针，而是变量，那么</li></ol><ul><li><ul><li>通过Elem获取原始值对应的对象则直接panic</li><li>通过CanSet方法查询是否可以设置返回false</li></ul></li></ul><ol type="1"><li>newValue.CantSet()表示是否可以重新设置其值，如果输出的是true则可修改，否则不能修改，修改完之后再进行打印发现真的已经修改了。</li><li>reflect.Value.Elem()表示获取原始值对应的反射对象，只有原始对象才能修改，当前反射对象是不能修改的，是指只能修改原是对象的<strong>值的大小，不能修改地址</strong></li><li>newValue.SetFloat(77)重新设置值的操作，传递引用来修改interface中的值</li></ol><h4 id="反射的基本原理">反射的基本原理</h4><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231219205804430.png"alt="反射基本原理总结" /><figcaption aria-hidden="true">反射基本原理总结</figcaption></figure><h3 id="section"></h3><h3 id="结构体标签">结构体标签</h3><p>本质上还是利用了反射，通过以下形式给结构体中的变量添加标签作用：其他包在调用这个当前包的时候对于某个属性的一个说明，指示某个包在具体使用中的作用。</p><p><strong>作用：能够将结构体转化为json格式</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><span class="hljs-keyword">type</span> resume <span class="hljs-keyword">struct</span>&#123;<br><span class="hljs-comment">/*  </span><br><span class="hljs-comment">通过以下形式给结构体中的变量添加标签</span><br><span class="hljs-comment">作用： 其他包在调用这个当前包的时候对于某个属性的一个说明，指示某个包在具体使用中的作用</span><br><span class="hljs-comment">*/</span><br>Name <span class="hljs-type">string</span> <span class="hljs-string">`info:&quot;name&quot; doc:&quot;我的名字&quot;`</span> <br>Sex <span class="hljs-type">string</span> <span class="hljs-string">`info:&quot;sex&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findtag</span><span class="hljs-params">(str <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span>&#123;<br>t :=reflect.TypeOf(str).Elem()<br><br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;t.NumField();i++&#123;<br>tagstring:=t.Field(i).Tag.Get(<span class="hljs-string">&quot;info&quot;</span>)<br>tagdoc:=t.Field(i).Tag.Get(<span class="hljs-string">&quot;doc&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;info:&quot;</span>,tagstring,<span class="hljs-string">&quot;doc&quot;</span>,tagdoc)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">var</span> re resume<br>findtag(&amp;re) <span class="hljs-comment">//注意这里传递的是引用</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231207215501791.png" alt="go printf的占位符格式" style="zoom:67%;" /></p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231207215514980.png" alt="go printf的占位符表示" style="zoom:67%;" /></p><p>输出之后在json格式转换中可以看到如下，注意可以看到的是输出的内容是根据给定的tag来进行标题的命名的</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231207215859488.png" alt="转化为json格式的例子" style="zoom:67%;" /></p><p>利用反射取出元素查询</p><p>利用编码和解码对struct 和json之间的转化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;encoding/json&quot;</span><br>)<br><br><span class="hljs-comment">//如何将结构体转化成json</span><br><span class="hljs-keyword">type</span> Movie <span class="hljs-keyword">struct</span>&#123;<br>Title <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;title&quot;`</span>  <span class="hljs-comment">//就是告诉json库对应的变量的标签名字是这个</span><br>Year <span class="hljs-type">int</span> <span class="hljs-string">`json:&quot;year&quot;`</span><br>Price <span class="hljs-type">int</span> <span class="hljs-string">`json:&quot;rmb&quot;`</span><br>Actors []<span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;actors&quot;`</span> <span class="hljs-comment">//slice `json:&quot;actors&quot;`</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>movie :=Movie&#123;<span class="hljs-string">&quot;喜剧之王&quot;</span>,<span class="hljs-number">2000</span>,<span class="hljs-number">10</span>,[]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;zhouxingchi&quot;</span>,<span class="hljs-string">&quot;zhangbozhi&quot;</span>&#125;&#125;<br><br><span class="hljs-comment">//编码的过程就是将 struct--&gt;json</span><br><br>jsonStr,err:=json.Marshal(movie)<br><br><span class="hljs-comment">//返回两个字段</span><br><br><span class="hljs-keyword">if</span> err!=<span class="hljs-literal">nil</span>&#123;<br>fmt.Println(<span class="hljs-string">&quot;json marshal error&quot;</span>,err)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;jsonStr=%s\n&quot;</span>,jsonStr )<br><span class="hljs-comment">/* jsonStr=&#123;&quot;title&quot;:&quot;喜剧之王&quot;,&quot;year&quot;:2000,&quot;rmb&quot;:10,&quot;Actors&quot;:[&quot;zhouxingchi&quot;,&quot;zhangbozhi&quot;]&#125; */</span><br><br><span class="hljs-comment">//解码过程：json--&gt;struct</span><br><span class="hljs-comment">//jsonStr=&#123;&quot;title&quot;:&quot;喜剧之王&quot;,&quot;year&quot;:2000,&quot;rmb&quot;:10,&quot;actors&quot;:[&quot;zhouxingchi&quot;,&quot;zhangbozhi&quot;]&#125;</span><br><br>myMovie:=Movie&#123;&#125;<br><span class="hljs-comment">//注意这个地方传递的参量是引用</span><br>err=json.Unmarshal(jsonStr,&amp;myMovie)<br><span class="hljs-keyword">if</span> err!=<span class="hljs-literal">nil</span>&#123;<br>fmt.Println(<span class="hljs-string">&quot;json unmashal error&quot;</span>,err)<br><span class="hljs-keyword">return</span> <br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>,myMovie)<br><span class="hljs-comment">//返回结构体</span><br><span class="hljs-comment">//&#123;喜剧之王 2000 10 [zhouxingchi zhangbozhi]&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【基础工具】Linux指令集</title>
    <link href="/2023/11/25/tool_linux/"/>
    <url>/2023/11/25/tool_linux/</url>
    
    <content type="html"><![CDATA[<h2 id="linux命令集">Linux命令集</h2><h4 id="查看当前路径的位置-pwd">查看当前路径的位置 pwd</h4><h4 id="查看命令历史">查看命令历史</h4><p>终端中输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">history</span><br></code></pre></td></tr></table></figure><h4 id="指定查找关键字">指定查找关键字</h4><p>通过增加grep来增加关键字的筛选</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">| grep GOPROXY<br></code></pre></td></tr></table></figure><h4 id="当前目录下的文件">当前目录下的文件</h4><ul><li>当前目录下的文件 ls</li><li>ls -l；ls-h；都是用来显示文件的详细信息</li><li>ls -a 来显示所有的文件（包含隐藏文件）</li><li>组合使用 ls -lha 显示所有并包含的隐藏文件且显示详细信息</li><li>使用dir显示当前文件夹下的文件名*</li></ul><h4 id="切换文件夹">切换文件夹</h4><ul><li><p>cd .. <em>#返回父级目录</em></p></li><li><table><thead><tr class="header"><th style="text-align: center;">cd</th><th>切换到当前用户的主目录(/home/用户目录)</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">cd ~</td><td>切换到当前用户的主目录(/home/用户目录)</td></tr><tr class="even"><td style="text-align: center;">cd .</td><td>保持在当前目录不变</td></tr><tr class="odd"><td style="text-align: center;">cd …</td><td>切换到上级目录</td></tr><tr class="even"><td style="text-align: center;">cd -</td><td>可以在最近两次工作目录之间来回切换</td></tr></tbody></table></li><li><p>相对路径 在输入路径时，最前面不是 / 或者 ~，表示相对 当前目录所在的目录位置 绝对路径 在输入路径时，最前面是 / 或者 ~，表示从<strong>根目录/家目录</strong> 开始的具体目录位置</p></li></ul><h4 id="移动文件到指定位置-mv">移动文件到指定位置 mv</h4><ul><li><p>mv <u>文件名</u> <u>指定的路径位置</u> -i 用于提示</p></li><li><p>修改文件夹名称：mv 原来的文件夹名称 后来的文件夹名称</p></li><li><h6 id="拷贝某个文件夹到指定路径">拷贝某个文件夹到指定路径</h6><ul><li><p>cp <u>当前文件夹下某个文件名</u>（带后缀） <u>目标路径</u> -i用于提示</p><table><thead><tr class="header"><th>命令</th><th>对应英文</th><th>作用</th><th></th></tr></thead><tbody><tr class="odd"><td>01</td><td>tree [目录名]</td><td>tree</td><td>以树状图列出文件目录结构</td></tr><tr class="even"><td>02</td><td>cp 源文件目标文件</td><td>copy</td><td>复制文件或者目录</td></tr><tr class="odd"><td>03</td><td>mv 源文件 目标文件</td><td>move</td><td>移动文件或者目录／文件或者目录重命名</td></tr></tbody></table></li></ul></li></ul><h4 id="创建文件夹">创建文件夹</h4><ul><li>进入路径的位置 mkdir <u>需要创建的文件夹的名称</u></li><li>递归创建文件夹 mkdir -p 123/456<u>在123文件夹下递归创建文件夹456</u></li></ul><h4 id="新建某个文件">新建某个文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> 123.txt<br></code></pre></td></tr></table></figure><h4 id="删除文件夹">删除文件夹</h4><ul><li>rmdir+ 需要删除的文件名</li></ul><h4 id="删除某个文件">删除某个文件</h4><ul><li><p>使用rm来对文件进行删除 -i 进行删除前的查询</p></li><li><table><thead><tr class="header"><th>选项</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>-f</td><td>强制删除，忽略不存在的文件，无需提示</td></tr><tr class="even"><td>-r</td><td>递归地删除目录下的内容，<strong>删除文件夹时必须加此参数</strong></td></tr></tbody></table></li></ul><h4 id="解压缩文件的指令">解压缩文件的指令</h4><ul><li><h5 id="对于zip文件的操作">对于ZIP文件的操作</h5><ul><li>解压操作：进入需要解压的文件的位置：<strong>unzipfilename.zip</strong></li><li>压缩文件：同理进入需要解压的文件夹的上一级 zip filename.zip</li></ul></li></ul><h4 id="linux中查看系统使用情况">Linux中查看系统使用情况</h4><ul><li><p>Top 来显示CPU的占用情况：</p><blockquote><table><thead><tr class="header"><th>PID</th><th>进程的ID</th><th>USER</th><th>进程所有者</th></tr></thead><tbody><tr class="odd"><td><strong>PR</strong></td><td>进程的优先级别，越小越优先被执行</td><td><strong>NInice</strong></td><td>值</td></tr><tr class="even"><td><strong>VIRT</strong></td><td>进程占用的虚拟内存</td><td><strong>RES</strong></td><td>进程占用的物理内存</td></tr><tr class="odd"><td><strong>SHR</strong></td><td>进程使用的共享内存</td><td>S</td><td>进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数</td></tr><tr class="even"><td><strong>%CPU</strong></td><td>进程占用CPU的使用率</td><td><strong>%MEM</strong></td><td>进程使用的物理内存和总内存的百分比</td></tr><tr class="odd"><td><strong>TIME+</strong></td><td>该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值</td><td><strong>COMMAND</strong></td><td>进程启动命令名称</td></tr></tbody></table></blockquote></li><li><p><strong>top</strong>退出方式是==用q进行退出==</p></li><li><p><strong>free</strong>查看内存的使用情况</p><blockquote><table><thead><tr class="header"><th>total</th><th>总计物理内存的大小</th><th>used</th><th>已使用多大</th></tr></thead><tbody><tr class="odd"><td><strong>free</strong></td><td>可用有多少</td><td><strong>Shared</strong></td><td>多个进程共享的内存总额</td></tr><tr class="even"><td><strong>Buffers/cached</strong></td><td>磁盘缓存的大小</td><td></td><td></td></tr></tbody></table></blockquote></li><li><p><strong>vmstat</strong>指令也是用于查看内存的使用</p><blockquote><ul><li><p><strong>Procs(进程)</strong>： r:运行队列中进程数量，这个值也可以判断是否需要增加CPU。(长期大于1) b:等待IO的进程数量</p></li><li><p><strong>Memory(内存)</strong>：swpd: 使用虚拟内存大小；free:空闲物理内存大小；buff: 用作缓冲的内存大小；cache:用作缓存的内存大小</p></li><li><p><strong>Swap</strong>： si:每秒从交换区写到内存的大小，由磁盘调入内存；so:每秒写入交换区的内存大小，由内存调入磁盘</p></li><li><p><strong>IO</strong>：bi: 每秒读取的块数，bo:每秒写入的块数</p></li><li><p><strong>系统</strong>： in: 每秒中断数，包括时钟中断。 cs:每秒上下文切换数。</p></li><li><p><strong>CPU(以百分比表示)</strong>：us:用户进程执行时间百分比(user time) sy: 内核系统进程执行时间百分比(systemtime) ；wa: IO等待时间百分比； id: 空闲时间百分比</p></li></ul></blockquote></li></ul><h4 id="查看系统的gpu">查看系统的GPU</h4><p>实时查看GPU使用情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">watch -n 1 nvidia-smi <br></code></pre></td></tr></table></figure><p>行代码的意思是只选择指定标号GPU进行使用，执行完该行代码之后python环境无法检测到指定GPU之外的其他</p><h4 id="系统环境变量">系统环境变量</h4><p>对于MACOS，用VIM进入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim ～/.zshrc<br></code></pre></td></tr></table></figure><p>添加环境变量的语句是，这里以增加路径为例子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> GOPATH=<span class="hljs-string">&quot;user/workspace/golang&quot;</span><br></code></pre></td></tr></table></figure><p>添加完环境变量之后，激活一下设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.zshrc<br></code></pre></td></tr></table></figure><p>同样对于Linux系统而言也是相同的步骤</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim ~/.bashrc<br></code></pre></td></tr></table></figure><p>添加完成之后最后激活一下设定</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure><p>如果想直接查看当前某个环境变量的设置的值可以用以下的命令进行查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$GOPARH</span><br></code></pre></td></tr></table></figure><p>输出的值是当前的这个环境变量设置的值，比如会输出：user/workspace/golang</p><h4 id="显示linux系统的其他信息">显示Linux系统的其他信息</h4><h5 id="时间和日期">时间和日期</h5><table><thead><tr class="header"><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>01</td><td>date</td><td>查看系统时间</td></tr><tr class="even"><td>02</td><td>cal</td><td>calendar 查看日历， -y 选项可以查看一年的日历</td></tr></tbody></table><h5 id="磁盘信息">磁盘信息</h5><table><thead><tr class="header"><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>01</td><td>df -h</td><td>disk free 显示磁盘剩余空间</td></tr><tr class="even"><td>02</td><td>du -h [目录名]</td><td>disk usage 显示目录下的文件大小</td></tr></tbody></table><h5 id="进程信息">进程信息</h5><p>​ 所谓<strong>进程</strong>，通俗地说就是<strong>当前正在执行的一个程序</strong></p><table><thead><tr class="header"><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>01</td><td>ps aux</td><td>process status 查看进程的详细状况</td></tr><tr class="even"><td>02</td><td>top</td><td>动态显示运行中的进程并且排序</td></tr><tr class="odd"><td>03</td><td>kill [-9] 进程代号</td><td>终止指定代号的进程， -9 表示强行终止</td></tr></tbody></table><h4 id="网络测试">网络测试</h4><p>​ ping 一般用于检测当前计算机到目标计算机之间的网络<strong>是否通畅，数值越大，速度越慢</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-meta"># 检测到目标主机是否连接正常</span><br>$ ping IP地址 www.baidu.com<br><span class="hljs-meta"># 检测本地网卡工作正常</span><br>$ ping <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br></code></pre></td></tr></table></figure><h4 id="gpu运行指定">GPU运行指定</h4><ol type="1"><li><p>首先先查看对应的GPU内存：<strong>nvidia-smi</strong></p></li><li><p>然后在终端输出代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">CUDA_VISIBLE_DEVICES=<span class="hljs-number">1</span> python your_model.py <br></code></pre></td></tr></table></figure><p>再或者使用<code>**torch.cuda.set_device()**函数</code>指定gpu使用编号：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br>torch.cuda.set_device(<span class="hljs-number">2</span>) <span class="hljs-comment"># 使用2号GPU</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>基础工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础工具</tag>
      
      <tag>后端开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【多智能体强化学习】基于自动分组的价值函数分解</title>
    <link href="/2023/11/22/marl_autogroup/"/>
    <url>/2023/11/22/marl_autogroup/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="automatic-grouping-for-marl">Automatic Grouping for MARL</h2><p>论文标题：</p><p><strong>《Vast: Value function factorization with variable agentsub-teams》</strong></p><p><strong>《Automatic Grouping for Efficient Cooperative Multi-AgentReinforcement Learning》</strong></p><p>论文代码：<ahref="https://github.com/zyfsjycc/GoMARL">https://github.com/zyfsjycc/GoMARL</a></p><h2 id="价值函数分解">价值函数分解</h2><p>价值函数的提出是为了缓解在传统的中心化训练和去中心化执行中的Critic网络出现的难以训练的问题，同时传统的合作型多智能体强化学习的方法难以解决信用分配的问题，即如何确定某个智能体<strong>对于全局任务而言的贡献程度</strong>。</p><h3 id="主体研究框架">主体研究框架：</h3><p><span class="math display">\[Q_{tot} (τ,a)≈Ψ([Q_i (τ_i,a_i)]_{i=1}^N)\]</span></p><p>目的就是学习到这样一个分解算子 <spanclass="math inline">\(Ψ\)</span>，能够将局部的价值函数 <spanclass="math inline">\(Q_i\)</span> 拟合成全局的价值函数 <spanclass="math inline">\(Q_{tot}\)</span>，而这样的拟合过程学习到的分解算子<spanclass="math inline">\(Ψ\)</span>应当满足以下的约束条件： <spanclass="math display">\[\underset{\boldsymbol{a}}{\arg \max } Q_{\text {tot}}(\boldsymbol{\tau}, \boldsymbol{a})=\left(\begin{array}{c}\operatorname{argmax}_{a_1} Q_1\left(\tau_1, a_1\right) \\\vdots \\\operatorname{argmax}_{a_N} Q_N\left(\tau_N, a_N\right)\end{array}\right)\]</span>这个公式的本质是希望分解之后的局部和全局的最优动作能够最优一致，才能保证这样的算子分解方法是有效果的。</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122215614627.png"alt="价值函数分解的基本思想" /><figcaption aria-hidden="true">价值函数分解的基本思想</figcaption></figure><h2 id="可变子团队的价值函数分解">可变子团队的价值函数分解</h2><h4 id="研究动机">研究动机：</h4><ol type="1"><li><strong>大部分</strong>价值函数方法对<strong>少量智能体</strong>的任务效果好</li><li><strong>VFF</strong>方法过于扁平，存在性能瓶颈，没有考虑群组之间的一个关系，比较朴素且直接</li><li>忽略智能体之间关系导致智能体训练信息不足</li></ol><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122202659835.png" alt="朴素的价值函数分解方法" style="zoom:60%;" /><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122202712624.png" alt="自动分组之后的价值函数分解方法" style="zoom:60%;" /></p><p>因此，为了能够缓解朴素的价值函数分解方法中的<strong>缺乏群组信息的缺陷</strong>，文中提出能够分组处理多智能体系统的工作VAST，能够动态处理群组划分的算子来给出基于分组的智能体价值函数方法。</p><h3 id="主要贡献">主要贡献：</h3><ol type="1"><li>基于 <span class="math inline">\(K ≤ N = |D|\)</span>的分解子团队值<spanclass="math inline">\(Q_{t,k}^G\)</span>，线性分解每个子团队成员$jG_{t,k}⊆D$ 局部值<span class="math inline">\(Q_j\)</span></li><li>提出了一种分解方式动态并随时间变化，同时保持VFF方法的去中心性执行的特点</li><li>提供了<strong>元梯度</strong>方法来优化子团队分组策略</li></ol><h3 id="实现方法">实现方法：</h3><h4 id="子团队分组策略">子团队分组策略：</h4><p>分组策略的本质是学习一个<strong>概率分布</strong><spanclass="math inline">\(\mathcal{X}(k∣i,τ_(t,i),s_t)\)</span>，概率分布的本质思想是能够通过每个智能体的状态以及历史数据信息给出智能体<span class="math inline">\(i\)</span> 所在的组别 <spanclass="math inline">\(k\)</span></p><h4 id="元梯度的更新方式">元梯度的更新方式：</h4><p><span class="math display">\[𝑔=𝐴 ̂(𝑘,𝑖,𝜏_{𝑡,𝑖},𝑠_𝑡 ) ∇_𝜃 log⁡𝒳_{MetaGrad}  (𝑘∣𝑖,𝜏_{𝑡,𝑖},𝑠_𝑡 )\]</span></p><ul><li>参考借鉴了强化学习的策略梯度更新的方式</li><li>在多智能体强化学习中利用<strong>强化学习</strong>的方法学习一个组别的分组器</li></ul><p><span class="math display">\[𝐴 ̂(𝑘,𝑖,𝜏_{𝑡,𝑖},𝑠_𝑡 )=𝑄 ̂(𝑘,𝑖,𝜏_{𝑡,𝑖},𝑠_𝑡 )−𝑉 ̂(𝑖,𝜏_{𝑡,𝑖},𝑠_𝑡 )\]</span></p><p><span class="math display">\[𝑉 ̂(𝑖,𝜏_{𝑡,𝑖},𝑠_𝑡 )=∑_(𝑎_{𝑡,𝑖}∈𝒜_𝑖) 𝜋_𝑖 (𝑎_{𝑡,𝑖}∣𝜏_{𝑡,𝑖} ) 𝑄_𝑖(𝜏_{𝑡,𝑖},𝑎_{𝑡,𝑖} )\]</span></p><ul><li>策略梯度更新的方式是基于优势函数的方法进行更新分组器</li></ul><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122220849824.png"alt="不同分类器的对比" /><figcaption aria-hidden="true">不同分类器的对比</figcaption></figure><p>这里还采用了不同的分组器方法加入实验的对比</p><h4 id="算法思路">算法思路</h4><ul><li><p>将D 分成<span class="math inline">\(K= ⌈ηN⌉≤ N =|D|\)</span>个子团队<span class="math inline">\(G_{t,k}\)</span>其中比例<span class="math inline">\(η ∈ [1⁄N,1]\)</span>，所有的团队集合 <spanclass="math inline">\(G_t=⟨G_{t,1},…,G_{t,K} ⟩\)</span>，</p></li><li><p>分组：<span class="math inline">\(G_{t,k}⊆D,G_{t,k}∩G_{t,k′}=∅;D=U_{k=1}^K  G_{t,k}\)</span></p></li><li><p>组内联合动作：<span class="math inline">\(a_{t,k}^G=a{t,j}_j∈G_{t,k}\)</span></p></li><li><p>选择<spanclass="math inline">\(Ψ_{VDN}\)</span>算子分解(满足IGM)：</p><p><span class="math display">\[Q_{t,k}^G (τ_{t,k}^G,a_{t,k}^G )=Ψ_{VDN} (⋅)=∑_{j∈G_{t,k}} Q_j(τ_{t,j},a_{t,j})\]</span></p></li><li><p>最终的全局联合价值函数近似：</p></li></ul><p><span class="math display">\[Q_{tot} (τ_t,a_t )=Ψ(Q_{t,1}^G (τ_{t,1}^G,a_{t,1}^G ),…,Q_{t,K}^G(τ_{t,K}^G,a_{t,K}^G ))\]</span><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122221728761.png" alt="可变子团队的伪代码" style="zoom:67%;" /></p><h4 id="igm条件保持">IGM条件保持</h4><p>如果以群组为单位的价值函数分解的方式能够保证IGM条件： <spanclass="math display">\[argmax_(𝑎_{𝑡,𝑘}^𝐺∈𝒜)⁡〖𝑄_{tot}(𝜏_𝑡,𝑎_𝑡)〗=⟨argmax_(⟨𝐚_{𝐭,𝐤}^𝐆 ⟩_(𝐺_{𝑡,𝑘}∈𝒢_𝑡 ))⁡𝑄_{𝑡,𝑘}^𝐺 (𝜏_{𝑡,𝑘}^𝐺,𝑎_{𝑡,𝑘}^𝐺)⟩_(𝐺_{𝑡,𝑘}∈𝒢_𝑡)\]</span> 希望能够满足对于局部智能体到全局价值函数的IGM条件的保持 <spanclass="math display">\[argmax_(𝑎_𝑡∈𝒜)⁡𝑄_{tot}(𝜏_𝑡,𝑎_𝑡 )=⟨argmax_(𝑎_{𝑡,𝑖}∈𝒜_𝑖 )⁡𝑄_𝑖 (𝜏_{𝑡,𝑖},𝑎_{𝑡,𝑖})⟩_(𝑖∈𝒟)\]</span> 推导过程如下： <span class="math display">\[\begin{aligned}&amp; Q_{t, k}^G\left(\tau_{t, k}^G, a_{t, k}^G\right)=\sum_{j \in G_{t,k}} Q_j\left(\tau_{t, j}, a_{t, j}\right) ; \operatorname{argmax}_{a_t\in G_{t, k}} Q_{t, k}^G\left(\tau_{t, k}^G, a_{t,k}^G\right)=\left\langle\operatorname{argmax}_{a_{t, i} \in\mathcal{A}_i} Q_i\left(\tau_{t, i}, a_{t, i}\right)\right\rangle_{i \inG_{t, k}} \\&amp; a_t \stackrel{\Psi}{=}\left\langle a_{t, k}^G\right\rangle_{G_{t,k} \in \mathcal{G}_t} \stackrel{\Psi_{V DN}}{=}\left\langle\left\langle\bar{a}_{t, i}\right\rangle_{i \in G_{t,k}}\right\rangle_{G_{t, k} \in \mathcal{G}_t}\stackrel{\mathcal{D}=G_{t, 1} \cup \cdots \cup G_{t,K}}{=}\left\langle\bar{a}_{t, i}\right\rangle_{i \in \mathcal{D}}\end{aligned}\]</span></p><h2 id="自适应分组的marl">自适应分组的MARL</h2><h3 id="研究动机-1">研究动机</h3><ul><li>通过任务分配实现隐式分组的方法仅解决结构清晰的任务，并且需要领域知识或先验设置</li><li>VAST 研究子团队对价值分解的影响，但需要先验的组数，ROMA的学习依赖于智能体观察的动态角色</li></ul><h3 id="gomarl算法的优势">GoMARL算法的优势</h3><ul><li>算法不依赖先验领域知识</li><li>动态调整：在分组学习过程中根据智能体的表现<strong>逐步调整</strong>分组划分。利用<strong>群体信息</strong>来促进策略专业化和高效的团队合作</li></ul><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122222736852.png" alt="引入群组划分板块的分解方法" style="zoom:67%;" /></p><h3 id="个体与群组关系假设">个体与群组关系假设</h3><ul><li><strong>所有智能体集合：</strong><spanclass="math inline">\(A={a_1,…,a_n }\)</span></li><li><strong>分组集合</strong>: <span class="math inline">\(G={g_1,…,g_m}，1≤m≤n\)</span></li><li>每个<spanclass="math inline">\(g_i\)</span><strong>包含</strong><spanclass="math inline">\(n_j(1≤n_j≤n)\)</span><strong>个不同的智能体，有</strong><spanclass="math inline">\(g_i={a_(j_1 ),…,a_(j_(n_j ))}\)</span>，<strong>且有</strong><spanclass="math inline">\(g_j∩g_k=∅\)</span>，<strong>且有</strong><spanclass="math inline">\(⋃_jg_j =A，j,k∈{1,2,…,m}\)</span></li></ul><h3 id="自动分组实现方法">自动分组实现方法</h3><p>自动分组的基本逻辑是学习<spanclass="math inline">\(f_g:A↦G\)</span>，这样的算子的目标是能够学习到系数权重<span class="math display">\[Q_G^{tot} (s_t,u_t )=E_(s_{t+1:∞},u_{t+1:∞} ) [∑_(k=0)^∞ γ^kr_{t+k}∣s_t,u_t;G]\]</span> 让总体的联合动作价值函数的值最大，分组的价值函数为： <spanclass="math display">\[𝑄^{𝑔_𝑗}=𝑓(𝑄^{𝑗_1} (𝜏^{𝑗_1},𝑢^{𝑗_1}),⋯,𝑄^{𝑗_{𝑛_𝑗}} (𝜏^{𝑗_(𝑛_𝑗)},𝑢^{𝑗_{𝑛_𝑗}};𝑤_1^{𝑔_𝑗})\]</span> 学习到的贡献程度为：<spanclass="math inline">\(𝑤_1^{𝑔_𝑗}\)</span>，训练的目标函数为： <spanclass="math display">\[ℒ_𝑔 (𝜃_{w_1})=𝔼_((𝐳,𝐮,𝑟,𝐳′)∼ℬ∑_𝑖(∥𝑓_(w_1)^𝑖 (𝜏^𝑖 (𝑧^𝑖,𝑢^𝑖 );𝜃_(w_1)^𝑖)∥_{𝑙_1})\]</span>根据每次在分组中的贡献权重来依次调整智能体的分组，当贡献的权重过小的话，就认为智能体不属于分组中，进入下一轮的分组调整中。</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122223325635.png"alt="自动分组的逻辑图" /><figcaption aria-hidden="true">自动分组的逻辑图</figcaption></figure><h3 id="agent-network的优化">Agent Network的优化</h3><ul><li><p>智能体内嵌信息网络获取的群组相关信息<spanclass="math inline">\(e_i\)</span></p></li><li><p><strong>Similarity-Diversityobjective</strong>：来自同一组的智能体的信息是相似的，来自不同群体的智能体信息之间保持多样性：<span class="math display">\[\begin{gathered}\mathcal{L}_{SD}\left(\theta_e\right)=\mathbb{E}_{\mathcal{B}}\left(\sum_{i \neq j}I(i, j) \cdot \operatorname{cosine}\left(f_e\left(h^i ; \theta_e\right),f_e\left(h^j ; \theta_e\right)\right)\right) \\\text { where } I(i, j)=\left\{\begin{array}{cc}-1, &amp; a^i, a^j \in g^k \\1, &amp; a^i \in g^k, a^j \in g^l, k \neq l\end{array}\right.\end{gathered}\]</span>很直观的理解，对于合作型的强化学习任务而言，我们希望能够在同一个任务域内强化策略的合作，而不同的任务域内的策略应当保持多样性，能够让多智能体系统探索更多的可能性，防止陷入局部最优的情况。</p></li><li><p><strong>Agent Network特点</strong>：</p><ul><li>多样化的策略，部分共享参数的策略去中心化</li><li>超网络<spanclass="math inline">\(f_d\)</span>将提取的智能体信息e集成到策略梯度中</li></ul></li><li><p>合理性表示： <span class="math display">\[𝜕𝑄^{𝑡𝑜𝑡}/(𝜕𝜃_ℎ )=(𝜕𝑄^{𝑡𝑜𝑡})/(𝜕𝑄^𝑎 )  (𝜕𝑄^𝑎)/(𝜕𝜃_ℎ )=(𝜕𝑄^{𝑡𝑜𝑡})/(𝜕𝑄^𝑎)  (𝜕𝑄^𝑎)/(𝜕𝑣_ℎ^𝑎 )  (𝜕𝑣_ℎ^𝑎)/(𝜕𝜃_ℎ )=𝑓_𝑑 (𝑒^𝑎 )⋅(𝜕𝑄^{𝑡𝑜𝑡})/(𝜕𝑄^𝑎)  (𝜕𝑣_ℎ^𝑎)/(𝜕𝜃_ℎ )\]</span></p></li></ul><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122225119182.png" alt="Agent Network优化方式" style="zoom:67%;" /></p><h3 id="整体的训练框架">整体的训练框架</h3><h6 id="双层混合网络">双层混合网络</h6><ul><li><p>群体状态下的群体行动价值信息，将全局的状态分解成局部的状态信息用于训练，这部分的局部状态信息是基于群组划分之后的状态信息</p></li><li><p><span class="math inline">\(s^{g_j}\)</span> 是分组后<spanclass="math inline">\(e_t^i (a_i∈g_j)\)</span>按组别融合，建立分组器映射</p><p><span class="math display">\[f_{w_2}(s^g )：s^g→w_2^g\]</span></p></li><li><p>集中到策略梯度中，内嵌群组状态信息潜在促进组内合作： <spanclass="math display">\[𝜕𝑄^{𝑡𝑜𝑡}/(𝜕𝜃_ℎ )=(𝜕𝑄^{𝑡𝑜𝑡})/(𝜕𝑄^𝑎 )  (𝜕𝑄^𝑎)/(𝜕𝜃_ℎ )=(𝜕𝑄^{𝑡𝑜𝑡})/(𝜕𝑄^𝑎)  (𝜕𝑄^𝑎)/(𝜕𝑣_ℎ^𝑎 )  (𝜕𝑣_ℎ^𝑎)/(𝜕𝜃_ℎ )=𝑓_𝑑 (𝑒^𝑎 )⋅(𝜕𝑄^{𝑡𝑜𝑡})/(𝜕𝑄^𝑎)  (𝜕𝑣_ℎ^𝑎)/(𝜕𝜃_ℎ )\]</span></p></li><li><p>按照全文的总共方法的总述可以得到全局分解目标： <spanclass="math display">\[ℒ(𝜃)=ℒ_𝑇𝐷 (𝜃)+𝜆_𝑔 ℒ_𝑔 (𝜃_(w_1 ) )+𝜆_𝑆𝐷 ℒ_𝑆𝐷 (𝜃_𝑒 )\]</span></p></li></ul><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122225354328.png"alt="总体训练框架" /><figcaption aria-hidden="true">总体训练框架</figcaption></figure><h3 id="section"></h3><h3 id="代码实现">代码实现</h3><p>GoMARL代码的实现是基于pymarl多智能体的训练框架进行改进的，这里主要对其中<code>learning</code> <code>mixing</code>的网络部分进行展开叙述</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> buffer.can_sample(args.batch_size):<br>      next_episode = episode + args.batch_size_run<br>      <span class="hljs-keyword">if</span> args.accumulated_episodes <span class="hljs-keyword">and</span> next_episode % args.accumulated_episodes != <span class="hljs-number">0</span>:<br>               <span class="hljs-keyword">continue</span><br><br>      episode_sample = buffer.sample(args.batch_size)<br>      max_ep_t = episode_sample.max_t_filled()<br>      episode_sample = episode_sample[:, :max_ep_t]<br>      <span class="hljs-keyword">if</span> episode_sample.device != args.device:<br>          episode_sample.to(args.device)<br><br>      learner.train(episode_sample, runner.t_env, episode)<br>      <span class="hljs-keyword">del</span> episode_sample<br><br></code></pre></td></tr></table></figure><p>在这一步中通过调用<code>learner.train(episode_sample, runner.t_env, episode)</code>来对自动分组的学习器进行强化学习</p><p>在<code>learner</code>中，通过使用其中的<code>mixer</code>对联合的动作价值函数进行学习</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Pick the Q-Values for the actions taken by each agent</span><br>        chosen_action_qvals = th.gather(mac_out[:, :-<span class="hljs-number">1</span>], dim=<span class="hljs-number">3</span>, index=actions).squeeze(<span class="hljs-number">3</span>)<br><br> <span class="hljs-comment"># Mixer</span><br>        chosen_action_qvals, w1_avg_list, sd_loss = self.mixer(chosen_action_qvals, batch[<span class="hljs-string">&quot;state&quot;</span>][:, :-<span class="hljs-number">1</span>], mac_hidden[:, :-<span class="hljs-number">1</span>], mac_group_state[:, :-<span class="hljs-number">1</span>], <span class="hljs-string">&quot;eval&quot;</span>)<br></code></pre></td></tr></table></figure><p>接下来我们将详细介绍 <code>mixer</code>函数部分的实现</p><p>第一部分是对超参数的预设，从<code>yaml</code>文件中读取了预设的超参数的数值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">self.args = args<br>    self.<span class="hljs-built_in">abs</span> = <span class="hljs-built_in">abs</span><br>    self.n_agents = args.n_agents<br>    self.embed_dim = args.mixing_embed_dim<br>    self.hypernet_dim = args.hypernet_embed<br>    self.grouping_hypernet_dim = args.grouping_hypernet_embed<br>    <br>    self.group = args.group<br>    <span class="hljs-keyword">if</span> self.group <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        self.group = [[_ <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.n_agents)]]<br></code></pre></td></tr></table></figure><p>这一步是计算出整个状态空间的全部维度=4<em>4 </em>10</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">self.state_dim = <span class="hljs-built_in">int</span>(np.prod(args.state_shape))<br></code></pre></td></tr></table></figure><h4 id="定义网络结构">定义网络结构</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python">self.hyper_w1 = nn.ModuleList(nn.Sequential(nn.Linear(self.a_h_dim, self.grouping_hypernet_dim),<br>                                        nn.ReLU(inplace=<span class="hljs-literal">True</span>),<br>                                        nn.Linear(self.grouping_hypernet_dim, self.embed_dim))<br>                                        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.n_agents))<br>self.hyper_b1 = nn.ModuleList([nn.Sequential(nn.Linear(self.a_h_dim, self.embed_dim))])<br><br>self.hyper_w2 = nn.ModuleList([nn.Sequential(nn.Linear(self.hypernet_dim, self.hypernet_dim),<br>                                        nn.ReLU(inplace=<span class="hljs-literal">True</span>),<br>                                        nn.Linear(self.hypernet_dim, self.embed_dim))])<br>        <br>self.hyper_b2 = nn.ModuleList([nn.Sequential(nn.Linear(self.hypernet_dim, self.embed_dim),<br>                                        nn.ReLU(inplace=<span class="hljs-literal">True</span>),<br>                                        nn.Linear(self.embed_dim, <span class="hljs-number">1</span>))])<br>self.hyper_w3 = nn.Sequential(nn.Linear(self.hypernet_dim, self.hypernet_dim),<br>                                        nn.ReLU(inplace=<span class="hljs-literal">True</span>),<br>                                        nn.Linear(self.hypernet_dim, self.embed_dim))<br>self.hyper_b3 = nn.Sequential(nn.Linear(self.hypernet_dim, self.embed_dim))<br>self.hyper_w4 = nn.Sequential(nn.Linear(self.state_dim, self.hypernet_dim),<br>                                        nn.ReLU(inplace=<span class="hljs-literal">True</span>),<br>                                        nn.Linear(self.hypernet_dim, self.embed_dim))<br>self.hyper_b4 = nn.Sequential(nn.Linear(self.state_dim, self.embed_dim),<br>                            nn.ReLU(inplace=<span class="hljs-literal">True</span>),<br></code></pre></td></tr></table></figure><p>MyModule 类中有一个名为 linears 的 <code>nn.ModuleList</code>属性，它包含了一个由五个 nn.Linear 层组成的列表。当 forward方法被调用时，输入 x 会被序列化地通过这五个线性层。</p><p><code>nn.Sequential</code>的好处是，它简化了模块的顺序管理，你不需要手动编写复杂的<code>forward</code>方法来处理数据通过每个模块的过程。<code>nn.Sequential</code>会自动为你完成这个过程</p><p>每次增加分组都会产生新的模块需要新的 <code>mixing network</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_new_net</span>(<span class="hljs-params">self</span>):<br>        self.hyper_b1.append(nn.Sequential(nn.Linear(self.a_h_dim, self.embed_dim)))<br><br>        self.hyper_w2.append(nn.Sequential(nn.Linear(self.hypernet_dim, self.hypernet_dim),<br>                                           nn.ReLU(inplace=<span class="hljs-literal">True</span>),<br>                                           nn.Linear(self.hypernet_dim, self.embed_dim)))<br>        <br>        self.hyper_b2.append(nn.Sequential(nn.Linear(self.hypernet_dim, self.embed_dim),<br>                                           nn.ReLU(inplace=<span class="hljs-literal">True</span>),<br>                                           nn.Linear(self.embed_dim, <span class="hljs-number">1</span>)))<br>        <span class="hljs-keyword">if</span> self.args.use_cuda:<br>            self.hyper_b1.cuda()<br>            self.hyper_w2.cuda()<br>            self.hyper_b2.cuda()<br>        <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;New Mixer Size:&quot;</span>)<br>        <span class="hljs-built_in">print</span>(get_parameters_num(self.parameters()))<br></code></pre></td></tr></table></figure><p>同样对应的就是删除某个组的某个网络</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">ef del_net(self, idx):<br>        <span class="hljs-keyword">del</span> self.hyper_b1[idx]<br>        <span class="hljs-keyword">del</span> self.hyper_w2[idx]<br>        <span class="hljs-keyword">del</span> self.hyper_b2[idx]<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Del Group &#123;&#125; Network Mixer Size:&quot;</span>.<span class="hljs-built_in">format</span>(idx))<br>        <span class="hljs-built_in">print</span>(get_parameters_num(self.parameters()))<br></code></pre></td></tr></table></figure><h4 id="划分成组为单位">划分成组为单位</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> group_index, group_i <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(self.group):<br>            group_state = all_group_state[:, group_i, :]<br>            group_state = th.<span class="hljs-built_in">max</span>(group_state, dim=<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]<br>            group_state_list.append(group_state)<br></code></pre></td></tr></table></figure><h4 id="生成最开始的-w_1权重">生成最开始的 <spanclass="math inline">\(w_1\)</span>权重</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.n_agents):<br>            w1 = self.hyper_w1[i](a_h[:, i, :])<br>            <span class="hljs-keyword">if</span> self.<span class="hljs-built_in">abs</span>:<br>                w1 = w1.<span class="hljs-built_in">abs</span>()<br>            w1_list.append(w1)<br>        <br>        w1 = th.stack(w1_list, dim=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="计算sd-loss">计算SD Loss</h4><p>这部分主要是在计算组内相似性 和组间相似性从而得出SD loss的损失值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python">sd_loss = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> group_index, group_i <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(self.group):<br>            group_n = <span class="hljs-built_in">len</span>(group_i)<br>            group_qs = qvals[:, :, group_i]<br>            group_qs = group_qs.reshape(b * t, <span class="hljs-number">1</span>, group_n)<br><br>            group_a_h = a_h[:, group_i, :]<br><br>            group_w1 = w1[:, group_i, :]<br><br>            b1 = self.hyper_b1[group_index](group_a_h)<br>            b1 = th.<span class="hljs-built_in">sum</span>(b1, dim=<span class="hljs-number">1</span>, keepdim=<span class="hljs-literal">True</span>)<br>            <br>            group_j = []<br>            <span class="hljs-keyword">for</span> group_tmp <span class="hljs-keyword">in</span> self.group:<br>                <span class="hljs-keyword">if</span> group_tmp != group_i:<br>                    group_j += group_tmp<br><br>            <span class="hljs-keyword">for</span> agent_i <span class="hljs-keyword">in</span> group_i:<br>                group_state_agent_i = all_group_state[:, agent_i, :].unsqueeze(<span class="hljs-number">1</span>)<br>                group_state_sim = all_group_state[:, group_i, :]<br>                group_state_div = all_group_state[:, group_j, :]<br>                group_state_agent_i_sim = group_state_agent_i.expand_as(group_state_sim)<br>                group_state_agent_i_div = group_state_agent_i.expand_as(group_state_div)<br><br>                sim_loss = th.<span class="hljs-built_in">sum</span>(group_state_agent_i_sim * group_state_sim, dim=-<span class="hljs-number">1</span>) / \<br>                                ((th.<span class="hljs-built_in">sum</span>(group_state_agent_i_sim ** <span class="hljs-number">2</span>, dim=-<span class="hljs-number">1</span>) ** <span class="hljs-number">0.5</span>) * (th.<span class="hljs-built_in">sum</span>(group_state_sim ** <span class="hljs-number">2</span>, dim=-<span class="hljs-number">1</span>) ** <span class="hljs-number">0.5</span>))<br>                div_loss = th.<span class="hljs-built_in">sum</span>(group_state_agent_i_div * group_state_div, dim=-<span class="hljs-number">1</span>) / \<br>                                ((th.<span class="hljs-built_in">sum</span>(group_state_agent_i_div ** <span class="hljs-number">2</span>, dim=-<span class="hljs-number">1</span>) ** <span class="hljs-number">0.5</span>) * (th.<span class="hljs-built_in">sum</span>(group_state_div ** <span class="hljs-number">2</span>, dim=-<span class="hljs-number">1</span>) ** <span class="hljs-number">0.5</span>))<br><br>                sd_loss -= th.<span class="hljs-built_in">sum</span>(sim_loss, dim=-<span class="hljs-number">1</span>)<br>                sd_loss += th.<span class="hljs-built_in">sum</span>(div_loss, dim=-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="生成组别为单位的价值函数">生成组别为单位的价值函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">group_state = group_state_list[group_index]<br>w2 = self.hyper_w2[group_index](group_state).view(b*t, self.embed_dim, <span class="hljs-number">1</span>)<br>b2 = self.hyper_b2[group_index](group_state).view(b*t, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> self.<span class="hljs-built_in">abs</span>:<br>      w2 = w2.<span class="hljs-built_in">abs</span>()<br>            <br>group_w1_avg = th.mean(th.mean(group_w1, dim=<span class="hljs-number">2</span>, keepdim=<span class="hljs-literal">False</span>), dim=<span class="hljs-number">0</span>, keepdim=<span class="hljs-literal">False</span>)<br><span class="hljs-keyword">if</span> self.group_turn_now == group_index:<br>      w1_avg_list.append(group_w1_avg)<br>    hidden = F.elu(th.matmul(group_qs, group_w1) + b1)<br>      q_group = th.matmul(hidden, w2) + b2<br>      group_q_list.append(q_group.view(b*t, <span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><h4 id="生成总的价值函数">生成总的价值函数</h4><p>下面这一步是基于按照组划分得到的价值函数生成总的联合动作价值函数的过程</p><p>其中用到了两个生成参数的机器 w3和w4以及b3，b4其实结构和之前的是一样的</p><p>最后返回值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">group_tot_q = th.stack(group_q_list, dim=-<span class="hljs-number">1</span>)<br>        group_state_stack = th.stack(group_state_list, dim=<span class="hljs-number">1</span>)<br>        w3 = self.hyper_w3(group_state_stack)<br>        b3 = self.hyper_b3(group_state_stack)<br>        b3 = th.<span class="hljs-built_in">sum</span>(b3, dim=<span class="hljs-number">1</span>, keepdim=<span class="hljs-literal">True</span>)<br><br>        w4 = self.hyper_w4(states).view(b*t, self.embed_dim, <span class="hljs-number">1</span>)<br>        b4 = self.hyper_b4(states).view(b*t, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br><br>        <span class="hljs-keyword">if</span> self.<span class="hljs-built_in">abs</span>:<br>            w3 = w3.<span class="hljs-built_in">abs</span>()<br>            w4 = w4.<span class="hljs-built_in">abs</span>()<br>        <br>        tot_hidden = F.elu(th.matmul(group_tot_q, w3) + b3)<br>        tot_q = th.matmul(tot_hidden, w4) + b4<br></code></pre></td></tr></table></figure><p>返回的东西分别是：总的联合动作价值函数、w1权重的平均值就是生成w1分类器的好坏、SDloss</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">return</span> tot_q.view(b, t, -<span class="hljs-number">1</span>) , w1_avg_list, sd_loss.view(b, t, -<span class="hljs-number">1</span>) / (self.n_agents * self.n_agents)<br></code></pre></td></tr></table></figure><h4 id="损失函数">损失函数</h4><p>这个地方利用了三个部分组成的损失函数来计算最终的损失</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># lasso loss</span><br>        lasso_loss = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(w1_avg_list)):<br>            group_w1_sum = th.<span class="hljs-built_in">sum</span>(w1_avg_list[i])<br>            lasso_loss += group_w1_sum * lasso_alpha[i]<br>        <br>        sd_loss = sd_loss * mask<br>        sd_loss = self.args.sd_alpha * sd_loss.<span class="hljs-built_in">sum</span>() / mask.<span class="hljs-built_in">sum</span>()<br><br>        td_error = (chosen_action_qvals - targets.detach())<br>        td_error = <span class="hljs-number">0.5</span> * td_error.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>)<br><br><br>        mask = mask.expand_as(td_error)<br>        masked_td_error = td_error * mask<br>        td_loss = masked_td_error.<span class="hljs-built_in">sum</span>() / mask.<span class="hljs-built_in">sum</span>()<br><br>        loss = td_loss + lasso_loss + sd_loss<br></code></pre></td></tr></table></figure><h4 id="改变分组的过程">改变分组的过程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> change_group_i == self.args.change_group_batch_num - <span class="hljs-number">1</span>:<br> self.agent_w1_avg /= self.args.change_group_batch_num<br>            group_now = copy.deepcopy(self.mixer.group)<br>            group_nxt = copy.deepcopy(self.mixer.group)<br>            <span class="hljs-keyword">for</span> group_index, group_i <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(group_now):<br>                group_w1_avg = self.agent_w1_avg[group_i]<br><br>                group_avg = th.mean(group_w1_avg)<br>                relative_lasso_threshold = group_avg * self.args.change_group_value<br>                indices = th.where(group_w1_avg &lt; relative_lasso_threshold)[<span class="hljs-number">0</span>]<br><br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(group_i) &lt; <span class="hljs-number">3</span>:<br>                    <span class="hljs-keyword">continue</span><br>                <br>                <span class="hljs-keyword">if</span> group_index+<span class="hljs-number">1</span> == <span class="hljs-built_in">len</span>(group_now) <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(indices) != <span class="hljs-number">0</span>:<br>                    tmp = []<br>                    group_nxt.append(tmp)<br>                    self.mixer.add_new_net()<br>                    self.target_mixer.add_new_net()<br>                <br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(indices)-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>                    idx = group_now[group_index][indices[i]]<br>                    group_nxt[group_index+<span class="hljs-number">1</span>].append(idx)<br>                    <span class="hljs-keyword">del</span> group_nxt[group_index][indices[i]]<br>                    <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> self.mixer.hyper_w1[idx]:<br>                        <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(m) != nn.ReLU:<br>                            m.reset_parameters()<br>            <br>            whether_group_changed = <span class="hljs-literal">True</span> <span class="hljs-keyword">if</span> group_now != group_nxt <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span><br>            <br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> whether_group_changed:<br>                <span class="hljs-keyword">return</span><br>            <br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(group_nxt)-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> group_nxt[i] == []:<br>                    <span class="hljs-keyword">del</span> group_nxt[i]<br>                    self.mixer.del_net(i)<br>                    self.target_mixer.del_net(i)<br>            <br>            self.mixer.update_group(group_nxt)<br>            self.target_mixer.update_group(group_nxt)<br>            self._update_targets()<br></code></pre></td></tr></table></figure><h3 id="实验结果">实验结果</h3><p>在星际争霸的环境中的训练结果</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122225759954.png"alt="SMAC训练结果" /><figcaption aria-hidden="true">SMAC训练结果</figcaption></figure><p>消融实验</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122225941711.png"alt="消融实验对比" /><figcaption aria-hidden="true">消融实验对比</figcaption></figure><p>谷歌足球的训练结果</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122225826734.png"alt="GRF的训练结果与可视化" /><figcaption aria-hidden="true">GRF的训练结果与可视化</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>强化学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>深度学习</tag>
      
      <tag>强化学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【基础工具】Git命令集</title>
    <link href="/2023/10/23/tool_git/"/>
    <url>/2023/10/23/tool_git/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>Git是一个版本控制系统，是任何软件开发项目中的主要内容。通常有两个主要用途：代码备份和代码版本控制。使用Git可以逐步处理代码，在需要回滚到备份副本的过程中保存每一步的进度。</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231206220759363.png"alt="Git与GitHub" /><figcaption aria-hidden="true">Git与GitHub</figcaption></figure><h2 id="git的安装与配置">Git的安装与配置</h2><h4 id="安装git">安装Git</h4><p>直接上官网下载安装</p><p><ahref="https://link.zhihu.com/?target=https%3A//git-scm.com/download">https://link.zhihu.com/?target=https%3A//git-scm.com/download</a></p><p><a href="https://git-scm.com/">https://git-scm.com/</a></p><p>或者MAC使用brew对git进行安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install git<br></code></pre></td></tr></table></figure><h4 id="查看git中的配置">查看Git中的配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --list<br>git config --global user.email <span class="hljs-built_in">test</span>@163.com<br>git config --global user.name <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><h4 id="检查是否安装成功">检查是否安装成功</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git version<br></code></pre></td></tr></table></figure><h2 id="git的基本控制">Git的基本控制</h2><h3 id="初始化git仓库">初始化Git仓库</h3><p>当完成上述的配置之后，就能开始初始化Git仓库，进入需要创建<strong>工作区</strong>workspace的文件夹输出git初始化的操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> workspace<br>git init<br></code></pre></td></tr></table></figure><p>创建一个名为 .git的新子目录（该目录为隐藏的），其中包含所有必需的存储库文件（Git存储库框架）；注意区分<strong>工作区</strong>和<strong>暂存区</strong>，在没有add之前我们都是在<strong>工作区</strong></p><p>【Vscode】考虑<strong>Gitgraph插件</strong>来可视化git分支目录的全貌</p><ul><li><h5 id="在github端新建仓库">在Github端新建仓库</h5><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231206215455986.png"alt="Github端新建仓库" /><figcaption aria-hidden="true">Github端新建仓库</figcaption></figure><p>根据需要可以设置为公有的或者是私有的，最好不要设置README.md，因为初始化的国过程可能会出现冲突，设置也没关系</p></li><li><h5id="本地的git和远端github的连接">本地的Git和远端github的连接</h5><p>获取本地的SSH公钥匙，打开终端并输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;youremail@example.com&quot;</span><br></code></pre></td></tr></table></figure><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231206221011696.png"alt="产生公钥的位置" /><figcaption aria-hidden="true">产生公钥的位置</figcaption></figure><p>进入.ssh中复制id_rsa.pub中的内容，并在Github中的如下位置复制改内容添加SSH🔗</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231206221215856.png"alt="SSH链接" /><figcaption aria-hidden="true">SSH链接</figcaption></figure><p>完成连接之后再配置git的相关内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.email <span class="hljs-built_in">test</span>@163.com<br>git config --global user.name <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure></li><li><h5 id="本地工作区的设置">本地工作区的设置</h5><p>首先进行初始化设置，使当前文件夹能够使用git</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br></code></pre></td></tr></table></figure><p>如果一开始没有设置README.md文件那么执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add README.md<br>git commit -m <span class="hljs-string">&quot;first commit&quot;</span><br>git branch -M main<br>git remote add origin git@github.com.....git<br>git push -u origin master<br></code></pre></td></tr></table></figure><p>以上这些步骤，就能将本地的git和远端的仓库进行关联</p></li><li><h5 id="本地和远端关联失败">本地和远端关联失败</h5><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231206220359185.png"alt="推送出现错误" /><figcaption aria-hidden="true">推送出现错误</figcaption></figure><p>当然会出现本地和远端关联失败的情况，产生的原因可能如下：</p><ol type="1"><li><p>在默认情况下，<code>git push</code>时一般会上传到<code>origin</code>下的<code>master</code>分支上，当<em>repository</em>和<em>branch</em>过多，又没有设置关联时，git就会产生疑问</p><p>通过以下命令查看<strong>远端</strong>和<strong>本地</strong>的分支，并<strong>选择合适的</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch //本地<br>git branch -a //远端<br></code></pre></td></tr></table></figure><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231206220538190.png"alt="远端和本地的不同分支" /><figcaption aria-hidden="true">远端和本地的不同分支</figcaption></figure></li><li><p>如果本地初始化的内容和远端的内容不一样，那么无法判断本地和远端的内容差异，因此需要选择如下之一</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard origin/master<br></code></pre></td></tr></table></figure><p>直接将远端的内容覆盖到本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push -f -u origin master<br></code></pre></td></tr></table></figure><p>强行将本地的内容覆盖到远端，那么就能形成统一，从而完成链接。</p></li></ul><h3 id="添加文件和备注">添加文件和备注</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add . <br>git add &lt;file&gt;<br></code></pre></td></tr></table></figure><p>执行上述命令之后将会将当前的file或者是工作区中的所有文件都上传到暂存区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m<span class="hljs-string">&quot;【test】XXX更改信息提示&quot;</span><br><span class="hljs-comment">#如果多次提交想覆盖到同一个提交的备注上执行下面</span><br>git commit --amend<br></code></pre></td></tr></table></figure><p>上述的命令是将本次的提交添加描述，分布式协作的时候能看清</p><h3 id="状态与日志">状态与日志</h3><p>查看默认配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --list<br></code></pre></td></tr></table></figure><p>查看当前所在的分支位置信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git status<br></code></pre></td></tr></table></figure><p>查看当前分支下的更改日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><h3 id="推送与拉取">推送与拉取</h3><p>将本地暂存区中的更改内容推送到远端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push<br>git push -f <span class="hljs-comment">#强行推出</span><br></code></pre></td></tr></table></figure><p>将远端所在的分支内容拉到本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull<br></code></pre></td></tr></table></figure><p>更新所在分支的最新内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch --all <br></code></pre></td></tr></table></figure><h3 id="复制分支">复制分支</h3><p>获取git连接git@ XXX.git之后执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git@ XXX.git<br></code></pre></td></tr></table></figure><p>如果觉得git的内容太大，可以选择内部的分支进行下载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> -b feature/xxx git@ XXX.git<br></code></pre></td></tr></table></figure><p>feature/xxx为具体的分支内容</p><h3 id="分支操作">分支操作</h3><p>查看分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -a <span class="hljs-comment">#查看所有的分支</span><br>git branch -r <span class="hljs-comment">#查看远端的分支</span><br></code></pre></td></tr></table></figure><p>切换不同的分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout [branch] <span class="hljs-comment">#切换到分支</span><br></code></pre></td></tr></table></figure><p>创建新的分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch [branch] <span class="hljs-comment">#创建新的分支</span><br></code></pre></td></tr></table></figure><p>创建新的分支并切换到上面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b [branch] <span class="hljs-comment">#创建并切换新的分支</span><br></code></pre></td></tr></table></figure><p>合并分支</p><ul><li>现在的任务是将b分支完全合并进a分支，同时只留下a分支</li><li>首先确保b分支上的修改提交到了origin</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout a <span class="hljs-comment">#先切换到a分支</span><br>git pull <span class="hljs-comment">#获取最新的内容</span><br>git merge origin/b <span class="hljs-comment">#合并b</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git commit -m <span class="hljs-string">&quot;merge test&quot;</span><br>git push<br></code></pre></td></tr></table></figure><p>但是此时还是有另一个分支存在，如果想删除分支b</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">git push origin --<span class="hljs-built_in">delete</span> b<br></code></pre></td></tr></table></figure><h3 id="分支冲突">分支冲突</h3><p><strong>问题描述：</strong>如果当前修改的版本基于旧版，但是远端已经是新版origin/master，<strong>此时修改基于的内容和远端不同不能强行推</strong>。</p><p><strong>解决方法1：</strong>通过换基的方法解决，通过将当前的修改的旧版换到最新的基上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#先将文件提交到暂存区</span><br>git add . <span class="hljs-comment">#保存在暂存区</span><br>git commit -m <span class="hljs-string">&quot;XXX&quot;</span><br><span class="hljs-comment">#进行换基操作</span><br>git rebase -i origin/master<br><span class="hljs-comment">#再次提交</span><br>git add .<br><span class="hljs-comment">#继续换基</span><br>git rebase --<span class="hljs-built_in">continue</span><br><span class="hljs-comment">#换基成功后,只需要一次备注（覆盖）</span><br>git commit --amend<br><span class="hljs-comment">#最后退出</span><br>git push<br>git push -f <span class="hljs-comment">#或者强行推出</span><br></code></pre></td></tr></table></figure><p><strong>解决方法2：</strong> 暴力覆盖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch --all <span class="hljs-comment">#获取远端的全部内容</span><br>git reset --hard origin/master <span class="hljs-comment">#强行将远端的内容覆盖到本地的文件中</span><br>git commit --amend <br>git push -f <span class="hljs-comment">#强行推出</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基础工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【基础工具】Anaconda命令集</title>
    <link href="/2023/10/22/tool_conda/"/>
    <url>/2023/10/22/tool_conda/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="conda安装">Conda安装</h2><h3 id="直接安装">直接安装</h3><p>安装网址https://www.anaconda.com/，但是下载速度很慢</p><h3 id="镜像安装">镜像安装</h3><p>清华源网址https://mirrors.tuna.tsinghua.edu.cn/anaconda/</p><p>下载速度会比较快</p><p>如果觉得anacodna的包非常大，可以选择安装minicondahttps://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/</p><h2 id="conda-常用命令">Conda 常用命令</h2><h3 id="查看conda版本">查看conda版本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">conda --version/ conda -V<br></code></pre></td></tr></table></figure><h3 id="查看已有环境">查看已有环境</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">conda info --envs<br>conda env <span class="hljs-built_in">list</span><br>conda info -e<br></code></pre></td></tr></table></figure><h3 id="进退环境">进退环境</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">conda activate  [name]<span class="hljs-comment"># 重新进入虚拟环境</span><br>conda deactivate  <span class="hljs-comment"># 退出虚拟环境</span><br></code></pre></td></tr></table></figure><h3 id="创建新的环境">创建新的环境</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">conda create -n *** python=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="删除环境">删除环境</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">conda remove -n old_name --<span class="hljs-built_in">all</span> <span class="hljs-comment"># 删除环境old_name</span><br></code></pre></td></tr></table></figure><h3 id="激活环境">激活环境</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">conda activate xxxx <span class="hljs-comment"># 激活xxxx环境</span><br></code></pre></td></tr></table></figure><h3 id="关闭环境">关闭环境</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">conda deactivate <span class="hljs-comment"># 关闭环境</span><br></code></pre></td></tr></table></figure><h3 id="克隆环境">克隆环境</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">conda create -n [new_name] --clone [old_name]<br></code></pre></td></tr></table></figure><h3 id="升级版本">升级版本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">conda update -n base conda <span class="hljs-comment">#update最新版本的conda；</span><br>conda update --<span class="hljs-built_in">all</span> <span class="hljs-comment">#更新所有包</span><br></code></pre></td></tr></table></figure><h3 id="pip管理的常用包">Pip管理的常用包</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">pip search package_name <br>pip show package_name <br>pip uninstall｜｜package_name<br>pip <span class="hljs-built_in">list</span><br></code></pre></td></tr></table></figure><h3 id="删除环境中的包">删除环境中的包</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">conda remove package <span class="hljs-comment">#删除当前环境中的包</span><br>conda remove -- name env_name package <span class="hljs-comment">#删除指定环境中的包</span><br></code></pre></td></tr></table></figure><h3 id="指定环境中安装包">指定环境中安装包</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">conda install --name env_name package_name <br></code></pre></td></tr></table></figure><h3 id="生成conda环境依赖包的版本">生成Conda环境依赖包的版本</h3><p>在做实验的过程中，需要输出一个关于当前环境的版本依赖文件，可以选择使用下面的方法进行输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip list --format=freeze&gt; requirements.txt<br></code></pre></td></tr></table></figure><h3 id="conda环境的python版本非指定">Conda环境的python版本非指定</h3><p>指定虚拟环境x的python版本是3.8，base环境是3.11；condaactivate激活x之后python版本仍为3.11。</p><p><strong>原因：</strong>在base环境中修改了.zshrc文件中的python只定路径，让每次虚拟环境中的python找到的python都只能按照指定的python路径进行寻找，从而导致conda环境中的python版本不能制定。</p><p><strong>修改方式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim .zshrc<br></code></pre></td></tr></table></figure><p>进入.zshrc环境中进行修改，如果发现一类诸如其他python版本指定的路径的话，需要进行删除，只需要保留最原始的关于anaconda的命令初始化，完成之后输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.zshrc<br></code></pre></td></tr></table></figure><p>解决问题</p><h3 id="镜像源安装">镜像源安装</h3><p>在conda环境中改变默认的下载镜像源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip config <span class="hljs-built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple <br></code></pre></td></tr></table></figure><p>加上这句话之后就会出现以下的写文件</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">Writing to /home/user/.config/pip/pip.conf<br></code></pre></td></tr></table></figure><p><strong>下载使用清华源加上： -ihttps://pypi.tuna.tsinghua.edu.cn/simple</strong></p><blockquote><p><strong>清华：<code>https://pypi.tuna.tsinghua.edu.cn/simple/</code></strong></p><p><strong>阿里云：<code>http://mirrors.aliyun.com/pypi/simple/</code></strong></p><p><strong>中国科技大学：<code>https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/</code></strong></p><p><strong>豆瓣：<code>http://pypi.doubanio.com/simple/</code></strong></p></blockquote><p>如果是给conda添加镜像：清华源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/win-64/<br></code></pre></td></tr></table></figure><p>添加阿里源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda config --add channels https://mirrors.aliyun.com/pypi/simple/<br></code></pre></td></tr></table></figure><p>查看已经添加的镜像源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda config --show channels<br></code></pre></td></tr></table></figure><p>移除其中的指定的镜像源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda config --remove channels + 镜像的名称<br></code></pre></td></tr></table></figure><h3 id="conda无法自动更新">Conda无法自动更新</h3><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231206113335958.png"alt="image-20231206113335958" /><figcaption aria-hidden="true">image-20231206113335958</figcaption></figure><p>原因：<ahref="https://so.csdn.net/so/search?q=conda&amp;spm=1001.2101.3001.7020">conda</a>和pip等相关包的版本太低，自动更新不能用，解决方案：在命令行中输入以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda clean --all<br>conda update --all<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基础工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【深度学习】PyTorch使用手册</title>
    <link href="/2023/10/22/dl_pytorch/"/>
    <url>/2023/10/22/dl_pytorch/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>本文主要介绍pytorch中的基本使用，包括如何导入数据集，如何搭建并训练网络以及可视化的内容，基本涵盖了深度学习中经典算法的使用以及相关的例子</p><h2 id="basics">Basics</h2><h3 id="计算梯度例子">计算梯度例子</h3><p>引入基本需要用到的包，深度学习中torch处理大部分张量的运算，而torch.nn则是对torch的网络中的一些运算，这些都是必须用到的包。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch <br><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> torchvision.transforms <span class="hljs-keyword">as</span> transforms<br></code></pre></td></tr></table></figure><p>在深度学习中，一般使用张量进行运算，此时会涉及到计算张量的梯度等问题，我们这里给出一个例子来展示如何使用张量来进行梯度计算：</p><p>初始化定义张量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">x = torch.tensor(<span class="hljs-number">1.</span>, requires_grad=<span class="hljs-literal">True</span>)<br>w = torch.tensor(<span class="hljs-number">2.</span>, requires_grad=<span class="hljs-literal">True</span>)<br>b = torch.tensor(<span class="hljs-number">3.</span>, requires_grad=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>建立<strong>计算图 computational graph</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">y = w * x + b    <span class="hljs-comment"># y = 2 * x + 3</span><br></code></pre></td></tr></table></figure><p>计算梯度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">y.backward()<br><span class="hljs-built_in">print</span>(x.grad)    <span class="hljs-comment"># x.grad = 2 </span><br><span class="hljs-built_in">print</span>(w.grad)    <span class="hljs-comment"># w.grad = 1 </span><br><span class="hljs-built_in">print</span>(b.grad)    <span class="hljs-comment"># b.grad = 1 </span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【多智能体强化学习】Pymarl环境配置</title>
    <link href="/2023/10/22/marl_pymarl_env/"/>
    <url>/2023/10/22/marl_pymarl_env/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>SMAC是基于暴雪星际争霸IIRTS游戏的协作多智能体强化学习领域的研究环境。SMAC利用星际争霸2机器学习API和DeepMind的PySC2为自主代理提供了一个方便的接口。</p><p>本文主要介绍在多智能体强化学习中的验证平台SAMC和Pymarl的配置和安装过程</p><p>环境地址：<ahref="https://github.com/oxwhirl/pymarl">https://github.com/oxwhirl/pymarl</a></p><p>依赖环境：<ahref="https://github.com/oxwhirl/smac">https://github.com/oxwhirl/smac</a></p><p>主要针对Ubuntu下的Pymarl环境的配置（MAC和Windows类似）</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231022145734342.png"alt="SMAC" /><figcaption aria-hidden="true">SMAC</figcaption></figure><h2 id="安装starcraftii">安装StarCraftII</h2><h3 id="windowsmac">Windows/Mac</h3><p>直接在官网下载安装最新版，需要加速器或者更换亚服：<ahref="https://sc2.blizzard.cn/landing">https://sc2.blizzard.cn/landing</a></p><p>安装地图：<ahref="https://link.zhihu.com/?target=https%3A//github.com/oxwhirl/smac/releases/download/v0.1-beta1/SMAC_Maps.zip">https://link.zhihu.com/?target=https%3A//github.com/oxwhirl/smac/releases/download/v0.1-beta1/SMAC_Maps.zip</a></p><p>将地图放在Maps文件夹下</p><h3 id="ubuntu">Ubuntu</h3><p>在Ubuntu系统中，安装需要版本的SCII即可<ahref="https://github.com/Blizzard/s2client-proto#downloads">https://github.com/Blizzard/s2client-proto#downloads</a></p><p>下载压缩包之后安装并解压放到用户名文件夹下：～/StarCraftII/</p><p>如果没有把SCII安装到用户名之下，这个地方的路径可以根据放置的位置来进行更改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim ~/.bashrc<br></code></pre></td></tr></table></figure><p>在最后一行增加环境变量，这里可以更改星际争霸的位置索引到任何想要放置的位置</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">SC2PATH</span>=~/StarCraftII/<br></code></pre></td></tr></table></figure><p>添加完之后更新环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure><p>添加SAMC的地图：Linux系统在下载SCII的时候就自带了地图</p><h2 id="安装smac">安装SMAC</h2><p>创建虚拟环境并安装pytorch</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">conda create -n pymarl python=<span class="hljs-number">3.8</span> -y<br>conda activate pymarl   <br><span class="hljs-comment"># CUDA 10.2 例子具体的的CUDA版本根据自己的服务器来定</span><br>conda install pytorch==<span class="hljs-number">1.10</span><span class="hljs-number">.0</span> torchvision==<span class="hljs-number">0.11</span><span class="hljs-number">.0</span> torchaudio==<span class="hljs-number">0.10</span><span class="hljs-number">.0</span> cudatoolkit=<span class="hljs-number">10.2</span> -c pytorch<br></code></pre></td></tr></table></figure><p>直接利用虚拟环境中的pip来安装</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install git+https://github.com/oxwhirl/smac.git<br></code></pre></td></tr></table></figure><p>或者可以利用git进行安装，先gitclone下载下来然后进入文件夹中进行安装</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">git clone https://github.com/oxwhirl/smac.git<br>pip install -e smac/<br></code></pre></td></tr></table></figure><p>如果pip install安装失败可以考虑升级pip：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install --upgrade pip<br></code></pre></td></tr></table></figure><p>如果安装的内容失败了可以手动安装，比如pymarl运行所依赖的包有以下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install sacred numpy scipy matplotlib seaborn pyyaml pygame pytest probscale imageio snakeviz tensorboard-logger<br><br></code></pre></td></tr></table></figure><p>或者根据<ahref="https://github.com/oxwhirl/pymarl/tree/master/docker">https://github.com/oxwhirl/pymarl/tree/master/docker</a>中的bash脚本中Dockerfile依赖内容进行安装</p><h2 id="pymarl与scii">Pymarl与SCII</h2><h3 id="采用上述安装步骤">采用上述安装步骤</h3><p>对于上述的操作完成操作之后，下载pymarl的环境包并进入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">git clone git@github.com:oxwhirl/pymarl.git<br>cd pymarl<br></code></pre></td></tr></table></figure><p>将上述安装的SCII文件夹复制到pymarl的src的3dparty之下</p><h3 id="如果利用docker安装">如果利用Docker安装</h3><p>或者根据pymarl中的内容对上述环境进行自动配置（需要Docker）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> docker<br>bash build.sh<br></code></pre></td></tr></table></figure><p>同时安装SCII和SMAC</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bash install_sc2.sh<br></code></pre></td></tr></table></figure><h2 id="测试环境">测试环境</h2><h3 id="测试地图信息">测试地图信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">python -m smac.<span class="hljs-built_in">bin</span>.map_list <br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231022153907123.png" alt="Maps show" style="zoom:67%;" /></p><h3 id="测试环境信息">测试环境信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">python -m smac.examples.random_agents<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231022153709693.png" alt="test agents" style="zoom: 50%;" /></p><h3 id="测试pymarl环境">测试Pymarl环境</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">python src/main.py --config=qmix --env-config=sc2 <span class="hljs-keyword">with</span> env_args.map_name=2s3z<br></code></pre></td></tr></table></figure><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231022153651418.png"alt="test pymarl" /><figcaption aria-hidden="true">test pymarl</figcaption></figure><h2 id="依赖包的版本问题">依赖包的版本问题</h2><p>当运行pymarl的时候容易因为依赖包产生问题</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240104210308852.png"alt="image-20240104210308852" /><figcaption aria-hidden="true">image-20240104210308852</figcaption></figure><p>原因是<code>sacred</code>版本不对劲，只需要将版本降低到0.7.5这个问题就能解决</p><h2 id="额外设置">额外设置</h2><p>在利用pymarl进行实验的过程中可能会出现</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231022154059365.png"alt="some bug" /><figcaption aria-hidden="true">some bug</figcaption></figure><p>需要进行设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim torch/_tensor.py<br></code></pre></td></tr></table></figure><p>将757行的内容进行修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">-: self.numpy()<br>+: self.cpu().numpy()<br></code></pre></td></tr></table></figure><h2 id="谷歌足球环境">谷歌足球环境</h2><p>Google ResearchFootball：https://github.com/google-research/football</p><h4 id="安装linux依赖环境">安装Linux依赖环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install git cmake build-essential libgl1-mesa-dev libsdl2-dev \<br>libsdl2-image-dev libsdl2-ttf-dev libsdl2-gfx-dev libboost-all-dev \<br>libdirectfb-dev libst-dev mesa-utils xvfb x11vnc python3-pip<br><br>python3 -m pip install --upgrade pip setuptools psutil wheel<br></code></pre></td></tr></table></figure><p>这一步非常重要，必须合理安装相应的包。</p><h4 id="安装gfootball">安装GFootball</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">python3 -m pip install gfootball<br></code></pre></td></tr></table></figure><p>或者用github的仓库来进行安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/google-research/football.git<br><span class="hljs-built_in">cd</span> football<br></code></pre></td></tr></table></figure><p>可以选择使用虚拟环境:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">python3 -m venv football-env<br><span class="hljs-built_in">source</span> football-env/bin/activate<br></code></pre></td></tr></table></figure><p>安装依赖包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python3 -m pip install .<br></code></pre></td></tr></table></figure><h4 id="运行结果展示">运行结果展示：</h4><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240106145437351.png" alt="谷歌足球结果展示" style="zoom:50%;" /></p><h4 id="遇到的问题">遇到的问题</h4><p>编译错误，缺少boost的包：</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240106145036965.png"alt="编译错误" /><figcaption aria-hidden="true">编译错误</figcaption></figure><p>选择安装如下包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda install anaconda::py-boost<br></code></pre></td></tr></table></figure><p>第二个错误：</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240106145218372.png" alt="错误二" style="zoom:67%;" /></p><p>解决方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libffi.so.7<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>强化学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>深度学习</tag>
      
      <tag>强化学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【自动驾驶】RSS Model for Autonomous Driving</title>
    <link href="/2023/10/21/dl_rss/"/>
    <url>/2023/10/21/dl_rss/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="rss-model-for-autonomous-driving"><strong>RSS Model forAutonomous Driving</strong></h2><h4id="论文on-a-formal-model-of-safe-and-scalable-self-driving-cars">论文：《Ona Formal Model of Safe and Scalable Self-driving Cars》</h4><h4 id="contribution"><strong>Contribution：</strong></h4><ul><li>Safety (RSS model) Reasonable care, Responsibility, agile drivingpolicy</li><li>Semantic (Semantic language) :Defined Q function over the Semanticspace</li><li>PAC sensing model：Safety and Comfort of driving ；tied to the Qfunction;</li></ul><h4 id="safety-concept"><strong>1. Safety Concept</strong></h4><p>Functional versus nominal safety 功能安全与名义安全</p><p>Functional Safety，FuSa 是指电子电路中操作的完整性</p><p>名义安全是在假设HW和SW系统运行无差错(即在功能上是安全的)的情况下，AV是否正在做出安全的逻辑决策。</p><p>Sense，Plan，Act 感知 计划 行动</p><h4 id="现有的自动驾驶汽车的决策方案"><strong>2.现有的自动驾驶汽车的决策方案</strong></h4><ul><li>Miles driven ：基于统计的论点，同时需要较大的统计量数据</li><li>disengagements（脱离）：被定义为人类安全驾驶人因为做出不安全的决定而不得不干预AV的运行，从而导致事故的情况。</li><li>simulation：建立虚拟世界模拟器，模拟器和显示世界的差距，无法建模全部的策略</li><li>scenario based testing：枚举现实世界的驾驶场景，过度拟合和泛化的问题</li><li>proprietary approaches</li></ul><h4id="rssresponsibility-sensitive-safety-model-for-multi-agent-safety"><strong>3.RSS(Responsibility-Sensitive-Safety) Model for Multi-agentSafety</strong></h4><ul><li><p>目标：</p><ul><li>做不到绝对安全，需要有Reasonable的响应</li><li>遵循RSS能做到乌托邦Utopia</li><li>敏捷而非防御，不应当过于谨慎而影响其他驾驶</li><li>法律解释的意义</li></ul></li><li><p>形式化的规则：</p><ol type="1"><li>Do not hit someone from behind.</li><li>Do not cut-in recklessly.</li><li><strong>Right-of-way is given, not taken.</strong>道路通行权是给予的而不是占用的</li><li>Be careful of areas with limited visibility小心有限可视化的范围</li><li>If you can avoid an accident without causing another one, you mustdo it.</li></ol></li></ul><h5 id="single-land-road-单向道路的情况"><strong>3.1 Single Land Road单向道路的情况</strong></h5><ul><li><p>不考虑前车倒退的情况，后车撞上前车那么后车负责，后车有责任和前车保持距离</p></li><li><p><span class="math inline">\(c_r\)</span>表示前车，<spanclass="math inline">\(c_f\)</span>表示后车，<spanclass="math inline">\(\rho\)</span>表示的是前车的反应时间，<spanclass="math inline">\(a_{max,break}\)</span>表示的是前车的最大加速度，<spanclass="math inline">\(a_{max,accel}\)</span>表示的是最多的加速制动，<spanclass="math inline">\(a_{min,break}\)</span>表示的是后车的最小制动加速度来保证不会撞到前车</p></li><li><p><strong>同方向行驶</strong>的安全距离</p><p>给出最小的安全纵向距离： <span class="math display">\[d_{min}=max\{v_r\rho+1/2a_{max,accel}\rho^2+((v_r+\rhoa_{max,accel})^2)/2a_{min,break}-v_f^2/2a_{max,break},0\}\]</span></p></li><li><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915172320331.png"alt="Definition 1" /><figcaption aria-hidden="true">Definition 1</figcaption></figure></li><li><p><span class="math inline">\(t_b\)</span> dangerous time；<spanclass="math inline">\([t_b,t_b+\rho]\)</span> 表示一定的反应时间在这个范围之内在给定的加速度范围之内 执行proper response</p></li><li><p>Proper Response：表示我们允许执行的最大加速度的限制，并取最小值约束保证满足所有的约束</p></li><li><p>安全纵向距离和Proper Response取决于参数：<spanclass="math inline">\(\rho,a_{max,sccel},a_{min,brake},a_{max,brake}\)</span>参数保证了对智能体行为的假设，选择适当的参数</p></li><li><p>Utopia is possible如果所有智能体车辆都能够遵循合理的响应，那么能归纳证明可以规避事故的发生</p></li></ul><h5 id="a-lane-based-coordinate-system-基于车道的坐标系"><strong>3.2 ALane-Based Coordinate System 基于车道的坐标系</strong></h5><ul><li><p>车道中心是平面上一条平滑有向的曲线 <spanclass="math inline">\(r\)</span> ,其中所有部分可以表示为 <spanclass="math inline">\(r^{(1)},...,r^{(k)}\)</span>即可以是线性的，也可以是弧形的</p></li><li><p>构造 <span class="math inline">\(R-&gt;R^2\)</span>的变换为 <spanclass="math inline">\(\phi\)</span>就是横纵坐标，从而来保证在逻辑上的前后车辆的关系</p></li><li><p>具体的映射的方式可以表示为如下：</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915172406204.png"alt="道路映射的方式" /><figcaption aria-hidden="true">道路映射的方式</figcaption></figure></li><li><p>横纵速度/加速度的计算就可以通过这样的坐标系定义之下得到的一阶/二阶的导数计算得到</p></li></ul><h5id="longitudinal-safe-distance-and-proper-response-纵向约束"><strong>3.3Longitudinal Safe Distance and Proper Response 纵向约束</strong></h5><ul><li><p>给出安全距离的定义：</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915172437378.png"alt="Definition 2" /><figcaption aria-hidden="true">Definition 2</figcaption></figure><p>安全距离定义的想法是，如果两辆车都能对违反安全距离的行为做出“适当”反应，那么就不会发生碰撞。如果其中一个没有“正确”反应，那么它就应对事故负责。</p></li><li><p>那么我们需要知道危险发生的时间，定义这样一个时刻<strong>DangerousLongitudinal Situation and Danger Threshold</strong></p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915172501683-20231022115917321.png"alt="真正的危险时间" /><figcaption aria-hidden="true">真正的危险时间</figcaption></figure><p>给定一个纵向的危险发生的时间段</p></li><li><p><strong>longitudinal proper response 纵向的适当响应</strong></p><p>blame time责任时间表示的是这个时间能够将驾驶的责任从自动驾驶汽车转移到驾驶员身上，如果接管了那么后续的责任将由驾驶员负责，否则由汽车负责</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915172514045-20231022115917843.png"alt="Definition 4" /><figcaption aria-hidden="true">Definition 4</figcaption></figure><p>给出了对于纵向单向行驶而言的速度和加速的要求，需要在危险到来之前做出合理的响应</p></li></ul><h5id="lateral-safe-distance-and-proper-response-横向的约束"><strong>3.4Lateral Safe Distance and Proper Response 横向的约束</strong></h5><ul><li><p>稳健侧向速度 <spanclass="math inline">\(\mu\)</span>：汽车总是存在横向的一个微小摆动:<span class="math display">\[\mu-lateral-v=(l_{out}-l)/(t_{out}-t)\]</span></p></li><li><p>横向安全距离：</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915172633796.png"alt="Definition 6" /><figcaption aria-hidden="true">Definition 6</figcaption></figure><p>对于双方而言都有一个加速度，同时有一个最小的制动加速度</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915172648760.png"alt="Lemma 4" /><figcaption aria-hidden="true">Lemma 4</figcaption></figure></li><li><p>同样定义横向的危险时间和危险区间时间：</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173056976-20231022115918644.png"alt="Definition 7" /><figcaption aria-hidden="true">Definition 7</figcaption></figure></li><li><p><strong>Lateral Proper response 给出横向的适当反应</strong></p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173119252.png"alt="Definition 8" /><figcaption aria-hidden="true">Definition 8</figcaption></figure><p>首先如果在适当的响应时间范围之内，那么只需要限制两车的加速度在一定的范围之内</p><p>如果超出了适当响应时间，那么对于两车的加速度限制需要更改</p></li></ul><h5id="combining-longitudinal-and-lateral-proper-responses-横向和纵向相结合"><strong>3.5Combining Longitudinal and Lateral Proper Responses横向和纵向相结合</strong></h5><ul><li><p>对于横向和纵向结合的车道，定义危险时间和危险情况</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173150615.png"alt="Defintion 9" /><figcaption aria-hidden="true">Defintion 9</figcaption></figure></li><li><p>危险阈值时间定义为横向和纵向的危险阈值时间的最大值，同样定义了危险时间t</p></li><li><p><strong>Basic Proper response to dangerous situations对于危险情况的正确反应处理</strong></p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173218415.png"alt="Definition 10" /><figcaption aria-hidden="true">Definition 10</figcaption></figure><p>对于危险的阈值速度进行分析，如果分别为纵向的阈值速度和横向的阈值速度，那么分别根据前面所述的Definition4和Definition 8 进行速度的限制</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173251798-20231022115919728.png" alt="横向纵向情况" style="zoom:50%;" /></p><p>上面的这张图可以说明问题，当横纵的任意一个方向到达危险的阈值情况，分别作出ProperResponse，那么就可以按照合理的方式来规避风险</p></li><li><p><strong>Lemma5 Utopia is possible</strong></p><p>Consider a multi-lane road where all lanes share the same geometry.Suppose that at all times, all cars on the road comply with the basicproper response as given in Definition 10. Then, there will be<strong>no collisions</strong></p><p>归纳证明说明如果在合适的范围之内作出合理的响应，那么能规避碰撞</p></li></ul><h5id="compensating-for-improper-behavior-of-others-他人的不正当行为"><strong>3.6Compensating for improper behavior of others他人的不正当行为</strong></h5><ul><li><p>如果对方没做出合理反应，那么自己应当作出合适反应避免发生事故，同时不引起下一个事故</p></li><li><p>Naive Prediction：根据速度和加速度线性外推</p></li><li><p>EvasiveManoeuvre：给出两个函数来尽量规避出现车祸，就是根据时间来给速度和加速度的变化规划</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173348421.png"alt="Definition 12" /><figcaption aria-hidden="true">Definition 12</figcaption></figure><p>相当于给出两个函数来知道汽车应当在某个时间范围内到达什么样的位置是安全的，那么要达到这样的位置汽车要采取什么样的速度和加速度来实现</p><p><strong>if you can avoid an accident without causing anotheraccident, you must do it</strong></p></li></ul><h5id="proper-response-with-extra-evasive-effort-制动规避的适当反应"><strong>ProperResponse with Extra Evasive Effort 制动规避的适当反应</strong></h5><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173422047-20231022115920481.png"alt="Definition 13" /><figcaption aria-hidden="true">Definition 13</figcaption></figure><h5id="multiple-geometry-and-right-of-way-rules处理几何图形区域的车辆优先权问题"><strong>3.7Multiple Geometry and Right-of-WayRules处理几何图形区域的车辆优先权问题</strong></h5><ul><li><p>如果有存在不同的几何形状的情形会导致响应的冲突</p></li><li><p>定义横向的安全距离对于<strong>不同的几何路径</strong>对于相同的几何路径仍然成立</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173615571.png"alt="Definition14" /><figcaption aria-hidden="true">Definition14</figcaption></figure><p>向位置范围为[x_i,min,x_i,max]，按照不同的加速度行驶，且不能超过指定的加速度制动那么，则c_1和c_2之间的横向安全距离需要满足：<strong>两车之间横向距离的最小值应大于Definition7中定义的横向安全距离</strong></p></li><li><p>那么如何作出适当的反应 Proper response，给出合适的速度约束</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173634068-20231022115921111.png"alt="横向的合适响应" /><figcaption aria-hidden="true">横向的合适响应</figcaption></figure><p>在反应时间之内可以按照加速度范围内进行移动，但是当超过反应时间之后就要对侧向的速度进行制动</p></li><li><p>定义不同几何路况的纵向的顺序</p><ul><li><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173650265-20231022115921291.png"alt="路况优先权问题" /><figcaption aria-hidden="true">路况优先权问题</figcaption></figure><p>如果在同一条路上那么直接有先后顺序</p><p>如果不在同一条路上，那么根据车辆距离两条道路的相交的位置来定</p><p>当存在纵向的安全距离才会用到这个定义，同时应当是明显的前后顺序</p></li></ul></li><li><p>纵向的安全距离（不同的几何路径）</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173703808-20231022115921710.png"alt="Definition 17" /><figcaption aria-hidden="true">Definition 17</figcaption></figure><ol type="1"><li>如果c_i没有路径的优先级，那么将在路口汇入的位置执行加速到减速的过程停在路口</li><li>如果c_1在c_2前面，c_1执行任意动作（最大刹车加速度的意思是保证这个动作的距离下限），c_2执行最大加速-最小减速过程。当两车速度都为0时，c_1仍然在c_2前面（即后车要刹得住，当前车停下时，纵向顺序关系依然能保持）</li><li>如果没有优先级和前后关系，则考虑两车到达路口的时间范围，如果两者时间范围相交，则有碰撞风险，都需要刹车，反之就正常走。</li></ol><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173722252.png"alt="示意图" /><figcaption aria-hidden="true">示意图</figcaption></figure></li><li><p>纵向的安全响应（Proper response）</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173840619.png"alt="Definition18" /><figcaption aria-hidden="true">Definition18</figcaption></figure><ol type="1"><li>longitudinal proper response取决于Danger ThresholdTime前的situation：</li><li>如果17.1满足，则优先车辆正常开，另外一个则需要在反应时间后刹车。</li><li>如果17.2满足，则前面车辆正常开，候车需要在反应时间后刹车。</li><li>如果17.3满足，两车都需要在横向和纵向上刹车（这里又提到了横向，是纵向已经不能完全规避碰撞风险，所以需要引入横向动作）。</li></ol></li><li><p>Traffic Lights</p><ol type="1"><li>不能简单通过红绿灯的情况来将责任分配给不同的车辆，对于例外的路口的车辆</li><li>绿灯的有优先权 但不是有优先权的就对于规则而言没有责任</li><li>The above discussion is a formalism of the common sense rule of<strong>right of way is given, not taken.</strong></li></ol></li></ul><h5 id="unstructured-road-非结构化的道路"><strong>3.8 Unstructured Road非结构化的道路</strong></h5><ol type="1"><li><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173851532-20231022115922491.png"alt="Definition 19" /><figcaption aria-hidden="true">Definition 19</figcaption></figure><p>轨迹这个表示了根据时间而改变的位置状态，ts的定义就表示车辆第一次完全停止的时间</p><p><strong>未来某部分时刻汽车的位置、某个时间车辆的角度</strong></p></li><li><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173902698-20231022115922745.png"alt="Definition20" /><figcaption aria-hidden="true">Definition20</figcaption></figure><p>当两车的轨迹不满足以下条件时，则称会发生碰撞：</p><p>（1）对于两车均停止之前的任意时刻，两车之间距离均大于epsilon。</p><p>（2）在某车停车之前，两车之前距离均大于epsilon，且此时第二辆车的速度矢量指向第一辆车。即当前车停车，后车依然往前车方向开，后车需要与前车保持距离。</p></li><li><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173913570.png"alt="Definition 21" /><figcaption aria-hidden="true">Definition 21</figcaption></figure><p>定义Constrains（C）下的轨迹T(C,c)，刹车/正常向前行驶的轨迹分别表示为T(Cb, c)和T(Cf,c).</p></li><li><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173936523.png"alt="Definition 22" /><figcaption aria-hidden="true">Definition 22</figcaption></figure><ol type="1"><li>其中一辆车的刹车轨迹和另一辆车的前进轨迹不相交，那么安全（注意保持先后关系对两辆车都适用）</li><li>两辆车都刹车，轨迹没有相交</li></ol></li><li><p>如果不满足安全的要求，那么应当选择Proper Response：</p><ol type="1"><li>如果两辆车都停着，那么其中一辆车应当远离另一辆车选择用Definition20的方法远离</li><li>否则，如果根据safedistance(1)的定义是安全的，一辆车执行刹车，另一辆车在停下来之前就要按照Cf的轨迹正常开，都停下来之后就回到了（1）</li><li>同时选择刹车</li></ol></li></ol><h5 id="pedestrians-行人"><strong>3.9 Pedestrians 行人</strong></h5><ul><li><p>安全距离和合理反应；和汽车相比调整参数且增加非结构化的假设</p></li><li><p>在斑马线或者是人行道上规定行人的行为，行人的合理活动范围是一个以他为圆心的圆</p></li><li><p>遵循互不干扰否则有责任的准则，当汽车进入行人的可能出事的范围那么汽车有责，否则行人有责任</p></li></ul><h5 id="cautiousness-with-respect-to-occlusion-遮挡问题"><strong>3.10Cautiousness with respect to Occlusion 遮挡问题</strong></h5><ul><li><p>Exposure Time 曝光时间：第一次看到这个物体的时间</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173954765-20231022115923512.png"alt="Definition23" /><figcaption aria-hidden="true">Definition23</figcaption></figure></li><li><p><strong>速度不合理导致的不合理情况</strong>：</p><p>相当于速度的范围不在给定的合理的区间。上述提到的参数和地图上的每个汽车的位置、优先级规则和其他的场景结构等条件相关联</p><ol type="1"><li><p>具有道路优先级的汽车的最大速度优先级较高</p></li><li><p>速度的阈值范围根据具体的道路结构</p></li></ol><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915174217869.png"alt="遮挡示意图" /><figcaption aria-hidden="true">遮挡示意图</figcaption></figure></li></ul><p>相当于对于遮挡问题需要对双方的车辆有速度限制才能保证危险的发生</p><h5 id="不当行为造成的不合理的情况"><strong>3.11不当行为造成的不合理的情况</strong></h5><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915174242726.png"alt="Definition 25" /><figcaption aria-hidden="true">Definition 25</figcaption></figure><p>对于出现遮挡的参与者都要保持合理的行为才能规避事故</p><p><strong>对于有遮挡的正确响应方法</strong>：规避不合理的情况，包括但不限于24-25的</p><h5 id="responsibility"><strong>3.12 Responsibility</strong></h5><ul><li>明确智能体责任</li><li>发生碰撞那么有可能是其中一个智能体没有遵守适当的响应约束，那么需要对事故负责</li></ul><h5 id="utopia">3.13 Utopia</h5><ul><li>Lemma 5证明如果所有汽车都遵循基本的响应规则，那么不会发生碰撞</li><li>Lemma6证明如果对于遮挡的问题都能做出合理的响应规则，那么就不会发生事故（反证法）</li></ul><h4 id="driving-policy-rl"><strong>4. Driving Policy（RL）</strong></h4><ul><li><p>驾驶策略的定义：驾驶策略是从感知状态到驾驶命令的映射</p></li><li><p>构建高效的驾驶策略，拓展到百万级别的策略</p></li><li><p>描述驾驶策略的语言：(利用强化学习的描述方法)</p><ol type="1"><li><p><span class="math inline">\(s_t\)</span>表示某一时刻的状态，<spanclass="math inline">\(\pi\)</span>表示的是策略函数，<spanclass="math inline">\(a_t\)</span>表示的是汽车能够选择的动作，根据策略函数来确定，得到一块序列<span class="math inline">\(&lt;s_t,a_t&gt;\)</span></p></li><li><p><span class="math inline">\(P_{\pi}\)</span>表示的是根据 <spanclass="math inline">\(\pi\)</span> 选择产生的后面不同序列<spanclass="math inline">\(&lt;s_t,a_t&gt;\)</span>的概率</p></li><li><p><span class="math inline">\(E_{s~P_\pi}[\rho(s)]\)</span>用于衡量当前策略的好坏程度，相当于对当下这个策略可能产生的不同奖励值选择期望，同时<spanclass="math inline">\(\rho(s)\)</span>表示的是当前状态下的奖励</p></li><li><p>在实际的实现过程中，<spanclass="math inline">\(a_t\)</span>表示的是本车与其他道路使用者的位置、速度和加速度等问题，<spanclass="math inline">\(s_{t+1}\)</span>表示的是下一时刻的状态，同时取决于当前时刻的动作以及其他智能体的行为，奖励函数<spanclass="math inline">\(\rho(s)\)</span>取决于当前环境中的其他智能体的相对位置速度等信息。</p></li><li><p>价值函数 <spanclass="math inline">\(Q\)</span>表示的是当前智能体执行某一个动作所能造成的长期回报,由此来选择最好的策略函数来保证<span class="math inline">\(\pi(s)=argmaxQ(s,a)\)</span></p></li><li><p><span class="math display">\[Q(s, a)=\max _{(a_t, \ldots, a_{t+T})} \sum_{\tau=t}^T \rho(s_\tau,a_\tau )  \quad  {  s.t. } \quad s_t=s, a_t=a, \forall \tau,s_{\tau+1}=f(s_\tau, a_\tau)\]</span></p><p>定义价值函数的计算方式，根据每个时刻汇总得到的奖励值进行求和得到的总的价值</p></li><li><p>参数 <span class="math inline">\(T\)</span>表示的是“规划时间范围” 控制计算时间和评估质量之间的自然权衡，如果 <spanclass="math inline">\(T\)</span>越大那么说明当前的动作评估效果越好</p></li></ol></li><li><p>计算价值函数挑战：</p><ol type="1"><li>如果将动作空间进行离散，那么需要较大的计算空间，依赖于巨大的计算能力</li><li>采用离线计算，离散化动作域和状态域，然后采用离线的计算方式评估每个<span class="math inline">\(（s,a）\)</span> 的价值</li><li>采用动态规划，计算每个 <spanclass="math inline">\(（s,a）\)</span>的价值函数值 <spanclass="math inline">\(Q（s,a）\)</span> 仍然面临计算空间较大的问题</li><li>利用有限类函数来近似价值函数，但是无法做出良好的近似，同时对于这样的神经网络比较难以学习</li><li>当更新时间较小存在一定的信噪比，导致学习速度及其缓慢，逼近类方法固有的问题</li><li>总结：<strong>资源计算量巨大的方法</strong>和<strong>粗糙近似逼近</strong>会带来不同程度的问题</li></ol></li><li><p><strong>Semantics</strong> to the rescue重新定义自动驾驶语义</p><ul><li><p>在语义动作空间上定义价值函数Q：语义空间较小无语大量计算资源，能够对价值函数Q进行准确的估计</p></li><li><p>语义动作空间：</p><ol type="1"><li><p>主要思想：纵向目标；横向目标；实现目标的积极性程度</p><p>横向：Lateral goals are desired positions in lane coordinate system(e.g., “my goal is to be in the center of lane number 2”).</p><p>纵向： Longitudinal goals are of three types. The first is relativeposition and speed w.r.t. other vehicles (e.g., “my goal is to be behindcar number 3, at its same speed, and at a distance of 2 seconds fromit”).</p><p>速度目标：speed target (e.g., “drive at the allowed speed for thisroad times 110%”).</p><p>速度限制：speed constraint at a certain position (e.g., whenapproaching a junction, “speed of 0 at the stop line”, or when passing asharp curve, “speed of at most 60kmh at a certain position on thecurve”).<strong>速度曲线</strong></p></li><li><p>确定横向目标和纵向目标之间的组合，利用运动学公式来实现目标</p></li><li><p>语义动作空间产生了所有可能的几何曲线的子集，除了特殊的情况</p></li></ol></li></ul></li><li><p><strong>Constructing an evaluation function for semanticactions</strong> 构建<strong>语义动作的评估</strong>函数</p><ul><li>定义语义动作 <spanclass="math inline">\(A^s\)</span>空间，通过当前的状态 <spanclass="math inline">\(s\)</span>,选择最好的动作 <spanclass="math inline">\(a^s\in A^s\)</span>, 根据一些列的几何轨迹 <spanclass="math inline">\((s_1,a_1),...,(s_T,a_T)\)</span>，同时认为新的下一时刻的状态有一个新的函数给出<span class="math inline">\(s_{t+1}=f(s_t,a_t)\)</span>同时继续根据奖励函数的值来评估执行的语义动作的好坏程度 <spanclass="math inline">\(\frac{1}{T}\sum_{t=1}^T\rho(s_t,a_t)\)</span></li><li>利用语义动作来评估能规避信噪比低等问题</li><li>利用机器学习来泛化，在不同类型的道路上进行训练，推广到不同的道路</li><li>语义动作空间：<strong>资源高效利用同时很准确地进行评估</strong></li></ul></li><li><p><strong>The dynamics of the other agents其他智能体的动态</strong></p><ul><li><span class="math inline">\(s_{t+1}=f(s_t,a_t)\)</span>这样的确定性函数与现实不符合，多个智能体之间会相互影响</li><li>通过高频次地重新应用决策，不断调整策略来适应新的环境</li></ul></li></ul><h4 id="sensing-传感"><strong>Sensing 传感</strong></h4><h5 id="传感研究的内容">传感研究的内容：</h5><p>静态对象：(a fence that occludes relevant part of a mergingroad).；</p><p>动态对象：车辆（边界框、速度、加速度）、行人（边界框、速度、加速度）、交通灯、动态道路分隔线（例如建筑区域的锥体）、临时交通标志和警察活动以及道路上的其他障碍物。</p><h5 id="sensing-system"><strong>Sensing system</strong></h5><ol type="1"><li>Let <span class="math inline">\(S\)</span> denote the domain ofsensing state and let X be the domain of raw sensor and mapping data. A传感系统表示的是一个函数 <span class="math inline">\(\hat{s}\)</span> :<span class="math inline">\(X → S.\)</span></li><li>什么时候传感器的值 <span class="math inline">\(\hat{s}\)</span>能够和状态 <span class="math inline">\(s\)</span>近似？<strong>通过近似之后对驾驶策略的总体表现：安全性和舒适性</strong></li><li>传感器系统可能会犯的<strong>错误类型</strong>：<ul><li>False negative: the sensing system misses an object误报：传感器错过了一个物体</li><li>False positive: the sensing system indicates a “ghost” object错误：传感器系统提示存在幽灵物体</li><li>Inaccurate measurements: the sensing system correctly detects anobject but incorrectly estimates its position or speed测量不准确：传感系统正确检测到物体但是错误估计位置和速度</li><li>Inaccurate semantic: the sensing system correctly detects an objectbut misinterpret its semantic meaning, for example, the color of atraffic light语义信息不准确：传感系统正确检测物体，但误解了语义信息，比如交通灯的颜色</li></ul></li></ol><h5 id="comfort"><strong>Comfort</strong></h5><ul><li>相当于利用传感器函数来近似估计 <spanclass="math inline">\(s\)</span> ,如果 <spanclass="math inline">\(\pi(\hat{s}(x))=\pi(s)\)</span> 也就是说<spanclass="math inline">\(\pi(\hat{s}(x))=argmaxQ(\hat{s}(x),a)\)</span>，那么就说明当前这个传感器是可以的，同时允许有一定的误差范围：<span class="math inline">\(Q(\hat{s}(x),a)\geQ(s,\pi(s))-\epsilon\)</span>，这个时候可以说是 <spanclass="math inline">\(\epsilon-\)</span>准确的，同时也允许传感器有小概率发生故障 <spanclass="math inline">\(\delta\)</span></li><li>For example, we can choose three thresholds, $$1 &lt; $<spanclass="math inline">\(2 &lt;\)</span>$3 to represent mild, medium, andgross mistakes，表示传感器的错误程度，轻中重</li></ul><h5 id="pac-sensing-system"><strong>PAC sensing system</strong></h5><ol type="1"><li><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915174341417.png"alt="Definition 28" /><figcaption aria-hidden="true">Definition 28</figcaption></figure><p><strong>Probably-Approximately-Correct (PAC)</strong>X表示的是原始的数据与映射的数据域，从期望的角度给出误差率的平均值：<span class="math display">\[\mathbb{P}_{(x, s) \sim D}\left[Q(s, \pi(\hat{s}(x))) \geq Q(s,\pi(s))-\epsilon_i\right] \geq 1-\delta_i\]</span></p></li><li><p>通过记录许多人类驾驶员的数据来构建此分布，而不是遵循自动驾驶车辆的特定策略（不切实际），由于任何合理策略对D的影响都很小，通过应用简单的数据增强技术，我们可以构建适当的分布，然后在传感系统的每次重大更新后执行离线验证。</p></li><li><p>重点关注经常发生的“测量不准确”类型的错误</p></li><li><p>let <span class="math inline">\(p(o)\)</span>，<spanclass="math inline">\(\hat{p}(o)\)</span> be the positions of o in thecoordinate system of the host vehicle according to <spanclass="math inline">\(s(x)\)</span>, <spanclass="math inline">\(\hat{s}(x)\)</span>respectively.分别表示某个对象的<strong>真实的位置信息</strong>和<strong>传感器的位置信息</strong>。</p><p>目标到主车辆的距离为：<span class="math inline">\(\|p\|\)</span>，加性误差：<spanclass="math inline">\(\|p(o)-\hat{p}(o)\|\)</span>，相对误差为 <spanclass="math inline">\(\frac{\|p(o)-\hat{p}(o)\|}{\|p(o)\|}\)</span></p></li><li><p>对于positions a set of objects <spanclass="math inline">\(O\)</span>表示的是一堆对象，要求 <spanclass="math inline">\(p(o)\)</span> 和 <spanclass="math inline">\(\hat{p}(o)\)</span>之间的相对误差小于一个精确度不妨计作$$ ,但是<span class="math inline">\(\epsilon-ego-accurate\)</span>的传感状态不能保证PAC传感系统能够满足每个合理的价值函数：当相对误差很小的时候，尽管认为合理了，但是对于实际的情况而言会出现不同的价值函数结果。选择制动or继续前进，<strong>横向不能用相对距离</strong></p></li><li><p>表明<span class="math inline">\(\epsilon-ego-accurate\)</span>并不能保证我们的传感系统是PAC。是否还有其他属性足以满足 PAC传感系统的要求</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915174411587-20231022115924657.png"alt="Definition 29" /><figcaption aria-hidden="true">Definition 29</figcaption></figure></li><li><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915174449633.png"alt="Definition 31" /><figcaption aria-hidden="true">Definition 31</figcaption></figure><p>给出价值函数合理的L-语义-<spanclass="math inline">\(Lipschitz\)</span>条件</p></li><li><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915174520766.png"alt="Lemma 7" /><figcaption aria-hidden="true">Lemma 7</figcaption></figure><p>判定为PAC传感系统的终极判定</p></li></ol><h5 id="safety"><strong>Safety</strong></h5><ul><li><p>目标是减少事故发生的概率，存在两类安全情况：</p><ol type="1"><li>传感系统认为危险情况是不危险的；</li><li>传感器系统认为不危险情况是危险的：当安全的时候突然出现紧急刹车会导致危险</li></ol></li><li><p>解决的是如何确保和验证safety-critic sensingmistake足够小，采用的方法是融合多个工程和技术都独立的子系统。多数子系统认为安全才算安全：</p></li><li><p><strong>单侧c-近似独立</strong>的多个子系统</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915174623604-20231022115925281.png"alt="Definition 32" /><figcaption aria-hidden="true">Definition 32</figcaption></figure></li><li><p>对于服从单侧-c近似独立的子系统，能够推出：</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915174653068.png"alt="Corollary 3" /><figcaption aria-hidden="true">Corollary 3</figcaption></figure><p>基于多子系统方案和Corollary 3，为了达到10^-9失效率，对sensing系统的验证不再需要10^9小时的数据，而是分别对每个子系统验证10^5小时就可以了</p></li><li><p>独立假设背后的合理性留给我们去推理。有些传感器对会产生完全不相关的误差；单侧-c近似独立是否成立</p></li><li><p>对于安全幽灵而言，当出现至少有两个传感器认为的情况是危险的，才能认为是危险的</p></li><li><p><strong>Building a scalable sensingsystem可扩展的传感器系统</strong></p><ol type="1"><li>Cameras</li><li>Road Experience Management (REM)，不使用点云，而是一种基于语义的方法approach，利用大量的车端detects semantically meaningful objects in thescene (lane marks, curbs, poles, traffic lights,etc.)，并可以对云端进行更新。以可扩展的方式非常频繁地更新地图。此外，自动驾驶车辆可以通过现有的通信平台（蜂窝网络）接收小型地图数据</li><li>A complementary radar and lidarsystem，能够产生极高的精度；直接测量速度和距离，这进一步提高了乘坐的舒适度</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>智能安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
