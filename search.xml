<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【多智能体强化学习】基于自动分组的价值函数分解</title>
    <url>/2023/11/22/MARL_%E8%87%AA%E5%8A%A8%E5%88%86%E7%BB%84/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>
<h2 id="automatic-grouping-for-marl">Automatic Grouping for MARL</h2>
<p>论文标题：</p>
<p><strong>《Vast: Value function factorization with variable agent
sub-teams》</strong></p>
<p><strong>《Automatic Grouping for Efficient Cooperative Multi-Agent
Reinforcement Learning》</strong></p>
<p>论文代码：<a
href="https://github.com/zyfsjycc/GoMARL">https://github.com/zyfsjycc/GoMARL</a></p>
<h2 id="价值函数分解">价值函数分解</h2>
<p>价值函数的提出是为了缓解在传统的中心化训练和去中心化执行中的Critic网络出现的难以训练的问题，同时传统的合作型多智能体强化学习的方法难以解决信用分配的问题，即如何确定某个智能体<strong>对于全局任务而言的贡献程度</strong>。</p>
<h4 id="主体研究框架">主体研究框架：</h4>
<p><span class="math display">\[
Q_{tot} (τ,a)≈Ψ([Q_i (τ_i,a_i)]_{i=1}^N)
\]</span></p>
<p>目的就是学习到这样一个分解算子 <span
class="math inline">\(Ψ\)</span>，能够将局部的价值函数 <span
class="math inline">\(Q_i\)</span> 拟合成全局的价值函数 <span
class="math inline">\(Q_{tot}\)</span>，而这样的拟合过程学习到的分解算子<span
class="math inline">\(Ψ\)</span>应当满足以下的约束条件： <span
class="math display">\[
\underset{\boldsymbol{a}}{\arg \max } Q_{\text {tot
}}(\boldsymbol{\tau}, \boldsymbol{a})=\left(\begin{array}{c}
\operatorname{argmax}_{a_1} Q_1\left(\tau_1, a_1\right) \\
\vdots \\
\operatorname{argmax}_{a_N} Q_N\left(\tau_N, a_N\right)
\end{array}\right)
\]</span>
这个公式的本质是希望分解之后的局部和全局的最优动作能够最优一致，才能保证这样的算子分解方法是有效果的。</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122215614627.png"
alt="价值函数分解的基本思想" />
<figcaption aria-hidden="true">价值函数分解的基本思想</figcaption>
</figure>
<h2 id="可变子团队的价值函数分解">可变子团队的价值函数分解</h2>
<h4 id="研究动机">研究动机：</h4>
<ol type="1">
<li><strong>大部分</strong>价值函数方法对<strong>少量智能体</strong>的任务效果好</li>
<li><strong>VFF</strong>方法过于扁平，存在性能瓶颈，没有考虑群组之间的一个关系，比较朴素且直接</li>
<li>忽略智能体之间关系导致智能体训练信息不足</li>
</ol>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122202659835.png" alt="朴素的价值函数分解方法" style="zoom:60%;" /><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122202712624.png" alt="自动分组之后的价值函数分解方法" style="zoom:60%;" /></p>
<p>因此，为了能够缓解朴素的价值函数分解方法中的<strong>缺乏群组信息的缺陷</strong>，文中提出能够分组处理多智能体系统的工作VAST，能够动态处理群组划分的算子来给出基于分组的智能体价值函数方法。</p>
<h4 id="主要贡献">主要贡献：</h4>
<ol type="1">
<li>基于 <span class="math inline">\(K ≤ N = |D|\)</span>
的分解子团队值<span
class="math inline">\(Q_{t,k}^G\)</span>，线性分解每个子团队成员$jG_{t,k}⊆D
$ 局部值<span class="math inline">\(Q_j\)</span></li>
<li>提出了一种分解方式动态并随时间变化，同时保持VFF方法的去中心性执行的特点</li>
<li>提供了<strong>元梯度</strong>方法来优化子团队分组策略</li>
</ol>
<h4 id="实现方法">实现方法：</h4>
<h5 id="子团队分组策略">子团队分组策略：</h5>
<p>分组策略的本质是学习一个<strong>概率分布</strong><span
class="math inline">\(\mathcal{X}(k∣i,τ_(t,i),s_t
)\)</span>，概率分布的本质思想是能够通过每个智能体的状态以及历史数据信息给出智能体
<span class="math inline">\(i\)</span> 所在的组别 <span
class="math inline">\(k\)</span></p>
<h5 id="元梯度的更新方式">元梯度的更新方式：</h5>
<p><span class="math display">\[
𝑔=𝐴 ̂(𝑘,𝑖,𝜏_{𝑡,𝑖},𝑠_𝑡 ) ∇_𝜃 log⁡𝒳_{MetaGrad}  (𝑘∣𝑖,𝜏_{𝑡,𝑖},𝑠_𝑡 )
\]</span></p>
<ul>
<li>参考借鉴了强化学习的策略梯度更新的方式</li>
<li>在多智能体强化学习中利用<strong>强化学习</strong>的方法学习一个组别的分组器</li>
</ul>
<p><span class="math display">\[
𝐴 ̂(𝑘,𝑖,𝜏_{𝑡,𝑖},𝑠_𝑡 )=𝑄 ̂(𝑘,𝑖,𝜏_{𝑡,𝑖},𝑠_𝑡 )−𝑉 ̂(𝑖,𝜏_{𝑡,𝑖},𝑠_𝑡 )
\]</span></p>
<p><span class="math display">\[
𝑉 ̂(𝑖,𝜏_{𝑡,𝑖},𝑠_𝑡 )=∑_(𝑎_{𝑡,𝑖}∈𝒜_𝑖) 𝜋_𝑖 (𝑎_{𝑡,𝑖}∣𝜏_{𝑡,𝑖} ) 𝑄_𝑖
(𝜏_{𝑡,𝑖},𝑎_{𝑡,𝑖} )
\]</span></p>
<ul>
<li>策略梯度更新的方式是基于优势函数的方法进行更新分组器</li>
</ul>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122220849824.png"
alt="不同分类器的对比" />
<figcaption aria-hidden="true">不同分类器的对比</figcaption>
</figure>
<p>这里还采用了不同的分组器方法加入实验的对比</p>
<h5 id="算法思路">算法思路</h5>
<ul>
<li><p>将D 分成<span class="math inline">\(K= ⌈ηN⌉≤ N =
|D|\)</span>个子团队<span class="math inline">\(G_{t,k}\)</span>
其中比例<span class="math inline">\(η ∈ [
1⁄N,1]\)</span>，所有的团队集合 <span
class="math inline">\(G_t=⟨G_{t,1},…,G_{t,K} ⟩\)</span>，</p></li>
<li><p>分组：<span class="math inline">\(G_{t,k}⊆D,G_{t,k}∩G_{t,k′}=∅
;D=U_{k=1}^K  G_{t,k}\)</span></p></li>
<li><p>组内联合动作：<span class="math inline">\(a_{t,k}^G=a{t,j}
_j∈G_{t,k}\)</span></p></li>
<li><p>选择<span
class="math inline">\(Ψ_{VDN}\)</span>算子分解(满足IGM)：</p>
<p><span class="math display">\[
Q_{t,k}^G (τ_{t,k}^G,a_{t,k}^G )=Ψ_{VDN} (⋅)=∑_{j∈G_{t,k}} Q_j
(τ_{t,j},a_{t,j})
\]</span></p></li>
<li><p>最终的全局联合价值函数近似：</p></li>
</ul>
<p><span class="math display">\[
Q_{tot} (τ_t,a_t )=Ψ(Q_{t,1}^G (τ_{t,1}^G,a_{t,1}^G ),…,Q_{t,K}^G
(τ_{t,K}^G,a_{t,K}^G ))
\]</span>
<img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122221728761.png" alt="可变子团队的伪代码" style="zoom:67%;" /></p>
<h5 id="igm条件保持">IGM条件保持</h5>
<p>如果以群组为单位的价值函数分解的方式能够保证IGM条件： <span
class="math display">\[
argmax_(𝑎_{𝑡,𝑘}^𝐺∈𝒜)⁡〖𝑄_{tot}(𝜏_𝑡,𝑎_𝑡)〗=
⟨argmax_(⟨𝐚_{𝐭,𝐤}^𝐆 ⟩_(𝐺_{𝑡,𝑘}∈𝒢_𝑡 ))⁡𝑄_{𝑡,𝑘}^𝐺 (𝜏_{𝑡,𝑘}^𝐺,𝑎_{𝑡,𝑘}^𝐺
)⟩_(𝐺_{𝑡,𝑘}∈𝒢_𝑡)
\]</span> 希望能够满足对于局部智能体到全局价值函数的IGM条件的保持 <span
class="math display">\[
argmax_(𝑎_𝑡∈𝒜)⁡𝑄_{tot}(𝜏_𝑡,𝑎_𝑡 )=
⟨argmax_(𝑎_{𝑡,𝑖}∈𝒜_𝑖 )⁡𝑄_𝑖 (𝜏_{𝑡,𝑖},𝑎_{𝑡,𝑖})⟩_(𝑖∈𝒟)
\]</span> 推导过程如下： <span class="math display">\[
\begin{aligned}
&amp; Q_{t, k}^G\left(\tau_{t, k}^G, a_{t, k}^G\right)=\sum_{j \in G_{t,
k}} Q_j\left(\tau_{t, j}, a_{t, j}\right) ; \operatorname{argmax}_{a_t
\in G_{t, k}} Q_{t, k}^G\left(\tau_{t, k}^G, a_{t,
k}^G\right)=\left\langle\operatorname{argmax}_{a_{t, i} \in
\mathcal{A}_i} Q_i\left(\tau_{t, i}, a_{t, i}\right)\right\rangle_{i \in
G_{t, k}} \\
&amp; a_t \stackrel{\Psi}{=}\left\langle a_{t, k}^G\right\rangle_{G_{t,
k} \in \mathcal{G}_t} \stackrel{\Psi_{V D
N}}{=}\left\langle\left\langle\bar{a}_{t, i}\right\rangle_{i \in G_{t,
k}}\right\rangle_{G_{t, k} \in \mathcal{G}_t}
\stackrel{\mathcal{D}=G_{t, 1} \cup \cdots \cup G_{t,
K}}{=}\left\langle\bar{a}_{t, i}\right\rangle_{i \in \mathcal{D}}
\end{aligned}
\]</span></p>
<h2 id="自适应分组的marl">自适应分组的MARL</h2>
<h4 id="研究动机-1">研究动机</h4>
<ul>
<li>通过任务分配实现隐式分组的方法仅解决结构清晰的任务，并且需要领域知识或先验设置</li>
<li>VAST 研究子团队对价值分解的影响，但需要先验的组数，ROMA
的学习依赖于智能体观察的动态角色</li>
</ul>
<h4 id="gomarl算法的优势">GoMARL算法的优势</h4>
<ul>
<li>算法不依赖先验领域知识</li>
<li>动态调整：在分组学习过程中根据智能体的表现<strong>逐步调整</strong>分组划分。利用<strong>群体信息</strong>来促进策略专业化和高效的团队合作</li>
</ul>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122222736852.png" alt="引入群组划分板块的分解方法" style="zoom:67%;" /></p>
<h4 id="个体与群组关系假设">个体与群组关系假设</h4>
<ul>
<li><strong>所有智能体集合：</strong><span
class="math inline">\(A={a_1,…,a_n }\)</span></li>
<li><strong>分组集合</strong>: <span class="math inline">\(G={g_1,…,g_m
}，1≤m≤n\)</span></li>
<li>每个<span
class="math inline">\(g_i\)</span><strong>包含</strong><span
class="math inline">\(n_j
(1≤n_j≤n)\)</span><strong>个不同的智能体，有</strong><span
class="math inline">\(g_i={a_(j_1 ),…,a_(j_(n_j )
)}\)</span>，<strong>且有</strong><span
class="math inline">\(g_j∩g_k=∅\)</span>，<strong>且有</strong><span
class="math inline">\(⋃_jg_j =A，j,k∈{1,2,…,m}\)</span></li>
</ul>
<h4 id="自动分组实现方法">自动分组实现方法</h4>
<p>自动分组的基本逻辑是学习<span
class="math inline">\(f_g:A↦G\)</span>，这样的算子的目标是能够学习到系数权重
<span class="math display">\[
Q_G^{tot} (s_t,u_t )=E_(s_{t+1:∞},u_{t+1:∞} ) [∑_(k=0)^∞ γ^k
r_{t+k}∣s_t,u_t;G]
\]</span> 让总体的联合动作价值函数的值最大，分组的价值函数为： <span
class="math display">\[
𝑄^{𝑔_𝑗}=𝑓(𝑄^{𝑗_1} (𝜏^{𝑗_1},𝑢^{𝑗_1}),⋯,𝑄^{𝑗_{𝑛_𝑗}} (𝜏^{𝑗_(𝑛_𝑗
)},𝑢^{𝑗_{𝑛_𝑗}};𝑤_1^{𝑔_𝑗})
\]</span> 学习到的贡献程度为：<span
class="math inline">\(𝑤_1^{𝑔_𝑗}\)</span>，训练的目标函数为： <span
class="math display">\[
ℒ_𝑔 (𝜃_{w_1})=𝔼_((𝐳,𝐮,𝑟,𝐳′)∼ℬ∑_𝑖(∥𝑓_(w_1)^𝑖 (𝜏^𝑖 (𝑧^𝑖,𝑢^𝑖 );𝜃_(w_1)^𝑖
)∥_{𝑙_1})
\]</span>
根据每次在分组中的贡献权重来依次调整智能体的分组，当贡献的权重过小的话，就认为智能体不属于分组中，进入下一轮的分组调整中。</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122223325635.png"
alt="自动分组的逻辑图" />
<figcaption aria-hidden="true">自动分组的逻辑图</figcaption>
</figure>
<h4 id="section"></h4>
<h4 id="agent-network的优化">Agent Network的优化</h4>
<ul>
<li><p>智能体内嵌信息网络获取的群组相关信息<span
class="math inline">\(e_i\)</span></p></li>
<li><p><strong>Similarity-Diversity
objective</strong>：来自同一组的智能体的信息是相似的，来自不同群体的智能体信息之间保持多样性：
<span class="math display">\[
\begin{gathered}
\mathcal{L}_{S
D}\left(\theta_e\right)=\mathbb{E}_{\mathcal{B}}\left(\sum_{i \neq j}
I(i, j) \cdot \operatorname{cosine}\left(f_e\left(h^i ; \theta_e\right),
f_e\left(h^j ; \theta_e\right)\right)\right) \\
\text { where } I(i, j)=\left\{\begin{array}{cc}
-1, &amp; a^i, a^j \in g^k \\
1, &amp; a^i \in g^k, a^j \in g^l, k \neq l
\end{array}\right.
\end{gathered}
\]</span>
很直观的理解，对于合作型的强化学习任务而言，我们希望能够在同一个任务域内强化策略的合作，而不同的任务域内的策略应当保持多样性，能够让多智能体系统探索更多的可能性，防止陷入局部最优的情况。</p></li>
<li><p><strong>Agent Network特点</strong>：</p>
<ul>
<li>多样化的策略，部分共享参数的策略去中心化</li>
<li>超网络<span
class="math inline">\(f_d\)</span>将提取的智能体信息e集成到策略梯度中</li>
</ul></li>
<li><p>合理性表示： <span class="math display">\[
𝜕𝑄^{𝑡𝑜𝑡}/(𝜕𝜃_ℎ )=(𝜕𝑄^{𝑡𝑜𝑡})/(𝜕𝑄^𝑎 )  (𝜕𝑄^𝑎)/(𝜕𝜃_ℎ )=(𝜕𝑄^{𝑡𝑜𝑡})/(𝜕𝑄^𝑎
)  (𝜕𝑄^𝑎)/(𝜕𝑣_ℎ^𝑎 )  (𝜕𝑣_ℎ^𝑎)/(𝜕𝜃_ℎ )=𝑓_𝑑 (𝑒^𝑎 )⋅(𝜕𝑄^{𝑡𝑜𝑡})/(𝜕𝑄^𝑎
)  (𝜕𝑣_ℎ^𝑎)/(𝜕𝜃_ℎ )
\]</span></p></li>
</ul>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122225119182.png" alt="Agent Network优化方式" style="zoom:67%;" /></p>
<h4 id="整体的训练框架">整体的训练框架</h4>
<h6 id="双层混合网络">双层混合网络</h6>
<ul>
<li><p>群体状态下的群体行动价值信息，将全局的状态分解成局部的状态信息用于训练，这部分的局部状态信息是基于群组划分之后的状态信息</p></li>
<li><p><span class="math inline">\(s^{g_j}\)</span> 是分组后<span
class="math inline">\(e_t^i (a_i∈g_j
)\)</span>按组别融合，建立分组器映射</p>
<p><span class="math display">\[
f_{w_2}(s^g )：s^g→w_2^g
\]</span></p></li>
<li><p>集中到策略梯度中，内嵌群组状态信息潜在促进组内合作： <span
class="math display">\[
𝜕𝑄^{𝑡𝑜𝑡}/(𝜕𝜃_ℎ )=(𝜕𝑄^{𝑡𝑜𝑡})/(𝜕𝑄^𝑎 )  (𝜕𝑄^𝑎)/(𝜕𝜃_ℎ )=(𝜕𝑄^{𝑡𝑜𝑡})/(𝜕𝑄^𝑎
)  (𝜕𝑄^𝑎)/(𝜕𝑣_ℎ^𝑎 )  (𝜕𝑣_ℎ^𝑎)/(𝜕𝜃_ℎ )=𝑓_𝑑 (𝑒^𝑎 )⋅(𝜕𝑄^{𝑡𝑜𝑡})/(𝜕𝑄^𝑎
)  (𝜕𝑣_ℎ^𝑎)/(𝜕𝜃_ℎ )
\]</span></p></li>
<li><p>按照全文的总共方法的总述可以得到全局分解目标： <span
class="math display">\[
ℒ(𝜃)=ℒ_𝑇𝐷 (𝜃)+𝜆_𝑔 ℒ_𝑔 (𝜃_(w_1 ) )+𝜆_𝑆𝐷 ℒ_𝑆𝐷 (𝜃_𝑒 )
\]</span></p></li>
</ul>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122225354328.png"
alt="总体训练框架" />
<figcaption aria-hidden="true">总体训练框架</figcaption>
</figure>
<h4 id="实验结果">实验结果</h4>
<p>在星际争霸的环境中的训练结果</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122225759954.png"
alt="SMAC训练结果" />
<figcaption aria-hidden="true">SMAC训练结果</figcaption>
</figure>
<p>消融实验</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122225941711.png"
alt="消融实验对比" />
<figcaption aria-hidden="true">消融实验对比</figcaption>
</figure>
<p>谷歌足球的训练结果</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122225826734.png"
alt="GRF的训练结果与可视化" />
<figcaption aria-hidden="true">GRF的训练结果与可视化</figcaption>
</figure>
]]></content>
      <categories>
        <category>强化学习</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>深度学习</tag>
        <tag>强化学习</tag>
      </tags>
  </entry>
  <entry>
    <title>【自动驾驶】RSS Model for Autonomous Driving</title>
    <url>/2023/10/21/RSS-Model/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>
<h2 id="rss-model-for-autonomous-driving"><strong>RSS Model for
Autonomous Driving</strong></h2>
<h4
id="论文on-a-formal-model-of-safe-and-scalable-self-driving-cars">论文：《On
a Formal Model of Safe and Scalable Self-driving Cars》</h4>
<h4 id="contribution"><strong>Contribution：</strong></h4>
<ul>
<li>Safety (RSS model) Reasonable care, Responsibility, agile driving
policy</li>
<li>Semantic (Semantic language) :Defined Q function over the Semantic
space</li>
<li>PAC sensing model：Safety and Comfort of driving ；tied to the Q
function;</li>
</ul>
<h4 id="safety-concept"><strong>1. Safety Concept</strong></h4>
<p>Functional versus nominal safety 功能安全与名义安全</p>
<p>Functional Safety，FuSa 是指电子电路中操作的完整性</p>
<p>名义安全是在假设HW和SW系统运行无差错(即在功能上是安全的)的情况下，AV是否正在做出安全的逻辑决策。</p>
<p>Sense，Plan，Act 感知 计划 行动</p>
<h4 id="现有的自动驾驶汽车的决策方案"><strong>2.
现有的自动驾驶汽车的决策方案</strong></h4>
<ul>
<li>Miles driven ：基于统计的论点，同时需要较大的统计量数据</li>
<li>disengagements（脱离）：被定义为人类安全驾驶人因为做出不安全的决定而不得不干预AV的运行，从而导致事故的情况。</li>
<li>simulation：建立虚拟世界模拟器，模拟器和显示世界的差距，无法建模全部的策略</li>
<li>scenario based testing
：枚举现实世界的驾驶场景，过度拟合和泛化的问题</li>
<li>proprietary approaches</li>
</ul>
<h4
id="rssresponsibility-sensitive-safety-model-for-multi-agent-safety"><strong>3.
RSS(Responsibility-Sensitive-Safety) Model for Multi-agent
Safety</strong></h4>
<ul>
<li><p>目标：</p>
<ul>
<li>做不到绝对安全，需要有Reasonable的响应</li>
<li>遵循RSS能做到乌托邦Utopia</li>
<li>敏捷而非防御，不应当过于谨慎而影响其他驾驶</li>
<li>法律解释的意义</li>
</ul></li>
<li><p>形式化的规则：</p>
<ol type="1">
<li>Do not hit someone from behind.</li>
<li>Do not cut-in recklessly.</li>
<li><strong>Right-of-way is given, not taken.</strong>
道路通行权是给予的而不是占用的</li>
<li>Be careful of areas with limited visibility
小心有限可视化的范围</li>
<li>If you can avoid an accident without causing another one, you must
do it.</li>
</ol></li>
</ul>
<h5 id="single-land-road-单向道路的情况"><strong>3.1 Single Land Road
单向道路的情况</strong></h5>
<ul>
<li><p>不考虑前车倒退的情况，后车撞上前车那么后车负责，后车有责任和前车保持距离</p></li>
<li><p><span class="math inline">\(c_r\)</span>表示前车，<span
class="math inline">\(c_f\)</span>表示后车，<span
class="math inline">\(\rho\)</span>表示的是前车的反应时间，<span
class="math inline">\(a_{max,break}\)</span>表示的是前车的最大加速度，<span
class="math inline">\(a_{max,accel}\)</span>表示的是最多的加速制动，<span
class="math inline">\(a_{min,break}\)</span>表示的是后车的最小制动加速度来保证不会撞到前车</p></li>
<li><p><strong>同方向行驶</strong>的安全距离</p>
<p>给出最小的安全纵向距离： <span class="math display">\[
d_{min}=max\{v_r\rho+1/2a_{max,accel}\rho^2+((v_r+\rho
a_{max,accel})^2)/2a_{min,break}-v_f^2/2a_{max,break},0\}
\]</span></p></li>
<li><figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915172320331.png"
alt="Definition 1" />
<figcaption aria-hidden="true">Definition 1</figcaption>
</figure></li>
<li><p><span class="math inline">\(t_b\)</span> dangerous time；<span
class="math inline">\([t_b,t_b+\rho]\)</span> 表示一定的反应时间
在这个范围之内在给定的加速度范围之内 执行proper response</p></li>
<li><p>Proper Response
：表示我们允许执行的最大加速度的限制，并取最小值约束保证满足所有的约束</p></li>
<li><p>安全纵向距离和Proper Response取决于参数：<span
class="math inline">\(\rho,a_{max,sccel},a_{min,brake},a_{max,brake}\)</span>
参数保证了对智能体行为的假设，选择适当的参数</p></li>
<li><p>Utopia is possible
如果所有智能体车辆都能够遵循合理的响应，那么能归纳证明可以规避事故的发生</p></li>
</ul>
<h5 id="a-lane-based-coordinate-system-基于车道的坐标系"><strong>3.2 A
Lane-Based Coordinate System 基于车道的坐标系</strong></h5>
<ul>
<li><p>车道中心是平面上一条平滑有向的曲线 <span
class="math inline">\(r\)</span> ,其中所有部分可以表示为 <span
class="math inline">\(r^{(1)},...,r^{(k)}\)</span>
即可以是线性的，也可以是弧形的</p></li>
<li><p>构造 <span class="math inline">\(R-&gt;R^2\)</span>的变换为 <span
class="math inline">\(\phi\)</span>
就是横纵坐标，从而来保证在逻辑上的前后车辆的关系</p></li>
<li><p>具体的映射的方式可以表示为如下：</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915172406204.png"
alt="道路映射的方式" />
<figcaption aria-hidden="true">道路映射的方式</figcaption>
</figure></li>
<li><p>横纵速度/加速度
的计算就可以通过这样的坐标系定义之下得到的一阶/二阶的导数计算得到</p></li>
</ul>
<h5
id="longitudinal-safe-distance-and-proper-response-纵向约束"><strong>3.3
Longitudinal Safe Distance and Proper Response 纵向约束</strong></h5>
<ul>
<li><p>给出安全距离的定义：</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915172437378.png"
alt="Definition 2" />
<figcaption aria-hidden="true">Definition 2</figcaption>
</figure>
<p>安全距离定义的想法是，如果两辆车都能对违反安全距离的行为做出“适当”反应，那么就不会发生碰撞。如果其中一个没有“正确”反应，那么它就应对事故负责。</p></li>
<li><p>那么我们需要知道危险发生的时间，定义这样一个时刻<strong>Dangerous
Longitudinal Situation and Danger Threshold</strong></p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915172501683-20231022115917321.png"
alt="真正的危险时间" />
<figcaption aria-hidden="true">真正的危险时间</figcaption>
</figure>
<p>给定一个纵向的危险发生的时间段</p></li>
<li><p><strong>longitudinal proper response 纵向的适当响应</strong></p>
<p>blame time
责任时间表示的是这个时间能够将驾驶的责任从自动驾驶汽车转移到驾驶员身上，如果接管了那么后续的责任将由驾驶员负责，否则由汽车负责</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915172514045-20231022115917843.png"
alt="Definition 4" />
<figcaption aria-hidden="true">Definition 4</figcaption>
</figure>
<p>给出了对于纵向单向行驶而言的速度和加速的要求，需要在危险到来之前做出合理的响应</p></li>
</ul>
<h5
id="lateral-safe-distance-and-proper-response-横向的约束"><strong>3.4
Lateral Safe Distance and Proper Response 横向的约束</strong></h5>
<ul>
<li><p>稳健侧向速度 <span
class="math inline">\(\mu\)</span>：汽车总是存在横向的一个微小摆动:
<span class="math display">\[
\mu-lateral-v=(l_{out}-l)/(t_{out}-t)
\]</span></p></li>
<li><p>横向安全距离：</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915172633796.png"
alt="Definition 6" />
<figcaption aria-hidden="true">Definition 6</figcaption>
</figure>
<p>对于双方而言都有一个加速度，同时有一个最小的制动加速度</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915172648760.png"
alt="Lemma 4" />
<figcaption aria-hidden="true">Lemma 4</figcaption>
</figure></li>
<li><p>同样定义横向的危险时间和危险区间时间：</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173056976-20231022115918644.png"
alt="Definition 7" />
<figcaption aria-hidden="true">Definition 7</figcaption>
</figure></li>
<li><p><strong>Lateral Proper response 给出横向的适当反应</strong></p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173119252.png"
alt="Definition 8" />
<figcaption aria-hidden="true">Definition 8</figcaption>
</figure>
<p>首先如果在适当的响应时间范围之内，那么只需要限制两车的加速度在一定的范围之内</p>
<p>如果超出了适当响应时间，那么对于两车的加速度限制需要更改</p></li>
</ul>
<h5
id="combining-longitudinal-and-lateral-proper-responses-横向和纵向相结合"><strong>3.5
Combining Longitudinal and Lateral Proper Responses
横向和纵向相结合</strong></h5>
<ul>
<li><p>对于横向和纵向结合的车道，定义危险时间和危险情况</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173150615.png"
alt="Defintion 9" />
<figcaption aria-hidden="true">Defintion 9</figcaption>
</figure></li>
<li><p>危险阈值时间定义为横向和纵向的危险阈值时间的最大值，同样定义了危险时间t</p></li>
<li><p><strong>Basic Proper response to dangerous situations
对于危险情况的正确反应处理</strong></p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173218415.png"
alt="Definition 10" />
<figcaption aria-hidden="true">Definition 10</figcaption>
</figure>
<p>对于危险的阈值速度进行分析，如果分别为纵向的阈值速度和横向的阈值速度，那么分别根据前面所述的Definition
4和Definition 8 进行速度的限制</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173251798-20231022115919728.png" alt="横向纵向情况" style="zoom:50%;" /></p>
<p>上面的这张图可以说明问题，当横纵的任意一个方向到达危险的阈值情况，分别作出Proper
Response，那么就可以按照合理的方式来规避风险</p></li>
<li><p><strong>Lemma5 Utopia is possible</strong></p>
<p>Consider a multi-lane road where all lanes share the same geometry.
Suppose that at all times, all cars on the road comply with the basic
proper response as given in Definition 10. Then, there will be
<strong>no collisions</strong></p>
<p>归纳证明说明如果在合适的范围之内作出合理的响应，那么能规避碰撞</p></li>
</ul>
<h5
id="compensating-for-improper-behavior-of-others-他人的不正当行为"><strong>3.6
Compensating for improper behavior of others
他人的不正当行为</strong></h5>
<ul>
<li><p>如果对方没做出合理反应，那么自己应当作出合适反应避免发生事故，同时不引起下一个事故</p></li>
<li><p>Naive Prediction：根据速度和加速度线性外推</p></li>
<li><p>Evasive
Manoeuvre：给出两个函数来尽量规避出现车祸，就是根据时间来给速度和加速度的变化规划</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173348421.png"
alt="Definition 12" />
<figcaption aria-hidden="true">Definition 12</figcaption>
</figure>
<p>相当于给出两个函数来知道汽车应当在某个时间范围内到达什么样的位置是安全的，那么要达到这样的位置汽车要采取什么样的速度和加速度来实现</p>
<p><strong>if you can avoid an accident without causing another
accident, you must do it</strong></p></li>
</ul>
<h5
id="proper-response-with-extra-evasive-effort-制动规避的适当反应"><strong>Proper
Response with Extra Evasive Effort 制动规避的适当反应</strong></h5>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173422047-20231022115920481.png"
alt="Definition 13" />
<figcaption aria-hidden="true">Definition 13</figcaption>
</figure>
<h5
id="multiple-geometry-and-right-of-way-rules处理几何图形区域的车辆优先权问题"><strong>3.7
Multiple Geometry and Right-of-Way
Rules处理几何图形区域的车辆优先权问题</strong></h5>
<ul>
<li><p>如果有存在不同的几何形状的情形会导致响应的冲突</p></li>
<li><p>定义横向的安全距离对于<strong>不同的几何路径</strong>对于相同的几何路径仍然成立</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173615571.png"
alt="Definition14" />
<figcaption aria-hidden="true">Definition14</figcaption>
</figure>
<p>向位置范围为[x_i,min,
x_i,max]，按照不同的加速度行驶，且不能超过指定的加速度制动那么，则c_1和c_2之间的横向安全距离需要满足：<strong>两车之间横向距离的最小值应大于Definition7中定义的横向安全距离</strong></p></li>
<li><p>那么如何作出适当的反应 Proper response，给出合适的速度约束</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173634068-20231022115921111.png"
alt="横向的合适响应" />
<figcaption aria-hidden="true">横向的合适响应</figcaption>
</figure>
<p>在反应时间之内可以按照加速度范围内进行移动，但是当超过反应时间之后就要对侧向的速度进行制动</p></li>
<li><p>定义不同几何路况的纵向的顺序</p>
<ul>
<li><figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173650265-20231022115921291.png"
alt="路况优先权问题" />
<figcaption aria-hidden="true">路况优先权问题</figcaption>
</figure>
<p>如果在同一条路上那么直接有先后顺序</p>
<p>如果不在同一条路上，那么根据车辆距离两条道路的相交的位置来定</p>
<p>当存在纵向的安全距离才会用到这个定义，同时应当是明显的前后顺序</p></li>
</ul></li>
<li><p>纵向的安全距离（不同的几何路径）</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173703808-20231022115921710.png"
alt="Definition 17" />
<figcaption aria-hidden="true">Definition 17</figcaption>
</figure>
<ol type="1">
<li>如果c_i没有路径的优先级，那么将在路口汇入的位置执行加速到减速的过程停在路口</li>
<li>如果c_1在c_2前面，c_1执行任意动作（最大刹车加速度的意思是保证这个动作的距离下限），c_2执行最大加速-最小减速过程。当两车速度都为0时，c_1仍然在c_2前面（即后车要刹得住，当前车停下时，纵向顺序关系依然能保持）</li>
<li>如果没有优先级和前后关系，则考虑两车到达路口的时间范围，如果两者时间范围相交，则有碰撞风险，都需要刹车，反之就正常走。</li>
</ol>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173722252.png"
alt="示意图" />
<figcaption aria-hidden="true">示意图</figcaption>
</figure></li>
<li><p>纵向的安全响应（Proper response）</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173840619.png"
alt="Definition18" />
<figcaption aria-hidden="true">Definition18</figcaption>
</figure>
<ol type="1">
<li>longitudinal proper response取决于Danger Threshold
Time前的situation：</li>
<li>如果17.1满足，则优先车辆正常开，另外一个则需要在反应时间后刹车。</li>
<li>如果17.2满足，则前面车辆正常开，候车需要在反应时间后刹车。</li>
<li>如果17.3满足，两车都需要在横向和纵向上刹车（这里又提到了横向，是纵向已经不能完全规避碰撞风险，所以需要引入横向动作）。</li>
</ol></li>
<li><p>Traffic Lights</p>
<ol type="1">
<li>不能简单通过红绿灯的情况来将责任分配给不同的车辆，对于例外的路口的车辆</li>
<li>绿灯的有优先权 但不是有优先权的就对于规则而言没有责任</li>
<li>The above discussion is a formalism of the common sense rule of
<strong>right of way is given, not taken.</strong></li>
</ol></li>
</ul>
<h5 id="unstructured-road-非结构化的道路"><strong>3.8 Unstructured Road
非结构化的道路</strong></h5>
<ol type="1">
<li><figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173851532-20231022115922491.png"
alt="Definition 19" />
<figcaption aria-hidden="true">Definition 19</figcaption>
</figure>
<p>轨迹这个表示了根据时间而改变的位置状态，ts的定义就表示车辆第一次完全停止的时间</p>
<p><strong>未来某部分时刻汽车的位置、某个时间车辆的角度</strong></p></li>
<li><figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173902698-20231022115922745.png"
alt="Definition20" />
<figcaption aria-hidden="true">Definition20</figcaption>
</figure>
<p>当两车的轨迹不满足以下条件时，则称会发生碰撞：</p>
<p>（1）对于两车均停止之前的任意时刻，两车之间距离均大于epsilon。</p>
<p>（2）在某车停车之前，两车之前距离均大于epsilon，且此时第二辆车的速度矢量指向第一辆车。即当前车停车，后车依然往前车方向开，后车需要与前车保持距离。</p></li>
<li><figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173913570.png"
alt="Definition 21" />
<figcaption aria-hidden="true">Definition 21</figcaption>
</figure>
<p>定义Constrains（C）下的轨迹T(C,
c)，刹车/正常向前行驶的轨迹分别表示为T(Cb, c)和T(Cf,c).</p></li>
<li><figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173936523.png"
alt="Definition 22" />
<figcaption aria-hidden="true">Definition 22</figcaption>
</figure>
<ol type="1">
<li>其中一辆车的刹车轨迹和另一辆车的前进轨迹不相交，那么安全（注意保持先后关系对两辆车都适用）</li>
<li>两辆车都刹车，轨迹没有相交</li>
</ol></li>
<li><p>如果不满足安全的要求，那么应当选择Proper Response：</p>
<ol type="1">
<li>如果两辆车都停着，那么其中一辆车应当远离另一辆车选择用Definition
20的方法远离</li>
<li>否则，如果根据safe
distance(1)的定义是安全的，一辆车执行刹车，另一辆车在停下来之前就要按照Cf的轨迹正常开，都停下来之后就回到了（1）</li>
<li>同时选择刹车</li>
</ol></li>
</ol>
<h5 id="pedestrians-行人"><strong>3.9 Pedestrians 行人</strong></h5>
<ul>
<li><p>安全距离和合理反应；和汽车相比调整参数且增加非结构化的假设</p></li>
<li><p>在斑马线或者是人行道上规定行人的行为，行人的合理活动范围是一个以他为圆心的圆</p></li>
<li><p>遵循互不干扰否则有责任的准则，当汽车进入行人的可能出事的范围那么
汽车有责，否则行人有责任</p></li>
</ul>
<h5 id="cautiousness-with-respect-to-occlusion-遮挡问题"><strong>3.10
Cautiousness with respect to Occlusion 遮挡问题</strong></h5>
<ul>
<li><p>Exposure Time 曝光时间：第一次看到这个物体的时间</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173954765-20231022115923512.png"
alt="Definition23" />
<figcaption aria-hidden="true">Definition23</figcaption>
</figure></li>
<li><p><strong>速度不合理导致的不合理情况</strong>：</p>
<p>相当于速度的范围不在给定的合理的区间。
上述提到的参数和地图上的每个汽车的位置、优先级规则和其他的场景结构等条件相关联</p>
<ol type="1">
<li><p>具有道路优先级的汽车的最大速度优先级较高</p></li>
<li><p>速度的阈值范围根据具体的道路结构</p></li>
</ol>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915174217869.png"
alt="遮挡示意图" />
<figcaption aria-hidden="true">遮挡示意图</figcaption>
</figure></li>
</ul>
<p>相当于对于遮挡问题需要对双方的车辆有速度限制才能保证危险的发生</p>
<h5 id="不当行为造成的不合理的情况"><strong>3.11
不当行为造成的不合理的情况</strong></h5>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915174242726.png"
alt="Definition 25" />
<figcaption aria-hidden="true">Definition 25</figcaption>
</figure>
<p>对于出现遮挡的参与者都要保持合理的行为才能规避事故</p>
<p><strong>对于有遮挡的正确响应方法</strong>：规避不合理的情况，包括但不限于24-25的</p>
<h5 id="responsibility"><strong>3.12 Responsibility</strong></h5>
<ul>
<li>明确智能体责任</li>
<li>发生碰撞那么有可能是其中一个智能体没有遵守适当的响应约束，那么需要对事故负责</li>
</ul>
<h5 id="utopia">3.13 Utopia</h5>
<ul>
<li>Lemma 5证明如果所有汽车都遵循基本的响应规则，那么不会发生碰撞</li>
<li>Lemma
6证明如果对于遮挡的问题都能做出合理的响应规则，那么就不会发生事故（反证法）</li>
</ul>
<h4 id="driving-policy-rl"><strong>4. Driving Policy
（RL）</strong></h4>
<ul>
<li><p>驾驶策略的定义：驾驶策略是从感知状态到驾驶命令的映射</p></li>
<li><p>构建高效的驾驶策略，拓展到百万级别的策略</p></li>
<li><p>描述驾驶策略的语言：(利用强化学习的描述方法)</p>
<ol type="1">
<li><p><span class="math inline">\(s_t\)</span>表示某一时刻的状态，<span
class="math inline">\(\pi\)</span>表示的是策略函数，<span
class="math inline">\(a_t\)</span>表示的是汽车能够选择的动作，根据策略函数来确定，得到一块序列
<span class="math inline">\(&lt;s_t,a_t&gt;\)</span></p></li>
<li><p><span class="math inline">\(P_{\pi}\)</span>表示的是根据 <span
class="math inline">\(\pi\)</span> 选择产生的后面不同序列<span
class="math inline">\(&lt;s_t,a_t&gt;\)</span>的概率</p></li>
<li><p><span class="math inline">\(E_{s~P_\pi}[\rho(s)]\)</span>
用于衡量当前策略的好坏程度，相当于对当下这个策略可能产生的不同奖励值选择期望，同时
<span
class="math inline">\(\rho(s)\)</span>表示的是当前状态下的奖励</p></li>
<li><p>在实际的实现过程中，<span
class="math inline">\(a_t\)</span>表示的是本车与其他道路使用者的位置、速度和加速度等问题，<span
class="math inline">\(s_{t+1}\)</span>表示的是下一时刻的状态，同时取决于当前时刻的动作以及其他智能体的行为，奖励函数<span
class="math inline">\(\rho(s)\)</span>
取决于当前环境中的其他智能体的相对位置速度等信息。</p></li>
<li><p>价值函数 <span
class="math inline">\(Q\)</span>表示的是当前智能体执行某一个动作所能造成的长期回报
,由此来选择最好的策略函数来保证<span class="math inline">\(\pi(s)=argmax
Q(s,a)\)</span></p></li>
<li><p><span class="math display">\[
Q(s, a)=\max _{(a_t, \ldots, a_{t+T})} \sum_{\tau=t}^T \rho(s_\tau,
a_\tau )  \quad  {  s.t. } \quad s_t=s, a_t=a, \forall \tau,
s_{\tau+1}=f(s_\tau, a_\tau)
\]</span></p>
<p>定义价值函数的计算方式，根据每个时刻汇总得到的奖励值进行求和得到的总的价值</p></li>
<li><p>参数 <span class="math inline">\(T\)</span>
表示的是“规划时间范围” 控制计算时间和评估质量之间的自然权衡，如果 <span
class="math inline">\(T\)</span>越大那么说明当前的动作评估效果越好</p></li>
</ol></li>
<li><p>计算价值函数挑战：</p>
<ol type="1">
<li>如果将动作空间进行离散，那么需要较大的计算空间，依赖于巨大的计算能力</li>
<li>采用离线计算，离散化动作域和状态域，然后采用离线的计算方式评估每个
<span class="math inline">\(（s,a）\)</span> 的价值</li>
<li>采用动态规划，计算每个 <span
class="math inline">\(（s,a）\)</span>的价值函数值 <span
class="math inline">\(Q（s,a）\)</span> 仍然面临计算空间较大的问题</li>
<li>利用有限类函数来近似价值函数，但是无法做出良好的近似，同时对于这样的神经网络比较难以学习</li>
<li>当更新时间较小存在一定的信噪比，导致学习速度及其缓慢，逼近类方法固有的问题</li>
<li>总结：<strong>资源计算量巨大的方法</strong>和
<strong>粗糙近似逼近</strong>会带来不同程度的问题</li>
</ol></li>
<li><p><strong>Semantics</strong> to the rescue重新定义自动驾驶语义</p>
<ul>
<li><p>在语义动作空间上定义价值函数Q：语义空间较小无语大量计算资源，能够对价值函数Q进行准确的估计</p></li>
<li><p>语义动作空间：</p>
<ol type="1">
<li><p>主要思想：纵向目标；横向目标；实现目标的积极性程度</p>
<p>横向：Lateral goals are desired positions in lane coordinate system
(e.g., “my goal is to be in the center of lane number 2”).</p>
<p>纵向： Longitudinal goals are of three types. The first is relative
position and speed w.r.t. other vehicles (e.g., “my goal is to be behind
car number 3, at its same speed, and at a distance of 2 seconds from
it”).</p>
<p>速度目标：speed target (e.g., “drive at the allowed speed for this
road times 110%”).</p>
<p>速度限制：speed constraint at a certain position (e.g., when
approaching a junction, “speed of 0 at the stop line”, or when passing a
sharp curve, “speed of at most 60kmh at a certain position on the
curve”).<strong>速度曲线</strong></p></li>
<li><p>确定横向目标和纵向目标之间的组合，利用运动学公式来实现目标</p></li>
<li><p>语义动作空间产生了所有可能的几何曲线的子集，除了特殊的情况</p></li>
</ol></li>
</ul></li>
<li><p><strong>Constructing an evaluation function for semantic
actions</strong> 构建<strong>语义动作的评估</strong>函数</p>
<ul>
<li>定义语义动作 <span
class="math inline">\(A^s\)</span>空间，通过当前的状态 <span
class="math inline">\(s\)</span>,选择最好的动作 <span
class="math inline">\(a^s\in A^s\)</span>, 根据一些列的几何轨迹 <span
class="math inline">\((s_1,a_1),...,(s_T,a_T)\)</span>，同时认为新的下一时刻的状态有一个新的函数给出
<span class="math inline">\(s_{t+1}=f(s_t,a_t)\)</span>
同时继续根据奖励函数的值来评估执行的语义动作的好坏程度 <span
class="math inline">\(\frac{1}{T}
\sum_{t=1}^T\rho(s_t,a_t)\)</span></li>
<li>利用语义动作来评估能规避信噪比低等问题</li>
<li>利用机器学习来泛化，在不同类型的道路上进行训练，推广到不同的道路</li>
<li>语义动作空间：<strong>资源高效利用同时很准确地进行评估</strong></li>
</ul></li>
<li><p><strong>The dynamics of the other agents
其他智能体的动态</strong></p>
<ul>
<li><span class="math inline">\(s_{t+1}=f(s_t,a_t)\)</span>
这样的确定性函数与现实不符合，多个智能体之间会相互影响</li>
<li>通过高频次地重新应用决策，不断调整策略来适应新的环境</li>
</ul></li>
</ul>
<h4 id="sensing-传感"><strong>Sensing 传感</strong></h4>
<h5 id="传感研究的内容">传感研究的内容：</h5>
<p>静态对象：(a fence that occludes relevant part of a merging
road).；</p>
<p>动态对象：车辆（边界框、速度、加速度）、行人（边界框、速度、加速度）、交通灯、动态道路分隔线（例如建筑区域的锥体）、临时交通标志和警察活动以及道路上的其他障碍物。</p>
<h5 id="sensing-system"><strong>Sensing system</strong></h5>
<ol type="1">
<li>Let <span class="math inline">\(S\)</span> denote the domain of
sensing state and let X be the domain of raw sensor and mapping data. A
传感系统表示的是一个函数 <span class="math inline">\(\hat{s}\)</span> :
<span class="math inline">\(X → S.\)</span></li>
<li>什么时候传感器的值 <span class="math inline">\(\hat{s}\)</span>
能够和状态 <span class="math inline">\(s\)</span>
近似？<strong>通过近似之后对驾驶策略的总体表现：安全性和舒适性</strong></li>
<li>传感器系统可能会犯的<strong>错误类型</strong>：
<ul>
<li>False negative: the sensing system misses an object
误报：传感器错过了一个物体</li>
<li>False positive: the sensing system indicates a “ghost” object
错误：传感器系统提示存在幽灵物体</li>
<li>Inaccurate measurements: the sensing system correctly detects an
object but incorrectly estimates its position or speed
测量不准确：传感系统正确检测到物体但是错误估计位置和速度</li>
<li>Inaccurate semantic: the sensing system correctly detects an object
but misinterpret its semantic meaning, for example, the color of a
traffic light
语义信息不准确：传感系统正确检测物体，但误解了语义信息，比如交通灯的颜色</li>
</ul></li>
</ol>
<h5 id="comfort"><strong>Comfort</strong></h5>
<ul>
<li>相当于利用传感器函数来近似估计 <span
class="math inline">\(s\)</span> ,如果 <span
class="math inline">\(\pi(\hat{s}(x))=\pi(s)\)</span> 也就是说<span
class="math inline">\(\pi(\hat{s}(x))=argmaxQ(\hat{s}(x),a)\)</span>，那么就说明当前这个传感器是可以的，同时允许有一定的误差范围：
<span class="math inline">\(Q(\hat{s}(x),a)\ge
Q(s,\pi(s))-\epsilon\)</span>，这个时候可以说是 <span
class="math inline">\(\epsilon
-\)</span>准确的，同时也允许传感器有小概率发生故障 <span
class="math inline">\(\delta\)</span></li>
<li>For example, we can choose three thresholds, $$1 &lt; $<span
class="math inline">\(2 &lt;\)</span>$3 to represent mild, medium, and
gross mistakes，表示传感器的错误程度，轻中重</li>
</ul>
<h5 id="pac-sensing-system"><strong>PAC sensing system</strong></h5>
<ol type="1">
<li><figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915174341417.png"
alt="Definition 28" />
<figcaption aria-hidden="true">Definition 28</figcaption>
</figure>
<p><strong>Probably-Approximately-Correct (PAC)</strong>
X表示的是原始的数据与映射的数据域，从期望的角度给出误差率的平均值：
<span class="math display">\[
\mathbb{P}_{(x, s) \sim D}\left[Q(s, \pi(\hat{s}(x))) \geq Q(s,
\pi(s))-\epsilon_i\right] \geq 1-\delta_i
\]</span></p></li>
<li><p>通过记录许多人类驾驶员的数据来构建此分布，而不是遵循自动驾驶车辆的特定策略（不切实际），由于任何合理策略对
D
的影响都很小，通过应用简单的数据增强技术，我们可以构建适当的分布，然后在传感系统的每次重大更新后执行离线验证。</p></li>
<li><p>重点关注经常发生的“测量不准确”类型的错误</p></li>
<li><p>let <span class="math inline">\(p(o)\)</span>，<span
class="math inline">\(\hat{p}(o)\)</span> be the positions of o in the
coordinate system of the host vehicle according to <span
class="math inline">\(s(x)\)</span>, <span
class="math inline">\(\hat{s}(x)\)</span>
respectively.分别表示某个对象的<strong>真实的位置信息</strong>和<strong>传感器的位置信息</strong>。</p>
<p>目标到主车辆的距离为：<span class="math inline">\(\|p\|\)</span>
，加性误差：<span
class="math inline">\(\|p(o)-\hat{p}(o)\|\)</span>，相对误差为 <span
class="math inline">\(\frac{\|p(o)-\hat{p}(o)\|}{\|p(o)\|}\)</span></p></li>
<li><p>对于positions a set of objects <span
class="math inline">\(O\)</span>表示的是一堆对象，要求 <span
class="math inline">\(p(o)\)</span> 和 <span
class="math inline">\(\hat{p}(o)\)</span>之间的相对误差小于一个精确度不妨计作
$$ ,但是<span class="math inline">\(\epsilon-ego-accurate\)</span>
的传感状态不能保证PAC传感系统能够满足每个合理的价值函数：当相对误差很小的时候，尽管认为合理了，但是对于实际的情况而言会出现不同的价值函数结果。选择制动or继续前进，<strong>横向不能用相对距离</strong></p></li>
<li><p>表明<span class="math inline">\(\epsilon-ego-accurate\)</span>
并不能保证我们的传感系统是PAC。是否还有其他属性足以满足 PAC
传感系统的要求</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915174411587-20231022115924657.png"
alt="Definition 29" />
<figcaption aria-hidden="true">Definition 29</figcaption>
</figure></li>
<li><figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915174449633.png"
alt="Definition 31" />
<figcaption aria-hidden="true">Definition 31</figcaption>
</figure>
<p>给出价值函数合理的L-语义-<span
class="math inline">\(Lipschitz\)</span>条件</p></li>
<li><figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915174520766.png"
alt="Lemma 7" />
<figcaption aria-hidden="true">Lemma 7</figcaption>
</figure>
<p>判定为PAC传感系统的终极判定</p></li>
</ol>
<h5 id="safety"><strong>Safety</strong></h5>
<ul>
<li><p>目标是减少事故发生的概率，存在两类安全情况：</p>
<ol type="1">
<li>传感系统认为危险情况是不危险的；</li>
<li>传感器系统认为不危险情况是危险的：当安全的时候突然出现紧急刹车会导致危险</li>
</ol></li>
<li><p>解决的是如何确保和验证safety-critic sensing
mistake足够小，采用的方法是融合多个工程和技术都独立的子系统。多数子系统认为安全才算安全：</p></li>
<li><p><strong>单侧c-近似独立</strong>的多个子系统</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915174623604-20231022115925281.png"
alt="Definition 32" />
<figcaption aria-hidden="true">Definition 32</figcaption>
</figure></li>
<li><p>对于服从单侧-c近似独立的子系统，能够推出：</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915174653068.png"
alt="Corollary 3" />
<figcaption aria-hidden="true">Corollary 3</figcaption>
</figure>
<p>基于多子系统方案和Corollary 3，为了达到10^-9
失效率，对sensing系统的验证不再需要10^9
小时的数据，而是分别对每个子系统验证10^5小时就可以了</p></li>
<li><p>独立假设背后的合理性留给我们去推理。有些传感器对会产生完全不相关的误差；单侧-c近似独立是否成立</p></li>
<li><p>对于安全幽灵而言，当出现至少有两个传感器认为的情况是危险的，才能认为是危险的</p></li>
<li><p><strong>Building a scalable sensing
system可扩展的传感器系统</strong></p>
<ol type="1">
<li>Cameras</li>
<li>Road Experience Management (REM)，不使用点云，而是一种基于语义的方法
approach，利用大量的车端detects semantically meaningful objects in the
scene (lane marks, curbs, poles, traffic lights,
etc.)，并可以对云端进行更新。以可扩展的方式非常频繁地更新地图。此外，自动驾驶车辆可以通过现有的通信平台（蜂窝网络）接收小型地图数据</li>
<li>A complementary radar and lidar
system，能够产生极高的精度；直接测量速度和距离，这进一步提高了乘坐的舒适度</li>
</ol></li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>智能安全</tag>
      </tags>
  </entry>
  <entry>
    <title>【基础工具】Git命令集</title>
    <url>/2023/10/23/git/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>
<p>Git
是一个版本控制系统，是任何软件开发项目中的主要内容。通常有两个主要用途：代码备份和代码版本控制。使用Git可以逐步处理代码，在需要回滚到备份副本的过程中保存每一步的进度。</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231206220759363.png"
alt="Git与GitHub" />
<figcaption aria-hidden="true">Git与GitHub</figcaption>
</figure>
<h2 id="git的安装与配置">Git的安装与配置</h2>
<h4 id="安装git">安装Git</h4>
<p>直接上官网下载安装</p>
<p><a
href="https://link.zhihu.com/?target=https%3A//git-scm.com/download">https://link.zhihu.com/?target=https%3A//git-scm.com/download</a></p>
<p><a href="https://git-scm.com/">https://git-scm.com/</a></p>
<p>或者MAC使用brew对git进行安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">brew install git<br></code></pre></td></tr></table></figure>
<h4 id="查看git中的配置">查看Git中的配置</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git config --list<br>git config --global user.email <span class="hljs-built_in">test</span>@163.com<br>git config --global user.name <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure>
<h4 id="检查是否安装成功">检查是否安装成功</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git version<br></code></pre></td></tr></table></figure>
<h2 id="git的基本控制">Git的基本控制</h2>
<h3 id="初始化git仓库">初始化Git仓库</h3>
<p>当完成上述的配置之后，就能开始初始化Git仓库，进入需要创建<strong>工作区</strong>workspace的文件夹输出git初始化的操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> workspace<br>git init<br></code></pre></td></tr></table></figure>
<p>创建一个名为 .git
的新子目录（该目录为隐藏的），其中包含所有必需的存储库文件（Git
存储库框架）；注意区分<strong>工作区</strong>和<strong>暂存区</strong>，在没有add之前我们都是在<strong>工作区</strong></p>
<p>【Vscode】考虑<strong>Git
graph插件</strong>来可视化git分支目录的全貌</p>
<ul>
<li><h5 id="在github端新建仓库">在Github端新建仓库</h5>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231206215455986.png"
alt="Github端新建仓库" />
<figcaption aria-hidden="true">Github端新建仓库</figcaption>
</figure>
<p>根据需要可以设置为公有的或者是私有的，最好不要设置README.md，因为初始化的国过程可能会出现冲突，设置也没关系</p></li>
<li><h5
id="本地的git和远端github的连接">本地的Git和远端github的连接</h5>
<p>获取本地的SSH公钥匙，打开终端并输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;youremail@example.com&quot;</span><br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231206221011696.png"
alt="产生公钥的位置" />
<figcaption aria-hidden="true">产生公钥的位置</figcaption>
</figure>
<p>进入.ssh中复制id_rsa.pub中的内容，并在Github中的如下位置复制改内容添加SSH🔗</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231206221215856.png"
alt="SSH链接" />
<figcaption aria-hidden="true">SSH链接</figcaption>
</figure>
<p>完成连接之后再配置git的相关内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git config --global user.email <span class="hljs-built_in">test</span>@163.com<br>git config --global user.name <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure></li>
<li><h5 id="本地工作区的设置">本地工作区的设置</h5>
<p>首先进行初始化设置，使当前文件夹能够使用git</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git init<br></code></pre></td></tr></table></figure>
<p>如果一开始没有设置README.md文件那么执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git add README.md<br>git commit -m <span class="hljs-string">&quot;first commit&quot;</span><br>git branch -M master<br>git remote add origin git@github.com.....git<br>git push -u origin master<br></code></pre></td></tr></table></figure>
<p>以上这些步骤，就能将本地的git和远端的仓库进行关联</p></li>
<li><h5 id="本地和远端关联失败">本地和远端关联失败</h5>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231206220359185.png"
alt="推送出现错误" />
<figcaption aria-hidden="true">推送出现错误</figcaption>
</figure>
<p>当然会出现本地和远端关联失败的情况，产生的原因可能如下：</p>
<ol type="1">
<li><p>在默认情况下，<code>git push</code>时一般会上传到<code>origin</code>下的<code>master</code>分支上，当<em>repository</em>和<em>branch</em>过多，又没有设置关联时，git就会产生疑问</p>
<p>通过以下命令查看<strong>远端</strong>和<strong>本地</strong>的分支，并<strong>选择合适的</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git branch //本地<br>git branch -a //远端<br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231206220538190.png"
alt="远端和本地的不同分支" />
<figcaption aria-hidden="true">远端和本地的不同分支</figcaption>
</figure></li>
<li><p>如果本地初始化的内容和远端的内容不一样，那么无法判断本地和远端的内容差异，因此需要选择如下之一</p></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git reset --hard origin/master<br></code></pre></td></tr></table></figure>
<p>直接将远端的内容覆盖到本地</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git push -f -u origin master<br></code></pre></td></tr></table></figure>
<p>强行将本地的内容覆盖到远端，那么就能形成统一，从而完成链接。</p></li>
</ul>
<h3 id="添加文件和备注">添加文件和备注</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git add . <br>git add &lt;file&gt;<br></code></pre></td></tr></table></figure>
<p>执行上述命令之后将会将当前的file或者是工作区中的所有文件都上传到暂存区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git commit -m<span class="hljs-string">&quot;【test】XXX更改信息提示&quot;</span><br><span class="hljs-comment">#如果多次提交想覆盖到同一个提交的备注上执行下面</span><br>git commit --amend<br></code></pre></td></tr></table></figure>
<p>上述的命令是将本次的提交添加描述，分布式协作的时候能看清</p>
<h3 id="状态与日志">状态与日志</h3>
<p>查看默认配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git config --list<br></code></pre></td></tr></table></figure>
<p>查看当前所在的分支位置信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git status<br></code></pre></td></tr></table></figure>
<p>查看当前分支下的更改日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure>
<h3 id="推送与拉取">推送与拉取</h3>
<p>将本地暂存区中的更改内容推送到远端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git push<br>git push -f <span class="hljs-comment">#强行推出</span><br></code></pre></td></tr></table></figure>
<p>将远端所在的分支内容拉到本地</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git pull<br></code></pre></td></tr></table></figure>
<p>更新所在分支的最新内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git fetch --all <br></code></pre></td></tr></table></figure>
<h3 id="复制分支">复制分支</h3>
<p>获取git连接git@ XXX.git之后执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git@ XXX.git<br></code></pre></td></tr></table></figure>
<p>如果觉得git的内容太大，可以选择内部的分支进行下载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> -b feature/xxx git@ XXX.git<br></code></pre></td></tr></table></figure>
<p>feature/xxx为具体的分支内容</p>
<h3 id="分支操作">分支操作</h3>
<p>查看分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git branch -a <span class="hljs-comment">#查看所有的分支</span><br>git branch -r <span class="hljs-comment">#查看远端的分支</span><br></code></pre></td></tr></table></figure>
<p>切换不同的分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git checkout [branch] <span class="hljs-comment">#切换到分支</span><br></code></pre></td></tr></table></figure>
<p>创建新的分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git branch [branch] <span class="hljs-comment">#创建新的分支</span><br></code></pre></td></tr></table></figure>
<p>创建新的分支并切换到上面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git checkout -b [branch] <span class="hljs-comment">#创建并切换新的分支</span><br></code></pre></td></tr></table></figure>
<h3 id="分支冲突">分支冲突</h3>
<p><strong>问题描述：</strong>如果当前修改的版本基于旧版，但是远端已经是新版origin/master，<strong>此时修改基于的内容和远端不同不能强行推</strong>。</p>
<p><strong>解决方法1：</strong>通过换基的方法解决，通过将当前的修改的旧版换到最新的基上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#先将文件提交到暂存区</span><br>git add . <span class="hljs-comment">#保存在暂存区</span><br>git commit -m <span class="hljs-string">&quot;XXX&quot;</span><br><span class="hljs-comment">#进行换基操作</span><br>git rebase -i origin/master<br><span class="hljs-comment">#再次提交</span><br>git add .<br><span class="hljs-comment">#继续换基</span><br>git rebase --<span class="hljs-built_in">continue</span><br><span class="hljs-comment">#换基成功后,只需要一次备注（覆盖）</span><br>git commit --amend<br><span class="hljs-comment">#最后退出</span><br>git push<br>git push -f <span class="hljs-comment">#或者强行推出</span><br></code></pre></td></tr></table></figure>
<p><strong>解决方法2：</strong> 暴力覆盖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git fetch --all <span class="hljs-comment">#获取远端的全部内容</span><br>git reset --hard origin/master <span class="hljs-comment">#强行将远端的内容覆盖到本地的文件中</span><br>git commit --amend <br>git push -f <span class="hljs-comment">#强行推出</span><br><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>基础工具</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>【后端开发】Golang基础</title>
    <url>/2023/11/27/go-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>
<hr />
<h1 id="golang基础">Golang基础</h1>
<p>参考学习资料：</p>
<ul>
<li><a
href="https://www.bilibili.com/video/BV1gf4y1r79E/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click">8小时转职Golang工程师</a></li>
<li><a href="https://gfw.go101.org/">Go语言101</a></li>
<li><a
href="https://golang.design/go-questions/">Go程序员面试笔试宝典</a></li>
</ul>
<h2 id="golang简介">Golang简介</h2>
<h3 id="go语言的优势">go语言的优势</h3>
<ol type="1">
<li><strong>部署简单</strong>
<ul>
<li>可以直接编译成机器码可执行</li>
<li>不依赖其他库</li>
<li>直接运行即可部署</li>
</ul></li>
<li><strong>静态类型语言</strong>
<ul>
<li>编译的时候就能查出来大多数的问题</li>
</ul></li>
<li><strong>语言层面的并发</strong>
<ul>
<li>能够成分利用多核</li>
</ul></li>
<li><strong>强大的标准库</strong>
<ul>
<li>runtime系统调度机制</li>
<li>丰富的标准库</li>
</ul></li>
<li><strong>简单易学</strong>
<ul>
<li>25个关键字，内嵌C语法支持</li>
<li>面向对象的特征，能够跨平台</li>
<li>go语言<strong>没有异常</strong>，全部都用ERROR来表示</li>
</ul></li>
</ol>
<h3 id="go应用方向">go应用方向</h3>
<ol type="1">
<li><strong>云计算基础设施建设</strong>
<ul>
<li>Docker, kubernetes</li>
<li>Consul, cloudflare CDN</li>
</ul></li>
<li><strong>基础后端软件</strong>：tide, influxdb, cockroachdb</li>
<li><strong>微服务</strong>：go-kit, micro</li>
<li><strong>互联网基础设施</strong>： 以太坊，hyperledger</li>
</ol>
<hr />
<h2 id="go的环境安装">Go的环境安装</h2>
<h3 id="下载官网">下载官网</h3>
<p>go的官网下载网站，选择合适的系统版本进行安装<a
href="https://go.dev/dl/">https://go.dev/dl/</a></p>
<h3 id="安装步骤">安装步骤</h3>
<ol type="1">
<li><p>下载安装包并按照安装包的指引下载相关的内容</p></li>
<li><p>对于Mac系统会直接配置好环境变量，根据官网的安装手册进行安装 <a
href="https://go.dev/doc/install">https://go.dev/doc/install</a></p></li>
<li><p>测试GO的版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">go version<br></code></pre></td></tr></table></figure>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231127204733470.png" alt="go version" style="zoom: 67%;" /></p></li>
<li><p>测试GO的环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">go <span class="hljs-built_in">env</span><br></code></pre></td></tr></table></figure>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231127204804150.png" alt="go env" style="zoom: 50%;" /></p></li>
</ol>
<h2 id="go环境变量">GO环境变量</h2>
<h3 id="goroot路径">GOROOT路径</h3>
<p>GOROOT 表示的是安装包所在的位置，一般不需要修改</p>
<h3 id="gopath路径">GOPATH路径</h3>
<p>GOPATH表示的是运行文件所在的位置，表示的是workspace的文件位置，GOPATH是我们的工作空间，保存go项目代码和第三方依赖包<strong>GOPATH</strong>可以设置多个，其中，第一个将会是默认的包目录，使用
go get 下载的包都会在第一个path中的src目录下，使用 go
install时，在哪个GOPATH中找到了这个包，就会在哪个GOPATH下的bin目录生成可执行文件</p>
<p>修改GOPATH的路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> GOPATH=<span class="hljs-string">&quot;/Users/lihaibin/workspace/golang&quot;</span><br></code></pre></td></tr></table></figure>
<p>将文件查找的路径设置为GOROOT和GOPATH的并集合</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$GOROOT</span>/bin:<span class="hljs-variable">$GOPATH</span>/bin<br></code></pre></td></tr></table></figure>
<p>将两个部分并在一起之后，就能从两个地方开始寻找定义的包</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203140236053.png"
alt="查找文件的路径顺序" />
<figcaption aria-hidden="true">查找文件的路径顺序</figcaption>
</figure>
<p>首先会从GOROOT进行搜索，接着从GOPATH进行搜索。</p>
<p>GOPATH是开发时的工作目录。用于：</p>
<ol type="1">
<li>保存编译后的二进制文件。</li>
<li><code>go get</code>和<code>go install</code>命令会下载go代码到GOPATH。</li>
<li>import包时的搜索路径</li>
</ol>
<p>使用GOPATH时，GO会在以下目录中搜索包：</p>
<ol type="1">
<li><code>GOROOT/src</code>：该目录保存了Go标准库代码。</li>
<li><code>GOPATH/src</code>：该目录保存了应用自身的代码和第三方依赖的代码。</li>
</ol>
<p><strong>GOPATH的弊端</strong></p>
<p>在 GOPATH 的 <code>$GOPATH/src</code> 下进行 <code>.go</code>
文件或源代码的存储，我们可以称其为 GOPATH
的模式，这个模式拥有一些弊端.</p>
<ul>
<li><p><strong>无版本控制概念.</strong>
在执行<code>go get</code>的时候，你无法传达任何的版本信息的期望，也就是说你也无法知道自己当前更新的是哪一个版本，也无法通过指定来拉取自己所期望的具体版本。</p></li>
<li><p><strong>无法同步一致第三方版本号.</strong> 在运行 Go
应用程序的时候，你无法保证其它人与你所期望依赖的第三方库是相同的版本，也就是说在项目依赖库的管理上，你无法保证所有人的依赖版本都一致。</p></li>
<li><p><strong>无法指定当前项目引用的第三方版本号.</strong> 你没办法处理
v1、v2、v3 等等不同版本的引用问题，因为 GOPATH
模式下的导入路径都是一样的，都是<code>github.com/foo/bar</code>。</p></li>
</ul>
<h3 id="goproxy设置">GOPROXY设置</h3>
<p>这个环境变量主要是用于设置 <strong>Go 模块代理（Go module
proxy）,其作用是用于使 Go
在后续拉取模块版本时直接通过镜像站点来快速拉取</strong>。</p>
<p>GOPROXY
的默认值是：<code>https://proxy.golang.org,direct</code>，<code>proxy.golang.org</code>国内访问不了,需要设置国内的代理</p>
<ul>
<li>阿里云 https://mirrors.aliyun.com/goproxy/</li>
<li>七牛云 https://goproxy.cn,direct</li>
</ul>
<p>并通过以下的命令进行设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">go <span class="hljs-built_in">env</span> -w GOPROXY=https://goproxy.cn,direct<br></code></pre></td></tr></table></figure>
<p>GOPROXY 的值是一个以英文逗号 “,” 分割的 Go
模块代理列表，允许设置多个模块代理，假设你不想使用，也可以将其设置为
“off” ，这将会禁止 Go 在后续操作中使用任何 Go 模块代理。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">go <span class="hljs-built_in">env</span> -w GOPROXY=https://goproxy.cn,https://mirrors.aliyun.com/goproxy/,direct<br></code></pre></td></tr></table></figure>
<h3 id="go111module">GO111MODULE</h3>
<p>GO111MODULE 有三个值：off, on和auto（默认值）。</p>
<ul>
<li>GO111MODULE=off，go命令行将不会支持module功能，寻找依赖包的方式将会沿用旧版本那种通过vendor目录或者GOPATH模式来查找。</li>
<li>GO111MODULE=on，go命令行会使用modules，而一点也不会去GOPATH目录下查找。</li>
<li>GO111MODULE=auto，默认值，go命令行将会根据当前目录来决定是否启用module功能。这种情况下可以分为两种情形：
当前目录在GOPATH/src之外且该目录包含go.mod文件
当前文件在包含go.mod文件的目录下面。</li>
</ul>
<p>执行以下命令开启go mod管理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">go <span class="hljs-built_in">env</span> -w GO111MODULE=on<br></code></pre></td></tr></table></figure>
<h2 id="go基本语法">Go基本语法</h2>
<h3 id="如何编译并运行一个go文件">如何编译并运行一个Go文件</h3>
<p>对于已经写好的go文件，这里以hello.go作为例子，直接使用以下语句进行编译并运行</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> run hello.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure>
<p>或者将编译和运行两个过程分开，先编译后运行：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> build hello.<span class="hljs-keyword">go</span><br>./ hello<br></code></pre></td></tr></table></figure>
<h3 id="写一个hello.go">写一个hello.go</h3>
<p>首先给出基本框架</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span>(<br>	<span class="hljs-string">&quot;fmt&quot;</span>,<br>  <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  fmt.Println(<span class="hljs-string">&quot;hello world!&quot;</span>)<br>  time.Sleep(<span class="hljs-number">1</span>*time.Second)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>程序的第一行声明了名为main的package。<strong>一个package会包含一个或多个.go源代码文件。每一个源文件都是以package开头。</strong>比如我们的例子里是package
main。这行声明语句表示该文件是属于哪一个package。</p>
<ul>
<li>第一行代码<strong>package
main</strong>定义了包名。你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package
main。package main表示一个可独立执行的程序，每个 Go
应用程序都包含一个名为 main 的包。</li>
<li>下一行<strong>import "fmt"</strong>告诉 Go 编译器这个程序需要使用
fmt 包（的函数，或其他元素），fmt 包实现了格式化
IO（输入/输出）的函数。</li>
<li>下一行func main()是程序开始执行的函数。main
函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有
init() 函数则会先执行该函数）。</li>
</ul>
<blockquote>
<p>一个程序的<code>main</code>入口函数必须不带任何输入参数和返回结果。而且go语言的语法，定义函数的时候，<strong>‘{’
必须和函数名在同一行，不能另起一行</strong></p>
</blockquote>
<h3 id="变量的声明">变量的声明</h3>
<p>声明变量的一般形式是使用 var 关键字</p>
<h4 id="第一种声明">第一种声明：</h4>
<p>指定变量类型，声明后若不赋值，使用<strong>默认值0</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> v_name v_type<br>v_name = value<br><span class="hljs-keyword">package</span> main<br><br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">var</span> a <span class="hljs-type">int</span><br>        fmt.Printf(<span class="hljs-string">&quot; = %d\n&quot;</span>, a)<br>&#125;<br><br><br>$<span class="hljs-keyword">go</span> run test.<span class="hljs-keyword">go</span><br>a = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<h4 id="第二种声明">第二种声明：</h4>
<p>根据值自行判定变量类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> v_name = value<br></code></pre></td></tr></table></figure>
<h4 id="第三种声明">第三种声明：</h4>
<p>省略var, 注意
:=左侧的变量不应该是已经声明过的，就是:=只能用于没有被声明的变量赋值上，否则会编译错误</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">v_name := value<br><br><br><span class="hljs-comment">// 例如</span><br><span class="hljs-keyword">var</span> a <span class="hljs-type">int</span> = <span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-number">10</span><br>c : = <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure>
<p>几种声明类型的对比</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">//第一种 使用默认值</span><br>        <span class="hljs-keyword">var</span> a <span class="hljs-type">int</span><br>        fmt.Printf(<span class="hljs-string">&quot;a = %d\n&quot;</span>, a)<br><br><br>        <span class="hljs-comment">//第二种</span><br>        <span class="hljs-keyword">var</span> b <span class="hljs-type">int</span> = <span class="hljs-number">10</span><br>        fmt.Printf(<span class="hljs-string">&quot;b = %d\n&quot;</span>, b)<br><br><br>        <span class="hljs-comment">//第三种 省略后面的数据类型,自动匹配类型</span><br>        <span class="hljs-keyword">var</span> c = <span class="hljs-number">20</span><br>        fmt.Printf(<span class="hljs-string">&quot;c = %d\n&quot;</span>, c)<br><br><br>        <span class="hljs-comment">//第四种 省略var关键字</span><br>        d := <span class="hljs-number">3.14</span><br>        fmt.Printf(<span class="hljs-string">&quot;d = %f\n&quot;</span>, d)<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="全局变量声明">全局变量声明</h4>
<p>和一般的定义变量的方式一样</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x, y <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> c, d <span class="hljs-type">int</span> = <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">var</span> e, f = <span class="hljs-number">123</span>, <span class="hljs-string">&quot;lihaibin&quot;</span><br></code></pre></td></tr></table></figure>
<p>特殊的定义全局变量的方式，而且<strong>:=的定义方式不能够用于定义全局变量</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">var</span> ( <span class="hljs-comment">//这种分解的写法,一般用于声明全局变量</span><br>        a <span class="hljs-type">int</span><br>        b <span class="hljs-type">bool</span><br>)<br><br><span class="hljs-comment">//这种不带声明格式的只能在函数体内声明</span><br><span class="hljs-comment">//g, h := 123, &quot;需要在func函数体内实现&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;&#125;<br></code></pre></td></tr></table></figure>
<h4 id="多变量声明">多变量声明</h4>
<p>:=不能用于已经被初始化之后的变量的赋值，如果对于_的情况是不具备可读性，相当于忽略</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        g, h := <span class="hljs-number">123</span>, <span class="hljs-string">&quot;需要在func函数体内实现&quot;</span><br>        fmt.Println(x, y, a, b, c, d, e, f, g, h)<br><br>        <span class="hljs-comment">//不能对g变量再次做初始化声明</span><br>        <span class="hljs-comment">//g := 400</span><br><br>        _, value := <span class="hljs-number">7</span>, <span class="hljs-number">5</span>  <span class="hljs-comment">//实际上7的赋值被废弃，变量 _  不具备读特性</span><br>        <span class="hljs-comment">//fmt.Println(_) //_变量的是读不出来的</span><br>        fmt.Println(value) <span class="hljs-comment">//5</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="常量">常量</h3>
<h4 id="常量的声明方式">常量的声明方式</h4>
<p>常量是一个简单值的标识符，在程序运行时，<strong>不会被修改的量</strong>。常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。</p>
<p>常量的定义格式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> identifier [<span class="hljs-keyword">type</span>] = value<br><span class="hljs-keyword">const</span> b <span class="hljs-type">string</span> = <span class="hljs-string">&quot;abc&quot;</span><br></code></pre></td></tr></table></figure>
<p>隐式定义类型方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> b = <span class="hljs-string">&quot;abc&quot;</span><br></code></pre></td></tr></table></figure>
<p>多重赋值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> a, b, c = <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;str&quot;</span> <span class="hljs-comment">//多重赋值</span><br></code></pre></td></tr></table></figure>
<p>枚举类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    Unknown = <span class="hljs-number">0</span><br>    Female = <span class="hljs-number">1</span><br>    Male = <span class="hljs-number">2</span><br>)<br></code></pre></td></tr></table></figure>
<p>常量可以用len(), cap(),
unsafe.Sizeof()常量计算表达式的值。常量表达式中，函数必须是内置函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;unsafe&quot;</span><br><span class="hljs-keyword">const</span> (<br>    a = <span class="hljs-string">&quot;abc&quot;</span><br>    b = <span class="hljs-built_in">len</span>(a)<br>    c = unsafe.Sizeof(a)<br>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">println</span>(a, b, c)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果为：abc, 3, 16</p>
<blockquote>
<p>unsafe.Sizeof(a) = 16</p>
<p>字符串类型在 go 里是个结构,
包含指向底层数组的指针和长度,这两部分每部分都是 8
个字节，所以字符串类型大小为 16 个字节。</p>
</blockquote>
<h4 id="常量中的iota标识符">常量中的iota标识符</h4>
<p>在 golang
中，一个方便的习惯就是使用<code>iota</code>标示符，简化了常量用于增长数字的定义。</p>
<p>下面的代码中，当第一行赋值了iota之后，那么相当于初始化位置是0，后面的依次增加是1，2</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    CategoryBooks = <span class="hljs-literal">iota</span> <span class="hljs-comment">// 0</span><br>    CategoryHealth       <span class="hljs-comment">// 1</span><br>    CategoryClothing     <span class="hljs-comment">// 2</span><br>)<br></code></pre></td></tr></table></figure>
<p>如果对<code>iota</code>进行运算，其实相当于是选择当前的行作为iota的取值进行运算，如果中间不对运算加以改变，那么会一直持续按照当前的运算规则执行下去</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>	<span class="hljs-comment">//关键字 iota</span><br>	<span class="hljs-comment">/* BEIJING=0</span><br><span class="hljs-comment">	SHANGHAI=1</span><br><span class="hljs-comment">	SHENGZHENG=2 */</span><br>	BEIJING = <span class="hljs-number">10</span> * <span class="hljs-literal">iota</span> <span class="hljs-comment">// 默认为0 输出0</span><br>	SHANGHAI  <span class="hljs-comment">//输出10</span><br>	HANGZHOU <span class="hljs-comment">//输出20</span><br>)<br></code></pre></td></tr></table></figure>
<p>同样的在同一个const中去定义不同的
<code>iota</code>的计算方式也可以，<code>iota</code>的取值就是选择当前的行，从哪个地方开始改变，那么就改成不同的计算方式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>	<span class="hljs-comment">//这个iota的值表示的是和行数有关的数值，因此计算的时候用行来表示</span><br>	a, b = <span class="hljs-literal">iota</span> + <span class="hljs-number">1</span>, <span class="hljs-literal">iota</span> + <span class="hljs-number">2</span> <span class="hljs-comment">//每次新开一个关于iota的计算 那么后续全部会跟着这个计算方式下去</span><br>	c, d<br>	e, f<br>	g, h = <span class="hljs-literal">iota</span> * <span class="hljs-number">2</span>, <span class="hljs-literal">iota</span> * <span class="hljs-number">3</span><br>	<span class="hljs-comment">//iota只能在const之中使用</span><br>	i, k<br>)<br></code></pre></td></tr></table></figure>
<p>以下是输出的内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">a= 1 b= 2 c= 2 d= 3 e= 3 f= 4 g= 6 h= 9 i= 8 k= 12<br></code></pre></td></tr></table></figure>
<h3 id="函数">函数</h3>
<h4 id="基本函数的定义">基本函数的定义</h4>
<p>多个返回值初始化设置了函数的形参之后，初始值是0</p>
<p>go每次设置一个变量值之后都有初始值，如果是数据就是0，如果是字符串那么就是空，防止出现一些野指针的情况</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(x, y <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">string</span>) &#123;<br>   <span class="hljs-keyword">return</span> y, x<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   a, b := swap(<span class="hljs-string">&quot;Mahesh&quot;</span>, <span class="hljs-string">&quot;Kumar&quot;</span>)<br>   fmt.Println(a, b)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出的结果是</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">Kumar Mahesh<br></code></pre></td></tr></table></figure>
<h4 id="import和init">import和init</h4>
<p>所有被导入的包都加载完毕了，就会开始对main包中的包级常量和变量进行初始化，执行main包中的init函数，最后执行main函数。下图详细地解释了整个执行过程：</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231202121630297.png"
alt="init的调用顺序" />
<figcaption aria-hidden="true">init的调用顺序</figcaption>
</figure>
<p>分别建不同的文件夹对应的就是package的名字，相应的在.go文件内部声明package的名字</p>
<p>main 函数只能在package main中</p>
<p><strong>注意：</strong>
在包中设置接口的时候，函数名称<strong>必须第一个字母是大写，如果是小写的话将无法识别</strong></p>
<ul>
<li>如果函数名第一个是大写就是对外开放的函数，认为是public</li>
<li>如果函数名第一个是小写的话就认为是私有的函数，认为是private</li>
</ul>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203140110880.png" alt="接口函数大小写的区别" style="zoom:67%;" /></p>
<p>init函数的调用过程，首先会对包中的init进行初始化再进行调用接口</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203140412429.png" alt="init()调用顺序和过程" style="zoom:67%;" /></p>
<p>如果你导入了包比如lib1，但是没有使用这个包里面的接口函数，仍然会报错</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203141038750.png" alt="导入包但是没有使用接口函数" style="zoom:67%;" /></p>
<p>以下是一个import包的例子，首先定义两个不同包以及对应的接口函数和初始化函数的实现</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> InitLib1<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;lib1&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> InitLib2<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;lib2&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;GolangTraining/InitLib1&quot;</span><br>    <span class="hljs-string">&quot;GolangTraining/InitLib2&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;libmain init&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;libmian main&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>"GolangTraining/InitLib1""GolangTraining/InitLib2"</code>是两个包的地址，go会默认从GOROOT和GOPATH两个默认的位置进行寻找，首先要保证地址的正确性</p>
<p>代码的输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">lib1<br>lib2<br>libmain init<br>libmian main<br></code></pre></td></tr></table></figure>
<h4 id="匿名导包方式">匿名导包方式</h4>
<p>如果我不想调用lib1的函数接口，但是想使用lib1的init()函数怎么办呢，如果这个时候直接导入了包但是不调用接口，就会出现上述的错误</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203141038750.png" alt="导入包但是没有使用接口函数" style="zoom:70%;" /></p>
<p>在导入的包前面加上下划线来认为这个包是匿名的，这样就能知进行init操作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span>(<br>			<span class="hljs-string">&quot;fmt&quot;</span><br>			_<span class="hljs-string">&quot;lib2&quot;</span><br>)<br></code></pre></td></tr></table></figure>
<p>那么这个时候就只会调用<code>init()</code>函数同时不会出错</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203141336299.png"
alt="只调用init()函数" />
<figcaption aria-hidden="true">只调用init()函数</figcaption>
</figure>
<p>除了能够匿名导包之外，还能给新导入的包起个别的名字，比如叫mylib作为新的别名</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203141500041.png" alt="给导入的包换个名字" style="zoom:67%;" /></p>
<p>或者直接使用<code>·</code>来进行调用</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203141620428.png" alt="换别名进行导包" style="zoom:67%;" /></p>
<p>最好别使用这种，如果两个包的函数名称一样那么可能会导致<strong>出现歧义的情况</strong></p>
<h4 id="函数值传递">函数值传递</h4>
<p>函数如果使用参数，该变量可称为函数的形参。</p>
<p><strong>形参</strong>就像定义在函数体内的<strong>局部变量</strong>。调用函数，可以通过两种方式来传递参数：<strong>值传递和指针传递</strong></p>
<p>值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。<strong>默认情况下，Go
语言使用的是值传递</strong>，即在调用过程中不会影响到实际参数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* 定义相互交换值的函数 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>   <span class="hljs-keyword">var</span> temp <span class="hljs-type">int</span><br><br><br>   temp = x <span class="hljs-comment">/* 保存 x 的值 */</span><br>   x = y    <span class="hljs-comment">/* 将 y 值赋给 x */</span><br>   y = temp <span class="hljs-comment">/* 将 temp 值赋给 y*/</span><br><br><br>   <span class="hljs-keyword">return</span> temp;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>接下来，让我们使用值传递来调用 swap() 函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">/* 定义局部变量 */</span><br>   <span class="hljs-keyword">var</span> a <span class="hljs-type">int</span> = <span class="hljs-number">100</span><br>   <span class="hljs-keyword">var</span> b <span class="hljs-type">int</span> = <span class="hljs-number">200</span><br><br><br>   fmt.Printf(<span class="hljs-string">&quot;交换前 a 的值为 : %d\n&quot;</span>, a )<br>   fmt.Printf(<span class="hljs-string">&quot;交换前 b 的值为 : %d\n&quot;</span>, b )<br><br><br>   <span class="hljs-comment">/* 通过调用函数来交换值 */</span><br>   swap(a, b)<br><br><br>   fmt.Printf(<span class="hljs-string">&quot;交换后 a 的值 : %d\n&quot;</span>, a )<br>   fmt.Printf(<span class="hljs-string">&quot;交换后 b 的值 : %d\n&quot;</span>, b )<br>&#125;<br><br><br><span class="hljs-comment">/* 定义相互交换值的函数 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>   <span class="hljs-keyword">var</span> temp <span class="hljs-type">int</span><br><br><br>   temp = x <span class="hljs-comment">/* 保存 x 的值 */</span><br>   x = y    <span class="hljs-comment">/* 将 y 值赋给 x */</span><br>   y = temp <span class="hljs-comment">/* 将 temp 值赋给 y*/</span><br><br><br>   <span class="hljs-keyword">return</span> temp;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行的结果为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">交换前 a 的值为 : 100<br>交换前 b 的值为 : 200<br>交换后 a 的值 : 100<br>交换后 b 的值 : 200<br></code></pre></td></tr></table></figure>
<h3 id="go指针">GO指针</h3>
<p>和C++以及C中的是一样的，对go中的指针定义的时候 *int
传递变量的地址&amp;</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203171319969.png" alt="指针和引用的传递例子" style="zoom:67%;" /></p>
<p>在对一个指针赋值的时候，传递的是某一个变量的地址，就是传递这个变量的引用，引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p>
<h3 id="defer">defer</h3>
<p>defer语句被用于预定对一个函数的调用。可以把这类被defer语句调用的函数称为<strong>延迟函数</strong>，主要作用：</p>
<ul>
<li>释放占用的资源</li>
<li>捕捉处理异常</li>
<li>输出日志</li>
</ul>
<p>如果一个函数中有多个defer语句，它们会以<strong>LIFO（后进先出）</strong>的顺序执行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Demo</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;1&quot;</span>)<br>	<span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;2&quot;</span>)<br>	<span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;3&quot;</span>)<br>	<span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;4&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	Demo()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出的内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">4<br>3<br>2<br>1<br></code></pre></td></tr></table></figure>
<h3 id="数组与切片">数组与切片</h3>
<p>Go 语言切片 <code>slice</code> 是对数组的抽象</p>
<h4 id="静态数组">静态数组</h4>
<p>通过这种方式进行初始化数组以及进行切片操作，通过range关键字进行遍历数组，并给出index和value进行给出不同的下标和数值</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203174817927.png" alt="初始化数组并进行切片操作" style="zoom:67%;" /></p>
<p>固定数组传递的是一个值拷贝</p>
<h4 id="动态数组-slice"><strong>动态数组 slice</strong></h4>
<p>切片不需要说明长度</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment">		声明切片之后的长度是3，同时初始化的值是1，2，3</span><br><span class="hljs-comment">	*/</span><br>slice1 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>s := arr[:]<br><span class="hljs-comment">//但是这个时候就只会重新赋予空间并复制0</span><br>slice1 = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">4</span>)<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">		声明slice是切片,但是没有分配空间</span><br><span class="hljs-comment">	*/</span><br><span class="hljs-keyword">var</span> slice2 []<span class="hljs-type">int</span><br></code></pre></td></tr></table></figure>
<p>也可以指定容量，其中<code>capacity</code>为可选参数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">make</span>([]T, length, capacity)<br></code></pre></td></tr></table></figure>
<p>将arr中从下标startIndex到<strong>endIndex-1</strong>
下的元素创建为一个新的切片</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">s := arr[startIndex:endIndex]<br></code></pre></td></tr></table></figure>
<p>缺省endIndex时将表示一直到arr的最后一个元素，缺省startIndex时将表示从arr的第一个元素开始</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">s := arr[startIndex:]<br>s := arr[:endIndex]<br></code></pre></td></tr></table></figure>
<p>通过切片s初始化切片s1</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">s1 := s[startIndex:endIndex]<br></code></pre></td></tr></table></figure>
<p>通过内置函数 <code>make()</code>初始化切片s,<code>[]int</code>
标识为其元素类型为int的切片</p>
<p>同时动态数组传递的过程中的参数形式是一致的，能够适配所有的slice参数类型，但是对于</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203205827787.png" alt="动态数组传递引用同时不会因为长度不一样而改变形参" style="zoom:67%;" /></p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203205839072.png" alt="动态数组的初始化和打印" style="zoom:67%;" /></p>
<p>这里面的下划线表示的是<strong>不需要考虑</strong>的index的数值，可以忽略，这里是关于切片slice的声明和打印</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">	<span class="hljs-comment">//声明切片之后的长度是3，同时初始化的值是1，2，3</span><br>	slice1 :=[]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br>	<span class="hljs-comment">//%v表示的是打印出全部的表示信息</span><br>	fmt.Printf(<span class="hljs-string">&quot;len = %d, slice =%v\n&quot;</span>, <span class="hljs-built_in">len</span>(slice1),slice1)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>打印的结果是</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203210558440.png" alt="输出的结果" style="zoom:67%;" /></p>
<p>声明slice但是不一定声明了空间，因此需要注意的是声明的同时并给出空间大小，同时没办法中途增加空间</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span>  <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-comment">/* </span><br><span class="hljs-comment">	声明切片之后的长度是3，同时初始化的值是1，2，3</span><br><span class="hljs-comment">	 */</span><br>	slice1 :=[]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br>	<span class="hljs-comment">//%v表示的是打印出全部的表示信息</span><br>	fmt.Printf(<span class="hljs-string">&quot;len = %d, slice =%v\n&quot;</span>, <span class="hljs-built_in">len</span>(slice1),slice1)<br>	<span class="hljs-comment">//直接对没有赋予空间的位置修改会出现位置越界</span><br>	<span class="hljs-comment">//slice1[3]=999</span><br>	slice1 = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">4</span>)<br>	<span class="hljs-comment">//但是这个时候就只会重新赋予空间并复制0</span><br>	fmt.Printf(<span class="hljs-string">&quot;len = %d, slice =%v\n&quot;</span>, <span class="hljs-built_in">len</span>(slice1),slice1)<br>	<span class="hljs-comment">/* </span><br><span class="hljs-comment">	声明slice是切片,但是没有分配空间</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">var</span> slice2 []<span class="hljs-type">int</span><br>	fmt.Printf(<span class="hljs-string">&quot;len = %d, slice =%v\n&quot;</span>, <span class="hljs-built_in">len</span>(slice2),slice2)<br>	<span class="hljs-comment">//slice2[0]=2 //直接赋予数值会出现错误，越界</span><br>	slice2 = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">3</span>)<br>	<span class="hljs-comment">//开辟空间，但是默认值都是0</span><br>	fmt.Printf(<span class="hljs-string">&quot;len = %d, slice =%v\n&quot;</span>, <span class="hljs-built_in">len</span>(slice2),slice2)<br>	slice2[<span class="hljs-number">0</span>]=<span class="hljs-number">1000</span><br>	fmt.Printf(<span class="hljs-string">&quot;len = %d, slice =%v\n&quot;</span>, <span class="hljs-built_in">len</span>(slice2),slice2)<br>	<span class="hljs-comment">//此时就修改成功</span><br>	<span class="hljs-comment">/*  </span><br><span class="hljs-comment">	声明slice类型，同时分配空间</span><br><span class="hljs-comment">	*/</span><br>	<span class="hljs-keyword">var</span> slice3 =<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">5</span>)<br>	fmt.Printf(<span class="hljs-string">&quot;len = %d, slice =%v\n&quot;</span>, <span class="hljs-built_in">len</span>(slice3),slice3)<br><br><br></code></pre></td></tr></table></figure>
<p>判断一个切片是不是空的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">	<span class="hljs-comment">/* </span><br><span class="hljs-comment">	判断一个slice切片是不是为0</span><br><span class="hljs-comment">	*/</span><br>	<span class="hljs-keyword">if</span> slice1 == <span class="hljs-literal">nil</span>&#123;<br>		fmt.Println(<span class="hljs-string">&quot;slice1 is null&quot;</span>)<br>	&#125;<span class="hljs-keyword">else</span>&#123;<br>		fmt.Println(<span class="hljs-string">&quot;slice1 is not null&quot;</span>)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意if-else的格式有要求，<code>&#123;</code>必须是出现在else和if紧接着的位置，不能换行写</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203211744713.png" alt="判断当前的动态数组是不是空的" style="zoom:67%;" /></p>
<h4 id="append和copy">append()和copy()</h4>
<p>如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231203213134825.png" alt="追加元素的操作显示" style="zoom:67%;" /></p>
<p><strong>注意，如果append超过了当前的空间，那么slice就会继续增加空间，增加的大小是cap的大小增加</strong></p>
<p>拷贝copy()操作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* 创建切片 numbers1 是之前切片的两倍容量*/</span><br>   numbers1 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(numbers), (<span class="hljs-built_in">cap</span>(numbers))*<span class="hljs-number">2</span>)<br><br><br>   <span class="hljs-comment">/* 拷贝 numbers 的内容到 numbers1 */</span><br>   <span class="hljs-built_in">copy</span>(numbers1,numbers)<br>   printSlice(numbers1)  <br></code></pre></td></tr></table></figure>
<p>关于切片的截取操作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* </span><br><span class="hljs-comment">	切片的截取 </span><br><span class="hljs-comment">	*/</span><br>	<span class="hljs-keyword">var</span> slice6 = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">3</span>)<br>	slice6[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span><br>	slice6[<span class="hljs-number">2</span>]=<span class="hljs-number">33</span><br>	fmt.Printf(<span class="hljs-string">&quot;len = %d, cap = %d, slice =%v\n&quot;</span>, <span class="hljs-built_in">len</span>(slice6), <span class="hljs-built_in">cap</span>(slice6), slice6)<br>	<span class="hljs-comment">//截取的过程中是左闭右开</span><br>	s1:=slice6[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]<br>	<span class="hljs-comment">// s1:=slice6[:]//表示截取全部</span><br>	fmt.Println(s1)<br>	<span class="hljs-comment">//注意此时的s1的地址和slice6的位置一样了</span><br><br>	<span class="hljs-comment">//copy</span><br>	<span class="hljs-keyword">var</span> s2 = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">3</span>)<br>	<span class="hljs-built_in">copy</span>(s2,slice6)<br>	fmt.Println(s2)<span class="hljs-comment">// 只会从头开始截取s2长度的，如果长了那么就是0，</span><br>	<span class="hljs-comment">//否则就是选择slice6中相同长度的元素，从左到右边</span><br></code></pre></td></tr></table></figure>
<h3 id="map">map</h3>
<p>map和slice类似，只不过是数据结构不同，下面是map的一些声明方式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//第一种声明</span><br>    <span class="hljs-keyword">var</span> test1 <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span><br>    <span class="hljs-comment">//在使用map前，需要先make，make的作用就是给map分配数据空间</span><br>    test1 = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>, <span class="hljs-number">10</span>) <br>    test1[<span class="hljs-string">&quot;one&quot;</span>] = <span class="hljs-string">&quot;php&quot;</span><br>    test1[<span class="hljs-string">&quot;two&quot;</span>] = <span class="hljs-string">&quot;golang&quot;</span><br>    test1[<span class="hljs-string">&quot;three&quot;</span>] = <span class="hljs-string">&quot;java&quot;</span><br>    fmt.Println(test1) <span class="hljs-comment">//map[two:golang three:java one:php]</span><br><br><br>    <span class="hljs-comment">//第二种声明</span><br>    test2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)<br>    test2[<span class="hljs-string">&quot;one&quot;</span>] = <span class="hljs-string">&quot;php&quot;</span><br>    test2[<span class="hljs-string">&quot;two&quot;</span>] = <span class="hljs-string">&quot;golang&quot;</span><br>    test2[<span class="hljs-string">&quot;three&quot;</span>] = <span class="hljs-string">&quot;java&quot;</span><br>    fmt.Println(test2) <span class="hljs-comment">//map[one:php two:golang three:java]</span><br><br>    <span class="hljs-comment">//第三种声明</span><br>    test3 := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<br>        <span class="hljs-string">&quot;one&quot;</span> : <span class="hljs-string">&quot;php&quot;</span>,<br>        <span class="hljs-string">&quot;two&quot;</span> : <span class="hljs-string">&quot;golang&quot;</span>,<br>        <span class="hljs-string">&quot;three&quot;</span> : <span class="hljs-string">&quot;java&quot;</span>,<br>    &#125;<br>    fmt.Println(test3) <span class="hljs-comment">//map[one:php two:golang three:java]</span><br><br><br>    <br>    language := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)<br>    language[<span class="hljs-string">&quot;php&quot;</span>] = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>, <span class="hljs-number">2</span>)<br>    language[<span class="hljs-string">&quot;php&quot;</span>][<span class="hljs-string">&quot;id&quot;</span>] = <span class="hljs-string">&quot;1&quot;</span><br>    language[<span class="hljs-string">&quot;php&quot;</span>][<span class="hljs-string">&quot;desc&quot;</span>] = <span class="hljs-string">&quot;php是世界上最美的语言&quot;</span><br>    language[<span class="hljs-string">&quot;golang&quot;</span>] = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>, <span class="hljs-number">2</span>)<br>    language[<span class="hljs-string">&quot;golang&quot;</span>][<span class="hljs-string">&quot;id&quot;</span>] = <span class="hljs-string">&quot;2&quot;</span><br>    language[<span class="hljs-string">&quot;golang&quot;</span>][<span class="hljs-string">&quot;desc&quot;</span>] = <span class="hljs-string">&quot;golang抗并发非常good&quot;</span><br>    <br>    fmt.Println(language) <span class="hljs-comment">//map[php:map[id:1 desc:php是世界上最美的语言] golang:map[id:2 desc:golang抗并发非常good]]</span><br><br><br>    <span class="hljs-comment">//增删改查</span><br>    <span class="hljs-comment">// val, key := language[&quot;php&quot;]  //查找是否有php这个子元素</span><br>    <span class="hljs-comment">// if key &#123;</span><br>    <span class="hljs-comment">//     fmt.Printf(&quot;%v&quot;, val)</span><br>    <span class="hljs-comment">// &#125; else &#123;</span><br>    <span class="hljs-comment">//     fmt.Printf(&quot;no&quot;);</span><br>    <span class="hljs-comment">// &#125;</span><br><br>    <span class="hljs-comment">//language[&quot;php&quot;][&quot;id&quot;] = &quot;3&quot; //修改了php子元素的id值</span><br>    <span class="hljs-comment">//language[&quot;php&quot;][&quot;nickname&quot;] = &quot;啪啪啪&quot; //增加php元素里的nickname值</span><br>    <span class="hljs-comment">//delete(language, &quot;php&quot;)  //删除了php子元素</span><br>    fmt.Println(language)<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="面向对象结构体">面向对象结构体</h3>
<h4 id="定义一个结构体">定义一个结构体</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//定义一个结构体</span><br><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>    name <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>分别定义不同的拷贝和引用的函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t T)</span></span> method1() &#123;<br>    t.name = <span class="hljs-string">&quot;new name1&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span></span> method2() &#123;<br>    t.name = <span class="hljs-string">&quot;new name2&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>结果是使用值拷贝的输出的name没有改变，只有使用引用的才发生了改变</p>
<p>关于结构体定义的细节，内部的成员变量和结构体本身的大小写就是蕴含了是不是私有和公有的关系，大写标识公有，小写表示私有</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 如果这个类如果是大写，那么其他的Package也能够访问</span><br><span class="hljs-keyword">type</span> Human <span class="hljs-keyword">struct</span> &#123;<br>	Name <span class="hljs-type">string</span> <span class="hljs-comment">//其中变量名称表示大写说明是能够对外界可见的public</span><br>	Age  <span class="hljs-type">int</span><br>	<span class="hljs-comment">//如果是小写那么就是private的属性</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>对于结构体内部的成员函数，必须是传递了引用的地址才能够修改，否则就是默认的值传递</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Human)</span></span> GetName() &#123;<br>	fmt.Println(this.Name)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Human)</span></span> SetName(newname <span class="hljs-type">string</span>) &#123;<br>	<span class="hljs-comment">//只有是引用地址的传递的时候才是能够修改的</span><br>	this.Name = newname<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this Human)</span></span> SetName1(newname <span class="hljs-type">string</span>) &#123;<br>	<span class="hljs-comment">//默认是值传递</span><br>	this.Name = newname<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="类的继承性">类的继承性</h4>
<p>如果新定义的类继承了某个类，那么只需要在内部写上所继承的类的名称，同时这里没有C++中的公有保护等其他类型的继承，公有私有的设定保持一致</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Superman <span class="hljs-keyword">struct</span> &#123;<br>	Human <span class="hljs-comment">//表示Superman继承了Human，同时这里没有C++中的公有保护等其他类型的继承</span><br>	<span class="hljs-comment">//在子类中重新增加变量</span><br>	Level <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>对继承类中的方法重写，同样传递的还是引用和指针</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 对于父类方法进行重写</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Superman)</span></span> GetName() &#123;<br>	fmt.Println(this.Name)<br>	fmt.Println(this.Level)<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>重新定义新的方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 子类中的新方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Superman)</span></span> LevelUp() &#123;<br>	fmt.Println(<span class="hljs-string">&quot;level up&quot;</span>)<br>	this.Level = this.Level + <span class="hljs-number">1</span><br>	fmt.Println(this)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>关于主函数中的调用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	human := Human&#123;Name: <span class="hljs-string">&quot;zhang&quot;</span>, Age: <span class="hljs-number">99</span>&#125;<br>	human.SetName1(<span class="hljs-string">&quot;li&quot;</span>)<br>	fmt.Println(human) <span class="hljs-comment">//&#123;zhang 99&#125;</span><br>	human.SetName(<span class="hljs-string">&quot;li&quot;</span>)<br>	fmt.Println(human) <span class="hljs-comment">//&#123;li 99&#125;</span><br>	human.GetName()<br>	fmt.Println(<span class="hljs-string">&quot;-------------&quot;</span>)<br>	superman := Superman&#123;Human&#123;<span class="hljs-string">&quot;li4&quot;</span>, <span class="hljs-number">18</span>&#125;, <span class="hljs-number">99</span>&#125;<br>	<span class="hljs-comment">//父类方法的重写</span><br>	superman.GetName()<br>	<span class="hljs-comment">//子类新方法</span><br>	superman.LevelUp()<br>	<span class="hljs-comment">/* level up</span><br><span class="hljs-comment">	&amp;&#123;&#123;li4 18&#125; 100&#125;	 */</span><br>	<span class="hljs-comment">//父类方法原封不动</span><br>	superman.SetName(<span class="hljs-string">&quot;wang5&quot;</span>)<br>	fmt.Println(superman) <span class="hljs-comment">//&#123;&#123;wang5 18&#125; 100&#125;</span><br><br>	fmt.Println(<span class="hljs-string">&quot;+++++++++++++&quot;</span>)<br>	<span class="hljs-comment">//第二种继承类对象的声明</span><br>	<span class="hljs-keyword">var</span> super Superman<br>	super.Name = <span class="hljs-string">&quot;zhangmazi&quot;</span><br>	super.Level = <span class="hljs-number">100</span><br>	super.Age = <span class="hljs-number">19</span><br>	fmt.Println(super)<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="interface与类型断言">Interface与类型断言</h3>
<p>在继承和多态上，一系列家族定义的接口，<strong>每个子类能够重写方法</strong>，实现同一个方法有多个接口表现形式</p>
<h4 id="类的多态性">类的多态性</h4>
<p>本质上利用interface来实现类的多态性</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 本质是一个指针多态</span><br><span class="hljs-keyword">type</span> Animal <span class="hljs-keyword">interface</span> &#123;<br>	<span class="hljs-comment">//给出接口包含的多态的函数</span><br>	Sleep()<br>	GetColor() <span class="hljs-type">string</span><br>	GetType() <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">// 定义一个具体的类</span><br><span class="hljs-keyword">type</span> Cat <span class="hljs-keyword">struct</span> &#123;<br>	<span class="hljs-comment">/*如果继承一个接口interface 那么就不需要直接写出来继承，</span><br><span class="hljs-comment">	只需要进行实现就可以认为继承了这个接口inerface</span><br><span class="hljs-comment">	*/</span><br>	color <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">// 第二个多态的类</span><br><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span> &#123;<br>	<span class="hljs-comment">//同样需要进行继承这个interface</span><br>	color <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>那怎么认为这个cat继承了这个animal类呢？只需要对animal中的所有函数重写即可认为是继承了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* 必须要完全重写所有的接口才能认为是多态满足 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Cat)</span></span> Sleep() &#123;<br>	fmt.Println(<span class="hljs-string">&quot;cat sleep...&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Cat)</span></span> GetColor() <span class="hljs-type">string</span> &#123;<br>	fmt.Printf(<span class="hljs-string">&quot;the cat color is %v\n&quot;</span>, this.color)<br>	<span class="hljs-keyword">return</span> this.color<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Cat)</span></span> GetType() <span class="hljs-type">string</span> &#123;<br>	fmt.Printf(<span class="hljs-string">&quot;the type is cat\n&quot;</span>)<br>	<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Cat&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>同理对于dog也是一样</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Dog)</span></span> Sleep() &#123;<br>	fmt.Println(<span class="hljs-string">&quot;dog sleep...&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Dog)</span></span> GetColor() <span class="hljs-type">string</span> &#123;<br>	fmt.Printf(<span class="hljs-string">&quot;the dog color is %v\n&quot;</span>, this.color)<br>	<span class="hljs-keyword">return</span> this.color<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Dog)</span></span> GetType() <span class="hljs-type">string</span> &#123;<br>	fmt.Printf(<span class="hljs-string">&quot;the type is dog\n&quot;</span>)<br>	<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Dog&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>主函数中如何实现不同的多态调用呢？注意哦，这个地方传递的是继承类的引用进去来实现多态</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">showanimal</span><span class="hljs-params">(animal Animal)</span></span> &#123;<br>	animal.Sleep()<br>	<span class="hljs-comment">// fmt.Println(&quot;color = &quot;,animal.GetColor())</span><br>	<span class="hljs-comment">// fmt.Println(&quot;type = &quot;,animal.GetType())</span><br>	animal.GetType()<br>	animal.GetColor()<br>&#125;<br><br><br>	cat := Cat&#123;<span class="hljs-string">&quot;Green&quot;</span>&#125;<br>	dog := Dog&#123;<span class="hljs-string">&quot;Yellow&quot;</span>&#125;<br><br>	<span class="hljs-comment">//通过传递指针和引用来实现多态性</span><br>	showanimal(&amp;cat)<br>	showanimal(&amp;dog)<br></code></pre></td></tr></table></figure>
<h4 id="万能类型interface">万能类型interface</h4>
<p>golang中的所有程序都实现了interface{}的接口，这意味着，所有的类型如string,int,int64甚至是自定义的struct类型都就此拥有了<code>interface&#123;&#125;</code>的接口，这种做法和java中的Object类型比较类似。那么在一个数据通过<code>func funcName(interface&#123;&#125;)</code>的方式传进来的时候，也就意味着这个参数被自动的转为<code>interface&#123;&#125;</code>的类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">funcName</span><span class="hljs-params">(a <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">string</span> &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(a)<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>interface&#123;&#125;</code>相当于是一个万能的数据类型，适用于对任何的函数的参数传递中的使用</p>
<ul>
<li>直接断言使用</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-keyword">interface</span>&#123;&#125;<br>fmt.Println(<span class="hljs-string">&quot;Where are you,Jonny?&quot;</span>, a.(<span class="hljs-type">string</span>))<br></code></pre></td></tr></table></figure>
<p>如果断言失败一般会导致panic的发生。所以为了防止panic的发生，我们需要在断言前进行一定的判断</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">value, ok := a.(<span class="hljs-type">string</span>)<br></code></pre></td></tr></table></figure>
<p>如果断言失败，<strong>那么ok的值将会是false,但是如果断言成功ok的值将会是true</strong>，同时value将会得到所期待的正确的值。</p>
<h5 id="interface的例子">interface{}的例子</h5>
<p>定义一个断言类型的函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunc</span><span class="hljs-params">(arg <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>	fmt.Println(<span class="hljs-string">&quot;myfunc is called...&quot;</span>)<br>	fmt.Println(arg)<br><br>	<span class="hljs-comment">//interface&#123;&#125;如何确定类型是什么呢？</span><br><br>	<span class="hljs-comment">//类型断言机制 用于判断是什么类型</span><br>	value, ok := arg.(<span class="hljs-type">string</span>)<br>	<span class="hljs-keyword">if</span> !ok &#123;<br>		fmt.Println(<span class="hljs-string">&quot;arg is not a string&quot;</span>)<br>		fmt.Printf(<span class="hljs-string">&quot;the value is %T\n&quot;</span>, arg) <span class="hljs-comment">//the value is main.Book</span><br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		fmt.Println(<span class="hljs-string">&quot;arg is string type,is = &quot;</span>, value)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>主函数的调用关系如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Book <span class="hljs-keyword">struct</span> &#123;<br>	auth <span class="hljs-type">string</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	book := Book&#123;<span class="hljs-string">&quot;golang&quot;</span>&#125;<br>	myFunc(book) <span class="hljs-comment">//&#123;golang&#125;</span><br>	myFunc(<span class="hljs-number">100</span>)  <span class="hljs-comment">//100</span><br>	myFunc(<span class="hljs-string">&quot;goland&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>输出的内容是：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#输出的值</span><br>myfunc is called...<br>&#123;golang&#125;<br>arg is not a string<br>the value is main.Book<br>myfunc is called...<br>100<br>arg is not a string<br>the value is int<br>myfunc is called...<br>goland<br></code></pre></td></tr></table></figure>
<h3 id="reflect反射">Reflect反射</h3>
<p>在讲反射之前，先来看看Golang关于类型设计的一些原则</p>
<ul>
<li>变量包括（type, value）两部分</li>
<li>type 包括 <code>static type</code>和<code>concrete type</code>.
简单来说
<code>static type</code>是你在编码是看见的类型(如int、string)，<code>concrete type</code>是<code>runtime</code>系统看见的类型</li>
<li>类型断言能否成功，取决于变量的<code>concrete type</code>，而不是<code>static type</code>.
因此，一个
<code>reader</code>变量如果它的<code>concrete type</code>也实现了<code>write</code>方法的话，它也可以被类型断言为<code>writer</code>.</li>
</ul>
<p><code>反射</code>，就是建立在类型之上的，Golang的指定类型的变量的类型是静态的（也就是指定int、string这些的变量，它的type是static
type），在创建变量的时候就已经确定，<strong>反射主要与Golang的interface类型相关</strong>（它的type是concrete
type），<strong>只有interface类型才有反射一说</strong></p>
<p>在Golang的实现中，每个<code>interface</code>变量都有一个对应<code>pair</code>，pair中记录了实际变量的值和类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">(value, <span class="hljs-keyword">type</span>)<br></code></pre></td></tr></table></figure>
<p>value是实际变量值，type是实际变量的类型。一个<code>interface&#123;&#125;</code>类型的变量包含了2个指针，一个指针指向值的<strong>类型<code>concrete type</code></strong>，另外一个指针指向<strong>实际的值对应<code>value</code></strong></p>
<h4 id="reflect的基本功能">reflect的基本功能</h4>
<p><strong>reflect的反射类型对象：TypeOf和ValueOf</strong></p>
<p>那么在Golang的reflect反射包中有什么样的方式可以让我们直接获取到变量内部的信息呢？
它提供了两种类型（或者说两个方法）让我们可以很容易的访问接口变量内容，分别是<code>reflect.ValueOf()</code>
和 <code>reflect.TypeOf()</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// ValueOf returns a new Value initialized to the concrete value</span><br><span class="hljs-comment">// stored in the interface i.  ValueOf(nil) returns the zero </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ValueOf</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> Value &#123;...&#125;<br><br><span class="hljs-comment">//ValueOf用来获取输入参数接口中的数据的值，如果接口为空则返回0</span><br><br><br><span class="hljs-comment">// TypeOf returns the reflection Type that represents the dynamic type of i.</span><br><span class="hljs-comment">// If i is a nil interface value, TypeOf returns nil.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TypeOf</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> Type &#123;...&#125;<br><br><span class="hljs-comment">//TypeOf用来动态获取输入参数接口中的值的类型，如果接口为空则返回nil</span><br></code></pre></td></tr></table></figure>
<p><code>reflect.TypeOf()</code>是获取pair中的type，<code>reflect.ValueOf()</code>获取pair中的value，示例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> num <span class="hljs-type">float64</span> = <span class="hljs-number">1.2345</span><br><br>    fmt.Println(<span class="hljs-string">&quot;type: &quot;</span>, reflect.TypeOf(num))<br>    fmt.Println(<span class="hljs-string">&quot;value: &quot;</span>, reflect.ValueOf(num))<br>&#125;<br><br>运行结果:<br><span class="hljs-keyword">type</span>:  <span class="hljs-type">float64</span><br>value:  <span class="hljs-number">1.2345</span><br></code></pre></td></tr></table></figure>
<p>说明：</p>
<ol type="1">
<li><strong>reflect.TypeOf：</strong>
直接给到了我们想要的type类型，如float64、int、各种pointer、struct
等等真实的类型</li>
<li><strong>reflect.ValueOf：</strong>直接给到了我们想要的具体的值，如1.2345这个具体数值，或者类似&amp;{1
"Allen.Wu" 25} 这样的结构体struct的值</li>
<li>反射可以将“接口类型变量”转换为“反射类型对象”，反射类型指的是<code>reflect.Type</code>和<code>reflect.Value这</code>两种</li>
</ol>
<h4 id="reflet例子1">reflet例子1:</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reflectNum</span><span class="hljs-params">(arg <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>	fmt.Println(<span class="hljs-string">&quot;type:&quot;</span>, reflect.TypeOf(arg))<br>	fmt.Println(<span class="hljs-string">&quot;value:&quot;</span>, reflect.ValueOf(arg))<br>&#125;<br></code></pre></td></tr></table></figure>
<p>主函数的调用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">var</span> num <span class="hljs-type">float64</span> = <span class="hljs-number">1.2345</span><br>	reflectNum(num)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意，在使用反射之前需要引入<strong>reflect的包</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;reflect&quot;</span><br>)<br></code></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> num <span class="hljs-type">float64</span> = <span class="hljs-number">1.2345</span><br><br>    pointer := reflect.ValueOf(&amp;num)<br>    value := reflect.ValueOf(num)<br><br>    <span class="hljs-comment">// 可以理解为“强制转换”，但是需要注意的时候，转换的时候，如果转换的类型不完全符合，则直接panic</span><br>    <span class="hljs-comment">// Golang 对类型要求非常严格，类型一定要完全符合</span><br>    <span class="hljs-comment">// 如下两个，一个是*float64，一个是float64，如果弄混，则会panic</span><br>    convertPointer := pointer.Interface().(*<span class="hljs-type">float64</span>)<br>    convertValue := value.Interface().(<span class="hljs-type">float64</span>)<br><br>    fmt.Println(convertPointer)<br>    fmt.Println(convertValue)<br>&#125;<br><br>运行结果：<br><span class="hljs-number">0xc42000e238</span><br><span class="hljs-number">1.2345</span><br></code></pre></td></tr></table></figure>
<h4 id="reflet例子2">reflet例子2:</h4>
<ul>
<li><p>首先定义一个类以及关于这个类的方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>	Id   <span class="hljs-type">int</span><br>	Name <span class="hljs-type">string</span><br>	Age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this User)</span></span> Call() &#123; <span class="hljs-comment">//为什么这个地方返回类型不是*</span><br>	fmt.Println(<span class="hljs-string">&quot;user is called ..&quot;</span>)<br>	fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, this)<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>再定义一个利用反射选择类中值和方法的函数</p></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DoFiledAndMethod</span><span class="hljs-params">(input <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>	<span class="hljs-comment">//获取输入的类型type</span><br>	inputType := reflect.TypeOf(input)<br>	fmt.Println(<span class="hljs-string">&quot;input type is: &quot;</span>, inputType.Name())<br>	<span class="hljs-comment">//output: input type is:  User</span><br><br>	<span class="hljs-comment">//获取input的value</span><br>	inputValue := reflect.ValueOf(input)<br>	fmt.Println(<span class="hljs-string">&quot;input value is: &quot;</span>, inputValue)<br>	<span class="hljs-comment">//output: input value is:  &#123;1 eric 19&#125;</span><br><br>	<span class="hljs-comment">//通过type获取其中的字段</span><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">		1、获取interface中的reflect的type, 通过type得到numfield，进行遍历</span><br><span class="hljs-comment">		2、得到每个filed，就是数据类型</span><br><span class="hljs-comment">		3、通过filed中有一个interface()方法得到对应的value</span><br><span class="hljs-comment">	*/</span><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; inputType.NumField(); i++ &#123;<br>		field := inputType.Field(i)<br>		<span class="hljs-comment">// value:=inputType.Field&#123;i&#125;.interface()</span><br>		value := inputValue.Field(i).Interface()<br>		<span class="hljs-comment">// fmt.Println(field) //&#123;Id  int  0 [0] false&#125;、&#123;Name  string  8 [1] false&#125;</span><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">			每个field表示的就是一行的元素内容，其中Name表示了这一行的变量名， Type表示的是这一行的类型</span><br><span class="hljs-comment">			通过value单独存在field里面，根据索引值寻找通过Interface()调用</span><br><span class="hljs-comment">		*/</span><br>		fmt.Printf(<span class="hljs-string">&quot;%s: %v = %v\n&quot;</span>, field.Name, field.Type, value)<br><br>	&#125;<br><br>	<span class="hljs-comment">/* 如何遍历选择方法呢</span><br><span class="hljs-comment">	也是根据inputType来进行划分</span><br><span class="hljs-comment">	*/</span><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; inputType.NumMethod(); i++ &#123;<br>		m := inputType.Method(i)<br>		fmt.Printf(<span class="hljs-string">&quot;%s: %v\n&quot;</span>, m.Name, m.Type)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意点：</p>
<ol type="1">
<li><strong>reflect.TypeOf</strong>(input)得到类型</li>
<li><strong>reflect.ValueOf</strong>(input)得到对应的值</li>
<li><strong>reflect.TypeOf</strong>(input).<strong>NumField()</strong>的方法是获得interface()中的所有的字段</li>
<li>如果选择字段中的类型： <strong>inputType.Field(i) =
reflect.TypeOf(input).Field(i)</strong></li>
<li>如果选择字段中的值：<strong>inputType.Field(i) =
reflect.TypeOf(input).Field(i).Interface()</strong></li>
<li>如果想便利interface中的方法：<strong>reflect.TypeOf</strong>(input).<strong>NumMethod()</strong>，其中具体的方法是：<strong>reflect.TypeOf(input).Method(i)</strong></li>
</ol>
<p>通过运行结果可以得知获取未知类型的interface的所属方法（函数）的步骤为：</p>
<ol type="1">
<li>先获取interface的reflect.Type，然后通过NumMethod进行遍历</li>
<li>再分别通过reflect.Type的Method获取对应的真实的方法（函数）</li>
<li>最后对结果取其Name和Type得知具体的方法名</li>
<li>也就是说反射可以将“反射类型对象”再重新转换为“接口类型变量”</li>
<li>struct 或者 struct 的嵌套都是一样的判断处理方式</li>
</ol>
<h4
id="通过reflect.value设置实际变量的值">通过reflect.Value设置实际变量的值</h4>
<p>reflect.Value是通过reflect.ValueOf(X)获得的，只有当X是指针的时候，才可以通过reflec.Value修改实际变量X的值，即：要修改反射类型的对象就一定要保证其值是“addressable”的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-keyword">var</span> num <span class="hljs-type">float64</span> = <span class="hljs-number">1.2345</span><br>    fmt.Println(<span class="hljs-string">&quot;old value of pointer:&quot;</span>, num)<br><br>    <span class="hljs-comment">// 通过reflect.ValueOf获取num中的reflect.Value，注意，参数必须是指针才能修改其值</span><br>    pointer := reflect.ValueOf(&amp;num)<br>    newValue := pointer.Elem()<br><br>    fmt.Println(<span class="hljs-string">&quot;type of pointer:&quot;</span>, newValue.Type())<br>    fmt.Println(<span class="hljs-string">&quot;settability of pointer:&quot;</span>, newValue.CanSet())<br><br>    <span class="hljs-comment">// 重新赋值</span><br>    newValue.SetFloat(<span class="hljs-number">77</span>)<br>    fmt.Println(<span class="hljs-string">&quot;new value of pointer:&quot;</span>, num)<br><br>    <span class="hljs-comment">////////////////////</span><br>    <span class="hljs-comment">// 如果reflect.ValueOf的参数不是指针，会如何？</span><br>    pointer = reflect.ValueOf(num)<br>    <span class="hljs-comment">//newValue = pointer.Elem() // 如果非指针，这里直接panic，“panic: reflect: call of reflect.Value.Elem on float64 Value”</span><br>&#125;<br><br>运行结果：<br>old value of pointer: <span class="hljs-number">1.2345</span><br><span class="hljs-keyword">type</span> of pointer: <span class="hljs-type">float64</span><br>settability of pointer: <span class="hljs-literal">true</span><br><span class="hljs-built_in">new</span> value of pointer: <span class="hljs-number">77</span><br></code></pre></td></tr></table></figure>
<ol type="1">
<li>需要传入的参数是*
float64这个指针，然后可以通过pointer.Elem()去获取所指向的Value，<strong>注意一定要是指针</strong>。</li>
<li>如果传入的参数不是指针，而是变量，那么</li>
</ol>
<ul>
<li><ul>
<li>通过Elem获取原始值对应的对象则直接panic</li>
<li>通过CanSet方法查询是否可以设置返回false</li>
</ul></li>
</ul>
<ol type="1">
<li>newValue.CantSet()表示是否可以重新设置其值，如果输出的是true则可修改，否则不能修改，修改完之后再进行打印发现真的已经修改了。</li>
<li>reflect.Value.Elem()
表示获取原始值对应的反射对象，只有原始对象才能修改，当前反射对象是不能修改的，是指只能修改原是对象的<strong>值的大小，不能修改地址</strong></li>
<li>newValue.SetFloat(77)重新设置值的操作，传递引用来修改interface中的值</li>
</ol>
<h4 id="反射的基本原理">反射的基本原理</h4>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231219205804430.png"
alt="反射基本原理总结" />
<figcaption aria-hidden="true">反射基本原理总结</figcaption>
</figure>
<h3 id="section"></h3>
<h3 id="结构体标签">结构体标签</h3>
<p>本质上还是利用了反射，通过以下形式给结构体中的变量添加标签作用：
其他包在调用这个当前包的时候对于某个属性的一个说明，指示某个包在具体使用中的作用。</p>
<p><strong>作用：能够将结构体转化为json格式</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;reflect&quot;</span><br>)<br><span class="hljs-keyword">type</span> resume <span class="hljs-keyword">struct</span>&#123;<br>	<span class="hljs-comment">/*  </span><br><span class="hljs-comment">	通过以下形式给结构体中的变量添加标签</span><br><span class="hljs-comment">	作用： 其他包在调用这个当前包的时候对于某个属性的一个说明，指示某个包在具体使用中的作用</span><br><span class="hljs-comment">	*/</span><br>	Name <span class="hljs-type">string</span> <span class="hljs-string">`info:&quot;name&quot; doc:&quot;我的名字&quot;`</span> <br>	Sex <span class="hljs-type">string</span> <span class="hljs-string">`info:&quot;sex&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findtag</span><span class="hljs-params">(str <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span>&#123;<br>	t :=reflect.TypeOf(str).Elem()<br><br>	<span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;t.NumField();i++&#123;<br>		tagstring:=t.Field(i).Tag.Get(<span class="hljs-string">&quot;info&quot;</span>)<br>		tagdoc:=t.Field(i).Tag.Get(<span class="hljs-string">&quot;doc&quot;</span>)<br>		fmt.Println(<span class="hljs-string">&quot;info:&quot;</span>,tagstring,<span class="hljs-string">&quot;doc&quot;</span>,tagdoc)<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">var</span> re resume<br>	findtag(&amp;re) <span class="hljs-comment">//注意这里传递的是引用</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231207215501791.png" alt="go printf的占位符格式" style="zoom:67%;" /></p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231207215514980.png" alt="go printf的占位符表示" style="zoom:67%;" /></p>
<p>输出之后在json格式转换中可以看到如下，注意可以看到的是输出的内容是根据给定的tag来进行标题的命名的</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231207215859488.png" alt="转化为json格式的例子" style="zoom:67%;" /></p>
<p>利用反射取出元素查询</p>
<p>利用编码和解码对struct 和json之间的转化</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;encoding/json&quot;</span><br>)<br><br><span class="hljs-comment">//如何将结构体转化成json</span><br><span class="hljs-keyword">type</span> Movie <span class="hljs-keyword">struct</span>&#123;<br>	Title <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;title&quot;`</span>  <span class="hljs-comment">//就是告诉json库对应的变量的标签名字是这个</span><br>	Year <span class="hljs-type">int</span> <span class="hljs-string">`json:&quot;year&quot;`</span><br>	Price <span class="hljs-type">int</span> <span class="hljs-string">`json:&quot;rmb&quot;`</span><br>	Actors []<span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;actors&quot;`</span> <span class="hljs-comment">//slice `json:&quot;actors&quot;`</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	movie :=Movie&#123;<span class="hljs-string">&quot;喜剧之王&quot;</span>,<span class="hljs-number">2000</span>,<span class="hljs-number">10</span>,[]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;zhouxingchi&quot;</span>,<span class="hljs-string">&quot;zhangbozhi&quot;</span>&#125;&#125;<br><br>	<span class="hljs-comment">//编码的过程就是将 struct--&gt;json</span><br><br>	jsonStr,err:=json.Marshal(movie)<br><br>	<span class="hljs-comment">//返回两个字段</span><br><br>	<span class="hljs-keyword">if</span> err!=<span class="hljs-literal">nil</span>&#123;<br>		fmt.Println(<span class="hljs-string">&quot;json marshal error&quot;</span>,err)<br>		<span class="hljs-keyword">return</span><br>	&#125;<br>	fmt.Printf(<span class="hljs-string">&quot;jsonStr=%s\n&quot;</span>,jsonStr )<br>	<span class="hljs-comment">/* jsonStr=&#123;&quot;title&quot;:&quot;喜剧之王&quot;,&quot;year&quot;:2000,&quot;rmb&quot;:10,&quot;Actors&quot;:[&quot;zhouxingchi&quot;,&quot;zhangbozhi&quot;]&#125; */</span><br><br>	<span class="hljs-comment">//解码过程：json--&gt;struct</span><br>	<span class="hljs-comment">//jsonStr=&#123;&quot;title&quot;:&quot;喜剧之王&quot;,&quot;year&quot;:2000,&quot;rmb&quot;:10,&quot;actors&quot;:[&quot;zhouxingchi&quot;,&quot;zhangbozhi&quot;]&#125;</span><br><br>	myMovie:=Movie&#123;&#125;<br>	<span class="hljs-comment">//注意这个地方传递的参量是引用</span><br>	err=json.Unmarshal(jsonStr,&amp;myMovie)<br>	<span class="hljs-keyword">if</span> err!=<span class="hljs-literal">nil</span>&#123;<br>		fmt.Println(<span class="hljs-string">&quot;json unmashal error&quot;</span>,err)<br>		<span class="hljs-keyword">return</span> <br>	&#125;<br>	fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>,myMovie)<br>	<span class="hljs-comment">//返回结构体</span><br>	<span class="hljs-comment">//&#123;喜剧之王 2000 10 [zhouxingchi zhangbozhi]&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>【后端开发】Golang协程与Channel</title>
    <url>/2023/12/19/goroutine/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>
<h1 id="golang进阶">Golang进阶</h1>
<p>这一部分主要介绍golang中的并发，并发是 golang 的优势之一，使用关键字
go 可以很方便的开启一个<strong>协程</strong>. go 语言中，常常用
<strong>go</strong>、<strong>chan</strong>、<strong>select</strong> 及
<strong>sync
库</strong>完成并发操作，处理<strong>同步</strong>、<strong>异步</strong>、<strong>阻塞</strong>、<strong>非阻塞</strong>任务</p>
<p>go 语言的并发编程，以下是需要了解的基础知识点</p>
<ul>
<li><strong>阻塞</strong>:
阻塞是进程(也可以是线程、协程)的状态之一（新建、就绪、运行、阻塞、终止).
指的是当数据未准备就绪，这个进程(线程、协程)一直等待，这就是阻塞.</li>
<li><strong>非阻塞</strong>:
当数据为准备就绪，该进程(线程、协程)不等待可以继续执行，这就是非阻塞.</li>
<li><strong>同步</strong>:
在发起一个调用时，在没有得到结果之前，这个调用就不返回，这个调用过程一直在等待.
这是同步.</li>
<li><strong>异步</strong>:
在发起调用后，就立刻返回了，这次调用过程就结束了.
等到有结果了被调用方主动通知调用者结果. 这是异步</li>
<li><strong>goroutine</strong>: 通过关键字 go 即可创建一个协程.</li>
<li><strong>chan :</strong> golang
中用于并发的通道，用于协程的通信.</li>
</ul>
<h2 id="goroutine协程">Goroutine协程</h2>
<p>协程并发，coroutine，也叫轻量级线程。</p>
<p>与传统的系统级线程和进程相比，协程最大的优势在于“轻量级”。可以轻松创建上万个而不会导致系统资源衰竭。</p>
<p>一个线程中可以有任意多个协程，但某一时刻只能有一个协程在运行，<strong>多个协程分享该线程分配到的计算机资源</strong>。</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231207223749991-20231219211513985.png" alt="传统的线程调度方式" style="zoom:80%;" /></p>
<p>存在切换成本，存储当前的线程的状态</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231207223845618.png"
alt="CPU切换造成的时间消耗" />
<figcaption aria-hidden="true">CPU切换造成的时间消耗</figcaption>
</figure>
<p>在协程中，调用一个任务就像调用一个函数一样，消耗的系统资源最少！但能达到进程、线程并发相同的效果。</p>
<p>在一次并发任务中，进程、线程、协程均可以实现。从系统资源消耗的角度出发来看，进程相当多，线程次之，协程最少</p>
<h3 id="goroutine基本模型">Goroutine基本模型</h3>
<p>线程数量越多会导致切换成本越大越容易造成浪费</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231210220547247.png" alt="CPU管理协程的具体细节" style="zoom:67%;" /></p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231210220633895.png" alt="早期调度器的方式" style="zoom:67%;" /></p>
<p>老式调度器的缺点：</p>
<ul>
<li>创建、销毁、调度G都需要每个M获取锁，这就形成了<strong>激烈的锁竞争</strong></li>
<li>M转移G会造成<strong>延迟和额外的系统负载</strong></li>
<li>系统调用(CPU在M之间的切换)
导致频繁的线程阻塞和取消阻塞操作<strong>增加了系统开销</strong></li>
</ul>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231210221404383.png" alt="调度器设计的准则" style="zoom:67%;" /></p>
<h3 id="goroutine的定义">Goroutine的定义</h3>
<p>goroutine是Go语言并行设计的核心，有人称之为go程。
Goroutine从量级上看很像协程，它比线程更小，十几个goroutine可能体现在底层就是五六个线程，Go语言内部帮你实现了这些goroutine之间的内存共享。执行goroutine只需极少的栈内存(大概是4~5KB)，当然会根据相应的数据伸缩。也正因为如此，可同时运行成千上万个并发任务。goroutine比thread更易用、更高效、更轻便。</p>
<p>一般情况下，一个普通计算机跑几十个线程就有点负载过大了，但是同样的机器却可以轻松地让成百上千个goroutine进行资源竞争。</p>
<h3 id="创建goroutine">创建Goroutine</h3>
<p>只需在函数调⽤语句前添加 <strong>go</strong>
关键字，就可创建并发执⾏单元。在并发编程中，我们通常想将一个过程切分成几块，然后让每个goroutine各自负责一块工作，当一个程序启动时，主函数在一个单独的goroutine中运行，我们叫它main
goroutine。</p>
<p>示例代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newTask</span><span class="hljs-params">()</span></span> &#123;<br>    i := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        i++<br>        fmt.Printf(<span class="hljs-string">&quot;new goroutine: i = %d\n&quot;</span>, i)<br>        time.Sleep(<span class="hljs-number">1</span>*time.Second) <span class="hljs-comment">//延时1s</span><br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//创建一个 goroutine，启动另外一个任务</span><br>    <span class="hljs-keyword">go</span> newTask()<br>    i := <span class="hljs-number">0</span><br>    <span class="hljs-comment">//main goroutine 循环打印</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        i++<br>        fmt.Printf(<span class="hljs-string">&quot;main goroutine: i = %d\n&quot;</span>, i)<br>        time.Sleep(<span class="hljs-number">1</span> * time.Second) <span class="hljs-comment">//延时1s</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">main Goroutine: i=1<br>new Goroutine: i =2<br>new Goroutine: i =3<br>main Goroutine: i=2<br>main Goroutine: i=3<br>new Goroutine: i =4<br>new Goroutine: i =5<br></code></pre></td></tr></table></figure>
<h3 id="goroutine特性">Goroutine特性</h3>
<p><strong>主goroutine退出后，其它的工作goroutine也会自动退出：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newTask</span><span class="hljs-params">()</span></span> &#123;<br>    i := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        i++<br>        fmt.Printf(<span class="hljs-string">&quot;new goroutine: i = %d\n&quot;</span>, i)<br>        time.Sleep(<span class="hljs-number">1</span> * time.Second) <span class="hljs-comment">//延时1s</span><br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//创建一个 goroutine，启动另外一个任务</span><br>    <span class="hljs-keyword">go</span> newTask()<br> <br>    fmt.Println(<span class="hljs-string">&quot;main goroutine exit&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231219213501210.png" alt="主进程结束那么其余的goroutine结束" style="zoom:67%;" /></p>
<h3 id="goexit函数">Goexit函数</h3>
<p>调用 runtime.Goexit() 将立即终止当前 goroutine
执⾏，调度器确保所有已注册 defer 延迟调用被执行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;runtime&quot;</span><br>)<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;A.defer&quot;</span>)<br> <br>        <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;B.defer&quot;</span>)<br>            runtime.Goexit() <span class="hljs-comment">// 终止当前 goroutine, import &quot;runtime&quot;</span><br>            fmt.Println(<span class="hljs-string">&quot;B&quot;</span>) <span class="hljs-comment">// 不会执行</span><br>        &#125;()<br> <br>        fmt.Println(<span class="hljs-string">&quot;A&quot;</span>) <span class="hljs-comment">// 不会执行</span><br>    &#125;()       <span class="hljs-comment">//不要忘记()</span><br> <br>    <span class="hljs-comment">//死循环，目的不让主goroutine结束</span><br>    <span class="hljs-keyword">for</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231219214022511.png" alt="image-20231219214022511" style="zoom:67%;" /></p>
<p>对于goroutine的形式没办法拿到协程返回的值
，从而阻塞了两个协程之间的通信，因此有必要研究如何让两个协程进行通信的机制因此这个地方引入了</p>
<h2 id="channel管道">Channel管道</h2>
<p>channel是Go语言中的一个<strong>核心类型</strong>，可以把它看成管道。并发核心单元通过它就可以发送或者接收数据进行通讯</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231213150125899.png" alt="go语言之间的goroutine通信机制" style="zoom:80%;" /></p>
<p>channel是一个数据类型，主要用来解决go程的同步问题以及go程之间数据共享（数据传递）的问题。引⽤类型
channel可用于<strong>多个 goroutine
通讯。其内部实现了同步，确保并发安全</strong>。</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231213150927632.png"
alt="基于channel的同步并发安全" />
<figcaption aria-hidden="true">基于channel的同步并发安全</figcaption>
</figure>
<p>这个channel在这个位置就已经隐含表示了先后执行的关系</p>
<ul>
<li>如果main.go在运行的时候如果找不到
channel返回的值，那么就会channel让main.go产生阻塞，</li>
<li>同理对于另一边的sub.go也是一样，如果没有另一个goroutine来接受发出的channel数据，那么就会一直处于等待接受的状态产生阻塞，</li>
<li><strong>相当于首先得握上手才能继续执行进程</strong></li>
</ul>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231213151022873.png" alt="主goroutine发生阻塞" style="zoom:67%;" /></p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231213151129109.png" alt="子进程发生阻塞" style="zoom:67%;" /></p>
<h3 id="定义channel基本语法">定义channel基本语法</h3>
<p>定义一个channel时，也需要定义发送到channel的值的类型。channel可以使用内置的<strong>make()函数</strong>来创建：</p>
<p><strong>chan</strong>是创建channel所需使用的关键字。Type
代表指定channel收发数据的类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Type)  <span class="hljs-comment">//等价于make(chan Type, 0)</span><br><span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Type, capacity)<br></code></pre></td></tr></table></figure>
<p>当 参数<code>capacity= 0</code> 时，channel
是<strong>无缓冲阻塞</strong>读写的；当<code>capacity &gt; 0</code>
时，channel <strong>有缓冲非阻塞的</strong>，直到写满
capacity个元素才阻塞写入。</p>
<p>channel非常像生活中的管道，一边可以存放东西，另一边可以取出东西。channel通过操作符
<code>&lt;-</code>
来接收和发送数据，<strong>发送和接收</strong>数据语法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">channel &lt;- value      <span class="hljs-comment">//发送value到channel</span><br>&lt;-channel             <span class="hljs-comment">//接收并将其丢弃</span><br>x := &lt;-channel        <span class="hljs-comment">//从channel中接收数据，并赋值给x</span><br>x, ok := &lt;-channel    <span class="hljs-comment">//功能同上，同时检查通道是否已关闭或者是否为空</span><br></code></pre></td></tr></table></figure>
<p>默认情况下，channel接收和发送数据都是阻塞的，除非另一端已经准备好，这样就使得goroutine同步变的更加的简单，而<strong>不需要显式的lock。</strong></p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br> <br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;子go程结束&quot;</span>)<br> <br>        fmt.Println(<span class="hljs-string">&quot;子go程正在运行……&quot;</span>)<br> <br>        c &lt;- <span class="hljs-number">666</span> <span class="hljs-comment">//666发送到c</span><br>    &#125;()<br> <br>    num := &lt;-c <span class="hljs-comment">//从c中接收数据，并赋值给num</span><br> <br>    fmt.Println(<span class="hljs-string">&quot;num = &quot;</span>, num)<br>    fmt.Println(<span class="hljs-string">&quot;main go程结束&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">goroutine 正在运行...<br>goroutine结束<br>num =  666<br>main goroutine 结束...<br></code></pre></td></tr></table></figure>
<p>分析：</p>
<ul>
<li>首先第一步会需要子进程将666放进channel中才不会发生阻塞，同时主进程会在
<code>num := &lt;-c</code>的位置进行等待channel中传入数据</li>
<li>当channel中出现了数据之后，那么下一步就是从中选择数据并进行赋值</li>
<li>最后结束</li>
</ul>
<h3 id="channel的无缓冲阻塞">channel的无缓冲阻塞</h3>
<p>无缓冲的通道（unbuffered
channel）是指在接收前没有能力保存任何数据值的通道。</p>
<p>这种类型的通道要求发送goroutine和接收goroutine同时准备好，才能完成发送和接收操作。否则，通道会导致先执行发送或接收操作的
goroutine 阻塞等待。</p>
<p><strong>阻塞：</strong>由于某种原因数据没有到达，当前go程（线程）持续处于等待状态，直到条件满足，才解除阻塞。</p>
<p><strong>同步：</strong>在两个或多个go程（线程）间，保持数据内容一致性的机制。</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231213151511356.png"
alt="无缓冲的channel同步" />
<figcaption aria-hidden="true">无缓冲的channel同步</figcaption>
</figure>
<p>如果两个goroutine存在利用channel通信的情况，两个goroutine之间存在相互的消息传递，那么在无缓冲的情况下，存在隐含的先后同步关系，必须接收方到达了channel之后消息发送方才会持续发送消息并往下运行</p>
<ul>
<li>在第 1 步，两个 goroutine
都到达通道，但哪个都没有开始执行发送或者接收。</li>
<li>在第 2 步，左侧的 goroutine
将它的手伸进了通道，这模拟了向通道发送数据的行为。这时，这个 goroutine
会在通道中被锁住，直到交换完成。</li>
<li>在第 3 步，右侧的 goroutine
将它的手放入通道，这模拟了从通道里接收数据。这个 goroutine
一样也会在通道中被锁住，直到交换完成。</li>
<li>在第 4 步和第 5 步，进行交换，并最终，在第 6 步，两个 goroutine
都将它们的手从通道里拿出来，这模拟了被锁住的 goroutine 得到释放。两个
goroutine 现在都可以去做其他事情了。</li>
</ul>
<p>无缓冲的channel创建格式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Type)   <span class="hljs-comment">//等价于make(chan Type, 0)</span><br></code></pre></td></tr></table></figure>
<p>如果<strong>没有指定缓冲区容量</strong>，那么该通道就是同步的，因此会阻塞到发送者准备好发送和接收者准备好接收。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">//创建无缓冲的通道 c </span><br> <br>    <span class="hljs-comment">//内置函数 len 返回未被读取的缓冲元素数量，cap 返回缓冲区大小</span><br>    fmt.Printf(<span class="hljs-string">&quot;len(c)=%d, cap(c)=%d\n&quot;</span>, <span class="hljs-built_in">len</span>(c), <span class="hljs-built_in">cap</span>(c))<br> <br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;子go程结束&quot;</span>)<br> <br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br>            c &lt;- i<br>            fmt.Printf(<span class="hljs-string">&quot;子go程正在运行[%d]: len(c)=%d, cap(c)=%d\n&quot;</span>, i, <span class="hljs-built_in">len</span>(c), <span class="hljs-built_in">cap</span>(c))<br>        &#125;<br>    &#125;()<br> <br>    time.Sleep(<span class="hljs-number">2</span> * time.Second) <span class="hljs-comment">//延时2s</span><br> <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br>        num := &lt;-c <span class="hljs-comment">//从c中接收数据，并赋值给num</span><br>        fmt.Println(<span class="hljs-string">&quot;num = &quot;</span>, num)<br>    &#125;<br> <br>    fmt.Println(<span class="hljs-string">&quot;main进程结束&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>那么运行的结果是：</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231219220132461.png" alt="无缓冲channel的运行结果" style="zoom:67%;" /></p>
<p>分析：</p>
<ul>
<li>本质上会出现阻塞，如果没有及时把数据拿出</li>
<li>因此必须是其中一个放进去数据，另一个拿出数据才能能让进程执行下去，本质上保证了同步的进行</li>
</ul>
<h3 id="channel的有缓冲阻塞">channel的有缓冲阻塞</h3>
<blockquote>
<p><strong>本质上是生产者消费者模型 消息队列模型</strong></p>
</blockquote>
<p>这种类型的通道并不强制要求 goroutine
之间必须同时完成发送和接收。通道会阻塞发送和接收动作的条件也不同。</p>
<p>只有通道中没有要接收的值时，接收动作才会阻塞。只有通道没有可用缓冲区容纳被发送的值时，发送动作才会阻塞。</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231219220401111.png"
alt="有缓冲的通道在channe之间同步数据" />
<figcaption
aria-hidden="true">有缓冲的通道在channe之间同步数据</figcaption>
</figure>
<ul>
<li>在第 1 步，右侧的 goroutine 正在从通道接收一个值。</li>
<li>在第 2 步，右侧的这个 goroutine独立完成了接收值的动作，而左侧的
goroutine 正在发送一个新值到通道里。</li>
<li>在第 3 步，左侧的goroutine 还在向通道发送新值，而右侧的 goroutine
正在从通道接收另外一个值。这个步骤里的两个操作<strong>既不是同步的，也不会互相阻塞</strong>。</li>
<li>最后，在第 4
步，所有的发送和接收都完成，而通道里还有几个值，也有一些空间可以存更多的值。</li>
</ul>
<p><strong>有缓冲的channel创建格式：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Type, capacity)<br></code></pre></td></tr></table></figure>
<p>如果给定了一个缓冲区容量，通道就是异步的。只要缓冲区有未使用空间用于发送数据，或还包含可以接收的数据，那么其通信就会无阻塞地进行。</p>
<p><strong>函数 len(ch)求取缓冲区中剩余元素个数， cap(ch)
求取缓冲区元素容量大小</strong></p>
<p>示例代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span>  <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> ,<span class="hljs-number">3</span>) <span class="hljs-comment">//带有缓冲的channel</span><br><br>	<span class="hljs-comment">//查看当前的channel中的缓冲的容量大小</span><br>	<span class="hljs-comment">//len表示的是元素数量 cap表示的是缓冲的容量大小</span><br>	fmt.Println(<span class="hljs-string">&quot;len(c) = &quot;</span>, <span class="hljs-built_in">len</span>(c), <span class="hljs-string">&quot;, cap(c)&quot;</span>, <span class="hljs-built_in">cap</span>(c))<br><br>	<span class="hljs-comment">//定义一个子goroutine</span><br>	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>		<span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;sub goroutine结束&quot;</span>)<br>		<br>		<span class="hljs-comment">// for i := 0; i&lt;3; i++&#123;</span><br>		<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">4</span>; i++&#123;<span class="hljs-comment">// 这种情况就会出现阻塞，因为超过了缓冲的容量</span><br>			c &lt;- i<br>			fmt.Println(<span class="hljs-string">&quot;sub goroutine 正在运行: len(c) = &quot;</span>, <span class="hljs-built_in">len</span>(c), <span class="hljs-string">&quot;, cap(c) =  &quot;</span>, <span class="hljs-built_in">cap</span>(c),<span class="hljs-string">&quot; 发送的元素是= &quot;</span>,i)<br>		&#125;<br>	&#125;()<br><br>	time.Sleep(<span class="hljs-number">1</span>*time.Second)<br><br>	<span class="hljs-comment">//有缓存的话就不会出现阻塞的情况</span><br><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">3</span>;i++&#123;<br>		num := &lt;-c <span class="hljs-comment">//从c中接受数据并赋值给num</span><br>		fmt.Println(<span class="hljs-string">&quot;num = &quot;</span>, num)<br>	&#125;<br>	fmt.Println(<span class="hljs-string">&quot;main 结束&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231219220650672.png"
alt="有缓冲通道的运行结果" />
<figcaption aria-hidden="true">有缓冲通道的运行结果</figcaption>
</figure>
<h3 id="关闭channel">关闭Channel</h3>
<p>没有更多的值需要发送到channel的话，那么让接收者也能及时知道没有多余的值可接收将是有用的，因为接收者可以停止不必要的接收等待。这可以通过内置的<code>close</code>函数来关闭channel实现。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>) <span class="hljs-comment">//channel要通过make来触发，如果是nil channel 会发生阻塞</span><br><br>	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>		<span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;sub finished ...&quot;</span>)<br>		<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++&#123;<br>			c &lt;- i<br>			<span class="hljs-comment">// close(c)</span><br>			<span class="hljs-comment">//如果向已经关闭的channel发送数据就会出现panic的错误</span><br>		&#125;<br>		<span class="hljs-comment">// close 关闭一个channel</span><br>		<span class="hljs-built_in">close</span>(c)<br>		<span class="hljs-comment">//如果去掉关闭channel这个开关，那么会出现死锁的情况，就是main的进程数据都在等待塞数据</span><br>	&#125;()<br><br>	<span class="hljs-keyword">for</span>&#123;<br>		<span class="hljs-comment">//如果ok为ture 那么channel没有关闭, 如果为false 那么已经被关闭</span><br>		<span class="hljs-keyword">if</span> data, ok := &lt;-c; ok&#123;<br>			fmt.Println(data)<br>		&#125;<span class="hljs-keyword">else</span>&#123;<br>			<span class="hljs-keyword">break</span><br>		&#125;<br>	&#125;<br><br>	fmt.Println(<span class="hljs-string">&quot;Main finished ...&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出的结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">/* 输出的值go run channel4.go<br>0<br>1<br>2<br>3<br>4<br>Main finished ...<br>sub finished ... */<br></code></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>channel不像文件一样需要经常去关闭，只有当你确实没有任何发送数据了，或者你想显式的结束range循环之类的，才去关闭channel；</li>
<li>如果向已经关闭的channel发送数据就会出现panic的错误</li>
<li>关闭channel后，可以继续从channel接收数据；</li>
<li>如果ok为ture 那么channel没有关闭, 如果为false 那么已经被关闭</li>
<li>对于nil channel，无论收发都会被阻塞。</li>
</ul>
<h3 id="range操作channel">Range操作channel</h3>
<p>可以使用 <strong>range</strong> 来迭代不断操作channel：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br> <br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>            c &lt;- i<br>        &#125;<br>        <span class="hljs-built_in">close</span>(c)<br>    &#125;()<br> <br>    <span class="hljs-keyword">for</span> data := <span class="hljs-keyword">range</span> c &#123;<br>        fmt.Println(data)<br>    &#125;<br>    fmt.Println(<span class="hljs-string">&quot;Finished&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li><p>利用range进行简写</p></li>
<li><p>利用range不断迭代从channel中操作数据</p></li>
</ul>
<h3 id="单向channel">单向Channel</h3>
<p>默认情况下，通道channel是双向的，也就是，既可以往里面发送数据也可以同里面接收数据。</p>
<p>但是，我们经常见一个通道作为参数进行传递而只希望对方是单向使用的，要么只让它发送数据，要么只让它接收数据，这时候我们可以指定通道的方向。</p>
<p>单向channel的定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ch1 <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>       <span class="hljs-comment">// ch1是一个正常的channel，是双向的</span><br><span class="hljs-keyword">var</span> ch2 <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">float64</span> <span class="hljs-comment">// ch2是单向channel，只用于写float64数据</span><br><span class="hljs-keyword">var</span> ch3 &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>     <span class="hljs-comment">// ch3是单向channel，只用于读int数据</span><br></code></pre></td></tr></table></figure>
<p>可以将 channel 隐式转换为单向队列，只收或只发，不能将单向 channel
转换为普通 channel：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">3</span>)<br><span class="hljs-keyword">var</span> send <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span> = c <span class="hljs-comment">// send-only</span><br><span class="hljs-keyword">var</span> recv &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> = c <span class="hljs-comment">// receive-only</span><br>send &lt;- <span class="hljs-number">1</span><br><span class="hljs-comment">//&lt;-send //invalid operation: &lt;-send (receive from send-only type chan&lt;- int)</span><br>&lt;-recv<br><span class="hljs-comment">//recv &lt;- 2 //invalid operation: recv &lt;- 2 (send to receive-only type &lt;-chan int)</span><br> <br><span class="hljs-comment">//不能将单向 channel 转换为普通 channel</span><br>d1 := (<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)(send) <span class="hljs-comment">//cannot convert send (type chan&lt;- int) to type chan int</span><br>d2 := (<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)(recv) <span class="hljs-comment">//cannot convert recv (type &lt;-chan int) to type chan int</span><br></code></pre></td></tr></table></figure>
<p>单向channel的示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//   chan&lt;- //只写</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">counter</span><span class="hljs-params">(out <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(out)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>        out &lt;- i <span class="hljs-comment">//如果对方不读 会阻塞</span><br>    &#125;<br>&#125;<br> <br><span class="hljs-comment">//   &lt;-chan //只读</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printer</span><span class="hljs-params">(in &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> num := <span class="hljs-keyword">range</span> in &#123;<br>        fmt.Println(num)<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>) <span class="hljs-comment">//   chan   //读写</span><br> <br>    <span class="hljs-keyword">go</span> counter(c) <span class="hljs-comment">//生产者</span><br>    printer(c)    <span class="hljs-comment">//消费者</span><br> <br>    fmt.Println(<span class="hljs-string">&quot;done&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="channel的select">Channel的Select</h2>
<h3 id="select基本定义">Select基本定义</h3>
<p>Go里面提供了一个关键字select，通过select可以监听channel上的数据流动。每个case表示监控不同的条件.
通过select来进行控制。</p>
<p>select有比较多的限制，其中最大的一条限制就是每个<strong>case语句里必须是一个IO操作</strong>，大致的结构如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;- chan1:<br>    <span class="hljs-comment">// 如果chan1成功读到数据，则进行该case处理语句</span><br><span class="hljs-keyword">case</span> chan2 &lt;- <span class="hljs-number">1</span>:<br>    <span class="hljs-comment">// 如果成功向chan2写入数据，则进行该case处理语句</span><br><span class="hljs-keyword">default</span>:<br>    <span class="hljs-comment">// 如果上面都没有成功，则进入default处理流程</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>在一个select语句中，Go语言会按顺序<strong>从头至尾</strong>评估每一个发送和接收的语句。如果其中的<strong>任意一语句可以继续执行</strong>(即没有被阻塞)，那么就从那些可以执行的语句中任意选择一条来使用。</p>
<p>如果<strong>没有任意一条语句可以执行</strong>(即所有的通道都被阻塞)，那么有两种可能的情况：</p>
<ol type="1">
<li>如果给出了default语句，那么就会执行default语句，同时程序的执行会从select语句后的语句中恢复</li>
<li>如果没有default语句，那么select语句将被阻塞，直到至少有一个通信可以进行下去</li>
</ol>
<p>下面是<strong>示例代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">(c, quit <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>    x, y := <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> c &lt;- x:<br>            x, y = y, x+y<br>        <span class="hljs-keyword">case</span> &lt;-quit:<br>            fmt.Println(<span class="hljs-string">&quot;quit&quot;</span>)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    quit := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br> <br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++ &#123;<br>            fmt.Println(&lt;-c)<br>        &#125;<br>        quit &lt;- <span class="hljs-number">0</span><br>    &#125;()<br> <br>    fibonacci(c, quit)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行的结果：</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231220211918321.png" alt="执行的结果" style="zoom:70%;" /></p>
<h3 id="交替打印数字字母">交替打印数字字母</h3>
<p>需求：反复打印数字1字母a-&gt;1a2b3c4d5e...依次类推</p>
<p>思路：选择两个goroutine来实现这部分的内容，产生阻塞的条件是一个进程需要取数，一个goroutine需要存数来进行阻塞</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><br>	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">26</span>; i++ &#123;<br>			&lt;-c<br>			fmt.Println(<span class="hljs-type">string</span>(<span class="hljs-number">96</span> + i))<br>			c &lt;- <span class="hljs-number">0</span><br>		&#125;<br>	&#125;()<br><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">26</span>; i++ &#123;<br>			fmt.Println(i)<br>			c &lt;- <span class="hljs-number">0</span><br>			&lt;-c<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>打印的结果是：</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231220214320935.png" alt="数字字母交替打印" style="zoom:70%;" /></p>
]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法题】LeetCode算法汇总</title>
    <url>/2024/01/01/leetcode/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>
<h1 id="语言细节">语言细节</h1>
<p>vector的长度：</p>
<ul>
<li>C++：nums.size()</li>
<li>Python：len(nums)</li>
<li>GO：len(nums)</li>
</ul>
<p>初始化数组：</p>
<ul>
<li>C++：array[n]={0} 让所有元素都是0</li>
</ul>
<p>构造vector:</p>
<ul>
<li>C++：vector result(长度，元素)</li>
<li>Python：res = [float('inf')] * len(nums)</li>
<li>GO：=make([]int，n)</li>
</ul>
<p>for循环：</p>
<ul>
<li>C++：条件小括号+循环体中括号</li>
<li>Python：冒号且不需要小括号包条件</li>
<li>GO：循环体中括号，条件按照C++写但是不需要小括号</li>
</ul>
<h1 id="数组">数组</h1>
<h3 id="二分查找">二分查找</h3>
<p><strong>题目描述</strong></p>
<p>链接：<a
href="https://leetcode.cn/problems/binary-search/description/">https://leetcode.cn/problems/binary-search/description/</a></p>
<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target
，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回
-1。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="hljs-section">输出: 4</span><br><span class="hljs-section">解释: 9 出现在 nums 中并且下标为 4</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="hljs-section">输出: -1</span><br><span class="hljs-section">解释: 2 不存在 nums 中因此返回 -1</span><br></code></pre></td></tr></table></figure>
<p><strong>思路</strong></p>
<p>题目表示的是有序数组，而且题目没有重复元素。在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是<strong>循环不变量</strong>规则</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>  <span class="hljs-comment"># 定义target在左闭右闭的区间里，[left, right]</span><br><br>        <span class="hljs-keyword">while</span> left &lt;= right:<br>            middle = left + (right - left) // <span class="hljs-number">2</span><br>            <br>            <span class="hljs-keyword">if</span> nums[middle] &gt; target:<br>                right = middle - <span class="hljs-number">1</span>  <span class="hljs-comment"># target在左区间，所以[left, middle - 1]</span><br>            <span class="hljs-keyword">elif</span> nums[middle] &lt; target:<br>                left = middle + <span class="hljs-number">1</span>  <span class="hljs-comment"># target在右区间，所以[middle + 1, right]</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> middle  <span class="hljs-comment"># 数组中找到目标值，直接返回下标</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>  <span class="hljs-comment"># 未找到目标值</span><br></code></pre></td></tr></table></figure>
<p>注意这里给出的题解法：当
<code>left &lt;= right</code>的时候，以下的条件中全部都不取到等号
<code>nums[middle] &gt; target nums[middle] &lt; target</code></p>
<p>需要注意的是：<code>right=nums.size()-1</code></p>
<p>C++版本</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)<br>        &#123;<br>            <span class="hljs-comment">// int middle = (left+right)/2; 这样写会溢出</span><br>            <span class="hljs-type">int</span> middle = left + ((right - left) / <span class="hljs-number">2</span>);<br>            <span class="hljs-keyword">if</span>(nums[middle]&gt;target)<br>            &#123;<br>                right = middle<span class="hljs-number">-1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[middle]&lt;target)<br>            &#123;<br>                left = middle+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> middle;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>Go版本</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    right:=<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span><br>    left:=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> left&lt;=right&#123;<br>        middle:= left+(right-left)/<span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[middle]&lt;target&#123;<br>            left = middle+<span class="hljs-number">1</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[middle]&gt;target&#123;<br>            right = middle<span class="hljs-number">-1</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> middle<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="移除元素">移除元素</h3>
<p><a
href="https://leetcode.cn/problems/remove-element/description/">https://leetcode.cn/problems/remove-element/description/</a></p>
<p><strong>题目描述</strong></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,2,3]</span>, val = 3<br>输出：2, nums = <span class="hljs-comment">[2,2]</span><br>解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = <span class="hljs-comment">[2,2,3,3]</span> 或 nums = <span class="hljs-comment">[2,2,0,0]</span>，也会被视作正确答案。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">0,1,2,2</span>,<span class="hljs-number">3,0,4,2</span>], val = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">5</span>, nums = [<span class="hljs-number">0,1,3,0</span>,<span class="hljs-number">4</span>]<br>解释：函数应该返回新的长度 <span class="hljs-number">5</span>, 并且 nums 中的前五个元素为 <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。<br></code></pre></td></tr></table></figure>
<p><strong>思路</strong></p>
<p>双指针法（快慢指针法）：
<strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p>
<p>定义快慢指针</p>
<ul>
<li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li>
<li>慢指针：指向更新 新数组下标的位置</li>
</ul>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240111141316267.png" alt="双指针题解" style="zoom:67%;" /></p>
<p>C++版本</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-type">int</span> slowindex=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fastindex = <span class="hljs-number">0</span>; fastindex&lt;nums.<span class="hljs-built_in">size</span>();fastindex++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(val!=nums[fastindex])&#123;<br>                nums[slowindex] = nums[fastindex];<br>                slowindex++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slowindex;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>python版本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeElement</span>(<span class="hljs-params">self, nums, val</span>):<br>        slowindex=<span class="hljs-number">0</span><br>        fastindex=<span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> fastindex&lt;<span class="hljs-built_in">len</span>(nums):<br>            <span class="hljs-keyword">if</span> val!=nums[fastindex]:<br>                nums[slowindex]=nums[fastindex]<br>                slowindex = slowindex+<span class="hljs-number">1</span><br>            fastindex+=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> slowindex        <br></code></pre></td></tr></table></figure>
<p>GO版本：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, val <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    slow:=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;<br>        <span class="hljs-keyword">if</span> nums[i]!=val&#123;<br>            nums[slow]=nums[i]<br>            slow++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="有序数组的平方">有序数组的平方</h3>
<p><a
href="https://leetcode.cn/problems/squares-of-a-sorted-array/">https://leetcode.cn/problems/squares-of-a-sorted-array/</a></p>
<p><strong>题目描述</strong></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><code class="hljs dns">输入：nums = [-<span class="hljs-number">4</span>,-<span class="hljs-number">1,0,3,10</span>]<br>输出：[<span class="hljs-number">0,1,9,16</span>,<span class="hljs-number">100</span>]<br>解释：平方后，数组变为 [<span class="hljs-number">16,1,0,9</span>,<span class="hljs-number">100</span>]<br>排序后，数组变为 [<span class="hljs-number">0,1,9,16</span>,<span class="hljs-number">100</span>]<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><code class="hljs dns">输入：nums = [-<span class="hljs-number">7</span>,-<span class="hljs-number">3,2,3,11</span>]<br>输出：[<span class="hljs-number">4,9,9,49</span>,<span class="hljs-number">121</span>]<br></code></pre></td></tr></table></figure>
<p><strong>思路</strong></p>
<p>双指针法，首尾遍历比较并存储</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240111144022821.png"
alt="双指针遍历存储" />
<figcaption aria-hidden="true">双指针遍历存储</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(nums.size(),<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> j = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> k =j;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ;i&lt;=j;)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i]*nums[i]&gt;nums[j]*nums[j])&#123;<br>                result[k--]= nums[i]*nums[i];<br>                i++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                result[k--]= nums[j]*nums[j];<br>                j--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>Python:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sortedSquares</span>(<span class="hljs-params">self, nums</span>):<br>        l, r, i = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span><br>        res = [<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)] * <span class="hljs-built_in">len</span>(nums) <span class="hljs-comment"># 需要提前定义列表，存放结果</span><br>        <span class="hljs-keyword">while</span> l&lt;=r :<br>            <span class="hljs-keyword">if</span> nums[l]*nums[l] &lt; nums[r]*nums[r] :<br>                res[i--]=nums[r]*nums[r]<br>                r--<br>            <span class="hljs-keyword">else</span>:<br>                res[i--]=nums[l]*nums[l]<br>                l++<br>        <span class="hljs-keyword">return</span> <br></code></pre></td></tr></table></figure>
<p>GO:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortedSquares</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>	n := <span class="hljs-built_in">len</span>(nums)<br>	i, j, k := <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>, n<span class="hljs-number">-1</span><br>	ans := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>	<span class="hljs-keyword">for</span> i &lt;= j &#123;<br>		lm, rm := nums[i]*nums[i], nums[j]*nums[j]<br>		<span class="hljs-keyword">if</span> lm &gt; rm &#123;<br>			ans[k] = lm<br>			i++<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			ans[k] = rm<br>			j--<br>		&#125;<br>		k--<br>	&#125;<br>	<span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="长度最小的子数组">长度最小的子数组</h3>
<p><a
href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">https://leetcode.cn/problems/minimum-size-subarray-sum/description/</a></p>
<p><strong>题目描述</strong></p>
<p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数
<code>target</code> <strong>。</strong></p>
<p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的
<strong>连续子数组</strong>
<code>[numsl, numsl+1, ..., numsr-1, numsr]</code>
，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回
<code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">输入：target = 7, nums = <span class="hljs-comment">[2,3,1,2,4,3]</span><br>输出：2<br>解释：子数组 <span class="hljs-comment">[4,3]</span> 是该条件下的长度最小的子数组。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj">输入：<span class="hljs-keyword">target</span> = <span class="hljs-number">4</span>, nums = [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><code class="hljs dns">输入：target = <span class="hljs-number">11</span>, nums = [<span class="hljs-number">1,1,1,1</span>,<span class="hljs-number">1,1,1,1</span>]<br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p><strong>思路</strong></p>
<p>滑动窗口法</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240111153940915.png" alt="滑动窗口法" style="zoom:67%;" /></p>
<p>滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动本题中实现滑动窗口，主要确定如下三点：</p>
<ul>
<li>窗口内是什么？</li>
<li>如何移动窗口的起始位置？</li>
<li>如何移动窗口的结束位置？</li>
</ul>
<p>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> s, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = INT32_MAX;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口数值之和</span><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口起始位置</span><br>        <span class="hljs-type">int</span> subLength = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口的长度</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j++) &#123;<br>            sum += nums[j];<br>            <span class="hljs-comment">// 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件</span><br>            <span class="hljs-keyword">while</span> (sum &gt;= s) &#123;<br>                subLength = (j - i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 取子序列的长度</span><br>                result = result &lt; subLength ? result : subLength;<br>                sum -= nums[i++]; <span class="hljs-comment">// 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span><br>        <span class="hljs-keyword">return</span> result == INT32_MAX ? <span class="hljs-number">0</span> : result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="螺旋矩阵">螺旋矩阵</h3>
<p><a
href="https://leetcode.cn/problems/spiral-matrix-ii/">https://leetcode.cn/problems/spiral-matrix-ii/</a></p>
<p><strong>题目描述</strong></p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240111155904466.png" alt="螺旋矩阵" style="zoom:67%;" /></p>
<p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到
<code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的
<code>n x n</code> 正方形矩阵 <code>matrix</code></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">[[1,2,3],[8,9,4],[7,6,5]]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure>
<p>思路：大模拟循环遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generateMatrix</span>(<span class="hljs-type">int</span> n) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">result</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>));<br>        <span class="hljs-type">int</span> is=<span class="hljs-number">0</span>,ie=n<span class="hljs-number">-1</span>,js=<span class="hljs-number">0</span>,je=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(is&lt;=ie&amp;&amp;js&lt;=je)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=js;j&lt;=je;j++)<br>            &#123;<br>                result[is][j] = k++;<br>            &#125;<br>            is++;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =is;i&lt;=ie;i++)<br>            &#123;<br>                result[i][je] = k++;<br>            &#125;<br>            je--;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=je;j&gt;=js;j--)<br>            &#123;<br>                result[ie][j] = k++;<br>            &#125;<br>            ie--;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=ie;i&gt;=is;i--)<br>            &#123;<br>                result[i][js] = k++;<br>            &#125;<br>            js++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="哈希表">哈希表</h1>
<p><strong>一般哈希表都是用来快速判断一个元素是否出现集合里</strong></p>
<p>只需要初始化把所有元素都存在哈希表里，在查询的时候通过索引直接就可以知道元素在不在这哈希表里了</p>
<p>建立索引：哈希函数</p>
<h3 id="有效的字母异位词">有效的字母异位词</h3>
<p><a
href="https://leetcode.cn/problems/valid-anagram/description/">https://leetcode.cn/problems/valid-anagram/description/</a></p>
<p><strong>题目描述</strong></p>
<p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s
的字母异位词。</p>
<p>示例 1: 输入: s = "anagram", t = "nagaram" 输出: true</p>
<p>示例 2: 输入: s = "rat", t = "car" 输出: false</p>
<p><strong>思路</strong></p>
<p>暴力的方法可能时间复杂度会很高</p>
<p>判断有没有异位词的本质就是查看当前的字母是不是有出现过，那么思路就是选择
<strong>哈希表</strong></p>
<p>定义一个数组叫做record用来上记录字符串s里字符出现的次数。</p>
<p>需要把字符映射到数组也就是哈希表的索引下标上，<strong>因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。</strong></p>
<p>再遍历 字符串s的时候，<strong>只需要将 s[i] - ‘a’ 所在的元素做+1
操作即可，并不需要记住字符a的ASCII，只要求出一个相对数值就可以了。</strong>
这样就将字符串s中字符出现的次数，统计出来了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> record[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">// 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了</span><br>            record[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; t.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            record[t[i] - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (record[i] != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// record数组所有元素都为零0，说明字符串s和t是字母异位词</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="两个数组的交集">两个数组的交集</h3>
<p><a
href="https://leetcode.cn/problems/intersection-of-two-arrays/description/">https://leetcode.cn/problems/intersection-of-two-arrays/description/</a></p>
<p>题目描述</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1,2,2,1]</span>, nums2 = <span class="hljs-comment">[2,2]</span><br>输出：<span class="hljs-comment">[2]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[4,9,5]</span>, nums2 = <span class="hljs-comment">[9,4,9,8,4]</span><br>输出：<span class="hljs-comment">[9,4]</span><br>解释：<span class="hljs-comment">[4,9]</span> 也是可通过的<br></code></pre></td></tr></table></figure>
<p>思路</p>
<p>使用哈希表存储，但是用<code>set(unordered_set)</code></p>
<p>std::set和std::multiset底层实现都是红黑树，std::unordered_set的底层实现是哈希表，
使用unordered_set
读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; result_set; <span class="hljs-comment">// 存放结果，之所以用set是为了给结果集去重</span><br>        <span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums_set</span><span class="hljs-params">(nums1.begin(), nums1.end())</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums2) &#123;<br>            <span class="hljs-comment">// 发现nums2的元素 在nums_set里又出现过</span><br>            <span class="hljs-keyword">if</span> (nums_set.<span class="hljs-built_in">find</span>(num) != nums_set.<span class="hljs-built_in">end</span>()) &#123;<br>                result_set.<span class="hljs-built_in">insert</span>(num);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(result_set.<span class="hljs-built_in">begin</span>(), result_set.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="快乐数">快乐数</h3>
<p><a
href="https://leetcode.cn/problems/happy-number/description/">https://leetcode.cn/problems/happy-number/description/</a></p>
<p>题目描述</p>
<p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p>
<p><strong>「快乐数」</strong> 定义为：</p>
<ul>
<li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li>
<li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong>
但始终变不到 1。</li>
<li>如果这个过程 <strong>结果为</strong> 1，那么这个数就是快乐数。</li>
</ul>
<p>如果 <code>n</code> 是 <em>快乐数</em> 就返回 <code>true</code>
；不是，则返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">输入：n = 19<br>输出：<span class="hljs-literal">true</span><br>解释：<br>1*<span class="hljs-number">*2</span> + 9*<span class="hljs-number">*2</span> = 82<br>8*<span class="hljs-number">*2</span> + 2*<span class="hljs-number">*2</span> = 68<br>6*<span class="hljs-number">*2</span> + 8*<span class="hljs-number">*2</span> = 100<br>1*<span class="hljs-number">*2</span> + 0*<span class="hljs-number">*2</span> + 0*<span class="hljs-number">*2</span> = 1<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>注意，题目中提到一个点是
<strong>无限循环</strong>，说明计算的结果<strong>sum是有限</strong>的只需要在哈希表中将这部分的结果存储进去，并每次比较是不是<strong>出现1</strong>
如果是那么就是快乐数，否则就不是快乐数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n)&#123;<br>            sum+=(n%<span class="hljs-number">10</span>)*(n%<span class="hljs-number">10</span>);<br>            n/=<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">//首先建立哈希表来存储是不是出现了无限循环的结果</span><br>        unordered_set&lt;<span class="hljs-type">int</span>&gt;sum_set;<br>        <span class="hljs-comment">//无限循环 直到出现1或者无限循环且不是快乐数</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            n=<span class="hljs-built_in">getSum</span>(n);<br>            <span class="hljs-keyword">if</span>(sum_set.<span class="hljs-built_in">find</span>(n)!=sum_set.<span class="hljs-built_in">end</span>())&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                sum_set.<span class="hljs-built_in">insert</span>(n);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="两数之和">两数之和</h3>
<p>题目描述</p>
<p><a
href="https://leetcode.cn/problems/two-sum/submissions/495021134/">https://leetcode.cn/problems/two-sum/submissions/495021134/</a></p>
<p>给定一个整数数组 <code>nums</code> 和一个整数目标值
<code>target</code>，请你在该数组中找出 <strong>和为目标值</strong>
<em><code>target</code></em> 的那 <strong>两个</strong>
整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，<strong>数组中同一个元素在答案里不能重复出现</strong>。</p>
<p>你可以按任意顺序返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br>解释：因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> == 9 ，返回 <span class="hljs-comment">[0, 1]</span> 。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,4]</span>, target = 6<br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,3]</span>, target = 6<br>输出：<span class="hljs-comment">[0,1]</span><br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>构建一个哈希表，然后遍历一遍就行了在哈希表中找n-a的值是否存在，但是最大的问题是<strong>数组中同一个元素在答案里不能重复出现</strong>，所以不能简单考虑unordered_set</p>
<p>这里提供一种新的思路，就是用unordered_map来存储数组中的数据内容和下标的数值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        std::unordered_map &lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">// 遍历当前元素，并在map中寻找是否有匹配的key</span><br>            <span class="hljs-keyword">auto</span> iter = map.<span class="hljs-built_in">find</span>(target - nums[i]); <br>            <span class="hljs-keyword">if</span>(iter != map.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-keyword">return</span> &#123;iter-&gt;second, i&#125;;<br>            &#125;<br>            <span class="hljs-comment">// 如果没找到匹配对，就把访问过的元素和下标加入到map中</span><br>            map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(nums[i], i)); <br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="四数相加">四数相加</h3>
<p><a
href="https://leetcode.cn/problems/4sum-ii/description/">https://leetcode.cn/problems/4sum-ii/description/</a></p>
<p>给你四个整数数组
<code>nums1</code>、<code>nums2</code>、<code>nums3</code> 和
<code>nums4</code> ，数组长度都是 <code>n</code> ，请你计算有多少个元组
<code>(i, j, k, l)</code> 能满足：</p>
<ul>
<li><code>0 &lt;= i, j, k, l &lt; n</code></li>
<li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>], <span class="hljs-symbol">nums3</span> = [<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>], <span class="hljs-symbol">nums4</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">2</span><br>解释：<br>两个元组如下：<br><span class="hljs-number">1.</span> <span class="hljs-comment">(0, 0, 0, 1)</span> -&gt; <span class="hljs-symbol">nums1</span>[<span class="hljs-number">0</span>] + <span class="hljs-symbol">nums2</span>[<span class="hljs-number">0</span>] + <span class="hljs-symbol">nums3</span>[<span class="hljs-number">0</span>] + <span class="hljs-symbol">nums4</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span> + <span class="hljs-comment">(-2)</span> + <span class="hljs-comment">(-1)</span> + <span class="hljs-number">2</span> = <span class="hljs-number">0</span><br><span class="hljs-number">2.</span> <span class="hljs-comment">(1, 1, 0, 0)</span> -&gt; <span class="hljs-symbol">nums1</span>[<span class="hljs-number">1</span>] + <span class="hljs-symbol">nums2</span>[<span class="hljs-number">1</span>] + <span class="hljs-symbol">nums3</span>[<span class="hljs-number">0</span>] + <span class="hljs-symbol">nums4</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span> + <span class="hljs-comment">(-1)</span> + <span class="hljs-comment">(-1)</span> + <span class="hljs-number">0</span> = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">0</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">0</span>], <span class="hljs-symbol">nums3</span> = [<span class="hljs-number">0</span>], <span class="hljs-symbol">nums4</span> = [<span class="hljs-number">0</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p>思路</p>
<ol type="1">
<li>首先定义 一个unordered_map，key放a和b两数之和，value
放a和b两数之和<strong>出现的次数</strong>。</li>
<li>遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。</li>
<li>定义int变量count，用来统计 a+b+c+d = 0 出现的次数。</li>
<li>在遍历大C和大D数组，找到如果 0-(c+d)
在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。</li>
<li>最后返回统计值 count 就可以了</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums3, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums4)</span> </span>&#123;<br>        std::unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;nm;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums1.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;nums2.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-type">int</span> s = nums1[i]+nums2[j];<br>                nm[s]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums3.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;nums4.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(nm.<span class="hljs-built_in">find</span>(<span class="hljs-number">0</span>-nums3[i]-nums4[j])!=nm.<span class="hljs-built_in">end</span>())&#123;<br>                    res+=nm[<span class="hljs-number">0</span>-(nums3[i]+nums4[j])];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="赎金信">赎金信</h3>
<p><a
href="https://leetcode.cn/problems/ransom-note/description/">https://leetcode.cn/problems/ransom-note/description/</a></p>
<p>给你两个字符串：<code>ransomNote</code> 和 <code>magazine</code>
，判断 <code>ransomNote</code> 能不能由 <code>magazine</code>
里面的字符构成。</p>
<p>如果可以，返回 <code>true</code> ；否则返回 <code>false</code> 。</p>
<p><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code>
中使用一次。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">ransomNote</span> = <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-attr">magazine</span> = <span class="hljs-string">&quot;b&quot;</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">ransomNote</span> = <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-attr">magazine</span> = <span class="hljs-string">&quot;ab&quot;</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>用哈希表unordered_map来存储次数，对于ransomNote来减去次数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canConstruct</span><span class="hljs-params">(string ransomNote, string magazine)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;umap;<br>        <span class="hljs-keyword">if</span>(ransomNote.<span class="hljs-built_in">size</span>()&gt;magazine.<span class="hljs-built_in">size</span>())&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;magazine.<span class="hljs-built_in">size</span>();i++)&#123;<br>            umap[magazine[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;ransomNote.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(umap.<span class="hljs-built_in">find</span>(ransomNote[i]-<span class="hljs-string">&#x27;a&#x27;</span>)!=umap.<span class="hljs-built_in">end</span>())&#123;<br>                umap[ransomNote[i]-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br>                <span class="hljs-keyword">if</span>(umap[ransomNote[i]-<span class="hljs-string">&#x27;a&#x27;</span>]&lt;<span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="三数之和">三数之和</h3>
<p><a
href="https://leetcode.cn/problems/3sum/description/">https://leetcode.cn/problems/3sum/description/</a></p>
<p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组
<code>[nums[i], nums[j], nums[k]]</code> 满足
<code>i != j</code>、<code>i != k</code> 且 <code>j != k</code>
，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p>
<p>你返回所有和为 <code>0</code> 且不重复的三元组。</p>
<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[-1,0,1,2,-1,-4]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[-1,-1,2]</span>,<span class="hljs-comment">[-1,0,1]</span>]</span><br>解释：<br>nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> + nums<span class="hljs-comment">[2]</span> = (-1) + 0 + 1 = 0 。<br>nums<span class="hljs-comment">[1]</span> + nums<span class="hljs-comment">[2]</span> + nums<span class="hljs-comment">[4]</span> = 0 + 1 + (-1) = 0 。<br>nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[3]</span> + nums<span class="hljs-comment">[4]</span> = (-1) + 2 + (-1) = 0 。<br>不同的三元组是 <span class="hljs-comment">[-1,0,1]</span> 和 <span class="hljs-comment">[-1,-1,2]</span> 。<br></code></pre></td></tr></table></figure>
<p>思路</p>
<p><strong>其实这道题目使用哈希法并不十分合适</strong>，因为在去重的操作中有很多细节需要注意，在面试中很难直接写出没有bug的代码，而且使用哈希法
在使用两层for循环的时候，能做的剪枝操作很有限，虽然时间复杂度是O(n^2)</p>
<p>这道题可以用双指针法求解</p>
<p>拿这个nums数组来举例，首先将数组排序，然后有一层for循环，<strong>i从下标0的地方开始，同时定一个下标left
定义在i+1的位置上，定义下标right 在数组结尾的位置上</strong>。</p>
<p>依然还是在数组中找到 abc 使得a + b +c =0，我们这里相当于 a =
nums[i]，b = nums[left]，c = nums[right]。</p>
<p>接下来如何移动left 和right呢， 如果nums[i] + nums[left] + nums[right]
&gt; 0 就说明
<strong>此时三数之和大了</strong>，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。</p>
<p>如果 nums[i] + nums[left] + nums[right] &lt; 0 说明 此时
三数之和小了，<strong>left
就向右移动，才能让三数之和大一些，直到left与right相遇为止</strong>。</p>
<p>还有一个难度就是不能有重复的结果，需要做一次去重的操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-comment">// 找出a + b + c = 0</span><br>        <span class="hljs-comment">// a = nums[i], b = nums[left], c = nums[right]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">// 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span><br>            <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br>          <span class="hljs-comment">// 正确去重a方法</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> left = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (right &gt; left) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="hljs-number">0</span>) right--;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="hljs-number">0</span>) left++;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    result.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);<br>                    <span class="hljs-comment">// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span><br>                    <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) right--;<br>                    <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) left++;<br>                  <span class="hljs-comment">// 找到答案时，双指针同时收缩</span><br>                    right--;<br>                    left++;<br>                &#125;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="双指针">双指针</h1>
<h3 id="移除元素-1">移除元素</h3>
<p><a
href="https://leetcode.cn/problems/remove-element/description/">https://leetcode.cn/problems/remove-element/description/</a></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,2,3]</span>, val = 3<br>输出：2, nums = <span class="hljs-comment">[2,2]</span><br>解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = <span class="hljs-comment">[2,2,3,3]</span> 或 nums = <span class="hljs-comment">[2,2,0,0]</span>，也会被视作正确答案。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">0,1,2,2</span>,<span class="hljs-number">3,0,4,2</span>], val = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">5</span>, nums = [<span class="hljs-number">0,1,3,0</span>,<span class="hljs-number">4</span>]<br>解释：函数应该返回新的长度 <span class="hljs-number">5</span>, 并且 nums 中的前五个元素为 <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>使用快慢指针来实现两个指针之间的移动，对于找到了和val数值一样的就进行替换</p>
<h3 id="反转字符串">反转字符串</h3>
<p><a
href="https://leetcode.cn/problems/reverse-string/description/">https://leetcode.cn/problems/reverse-string/description/</a></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><code class="hljs prolog">输入：s = [<span class="hljs-string">&quot;h&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;o&quot;</span>]<br>输出：[<span class="hljs-string">&quot;o&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;h&quot;</span>]<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><code class="hljs prolog">输入：s = [<span class="hljs-string">&quot;H&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;h&quot;</span>]<br>输出：[<span class="hljs-string">&quot;h&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;H&quot;</span>]<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>采用两个指针之间互相交换，首尾交换</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; s)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, b = s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;a&lt;b;)&#123;<br>            <span class="hljs-type">char</span> tmp;<br>            tmp=s[a];<br>            s[a]=s[b];<br>            s[b]=tmp;<br>            a++;<br>            b--;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="反转字符串中的单词">反转字符串中的单词</h3>
<p><a
href="https://leetcode.cn/problems/reverse-words-in-a-string/description/">https://leetcode.cn/problems/reverse-words-in-a-string/description/</a></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;the sky is blue&quot;</span><br>输出：<span class="hljs-string">&quot;blue is sky the&quot;</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;  hello world  &quot;</span><br>输出：<span class="hljs-string">&quot;world hello&quot;</span><br>解释：反转后的字符串中不能存在前导空格和尾随空格。<br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a good   example&quot;</span><br>输出：<span class="hljs-string">&quot;example good a&quot;</span><br>解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>首先对字符串中额外的空格进行删除</p>
<p>字符串进行全局的逆序</p>
<p>再根据空格作为一个单独字母的节点进行分格分别进行逆序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(s[i]==s[i<span class="hljs-number">-1</span>]&amp;&amp;s[i]==<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>()+i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">0</span>&amp;&amp;s[s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>            s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>()+s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">0</span>&amp;&amp;s[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>            s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>());<br>        &#125;<br><br>        <span class="hljs-comment">//完成全局的交换</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j=s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&lt;j;i++,j--)&#123;<br>            <span class="hljs-type">char</span> tmp;<br>            tmp = s[i];<br>            s[i] = s[j];<br>            s[j] = tmp;<br>        &#125;<br>        cout&lt;&lt;s;<br>        <span class="hljs-comment">//进行局部的交换</span><br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(j&lt;=s.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">if</span>(s[j]==<span class="hljs-string">&#x27; &#x27;</span>||j==s.<span class="hljs-built_in">size</span>())&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k =i, q =j<span class="hljs-number">-1</span>;k&lt;q;k++,q--)&#123;<br>                    <span class="hljs-type">char</span> tmp;<br>                    tmp = s[k];<br>                    s[k] = s[q];<br>                    s[q] = tmp;<br>                &#125;<br>                i=j+<span class="hljs-number">1</span>;<br>                j=i+<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                j++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="反转链表">反转链表</h3>
<p><a
href="https://leetcode.cn/problems/reverse-linked-list/description/">https://leetcode.cn/problems/reverse-linked-list/description/</a></p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240118151406885.png" alt="image-20240118151406885" style="zoom:67%;" /></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span><br>输出：<span class="hljs-string">[5,4,3,2,1]</span><br></code></pre></td></tr></table></figure>
<p>思路：本质上就是利用了两个链表指针实现对元素的转向</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* temp;<br>        ListNode* cur = head;<br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            temp = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="删除链表的倒数第n个结点">删除链表的倒数第N个结点</h3>
<p><a
href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/</a></p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240118152000575.png" alt="image-20240118152000575" style="zoom:67%;" /></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><code class="hljs dns">输入：head = [<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5</span>], n = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">1,2,3,5</span>]<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1]</span>, n = 1<br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure>
<h1 id="二叉树">二叉树</h1>
<h1 id="深搜回溯">深搜回溯</h1>
<h1 id="贪心算法">贪心算法</h1>
<h1 id="动态规划">动态规划</h1>
]]></content>
      <categories>
        <category>LeetCode算法</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>【基础工具】Linux指令集</title>
    <url>/2023/11/25/linux/</url>
    <content><![CDATA[<h2 id="linux命令集">Linux命令集</h2>
<h4 id="查看当前路径的位置-pwd">查看当前路径的位置 pwd</h4>
<h4 id="查看命令历史">查看命令历史</h4>
<p>终端中输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">history</span><br></code></pre></td></tr></table></figure>
<h4 id="指定查找关键字">指定查找关键字</h4>
<p>通过增加grep来增加关键字的筛选</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">| grep GOPROXY<br></code></pre></td></tr></table></figure>
<h4 id="当前目录下的文件">当前目录下的文件</h4>
<ul>
<li>当前目录下的文件 ls</li>
<li>ls -l；ls-h；都是用来显示文件的详细信息</li>
<li>ls -a 来显示所有的文件（包含隐藏文件）</li>
<li>组合使用 ls -lha 显示所有并包含的隐藏文件且显示详细信息</li>
<li>使用dir显示当前文件夹下的文件名*</li>
</ul>
<h4 id="切换文件夹">切换文件夹</h4>
<ul>
<li><p>cd .. <em>#返回父级目录</em></p></li>
<li><table>
<thead>
<tr class="header">
<th style="text-align: center;">cd</th>
<th>切换到当前用户的主目录(/home/用户目录)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">cd ~</td>
<td>切换到当前用户的主目录(/home/用户目录)</td>
</tr>
<tr class="even">
<td style="text-align: center;">cd .</td>
<td>保持在当前目录不变</td>
</tr>
<tr class="odd">
<td style="text-align: center;">cd …</td>
<td>切换到上级目录</td>
</tr>
<tr class="even">
<td style="text-align: center;">cd -</td>
<td>可以在最近两次工作目录之间来回切换</td>
</tr>
</tbody>
</table></li>
<li><p>相对路径 在输入路径时，最前面不是 / 或者 ~，表示相对 当前目录
所在的目录位置 绝对路径 在输入路径时，最前面是 / 或者 ~，表示从
<strong>根目录/家目录</strong> 开始的具体目录位置</p></li>
</ul>
<h4 id="移动文件到指定位置-mv">移动文件到指定位置 mv</h4>
<ul>
<li><p>mv <u>文件名</u> <u>指定的路径位置</u> -i 用于提示</p></li>
<li><p>修改文件夹名称：mv 原来的文件夹名称 后来的文件夹名称</p></li>
<li><h6 id="拷贝某个文件夹到指定路径">拷贝某个文件夹到指定路径</h6>
<ul>
<li><p>cp <u>当前文件夹下某个文件名</u>（带后缀） <u>目标路径</u> -i
用于提示</p>
<table>

<thead>
<tr class="header">
<th>命令</th>
<th>对应英文</th>
<th>作用</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>01</td>
<td>tree [目录名]</td>
<td>tree</td>
<td>以树状图列出文件目录结构</td>
</tr>
<tr class="even">
<td>02</td>
<td>cp 源文件目标文件</td>
<td>copy</td>
<td>复制文件或者目录</td>
</tr>
<tr class="odd">
<td>03</td>
<td>mv 源文件 目标文件</td>
<td>move</td>
<td>移动文件或者目录／文件或者目录重命名</td>
</tr>
</tbody>
</table></li>
</ul></li>
</ul>
<h4 id="创建文件夹">创建文件夹</h4>
<ul>
<li>进入路径的位置 mkdir <u>需要创建的文件夹的名称</u></li>
<li>递归创建文件夹 mkdir -p 123/456
<u>在123文件夹下递归创建文件夹456</u></li>
</ul>
<h4 id="新建某个文件">新建某个文件</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> 123.txt<br></code></pre></td></tr></table></figure>
<h4 id="删除文件夹">删除文件夹</h4>
<ul>
<li>rmdir+ 需要删除的文件名</li>
</ul>
<h4 id="删除某个文件">删除某个文件</h4>
<ul>
<li><p>使用rm来对文件进行删除 -i 进行删除前的查询</p></li>
<li><table>
<thead>
<tr class="header">
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-f</td>
<td>强制删除，忽略不存在的文件，无需提示</td>
</tr>
<tr class="even">
<td>-r</td>
<td>递归地删除目录下的内容，<strong>删除文件夹
时必须加此参数</strong></td>
</tr>
</tbody>
</table></li>
</ul>
<h4 id="解压缩文件的指令">解压缩文件的指令</h4>
<ul>
<li><h5 id="对于zip文件的操作">对于ZIP文件的操作</h5>
<ul>
<li>解压操作：进入需要解压的文件的位置：<strong>unzip
filename.zip</strong></li>
<li>压缩文件：同理进入需要解压的文件夹的上一级 zip filename.zip</li>
</ul></li>
</ul>
<h4 id="linux中查看系统使用情况">Linux中查看系统使用情况</h4>
<ul>
<li><p>Top 来显示CPU的占用情况：</p>
<blockquote>
<table>

<thead>
<tr class="header">
<th>PID</th>
<th>进程的ID</th>
<th>USER</th>
<th>进程所有者</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>PR</strong></td>
<td>进程的优先级别，越小越优先被执行</td>
<td><strong>NInice</strong></td>
<td>值</td>
</tr>
<tr class="even">
<td><strong>VIRT</strong></td>
<td>进程占用的虚拟内存</td>
<td><strong>RES</strong></td>
<td>进程占用的物理内存</td>
</tr>
<tr class="odd">
<td><strong>SHR</strong></td>
<td>进程使用的共享内存</td>
<td>S</td>
<td>进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数</td>
</tr>
<tr class="even">
<td><strong>%CPU</strong></td>
<td>进程占用CPU的使用率</td>
<td><strong>%MEM</strong></td>
<td>进程使用的物理内存和总内存的百分比</td>
</tr>
<tr class="odd">
<td><strong>TIME+</strong></td>
<td>该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值</td>
<td><strong>COMMAND</strong></td>
<td>进程启动命令名称</td>
</tr>
</tbody>
</table>
</blockquote></li>
<li><p><strong>top</strong>退出方式是==用q进行退出==</p></li>
<li><p><strong>free</strong>查看内存的使用情况</p>
<blockquote>
<table>

<thead>
<tr class="header">
<th>total</th>
<th>总计物理内存的大小</th>
<th>used</th>
<th>已使用多大</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>free</strong></td>
<td>可用有多少</td>
<td><strong>Shared</strong></td>
<td>多个进程共享的内存总额</td>
</tr>
<tr class="even">
<td><strong>Buffers/cached</strong></td>
<td>磁盘缓存的大小</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</blockquote></li>
<li><p><strong>vmstat</strong>指令也是用于查看内存的使用</p>
<blockquote>
<ul>
<li><p><strong>Procs(进程)</strong>： r:
运行队列中进程数量，这个值也可以判断是否需要增加CPU。(长期大于1) b:
等待IO的进程数量</p></li>
<li><p><strong>Memory(内存)</strong>：swpd: 使用虚拟内存大小；free:
空闲物理内存大小；buff: 用作缓冲的内存大小；cache:
用作缓存的内存大小</p></li>
<li><p><strong>Swap</strong>： si:
每秒从交换区写到内存的大小，由磁盘调入内存；so:
每秒写入交换区的内存大小，由内存调入磁盘</p></li>
<li><p><strong>IO</strong>：bi: 每秒读取的块数，bo:
每秒写入的块数</p></li>
<li><p><strong>系统</strong>： in: 每秒中断数，包括时钟中断。 cs:
每秒上下文切换数。</p></li>
<li><p><strong>CPU(以百分比表示)</strong>：us:
用户进程执行时间百分比(user time) sy: 内核系统进程执行时间百分比(system
time) ；wa: IO等待时间百分比； id: 空闲时间百分比</p></li>
</ul>
</blockquote></li>
</ul>
<h4 id="查看系统的gpu">查看系统的GPU</h4>
<p>实时查看GPU使用情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">watch -n 1 nvidia-smi <br></code></pre></td></tr></table></figure>
<p>行代码的意思是只选择指定标号GPU进行使用，执行完该行代码之后python环境无法检测到指定GPU之外的其他</p>
<h4 id="系统环境变量">系统环境变量</h4>
<p>对于MACOS，用VIM进入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">vim ～/.zshrc<br></code></pre></td></tr></table></figure>
<p>添加环境变量的语句是，这里以增加路径为例子</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> GOPATH=<span class="hljs-string">&quot;user/workspace/golang&quot;</span><br></code></pre></td></tr></table></figure>
<p>添加完环境变量之后，激活一下设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.zshrc<br></code></pre></td></tr></table></figure>
<p>同样对于Linux系统而言也是相同的步骤</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">vim ~/.bashrc<br></code></pre></td></tr></table></figure>
<p>添加完成之后最后激活一下设定</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure>
<p>如果想直接查看当前某个环境变量的设置的值可以用以下的命令进行查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$GOPARH</span><br></code></pre></td></tr></table></figure>
<p>输出的值是当前的这个环境变量设置的值，比如会输出：user/workspace/golang</p>
<h4 id="显示linux系统的其他信息">显示Linux系统的其他信息</h4>
<h5 id="时间和日期">时间和日期</h5>
<table>
<thead>
<tr class="header">
<th>序号</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>01</td>
<td>date</td>
<td>查看系统时间</td>
</tr>
<tr class="even">
<td>02</td>
<td>cal</td>
<td>calendar 查看日历， -y 选项可以查看一年的日历</td>
</tr>
</tbody>
</table>
<h5 id="磁盘信息">磁盘信息</h5>
<table>
<thead>
<tr class="header">
<th>序号</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>01</td>
<td>df -h</td>
<td>disk free 显示磁盘剩余空间</td>
</tr>
<tr class="even">
<td>02</td>
<td>du -h [目录名]</td>
<td>disk usage 显示目录下的文件大小</td>
</tr>
</tbody>
</table>
<h5 id="进程信息">进程信息</h5>
<p>​ 所谓<strong>进程</strong>，通俗地说就是
<strong>当前正在执行的一个程序</strong></p>
<table>
<thead>
<tr class="header">
<th>序号</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>01</td>
<td>ps aux</td>
<td>process status 查看进程的详细状况</td>
</tr>
<tr class="even">
<td>02</td>
<td>top</td>
<td>动态显示运行中的进程并且排序</td>
</tr>
<tr class="odd">
<td>03</td>
<td>kill [-9] 进程代号</td>
<td>终止指定代号的进程， -9 表示强行终止</td>
</tr>
</tbody>
</table>
<h4 id="网络测试">网络测试</h4>
<p>​ ping 一般用于检测当前计算机到目标计算机之间的网络
<strong>是否通畅，数值越大，速度越慢</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-meta"># 检测到目标主机是否连接正常</span><br>$ ping IP地址 www.baidu.com<br><span class="hljs-meta"># 检测本地网卡工作正常</span><br>$ ping <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br></code></pre></td></tr></table></figure>
<h4 id="gpu运行指定">GPU运行指定</h4>
<ol type="1">
<li><p>首先先查看对应的GPU内存：<strong>nvidia-smi</strong></p></li>
<li><p>然后在终端输出代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">CUDA_VISIBLE_DEVICES=<span class="hljs-number">1</span> python your_model.py <br></code></pre></td></tr></table></figure>
<p>再或者使用
<code>**torch.cuda.set_device()**函数</code>指定gpu使用编号：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br>torch.cuda.set_device(<span class="hljs-number">2</span>) <span class="hljs-comment"># 使用2号GPU</span><br></code></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>基础工具</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
        <tag>基础工具</tag>
      </tags>
  </entry>
  <entry>
    <title>【多智能体强化学习】Pymarl环境配置</title>
    <url>/2023/10/22/pymarl%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>
<p>SMAC是基于暴雪星际争霸II
RTS游戏的协作多智能体强化学习领域的研究环境。SMAC利用星际争霸2机器学习API和DeepMind的PySC2为自主代理提供了一个方便的接口。</p>
<p>本文主要介绍在多智能体强化学习中的验证平台SAMC和Pymarl的配置和安装过程</p>
<p>环境地址：<a
href="https://github.com/oxwhirl/pymarl">https://github.com/oxwhirl/pymarl</a></p>
<p>依赖环境：<a
href="https://github.com/oxwhirl/smac">https://github.com/oxwhirl/smac</a></p>
<p>主要针对Ubuntu下的Pymarl环境的配置（MAC和Windows类似）</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231022145734342.png"
alt="SMAC" />
<figcaption aria-hidden="true">SMAC</figcaption>
</figure>
<h2 id="安装starcraftii">安装StarCraftII</h2>
<h3 id="windowsmac">Windows/Mac</h3>
<p>直接在官网下载安装最新版，需要加速器或者更换亚服：<a
href="https://sc2.blizzard.cn/landing">https://sc2.blizzard.cn/landing</a></p>
<p>安装地图：<a
href="https://link.zhihu.com/?target=https%3A//github.com/oxwhirl/smac/releases/download/v0.1-beta1/SMAC_Maps.zip">https://link.zhihu.com/?target=https%3A//github.com/oxwhirl/smac/releases/download/v0.1-beta1/SMAC_Maps.zip</a></p>
<p>将地图放在Maps文件夹下</p>
<h3 id="ubuntu">Ubuntu</h3>
<p>在Ubuntu系统中，安装需要版本的SCII即可<a
href="https://github.com/Blizzard/s2client-proto#downloads">https://github.com/Blizzard/s2client-proto#downloads</a></p>
<p>下载压缩包之后安装并解压放到用户名文件夹下：～/StarCraftII/</p>
<p>如果没有把SCII安装到用户名之下，这个地方的路径可以根据放置的位置来进行更改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">vim ~/.bashrc<br></code></pre></td></tr></table></figure>
<p>在最后一行增加环境变量，这里可以更改星际争霸的位置索引到任何想要放置的位置</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">SC2PATH</span>=~/StarCraftII/<br></code></pre></td></tr></table></figure>
<p>添加完之后更新环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure>
<p>添加SAMC的地图：Linux系统在下载SCII的时候就自带了地图</p>
<h2 id="安装smac">安装SMAC</h2>
<p>创建虚拟环境并安装pytorch</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">conda create -n pymarl python=<span class="hljs-number">3.8</span> -y<br>conda activate pymarl   <br><span class="hljs-comment"># CUDA 10.2 例子具体的的CUDA版本根据自己的服务器来定</span><br>conda install pytorch==<span class="hljs-number">1.10</span><span class="hljs-number">.0</span> torchvision==<span class="hljs-number">0.11</span><span class="hljs-number">.0</span> torchaudio==<span class="hljs-number">0.10</span><span class="hljs-number">.0</span> cudatoolkit=<span class="hljs-number">10.2</span> -c pytorch<br></code></pre></td></tr></table></figure>
<p>直接利用虚拟环境中的pip来安装</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">pip install git+https://github.com/oxwhirl/smac.git<br></code></pre></td></tr></table></figure>
<p>或者可以利用git进行安装，先git
clone下载下来然后进入文件夹中进行安装</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">git clone https://github.com/oxwhirl/smac.git<br>pip install -e smac/<br></code></pre></td></tr></table></figure>
<p>如果pip install安装失败可以考虑升级pip：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">pip install --upgrade pip<br></code></pre></td></tr></table></figure>
<p>如果安装的内容失败了可以手动安装，比如pymarl运行所依赖的包有以下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">pip install sacred numpy scipy matplotlib seaborn pyyaml pygame pytest probscale imageio snakeviz tensorboard-logger<br><br></code></pre></td></tr></table></figure>
<p>或者根据<a
href="https://github.com/oxwhirl/pymarl/tree/master/docker">https://github.com/oxwhirl/pymarl/tree/master/docker</a>中的bash脚本中Dockerfile依赖内容进行安装</p>
<h2 id="pymarl与scii">Pymarl与SCII</h2>
<h3 id="采用上述安装步骤">采用上述安装步骤</h3>
<p>对于上述的操作完成操作之后，下载pymarl的环境包并进入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">git clone git@github.com:oxwhirl/pymarl.git<br>cd pymarl<br></code></pre></td></tr></table></figure>
<p>将上述安装的SCII文件夹复制到pymarl的src的3dparty之下</p>
<h3 id="如果利用docker安装">如果利用Docker安装</h3>
<p>或者根据pymarl中的内容对上述环境进行自动配置（需要Docker）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> docker<br>bash build.sh<br></code></pre></td></tr></table></figure>
<p>同时安装SCII和SMAC</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">bash install_sc2.sh<br></code></pre></td></tr></table></figure>
<h2 id="测试环境">测试环境</h2>
<h3 id="测试地图信息">测试地图信息</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">python -m smac.<span class="hljs-built_in">bin</span>.map_list <br></code></pre></td></tr></table></figure>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231022153907123.png" alt="Maps show" style="zoom:67%;" /></p>
<h3 id="测试环境信息">测试环境信息</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">python -m smac.examples.random_agents<br></code></pre></td></tr></table></figure>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231022153709693.png" alt="test agents" style="zoom: 50%;" /></p>
<h3 id="测试pymarl环境">测试Pymarl环境</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">python src/main.py --config=qmix --env-config=sc2 <span class="hljs-keyword">with</span> env_args.map_name=2s3z<br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231022153651418.png"
alt="test pymarl" />
<figcaption aria-hidden="true">test pymarl</figcaption>
</figure>
<h2 id="依赖包的版本问题">依赖包的版本问题</h2>
<p>当运行pymarl的时候容易因为依赖包产生问题</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240104210308852.png"
alt="image-20240104210308852" />
<figcaption aria-hidden="true">image-20240104210308852</figcaption>
</figure>
<p>原因是
<code>sacred</code>版本不对劲，只需要将版本降低到0.7.5这个问题就能解决</p>
<h2 id="额外设置">额外设置</h2>
<p>在利用pymarl进行实验的过程中可能会出现</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231022154059365.png"
alt="some bug" />
<figcaption aria-hidden="true">some bug</figcaption>
</figure>
<p>需要进行设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">vim torch/_tensor.py<br></code></pre></td></tr></table></figure>
<p>将757行的内容进行修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">-: self.numpy()<br>+: self.cpu().numpy()<br></code></pre></td></tr></table></figure>
<h2 id="谷歌足球环境">谷歌足球环境</h2>
<p>Google Research
Football：https://github.com/google-research/football</p>
<h4 id="安装linux依赖环境">安装Linux依赖环境</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo apt-get install git cmake build-essential libgl1-mesa-dev libsdl2-dev \<br>libsdl2-image-dev libsdl2-ttf-dev libsdl2-gfx-dev libboost-all-dev \<br>libdirectfb-dev libst-dev mesa-utils xvfb x11vnc python3-pip<br><br>python3 -m pip install --upgrade pip setuptools psutil wheel<br></code></pre></td></tr></table></figure>
<p>这一步非常重要，必须合理安装相应的包。</p>
<h4 id="安装gfootball">安装GFootball</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">python3 -m pip install gfootball<br></code></pre></td></tr></table></figure>
<p>或者用github的仓库来进行安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/google-research/football.git<br><span class="hljs-built_in">cd</span> football<br></code></pre></td></tr></table></figure>
<p>可以选择使用虚拟环境:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">python3 -m venv football-env<br><span class="hljs-built_in">source</span> football-env/bin/activate<br></code></pre></td></tr></table></figure>
<p>安装依赖包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">python3 -m pip install .<br></code></pre></td></tr></table></figure>
<h4 id="运行结果展示">运行结果展示：</h4>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240106145437351.png" alt="谷歌足球结果展示" style="zoom:50%;" /></p>
<h4 id="遇到的问题">遇到的问题</h4>
<p>编译错误，缺少boost的包：</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240106145036965.png"
alt="编译错误" />
<figcaption aria-hidden="true">编译错误</figcaption>
</figure>
<p>选择安装如下包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">conda install anaconda::py-boost<br></code></pre></td></tr></table></figure>
<p>第二个错误：</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240106145218372.png" alt="错误二" style="zoom:67%;" /></p>
<p>解决方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libffi.so.7<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>强化学习</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>深度学习</tag>
        <tag>强化学习</tag>
      </tags>
  </entry>
  <entry>
    <title>【深度学习】PyTorch使用手册</title>
    <url>/2023/10/22/pytorch/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>
<p>本文主要介绍pytorch中的基本使用，包括如何导入数据集，如何搭建并训练网络以及可视化的内容，基本涵盖了深度学习中经典算法的使用以及相关的例子</p>
<h2 id="basics">Basics</h2>
<h3 id="计算梯度例子">计算梯度例子</h3>
<p>引入基本需要用到的包，深度学习中torch处理大部分张量的运算，而torch.nn则是对torch的网络中的一些运算，这些都是必须用到的包。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch <br><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> torchvision.transforms <span class="hljs-keyword">as</span> transforms<br></code></pre></td></tr></table></figure>
<p>在深度学习中，一般使用张量进行运算，此时会涉及到计算张量的梯度等问题，我们这里给出一个例子来展示如何使用张量来进行梯度计算：</p>
<p>初始化定义张量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">x = torch.tensor(<span class="hljs-number">1.</span>, requires_grad=<span class="hljs-literal">True</span>)<br>w = torch.tensor(<span class="hljs-number">2.</span>, requires_grad=<span class="hljs-literal">True</span>)<br>b = torch.tensor(<span class="hljs-number">3.</span>, requires_grad=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure>
<p>建立<strong>计算图 computational graph</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">y = w * x + b    <span class="hljs-comment"># y = 2 * x + 3</span><br></code></pre></td></tr></table></figure>
<p>计算梯度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">y.backward()<br><span class="hljs-built_in">print</span>(x.grad)    <span class="hljs-comment"># x.grad = 2 </span><br><span class="hljs-built_in">print</span>(w.grad)    <span class="hljs-comment"># w.grad = 1 </span><br><span class="hljs-built_in">print</span>(b.grad)    <span class="hljs-comment"># b.grad = 1 </span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>【深度学习】推荐系统</title>
    <url>/2024/01/16/rec/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>
<h1 id="推荐系统学习资料">推荐系统学习资料</h1>
<ul>
<li><a
href="https://zhuanlan.zhihu.com/p/407871839">从零单排推荐系统文章汇总目录</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/119248677">深度推荐系统
王喆</a></li>
<li><a
href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;__biz=MzI5NTU2ODQzMg==&amp;scene=1&amp;album_id=2893245558629466114&amp;count=3#wechat_redirect">推荐系统算法实战课程</a></li>
</ul>
<h1 id="推荐系统简介">推荐系统简介</h1>
<p>搜索弓|擎需要用户主动输入自己的意图，有时候，用户并不知道自己需要什么，有些需求、意愿，是用户自己都意识不到的。因为用户提不出需求，就"无所事事"，显然这是对宝贵流量的巨大浪费，不利于建立用户粘性。将自己拥有的、用户可能喜欢的内容主动展示给用户，从而留住用户花费更多的时间与金钱。这就是<strong>推荐系统</strong>。</p>
<p>学习推荐系统算法需要注意以下的关键要点：</p>
<ul>
<li>记忆性与拓展性</li>
<li>推荐系统的高维稀疏的类别特征</li>
<li>特征的Embedding</li>
<li>特征的交叉结构</li>
</ul>
<h2 id="推荐系统的例子">推荐系统的例子</h2>
<p>假设一个极简版的推荐系统中，也有两类角色:用户和物料。</p>
<ul>
<li>用户(User)
就是推荐系统要服务的对象。用户也是推荐系统的重要贡献者。用户通过"大拇指投票"
帮推荐系统分辨出内容、信息的真假优劣。</li>
<li>物料(Item)，用于统称要推荐出去的信息、内容。不同场景下，物料会有不同的内涵:电商推荐中,物料就是商品；内容推荐中，物料就是一篇文章、一首歌；社交推荐中，物料就是另一个人。</li>
</ul>
<p>建立推荐系统的步骤如下：</p>
<ol type="1">
<li>第一步是<strong>给物料打标签</strong>。比如对一个视频《豆瓣评分9.3，最恐怖的喜剧电影：楚门的世界》，我们给它打上"电影、喜剧、真人秀、金凯瑞'这样的标签。</li>
<li>第二步，建立<strong>倒排索引</strong>，将所有物料组织起来，倒排索引类似一个HashMap,
键是标签，值是一个列表，包含着被打上这个标签的所有视频。</li>
<li>第三步，推荐系统接到一个用户的推荐请求。推荐系统根据从请求中提取出来的用户ID，从<strong>数据库中检索</strong>出该用户的兴趣爱好。假设该用户过去看过10个视频，其中7个带有"喜剧"的标签，3个带有"足球"的标签，则提取出来的该用户的兴趣爱好就是{"喜剧":
0.7, "足球": 0.3}，
其中键表示用户感兴趣的标签，后面的数字表示用户对这个标签的喜好程度。</li>
<li>第四步，<strong>召回</strong>，拿用户感兴趣的每个标签去<strong>倒排索引中检索</strong>。假设"喜剧"这个标签对应的倒排链中包含A、B两个视频，"足球"标签对应的倒排链中包含C、D、
E两个视频。汇总起来，推荐系统为该用户找到了5个他可能感兴趣的视频。这个过程叫作"召回"
(Retrieval) ，查寻倒排索引只是其中一种实现方式。</li>
<li>第五步，推荐系统会猜测用户对这5个视频的喜爱程度，再按照喜爱程度降序排列，将用户最可能喜欢的视频排在最显眼的第一位,
让用户一眼就能看到。这个过程叫作<strong>"排序" (Ranking)</strong>
。至于如何猜测用户的喜爱程度，在这个极简版的推荐系统中，这里只使用一个简单的评价规则：<span
class="math display">\[Score(u,g,v)=Like(u,g)\times Q(v)\]</span>
<ol type="1">
<li>u表示发出请求的用户</li>
<li>g表示用户u喜欢的一个标签</li>
<li>v表示，在第四步中，根据标签g从倒排索引中提取出来的一个视频</li>
<li>Like(u,g)表示用户u对标签g的喜爱程度。比如在上面的例子中，Like(u,"喜
剧")=0.7</li>
<li>Q(v)表示视频v的质量。可以由v的各种后验消费指标来表示，比如可以用点击率(CTR)
来表示</li>
<li>Score(u, g, v)表示推荐系统猜测的用户u对视频v的喜爱程度。</li>
</ol></li>
<li>第六步推荐系统对排序结果进行截断，只保留前4个视频，返回给用户。</li>
<li>第七步，用户按照[B, C,
A,D]的顺序看到了4个视频，点击并观看了视频B。用户行为，即"用户u点
击视频B, A/C/D曝光未点击"，被记录进日志，发送给推荐系统。</li>
<li>第八步，推荐系统接收到了用户反馈，并据此更新用户的兴趣爱好。</li>
</ol>
<p>以上是比较简单的推荐系统的例子，具体的实现过程中可能会非常复杂，考虑的东西会非常多，因此具体实现上可能需要进一步的考虑。</p>
<h2 id="推广搜简介">推广搜简介</h2>
<p>含义：推荐、广告、搜索。<strong>用户需求表达方式：</strong>推荐、搜索<strong>。信息服务对象：</strong>推搜、广告</p>
<h3 id="相同点">相同点</h3>
<ul>
<li>功能架构相同：都遵循先召回再排序</li>
<li>数据架构相同：都遵循使用Lambda架构(后续会提到)</li>
<li>技术栈相同，面向的功能相同，都需要高度个性化设计(都十分依赖于用户的画像)</li>
</ul>
<h3 id="不同点">不同点</h3>
<ul>
<li><strong>推荐&amp;搜索</strong></li>
</ul>
<p>推荐和搜索的最大差异在于用户表达意图的方式不同，用户输入显式的查询语句来表明自己的意图
<span class="math display">\[
F_{search}(t|q,u)
\]</span></p>
<ul>
<li>u表示当前用户，q表示用户输入的查询语句，t表示某一个候选物料</li>
<li>Fsearch表示搜索模型， 衡量物料t对用户u输入的查询q的匹配程度</li>
<li>用户信息u也是公式的输入条件。不同用户输入相同的查询语句q，得到的结果也是不一样的</li>
</ul>
<p>推荐中，用户无须显式表达其意图。推荐系统通过自己的长期观察，猜测用户意图，完成推荐
<span class="math display">\[
F_{recommend}(t|u)
\]</span></p>
<ul>
<li>表示推荐模型，衡量物料t对用户u的匹配程度</li>
</ul>
<p>q表示物料对用户查询的匹配程度，搜索有显式的匹配程度，但是推荐没有，总结如下：</p>
<ul>
<li><p>搜索：查询语句与物料信息交叉</p></li>
<li><p>推荐：用户信息与物料信息交叉</p></li>
<li><p><strong>推搜&amp;广告</strong></p></li>
</ul>
<p>最终目标性：（优化指标）</p>
<ul>
<li>推搜是为了制造流量，给予用户最佳的使用体验</li>
<li>广告是为了变现流量，要兼顾用户、广告主、平台三方面的利益，参与方更多、更复杂，优化起来难度更高</li>
</ul>
<p>实现流程：</p>
<ul>
<li>推搜目标即刻完成，比如点击和播放</li>
<li>广告是深层次的转化，需要用户选择并下载APP，存在较大的延时反馈问题，成功转化的正样本越稀疏，建模难度越高。</li>
</ul>
<p>预测精度的要求：</p>
<ul>
<li>推荐与搜索对预测出来的CTR/CVR只要求"相对准确性"，即它们的预测精度能够将用户最喜欢的物料排在最前面，这就足够了</li>
<li>广告对预测精度要求"绝对准确性"。在模型的预测结果出来之后，广告还需要对其修正、校准。毕竟制作、投放广告还存在一定技术、财力上的门槛。</li>
</ul>
<h1 id="推荐系统模型架构">推荐系统模型架构</h1>
<p>根据划分角度不同，将分成“功能架构”和“数据架构”两个板块</p>
<h2 id="功能架构">功能架构</h2>
<p>为了应对海量的候选集合，现代大型推荐系统都采用由<strong>"召回→粗排→精排→
重排"</strong>四个环节组成的分级推荐模式，在推荐链路中越靠前的环节，面对的候选集合越大，因此要采用技术较简单、精度稍逊、速度较快的算法，牺牲部分精度换速度；反之，链路靠后的环节，面对的候选集合较小，有条件采用技术较复杂、精度高、速度较慢的算法，牺牲部分速度换精度。</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240118142732765.png"
alt="推荐功能的结构" />
<figcaption aria-hidden="true">推荐功能的结构</figcaption>
</figure>
<figure>
<img
src="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGE5NDI3YTkxNzUzYmNjODhmNTdhNWY3YmYzZjQxNjNfYXlpcWFEZ3NIQkxob2JvakRPNUZOQkNvWldyRlVYYWFfVG9rZW46WlNuMWJwbHZBbzBBUjh4cXVqY2NnSkFsbkxiXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"
alt="推荐系统的功能架构" />
<figcaption aria-hidden="true">推荐系统的功能架构</figcaption>
</figure>
<h3 id="召回">召回</h3>
<p>召回模块的第一要务就是"快"，可以牺牲一部分精度，
只要能找到与用户兴趣比较匹配的物料就好，而非最匹配的，因为后者是下游排序模块的目标。</p>
<p>召回模块主要依赖<strong>"离线计算+在线缓存"</strong>模式来实现对上百万候选集的快速筛选。上百万的候选物料在离线就处理好，处理结果被存入数据库并建立好索引，线上召回时，只花费一个在索引中的检索时间，时间开销非常小。</p>
<p>离线处理物料时肯定不知道将来要访问的用户是谁，召回模型在结构与特征上，都不能出现<strong>用户信息与物料信息的交叉</strong>。这个特点限制了召回模型的表达能力，也就限制了制约了召回模型的预测精度。</p>
<p>为了弥补精度上的不足，召回模块一般采用<strong>多路召回</strong>的方式，以数量弥补质量。每路召回只关注用户信息或物料信息的一个侧面，比如有的只负责召回当下最火爆的内容，有的只根据用户喜爱的"标签"进行召回，虽然单独一路召回的视角是
片面的，但是多路召回的结果汇总起来，取长补短，查漏补缺，就能覆盖用户兴趣的方方面面。</p>
<p><strong>区分召回和排序：</strong></p>
<ul>
<li><p>召回是从一大堆物料中排除与用户兴趣八杆子打不着的，留下还比较合用户品味的。举个例子，召回好比经历过社会历练，无论哪种"不靠谱"，他都见识过。</p></li>
<li><p>精排是从一小拨儿还不错的物料中，精挑细选，优中选优，挑出对用户来说最好的物料。举个例子，精排好比还在校园中的乖学生，见过最不靠谱的人不过是借橡皮不还的同桌。</p></li>
</ul>
<h4 id="传统召回算法"><strong>传统召回算法</strong></h4>
<ul>
<li>基于物料属性的倒排索引</li>
<li>基于统计的协同过滤算法
<ul>
<li>基于用户的协同过滤：给用户A找到与他相似爱好的用户B，把B喜欢的东西推荐给A</li>
<li>基于物料的协同过滤：用户A喜欢物料C，找到与A相似的其他物料D，把D推荐给A</li>
</ul></li>
<li>矩阵分解算法(Matrix Factorization, MF)</li>
</ul>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/(null)-20240116152608169.(null)"
alt="矩阵分解算法图示例" />
<figcaption aria-hidden="true">矩阵分解算法图示例</figcaption>
</figure>
<h4
id="向量化召回统一建模框架"><strong>向量化召回统一建模框架</strong></h4>
<p>如何定义负样本、如何定义证样本、如何生成Embedding、如何定义优化目标</p>
<p>定义：将召回问题建模成向量空间中的近邻搜索问题</p>
<p>分类：两类实体QT，可以是物料-用户、用户-用户、物料-物料</p>
<p>方法流程：</p>
<ol type="1">
<li>训练一个模型，并将QT映射到同一个向量空间</li>
<li>构建起索引向量数据库</li>
<li>对于传入的Q实例先进行Embedding 再进行近邻搜索</li>
</ol>
<p>建模方法：</p>
<ul>
<li>如何定义正样本（哪些q和t在向量空间中应该近）
<ul>
<li>qt都是物料：时间间隔很近的用户行为序列交互过的物料认为很近，相似性</li>
<li>q是用户t是物料：用户交互过的物料认为是相近的，匹配性</li>
<li>qt都是用户：比如孪生网络，q是用户一半的交互历史，t是同一用户另一半的交互历史，同一性</li>
</ul></li>
<li>如何定义负样本（哪些q和t在向量空间中应该远）
<ul>
<li><strong>负样本为王</strong>，负样本选择对模型很重要</li>
<li><strong>离线训练的数据分布应该与线上服务的数据分布保持一致</strong></li>
<li>注意 召回和排序
候选集完全不同：<strong>召回</strong>要让模型见过最匹配也要见最不靠谱，因此<strong>召回的负样本主要依靠随机采样生成，不能（只）拿“曝光未点击”作为负样本</strong></li>
<li>注意Easy
Negative问题，负样本要和q有细节差异，增加难度；<code>easy:hard=100:1</code></li>
</ul></li>
<li>如何将q和t映射成Embedding
<ul>
<li><strong>排序鼓励特征交叉，召回要求解耦</strong></li>
<li>排序使用了大量的交叉统计特征，排序将用户特征、物料特征、交叉统计特征拼接</li>
<li>召回解耦，不用知道用户的请求提前计算好物料向量，避免计算交叉特征耗时</li>
</ul></li>
<li>如何定义优化目标和损失函数
<ul>
<li>NCE Loss</li>
<li>Sampled Softmax Loss</li>
<li>Pairwise Loss</li>
</ul></li>
</ul>
<h3 id="精排">精排</h3>
<p>任务目标：精排的任务是从上游层层筛选出来的千余号还比较符合用户兴趣的物料中，<strong>精挑细选</strong>出百余个最合用户品味的物料。</p>
<p>设计重点：精排的设计重点是提升预测精度。所以不同于召回、粗排不允许用户信息与物料信息交叉，精排模型的发力<strong>重点就是让物料信息与用户信息更加充分地交叉</strong>，为此业界在精排引入了更多更复杂的<strong>交叉特征</strong>，</p>
<h4 id="特征交叉方法"><strong>特征交叉方法</strong></h4>
<ul>
<li>传统方法：FTRL</li>
<li>FM：引入了二阶特征交叉（手动二阶特征交叉）</li>
<li>Wide&amp;Deep：兼顾记忆与扩展</li>
<li>DeepFM ：融合二阶交叉（实现了自动二阶特征交叉）</li>
<li>DCN：能够指定任意显式交叉</li>
<li>Autolnt：基于Transformer作特征交叉</li>
</ul>
<h4 id="用户行为序列建模"><strong>用户行为序列建模</strong></h4>
<p>本质：将用户行为序列提炼并压缩成<strong>用户兴趣的Embedding</strong></p>
<ul>
<li>DIN：利用Attention，将当前的物料t作为用户历史序列的Query</li>
<li>双层Attention行为序列：第一层Attention历史行为序列内部的依赖关系；第二层是当前物料和历史行为序列</li>
<li>SIM：将“软过滤”变成“硬过滤”，相当于从长序列选择短序列进行DIN</li>
</ul>
<h3 id="粗排">粗排</h3>
<p>召回的精度不足，所以用数量弥补质量，倾向于召回更多物料，送往下游。精排为了提升预测精度，不断加大模型复杂度，而牺牲了模型的吞吐能力。
如果让召回直接对接精排，笨重的精排无法面对召回送来的越来越多的候选物料，粗排接在召回后面，一般将召回的10000个结果再过滤掉9成，再交给精排重点考察。粗排夹在召回与精排之间，又是一个<strong>速度与精度折衷妥协</strong>的产物。</p>
<ul>
<li>一方面，由于候选集规模比召回小得多，相比召回，粗排模型可以接入更多特征，使用更复杂的结构。</li>
<li>另一方面，由于候选集比精排还大得多，粗排模型比精排又简单太多。比如主流粗排模型仍然依赖"离线计算+在线缓存"模式来处理候选物料，所以<strong>仍然不能使用用户信息与物料信息交叉的特征与结构</strong>。</li>
</ul>
<h4 id="基于改进的双塔模型">基于改进的双塔模型</h4>
<ul>
<li>召回需要向量数据库建立索引，粗排不需要索引</li>
<li>负样本的选择，可以拿“曝光未点击”当负样本</li>
<li>损失函数，粗排的损失函数需要考虑用户实际反馈，召回不需要</li>
<li>召回ANN快速搜索近邻使用点积实现交叉，粗排可以选择任意的交叉方式
<ul>
<li>双塔结构的问题：细粒度信息在塔中被消耗，如何保留更多的塔中输出信息</li>
<li>动态调整输入信息，减少噪声信息的输入</li>
<li>重要的信息走捷径，ResNet</li>
</ul></li>
</ul>
<h4 id="基于知识蒸馏">基于知识蒸馏</h4>
<h3 id="重排">重排</h3>
<p>相似内容(比如相同话题、相同标签)会被粗排模型打上相近的分数，从而在结果集中排在相近的位置。如果将这样的排序结果直接呈现给用户，用户连看几条相似内容，很容易审美疲劳，从而伤害用户体验。所以，精排结果还需要经过重排。重排的主要目的不是为了过滤筛选，而是为了调整精排结果的顺序，<strong>将相似内容打散</strong>，保证用户在一屏之内看到的推荐结果，丰富而多样。</p>
<h4 id="基于启发式规则">基于启发式规则</h4>
<p><strong>滑动窗口打散法</strong></p>
<p>一种常见的打散规则叫做"滑窗打散"，即在一个长度为K的滑动窗口(Sliding
Window, SW)内,相似物料最多出现n次。</p>
<p>下面是一个例子</p>
<ul>
<li>初始时，所有物料按照精排打分从大到小排序；</li>
<li>在第1个滑窗内，物料2和3是相同类别，违反打散目标，物料4和3对调；</li>
<li>在第2个滑窗内，还是物料2和3违反打散目标，物料3和5对调；</li>
<li>在第3个滑窗内，每个类别只出现一次，满足打散目标，路过；</li>
<li>在第4个滑窗内，物料5和6违反打散目标，物料6和7对调；</li>
<li>如果滑动到最后一次窗口，还不满足打散目标，但是后面已经没有物料可对调了，不做处理。</li>
</ul>
<figure>
<img
src="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjA4NGYwOWRkZDU4ZGNiYThkNWQ5MzhjNjg4ZWM0YzlfbHY0dkwwZUtzTW9SQnFJM0ZZVXZ6d2phTUlEWVBjNHJfVG9rZW46V0FJemIxa0R5bzVwS0p4dzF2UGNHSm5Mbk9jXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p><strong>分桶打散法</strong></p>
<p>首先按照不同类别将排好序的物料放入按照<strong>某个指标划分的桶</strong>中，紧接着均匀地从每个桶中抽取对应的物料来保证物料不相似</p>
<figure>
<img
src="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=MTZjN2YxNmNjMTRhZGNmZGY1NjZkMjMwNDhjM2ZhYTlfYkpOU01rZ0lEWDRGQ0x1S3NxanptV0pyU0MwQjRjd1pfVG9rZW46VEUyOGJ3TjlHb1BKYzl4Mktxc2MzMFJUbmtiXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h4 id="基于贪心算法">基于贪心算法</h4>
<p><span class="math display">\[N e x t=\underset{t \in R \backslash
S}{\operatorname{argmax}} \lambda \operatorname{Sim}_1(u, t)-(1-\lambda)
\operatorname{Sim}_2(S, t)\]</span></p>
<ul>
<li>$$$$ 是全体精排结果, 也就是重排的全体候选集。</li>
<li>$<span class="math display">\[$ 是当前的重排结果集。当
\]</span><span class="math display">\[ 的长度达到指定长度时, 重排结束,
将 \]</span>$$ 展示给用户。</li>
<li><span class="math display">\[R \backslash \]</span>
表示还未插入重排结果集的所有精排结果。</li>
<li><span class="math display">\[\operatorname{Sim}_1(u, t\]</span>
代表当前候选物料 $<span class="math display">\[$ 与发起请求的用户
\]</span>$$ 之间的相关性, 可以用精排打分表示。</li>
<li><span class="math display">\[\operatorname{Sim}_2(S, t\]</span>
是当前物料 $<span class="math display">\[$ 与当前重排结果集合
\]</span>$$ 的相似度。这个数值越小, 将加入 <span
class="math inline">\(S\)</span>, 对重排结果多样性的提升越大。</li>
<li><span class="math display">\[\lambda \operatorname{Sim}_1(u,
t)-(1-\lambda) \operatorname{Sim}_2(S, t\]</span> 代表将候选物料 $<span
class="math display">\[$ 加入 \]</span><span class="math display">\[
带来的边际收益, 是相关性与多样性的折中, \]</span>$$ 是组合的权重。</li>
</ul>
<p>其余的方法：基于行列式点过程、基于上下文感知等方法</p>
<h2 id="数据架构">数据架构</h2>
<p>除了上面介绍的功能架构，推荐系统中的模块还可以按照数据生产、计算、存储的不同方式进行划分，也就是推荐系统的数据架构。</p>
<p>数据类型：</p>
<ul>
<li>冷数据：存储在Hadoop分布式文件系统(Hadoop Distributed File System,
HDFS)上的那部分日志数据</li>
<li>热数据：HDFS只支持批量读写的性质所限，还有许多用户行为未得及组成用户日志，或者未来得及落盘在HDFS上的数据</li>
</ul>
<p>为了应对互联网大数据系统的复杂性，Lambda架构应运而生。</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/(null)-20240116152608613.(null)"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ul>
<li>将数据请求拆解为分别针对冷、热数据的两个子请求。</li>
<li>针对冷数据的请求，
由<strong>"离线层"</strong>批量完成计算，其结果由<strong>"近线层"</strong>缓存并提供快速查询。</li>
<li>针对热数据的请求，
由<strong>"在线层"</strong>基于流式算法进行处理。</li>
<li>汇总从冷、热数据分别获得的子结果，得到最终的计算结果。</li>
</ul>
<h3 id="离线层">离线层</h3>
<p>为了计算可以启动一个小时级的定时任务，每个小时都向前回溯一周的用户行为日志，
统计这个时间窗口内每个视频V的曝光数与点击数。为了加速，我们可以定时跑另一个小时级的批量任务，统计每个小时内每个视频的曝光、点击总数，并保存结果。另外，这些小时级的中间结果也能够被其他上层计算任务所复用，避免重复计算。</p>
<p>以上这些<strong>定时扫描日志的批量计算任务</strong>，就构成了Lambda架构中的"离线层"。技术上，这些批量计算任务可以凭借Hadoop、Spark、
Flink等大数据框架来完成，而多个任务之间的协同可以由Airflow来完成。</p>
<h3 id="近线层">近线层</h3>
<p>HDFS是一种擅长批量读写，但随机读写效率极低的存储介质，不利于线上快速读取。为了提高查询速度，我们将离线批量计算的结果导入Cassandra、Redis这样的"键
~值" (Key-Value， KV)
型数据库。这些<strong>起缓存、加速访问</strong>作用的KV数据库就构成了Lambda架构中的"近线层"。</p>
<h3 id="在线层">在线层</h3>
<p>因为HDFS只支持批量读写，所以用户行为从发生到被记录在HDFS上，之间存在着小时级别的延时。用户最新的行为都未能体现在离线批量计算的结果中。</p>
<p>"在线层"正是为了弥补上这块短板。这一层凭借Storm、Flink等流式计算框架，对接用户的行为数据流，<strong>不等数据落地，就直接对它们进行分析计算</strong>，计算结果也缓存在Redis这样支持随机读写的数据库中，方便线上查询。</p>
<h1 id="推荐系统的特征工程">推荐系统的特征工程</h1>
<p>好的特征工程能够将数据处理得更加适配模型，能够让模型发挥最大的性能</p>
<h2 id="特征工程的必要性">特征工程的必要性</h2>
<ul>
<li>DNN万能函数模拟器并不可靠，输入数据未经处理会影响DNN性能的发挥</li>
<li>DNN的自动化特征工程对于大量的数据存在耗时等问题</li>
</ul>
<h2 id="特征提取">特征提取</h2>
<p>这一部分会介绍如何对各类不同的特征提取的方法</p>
<h3 id="物料特征">物料特征</h3>
<ul>
<li><strong>物料自身属性</strong>
<ul>
<li>在视频推荐场景下，视频的作者、作者等级、作者粉丝数、投稿栏目、视频标题与简介、上传时间、
时长、清晰度等信息，都属于物料属性。</li>
<li>在电商场景下，商品标题与简介、封面图片、所属商铺、商铺等级、品牌、价格、折扣、物料方式、上架时间等信息，都属于物料属性。</li>
<li>物料的唯一标识(tem
ID)也是重要的特征<strong>（高维、稀疏）</strong>Item
ID当成特征能够在物料侧提供最个性化的信息。</li>
</ul></li>
<li><strong>物料的类别与标签</strong></li>
</ul>
<p>所谓物料的静态画像，是指不依赖用户反馈，只通过分析物料内容就能获得的物料的<strong>类别、标签</strong>等信息。</p>
<ul>
<li><p>可以用"自然语言处理" (Natural Language Processing, NLP)
算法，比如BERT[5]，
分析物料的标题、摘要、评论等。如果是文章还可以分析正文，如果是视频还可以分析字幕。</p></li>
<li><p>我们可以用"计算机视觉" (ComputerVision, CV)
算法，比如CNN模型[6]，
分析物料的封面，或者视频的关键帧。内容分析的结果就构成了物料的静态画像。</p></li>
<li><p><strong>基于内容的Embedding</strong></p></li>
</ul>
<p>利用CNN或BERT之类的模型，从一篇文章、一个视频中提炼出几个标签，其结果是超级稀疏的。</p>
<p>这回拿模型的<strong>某一层的输出</strong>，当成物料特征，<strong>喂入上层模型</strong>。尽管这个向量不如那几个标签好理解，但是它有32位或64位那么长，里面蕴含的信息要比几个标签丰富一些。</p>
<ul>
<li><strong>物料的动态画像</strong></li>
</ul>
<p>物料的动态画像，指它们的后验统计数据，反映了物料的受欢迎程度，是物料侧最最重要的特征。物料的动态画像可以从以下两个维度来进行刻画:</p>
<ul>
<li><p>时间粒度:全生命周期、过去一周、过去1天、过去1小时</p></li>
<li><p>统计对象: CTR、平均播放进度、 平均消费时长、排名</p></li>
<li><p><strong>用户给物料反向标签</strong></p></li>
</ul>
<p>将消费过某个物料的用户身上的标签，传递<strong>积累到这个物料身上，丰富物料画像</strong>。</p>
<p>比如一篇关于某足球明星八卦绯闻的文章，由于该球星的名字出现频繁，NLP算法可能会给它打上"体育"标</p>
<p>签。但是后验数据显示，带"体育"标签的用户不太喜欢这篇文章，反而带"娱乐"标签的用户更喜欢，显然这</p>
<p>篇文章也应该被打上"娱乐"的标签。类似的，给物料打上诸如"文青喜欢的电影榜第3名"、或者"数码迷最喜</p>
<p>欢的手机"这样的反向标签，都包含了非常重要的信息，能够帮助提升模型性能。</p>
<h3 id="用户特征">用户特征</h3>
<ul>
<li><strong>用户的静态画像</strong></li>
</ul>
<p>静态画像就是人口属性(e.g.,
性别、年龄、职业、籍贯)、用户安装的APP列表等比较稳定的数据信息。</p>
<p>由于互联网大厂的主打APP的存量老用户居多，行为丰富，能够提供足够的训练数据，因此在大厂的实践中还是非常喜欢拿User
ID当特征的。</p>
<ul>
<li><strong>用户的动态画像</strong></li>
</ul>
<p>用户的动态画像就是从用户的历史行为中提取出来的他的兴趣爱好。</p>
<p>最简单直接的动态画像就是，将用户一段时间内用户交互过的物料的Item
ID按时间顺序组成的集合。将这个集合扔进模型，让模型自动从中提取出用户兴趣。最简单的提取方式无非就是将每个ltemID先Embedding，再把多个Embedding聚合(也称"池化"，
Pooling，比如采用加和或平均)成一个向量，这个向量就是用户兴趣的抽象表达。</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/(null)-20240116152608785.(null)"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>至于可以统计哪些指标来反映用户兴趣，我们可以从以下6个维度展开，做到不重不漏：</p>
<ul>
<li>用户粒度，可以是单个用户，也可以是一群用户。针对一个用户群体的统计，有利于新用户冷启。</li>
<li>时间粒度，比如最近的100次曝光，再比如过去1小时、1周、1月。</li>
<li>物料属性，比如视频的一二级类别、标签、作者，再比如商品的分类、品牌、店铺、价位。</li>
<li>动作类型，可以是正向的，比如点击、点赞、转发等，也可以是负向的，比如忽略、点踩。</li>
<li>统计对象，比如次数、时长、金额等。</li>
<li>统计方法，比如加和、求平均、计算各种比例等。</li>
</ul>
<p>通过以上6个维度的交叉，我们可以构造出一系列的统计指标来反映用户在各个时间跨度、各个维度上的兴趣</p>
<h3 id="交叉特征">交叉特征</h3>
<p>DNN并非万能，其交叉能力也有限；另一方面，手动交叉的特征犹如加工好的食材，个中信息更容易被模型消化吸收。因此，在推荐模型的深度学习时代，交叉特征依然大有可为，值得重视。</p>
<p>在具体交叉方式上，又有做<strong>"笛卡尔积"</strong>与做<strong>"内积"</strong>两种方式。</p>
<ul>
<li><strong>笛卡尔积交叉</strong></li>
</ul>
<p>笛卡尔交叉就是将两个Field内的Feature两两组合，组成一个新的Field。
比如用户感兴趣的电影类别有{"动作片"、科幻片"}，而当前候选物料的标签是("施瓦辛格"、"终结者"
、"机器人"}，
这两个Field做笛卡尔交叉的结果就是{"动作片+施瓦辛格"，“动作片
+终结者"，"动作片+机器人"，
"科幻片+施瓦辛格"，科幻片+终结者"，"科幻片+机器人"}，显然"动作片+施瓦辛格"、"科幻片+机器人"都是非常强烈的信号，有助于模型判断用户与物料间的匹配程度。</p>
<ul>
<li><strong>内积交叉</strong></li>
</ul>
<p>点积，即选定一个画像维度(比如标签、分类)，将用户在这个维度上的兴趣，和物料在这个维度上的属性，想像成两个稀疏向量，这两个向量做点积结果反映出用户和物料在这个画像维度上的匹配程度。</p>
<p><strong>点积结果越大，说明用户与候选物料在这个维度上越匹配</strong>。</p>
<p>比如用户感兴趣的标签是Tagsuser ={"坦克": 0.8, "足球": 0.4， "二战":
0.6, "台球": -0.3}，
每个标签后面的数字表示用户对这个标签的喜爱程度，可以拿用户在这个标签上的后验指标来表示，而当前候选物料的标签是Tagsitem
={"坦克": 1， "二战": 0.5，"一战": 0.8}。
将Tagsuser与是Tagsitem'做点积，也就是将共同标签对应的分数相乘再相加，结果是1.3，表示用户与当前候选物料在"标签"这个维度上的匹配程度。</p>
<h3 id="偏差特征">偏差特征</h3>
<ul>
<li>无法做到绝对公平，没点击不代表不喜欢，点击的未必喜欢，偏差Bias</li>
</ul>
<figure>
<img
src="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=NDc4NmViNDYwODYxZTFmNmQzZmYyOTkyNjY4ZTI1NDFfelBIb0IxVUdYbWFmT3phcmx2QjJUU1ZlRFJDdXRlUlRfVG9rZW46VHRSbmJCV25sb2JUNnN4Y1BTT2Nab1BHbkdlXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ul>
<li><strong>Above Click:</strong>
只有在点击物料上方的未点击的物料才被当作负样本，没被点击的且不在点击上方的就不放进训练的集合中，就不当成训练样本</li>
</ul>
<figure>
<img
src="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=YTkyNjFmYTU2OTc1MjhhZjliYWMwNmVmZjNjMzk1MTBfV2wyaWRQWGV4MEMxSXBDam1UZlNNYnhVYTN4RTJKSEZfVG9rZW46UGNEVWJSWVU0b1FtMWF4MHpGVWNJNzlwbkVkXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ul>
<li>训练的过程中，会将这个偏差特征不能和正常特征一起喂入DNN，否则会改变排序结果</li>
</ul>
<h2 id="数据特征处理">数据特征处理</h2>
<h3 id="处理缺失值">处理缺失值</h3>
<ul>
<li>训练模型来预测缺失值</li>
</ul>
<p>比如对于新用户，我们可以构建一个模型，利用比较容易获得的人口属性(比如性别、年龄等)预测新用户对某个内容分类、标签的喜爱程度(比如对某类内容的CTR)。再比如对于新物料，我们可以训练一个模型，利用物料的静态画像(比如分类、标签、品牌、价位)预测它的动态画像(CTR、
平均观看时长、平均销售额等)。</p>
<h3 id="标准化处理">标准化处理</h3>
<p>标准化的目的是将不同量纲、不同取值范围的数值特征都压缩到同一个数值范围内，使它们彼此可比。最常用的标准化是z-score标准化</p>
<p><span class="math display">\[x^*=(x-\mu)/\sigma\]</span></p>
<ul>
<li>x是某条样本在特征F的原始取值。</li>
<li>μ、σ分别是特征F在训练数据集上的均值和标准差。</li>
<li>x*是某条样本在特征F的标准化结果，称为z-score。</li>
</ul>
<p>标准化数据</p>
<ul>
<li>目的：将不同量纲、不同取值范围的数值压缩到一个数值范围内</li>
<li>标准化z-score方法：<span
class="math display">\[x^*=(x-\mu)/\sigma\]</span>分别是均值和标准差</li>
</ul>
<h3 id="数据平滑与消偏">数据平滑与消偏</h3>
<p>目标：<strong>克服小样本的负面影响</strong>，提高计算结果的置信区间</p>
<p>推荐系统中经常要计算各种比率作为特征，比如点击率、点赞率、购买率、复购率等。计算这些比率时，我们经常遇到的一个问题就是样本太少，导致计算结果不可信。比如计算一件商品，
只被曝光了一次并被购买了，由此我们就说它的购买率是100%，从而认定它是爆款，应该大力推荐，显然这是站不住脚的。为克服小样本的负面影响，提高计算结果的置信水平，我们可以采用"威尔逊区间平滑"：</p>
<p><span
class="math display">\[p^*=\frac{p+\frac{z^2}{2n}-z(\frac{p(1-p)}{n}+\frac{z^2}{4n^2})^{1/2}}{1+{2n}\frac{z^2}{n}}\]</span></p>
<ul>
<li>z是一个超参，代表对应某个置信水平的z-score。比如当我们希望计算结果有95%的置信水平时，z应该</li>
</ul>
<p>等于1.96。p是用简单方法计算出的比率。比如当p代表点击率时，就是拿点击样本数除以曝光样本数。</p>
<ul>
<li><span
class="math display">\[p^*\]</span>是平滑后的比率。n是样本数量。</li>
</ul>
<h3 id="分桶离散化">分桶离散化</h3>
<p>在推荐模型中，使用类别特征具有能更好反映非线性关系、便于存储与计算等多方面优势，因此在实践中，我们更喜欢将<strong>实数特征离散成类别特征</strong>。</p>
<p>离散方法就是分桶，即将实数特征的值域划分为若干区间，又称为"桶"，看实数特征落进哪个桶，就以那个桶的桶号作为类别特征值。比如，某用户在最近一小时看了5个视频，如果用实数特征描述，特征是"最近1小时看的视频数"，特征值是5。而如果离散成类别特征，整个特征可以表示成"ast1hour_
<em>0</em> _10"这
个字符串，表示该用户在最近1小时看的视频数在0~10之间。</p>
<p>分桶有三种实现方式:</p>
<ul>
<li>等宽分桶:即将特征值域平均划分为了N等份,每份算一个桶。</li>
<li>等频分桶:将整个值域的N个分位数(Percentile)
作为各桶的边界，保证落入各个桶的样本个数大致要相等。</li>
<li>模型分桶：对实数特征F分桶，。第1阶段，单独拿特征F与目标值拟合一棵简单的决策树。第2阶段才进行分桶，将某个特征中F的实数取值f喂进决策树，f最终落进的那个叶子节点的编号就是f的离散化结果。</li>
</ul>
<h2 id="类别特征的处理">类别特征的处理</h2>
<p>首先明确一下<strong>推荐系统的特征空间：高维、稀疏</strong>的特点</p>
<h3 id="增强类别特征表达">增强类别特征表达</h3>
<ul>
<li>Embedding自动学习并拓展内涵，学习<strong>隐语义</strong>拓展单个特征的内涵，扩展单个特征的内涵</li>
<li>多特征交叉，选择用户多个不同的<strong>特征</strong>进行交叉一次来增强特征的表达能力，比如“20岁”和“程序员”的特征交叉，“格子衬衫”作为推荐选择</li>
</ul>
<h3 id="类别特征的高维性">类别特征的高维性</h3>
<ul>
<li>数据位的很高，需要上百万的标签，多维特征交叉</li>
<li><strong>Parameter Server架构</strong>缓解高维数据的难度</li>
<li>分散了参数存储检索的压力，降低了带宽资源与时间开销</li>
</ul>
<h3 id="类别特征的稀疏">类别特征的稀疏</h3>
<ul>
<li>FTRL自适应调整学习率，常见的特征受训机会多，罕见特征受训机会少</li>
<li>DIN模型提出自适应调整正则系数</li>
</ul>
<h3 id="特征如何表征">特征如何<strong>表征</strong></h3>
<ul>
<li>建立字符串到数字的映射表，缺点在于需要更新维护且对于大规模而言比较难以负担</li>
</ul>
<figure>
<img
src="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=OTY4NDhmYTRiY2ViZGJjYWYxMDdjNWI0MTgwNDgyOWZfYjdCMmlkU2pKaHZNUEltNnBDTFBxTWQwTE5aaUVEZkZfVG9rZW46STBpMGJoa0lpb3k0SlR4M01Fa2NidWx5bnVkXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ul>
<li>特征哈希Feature Hashing
<ul>
<li>Feature Hashing负责将输入的字符串映射成一个[0,
N)之间的整数，N是Embedding矩阵的总行数，映射得到的整数代表该类别特征的Embedding在Embedding矩阵中的行号。</li>
<li>Feature
Hashing可以简单理解为，先计算输入的字符串的哈希值，再拿哈希值对Embedding矩阵行数N取余数。当然实际实现要更复杂一些，以减少发生"哈希冲突"
(Hash Collision)的可能性。</li>
<li>只要Embedding的长度相同，若干Field可以共享一个Feature
Hash模块与背后的Embedding矩阵。相比于让各个Field拥有独立的Embedding矩阵，这种共享方式对空间的利用率更高，是大型推荐模型的主流作法。</li>
</ul></li>
</ul>
<figure>
<img
src="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWZhZjNlODk0MTAzM2I3YWI5NTIxNTJiNDUzZjc2ZTJfSzkyalBacmxtRVYyOWNxalpubmZGdDY2MUhYbEJWYkFfVG9rZW46RDA1dWJpQmhRb25mVWZ4Y3BncGNqd1FWbjBkXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h1 id="推荐系统的embedding">推荐系统的Embedding</h1>
<h2 id="embedding的必要性"><strong>Embedding的必要性</strong></h2>
<p>对于推荐系统而言：<strong>记忆+拓展</strong></p>
<p><strong>记忆</strong>能够处理80%的需求，但是个性化太弱（评分）</p>
<ul>
<li>Logistic Regression
能够很好的实现记忆功能，记住一些比较经典的关联标签</li>
<li>所有的模式，都依赖人工输入。所以在推荐模型的LR时代，特征程既需要创意，同时也是一项体力活。</li>
<li>LR本身并不能够发掘出新模式，它只负责评估各模式的重要性。这个重要性是通过大量的历史数据拟合得到的。</li>
<li>LR
(评分卡)模型，强于记忆，但是弱于扩展。、中国顾客来了推饺子，美国客户来了推.火鸡，效果都不错，毕竟LR记性好。但是，当一个中国客户来了，你的推荐系统会给他推荐一只火鸡吗？如果你的推荐系统只有LR，只有记忆功能，答案是:不会。</li>
<li>因为&lt;中国人，火鸡&gt;毕竟属于小众模式，在历史样本罕有出现，LR的L1正则直接将打分置为0，从而被从评分卡中剔除。</li>
</ul>
<p><strong>拓展</strong>将细粒度变成粗粒度，借助深度学习的Embedding</p>
<ul>
<li>在训练LR模型的时候，每条样本除了将原来细粒度的概念&lt;春节，
中国人，饺子&gt;和&lt;感恩节，美国人，火鸡&gt;作为特征，也将扩展后的&lt;节日，和节日相关的食物&gt;作为特征，一同喂入LR模型。</li>
<li>这样训练后的"评分卡"工作量大，劳神费力。比如饺子、火鸡这两个概念，还能不能从其他角度拆解，从而发现更多的相似性?这就要受到工程师的业务水平、理解能力、创意水平的制约。</li>
<li>使用<strong>Embedding就是很有必要</strong>的</li>
</ul>
<h2 id="共享独占embedding"><strong>共享/独占Embedding</strong></h2>
<h3 id="共享embedding">共享Embedding</h3>
<p>所谓共享Embedding，是指同一套Embedding要喂入模型的多个地方，发挥多个作用。共享Embedding的好处有二：</p>
<ul>
<li>能够缓解由于特征稀疏、数据不足所导致的训练不充分。</li>
<li>Embedding矩阵一般都很大， 复用能够节省存储空间。</li>
</ul>
<p>再比如，召回模型中的双塔模型例子，</p>
<ul>
<li>Item ID Embedding既是重要的物料特征，要喂入ltem Tower；</li>
<li>同时，用户行为序列作为最重要的用户侧特征，也是由一系列的Item
ID组成， 因此ltem ID Embedding也要喂入User Tower。</li>
</ul>
<p>如果选择让喂入User Tower和Item Tower的Item ID
Embedding共享同一个Embedding矩阵,模型结构如图</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/(null)-20240116152609558.(null)"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="独占embedding">独占Embedding</h3>
<p>共享Embedding最大的优点，就是缓解因为数据不足而导致的稀疏特征训练不充分的问题。但是各互联网大厂最不缺的就是数据，这时共享Embedding的缺陷就暴露出来，即不同目标在训练同一套Embedding时可能相互干扰。</p>
<p>例子：APP的安装、 启动、卸载，对于要学习的APP
Embedding有着不同的要求。理想情况下，"安装"与"启动"两个Field要求APP
Embedding能够反映出APP为什么能够招人喜欢，而"卸载"这个Field要能够反映出APP为什么招人烦，所以大厂一般选择让"装/启/卸"三个Field各自拥有独立的Embedding矩阵。</p>
<p>更有甚者，大厂的推荐系统都是<strong>多目标</strong>的，比如要同时优化点击率、购买率、转发率、....
等多个目标。有一些重要特征，
在参与不同目标的建模时，也要使用不同的Embedding。</p>
<ul>
<li>不同的任务使用不同的Embedding的方法</li>
<li>如果在特征交叉的时候使用的是共享Embedding，会产生<strong>相互干扰</strong>的情况（不同需求要求不同Embedding）</li>
<li>FFM算法：每个特征在与不同特征交叉的时候，根据对方特征所属的Field要使用不同的Embedding</li>
<li>CAN算法：既要使用不同的Embedding进行特征交叉，但是又不想要太多的参数导致训练的难度增加</li>
</ul>
<h2 id="parameter-server训练框架">Parameter Server训练框架</h2>
<h3 id="传统的训练方式">传统的训练方式</h3>
<p>传统利用Hadoop/Spark的分布式训练方法忽略了<strong>高维稀疏特征空间，</strong>直接让master处理会参数量很大，传统的训练方式：</p>
<ol type="1">
<li>将训练数据分散到所有Slave节点。</li>
<li>Master节点将模型的最新参数广播到所有Slave节点。</li>
<li>每个Slave节点收到最新的参数后，用本地训练数据，先前代再回代，计算出梯度并.上传至Master。</li>
<li>Master节点收集齐所有Slave节点发来的梯度后，平均之，再用平均后的梯度更新模型参数。</li>
<li>回到步骤1，开始下一轮训练。</li>
</ol>
<p>"高维稀疏的特征空间"，造成了两个困难:</p>
<ol type="1">
<li>推荐系统的特征动辄上亿、上十亿，每个特征的Embedding是16位、
32位甚至更长，这么大的参数量是一台Master所容纳不下的。</li>
<li>每轮训练中，Master节点都要将这么大的参数量广播到各Slave节点，每个Slave还要将相同大小的梯度回传，占据的带宽、造成的时延绝对达不到在线实时训练的需求。</li>
</ol>
<h3 id="ps训练方式">PS训练方式</h3>
<figure>
<img
src="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=OWZlZWYzYTc2NTRjYWVlYWY1MTFlMzY3MzQ4NTMyZWFfTkpFUzNkRUlxcG1KRmx1UHpxVHNsNmJsb1Jyb3RHSDFfVG9rZW46U1FXbmI4UWg0b3E4eDd4Y1NpOWN5OFFFbmdjXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>训练步骤：</p>
<figure>
<img
src="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=MzVjZGIwNGIwMWJjNGVlOGQ4ZTRlY2IzMjg2MTJhNGNfbWlFNEJSSlF2TUxyZkV2RHp0UHpIV1JqcHhYVXh2cjBfVG9rZW46UEVQYWI3NTF4b1ZvZ2h4QVB6a2N3S1hobkRkXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>PS训练模式是Data Parallelism(数据并行)和Model
Parallelism(模型并行)的计算范式的结合，具体的训练流程见如下图：</p>
<figure>
<img
src="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=NWY4MzVlZmE0ZDc1YTRiNjNiNGFmYjg1YmJmNjJhNzhfUVpxTkMzQVJyZ2VEa3BiSnhHZDhSODdMWEV1YUtZT1VfVG9rZW46TnpRbGJ0OHZibzBvaWd4Z0RhYmNqY01VbkZmXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="ps并发策略">PS并发策略</h3>
<ul>
<li><strong>同步并发(BSP)</strong>
<ul>
<li><p>各Worker完成自己的本轮计算，将梯度汇报给Server，然后阻塞等待。</p></li>
<li><p>Server在收集齐所有Worker上报的梯度后，聚合梯度，用SGD算法更新自己负责的那部分模型参数。</p></li>
<li><p>Server通知各Worker解除阻塞。</p></li>
<li><p>Worker接到解除阻塞的通知，从Server拉取更新过的模型参数，开始下一轮训练。</p></li>
<li><p>这种模式的优点是，多个Worker节点更新Server，上的参数时不会发生冲突，所以分布式训练的效果赞同于单机训练的效果。缺点是，一轮迭代中，速度快的节点要停下来等待速度慢的节点，从而形成了"短板效应"，慢节点就能拖累整个集群的计算速度。</p></li>
<li><figure>
<img
src="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=YWZkM2ZmNTFlM2RiNTkyMmEzNjExYzM1NWViMzQ0OTFfY1pQcUF6SnJDOTNGTUk2ODB6RlNicnNTWnRRdmRFSGFfVG9rZW46SHd2RmJHTG1Lb1hwRHp4ZmRhWmNObGVxbmhkXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure></li>
</ul></li>
<li><strong>异步并发(ASP)</strong>
<ul>
<li><p>ASP在每台worker推送完自己的梯度之和，不用等待其他worker，就可以开始训练下一个batch的数据，没有短板效应</p></li>
<li><p>但是由于缺乏同步控制，ASP可 能发生"梯度失效" (Stale
Gradient)的问题，从而影响收敛速度。举一个极度简化的例子：</p></li>
<li><p>当前Server端 上模型参数的版本是<span
class="math display">\[\theta_0\]</span>，有两个Worker节点，都从Server拉取<span
class="math display">\[\theta_0\]</span>，同时开始一轮训练。</p></li>
<li><p>Worker
1的速度比较快，很快训练完本地数据并向Server上报梯度g1。</p></li>
<li><p>Server收到g1后，根据SGD算法迭代一 步(步长为<span
class="math display">\[\lambda\]</span>)，将Server端的参数值由<span
class="math display">\[\theta_0\]</span>更新为<span
class="math display">\[\theta_1=\theta_0-g_1\]</span>。</p></li>
<li><p>此时Worker 2才完成计算并向Server报了自己的梯度g2。</p></li>
<li><p>Server收到g2后，如果像<span
class="math display">\[\theta_2=\theta_1-\lambda
g_2\]</span>这样更新模型参数，反而可能损害收敛。这是因为g2是Worker
2基于<span
class="math display">\[\theta_0\]</span>计算得到的，而Server端的参
数此时已经变成了<span
class="math display">\[\theta_1\]</span>，g2已经失效。</p></li>
<li><figure>
<img
src="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=YTg1NzdmM2Q5ZDk5ZTQzODQyMGQ3Njc3ZThkODNmMmRfMVd1a1A4cGFOTkhtUVo5Q2pFRkdLc1BwSFhWbkZvRFpfVG9rZW46SDJ6Q2JpYUQ5b1BWSFp4MjZ0ZGNwUjkybktjXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure></li>
</ul></li>
</ul>
<p>得益于推荐系统中的<strong>特征超级稀疏</strong>的特点，在一轮迭代中，各个Worker节点的局部训练数据所包含的非零特征，相互重叠得并不严重。多个Worker节点同时更新同一个特征的参数的可能性非常小，所以Server端
的冲突也就没有那么频繁和严重，ASP模式在推荐系统中依然比较常用的。</p>
<ul>
<li><strong>半同步半异步并发(SSP)</strong></li>
</ul>
<p>半同步半异步(Staleness Synchronous Parallel, SSP) 是BSP与
ASP的折衷方案。SSP允许各Worker节点在一定迭代轮数之内保持异步。如果发现最快Worker节点与最慢Worker节点的迭代步数之差已经超过了允许的最大值，所有Worker都要停下来进行一次<strong>参数同步</strong>。SSP希望通过折衷，实现"计算效率"与"收敛精度"之间的平衡。</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/(null)-20240116152610714.(null)"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h1 id="冷启动">冷启动</h1>
<p>推荐系统的冷启问题是指：
针对<strong>较少消费记录</strong>的新用户、新物料的推荐。声明一下,
本章提到的新用户，既包括那些初次使用APP、没有任何历史行为的纯新用户，也包括那些虽然APP安装了很久、但偶尔使用的低活跃用户。新物料的定义也类似。</p>
<p>冷启是困扰推荐系统的一大难题。</p>
<ul>
<li>一方面, 冷启非常重要。对新用户而言, 现在互联网行业竞争激烈,
拉新、获客成本居高不下, 好不容易拉来的新用户,
如果模型承接做得不好而让其流失掉, 前面的努力也就白白浪费了;
对新物料而言,新物料推荐不出去, 既会让用户失去新鲜感而加速流失,
也会打击创作者的积极性, 不利于建立良好的内容生态。</li>
<li>另一方面, 冷启又相当困难。毕竟"巧妇难为无米之炊", 再强大的模型,
没有信息喂进去, 也发挥不出什么作用。而且,
很多经典的推荐算法从根本上就不支持新用户与新物料, 比如Item <span
class="math display">\[2 \mathrm{Vec\]</span>
对不曾在训练集中出现的物料就无法获得其Embedding,
比如DIN/SIM要对用户历史行为序列做Attention,
在新用户身上也就没有了用武之地。</li>
</ul>
<p>既然冷启是如此重要且艰巨,
业界涌现出了许多方法来应对这一难题。其中不乏一些简单、经典的策略,比如:</p>
<ul>
<li>给新用户推荐全网最热门的物料。</li>
<li>不依赖消费记录, 重视使用基本属性（比如用户的性别与年龄,
物料的分类与标签）。</li>
</ul>
<h2 id="代表算法">代表算法</h2>
<ol type="1">
<li><p>Bandit算法</p>
<ol type="1">
<li><p><strong>多臂老虎机问题：本质就是平衡探索和利用</strong></p></li>
<li><p>多臂老虎机问题与"冷启动"问题是非常相似的:</p></li>
<li><ul>
<li>对于新用户冷启动, 每个新用户就是一台老虎机,
每个兴趣大类（比如：电影、音乐、军事、体育、......)
就是老虎机的一个手柄。向该新用户展示某个兴趣类目下的物料,
相当于拉动某一根手柄。用户的反馈（比如点击）犹如老虎机吐出的金币。我们希望通过有限次试探,
使得到的用户正反馈最大化，也就摸清了用户兴趣，使用户获得了良好的初体验，增强APP对新用户的粘性。</li>
<li>对于新物料冷启动, 所有用户组成一台老虎机,
候选新品池中的每个新物料相当于一根手柄。曝光某个新物料相当于拉动一次手柄。我们希望通过有限流量的试探,
找到新品池中最优质的候选物料,
犹如在多臂老虎机中找到那根能吐出最多金币的手柄。</li>
</ul></li>
<li><p>因此，我们可以借鉴MAB问题的成熟算法来解决推荐系统中的冷启动问题。</p></li>
<li><p>MAB问题最朴素、最初级的解法就是将N次尝试划分成"探索（Explore）"与"开发（Exploit）"先后两个阶段:</p></li>
<li><ul>
<li>先"探索", 也就是将每个手柄都拉动 $<span class="math display">\[$
次。统计 \]</span>{R}(i<span class="math display">\[ 为拉动第
\]</span><span class="math display">\[ 根手柄 \]</span>$$
次得到的平均收益。</li>
<li>再"开发", 找到平均收益最大的那根手柄 <span
class="math display">\[a_{\max }=\operatorname{argmax}_i
\bar{R}(i)\]</span>，然后将剩余的机会全部用来拉动 <span
class="math display">\[a_{\max \text { 。 }\]</span></li>
</ul></li>
<li><p><strong>Epsilon Greedy</strong></p></li>
<li><figure>
<img
src="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=NGQ4NDMwYWRiYjEzNmFiOWFlYWU0Njg4Nzc5NmYyMzNfcjFCdjlnVXBkQ3dDV01SeUJHR2NSdmdvYWw2WmNrV2ZfVG9rZW46Tk1JWmJ0ckZLb0lHRFV4NDk2bWN0ZnJ1bk5kXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure></li>
<li><p><strong>UCB算法，每次尝试都选择收益最高的</strong></p></li>
<li><figure>
<img
src="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=Yzk4YTNjNGYzM2U0ZjYxY2RlMGE5ZDRmY2QxNzg4MTlfSUVXcXRDVGNtNVpRWG5TbGtZa1JMVWZxTkRIcWczVTNfVG9rZW46UE9IUmJvd3F1b1JRWWV4eTRHQ2NYRURibmcyXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure></li>
<li><p>第 $$$$根手柄的收益上限，如公式所示。</p></li>
<li><p><span class="math display">\[U C B(i)=\bar{R}(i)+c \sqrt{\frac{2
\log N}{n_i}}\]</span></p></li>
<li><ul>
<li><span class="math display">\[\bar{R}(i\]</span> 表示第
$$$$根手柄的平均收益</li>
<li><span class="math display">\[\sqrt{\frac{2 \log N}{n_i}\]</span>
表示第 $<span class="math display">\[$根手柄的收益的不确定性。
\]</span><span class="math display">\[ 是到目前为止一共尝试的总次数,
\]</span>n_<span class="math display">\[ 是其中拉动第 \]</span><span
class="math display">\[根手柄的次数。可见, \]</span>n_<span
class="math display">\[ 越小, 即第
\]</span>$$根手柄尝试得越少，其收益的不确定性越高, 也就是潜力越大,
尝试的机会也就应该增加。</li>
<li>$$$$ 表示"收益均值"与"收益潜力"之间的调节权重, 和Decay Epsilon
Greedy一样, c也随时间衰减，后期"探索"应该降低，而主要以"开发"为主。</li>
</ul></li>
<li><p>从公式(8-1)可以看出, 一根手柄的收益上限高,
只有两种可能性：</p></li>
<li><ul>
<li>要么是这根手柄的平均收益高。此时, 选择上限最高的手柄,
就是在<strong>"开发"</strong>。</li>
<li>要么是这根手柄的收益潜力高。此时, 选择上限最高的手柄,
就是在<strong>"探索"</strong>。</li>
</ul></li>
<li><figure>
<img
src="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=YzJjNWYwNDQ1ZGRjMDA4Y2M1YzQxOWJlZjI4YWFhNTBfb1gxQ1kxQ0lkek1nSVJpWnM2UDNqY2M2MXU5ZnRsSFdfVG9rZW46UjVMemJ5MklIb0JWVWd4MjdzR2NPTTlLbnFiXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure></li>
<li><p><strong>Bayesian Bandit</strong></p></li>
<li><p>基于Bayesian的MAB问题求解方法如下:</p></li>
<li><ul>
<li>假定第 $<span class="math display">\[$ 根手柄的平均收益遵循先验概率
\]</span>p({R}(i)$$</li>
<li>经过若干次实验, 第 $<span class="math display">\[$
根手柄收到一批反馈 \]</span>D_i={r_1, r_2, , r_{n_i}$$</li>
<li>根据Bayes公式, 第 $<span class="math display">\[$
根手柄的平均收益的后验概率
-    \]</span>p({R}(i) D_i) p(D_i {R}(i)) p({R}(i)$$</li>
<li>此时让我们选择手柄时,
我们只需要从各手柄收益的后验概率中随机采样一个数字,
然后选择采样数字最大的那根手柄去拉动即可。</li>
</ul></li>
<li><p>当各手柄的收益非 0 即 1 （这一点非常适用于推荐场景,
比如点击与否）时,
我们可以用Bernoulli分布来描述。而这个Bernoulli的均值（即每根手柄的平均收益）可以用Bernoulli分布的共轭分布Beta分布来描述，好处是先验分布与后验分布都遵循同样的形式，方便Bayes公式的计算。这种Bayesian
Bandit算法被称为 Thompson Sampling, 可用于试探新用户的兴趣分布,
如代码代码 8-3所示。</p></li>
<li><figure>
<img
src="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDUyYmY4NzU1MGI4NTU2MjA3M2JkNTA0MDY1MjE5MjRfWEtZUWhSbU9xaUw1VkRyT0VoOEo1RnJxa2ZwWDROZUlfVG9rZW46U1p3NGJFNFNpb2dkSzN4dzhrVGNTTTI2bk1kXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure></li>
<li><ul>
<li>将每个新用户设想成一台老虎机,
假设一共有K个兴趣分类（比如：军事、历史、电影、音乐、......)，相当于每个新用户的老虎机有
$$$$ 个手柄可选择。</li>
<li>第 2 行：向当前新用户展示第 <span
class="math display">\[\mathrm{k\]</span>
个兴趣分类的平均收益用Beta分布来描述, 涉及到两个参数 <span
class="math display">\[\alpha_\]</span> 和 <span
class="math display">\[\beta_\]</span> 。这里将 <span
class="math display">\[\alpha_\]</span> 和 <span
class="math display">\[\beta_\]</span> 都初始化为 1 ,
Beta分布退化成平均分布</li>
<li>第7行：选择采样随机数最大的那个兴趣分类。
三根手柄采样到的随机数分别为 [0.1,0.75,0.2]，所以应该选择第 2
个手柄代表的兴趣分类。</li>
<li>第 8 行：将选中的兴趣分类 <span class="math display">\[c_\]</span>
中优质物料推荐给新用户。至于如何获得一个兴趣分类下的优质物料,
方法就多种多样了, 可以通过大数据统计, 也可以让运营团队人工管选。</li>
</ul></li>
</ol></li>
<li><p><strong>元学习(Meta</strong> <strong>Learning)</strong></p>
<ol type="1">
<li><p>元学习介绍</p>
<ul>
<li><p>首先注意, 喂入Meta Learning的基本数据单位不再是一条条单独的样本,
而是一个个<strong>"任务"（Task）</strong>。一个Task内部又包含两个数据集,
一个训练集（元学习领域又称Support Set）, 一个测试集（元学习领域又称Query
Set）。</p></li>
<li><p>如图所示, 第一个Task是用于分类水果图片。训练Task 1时,
将其中的训练集 (一批水果图片和标注) 喂入模板<span
class="math display">\[ F_{\phi}\]</span>, 训练得到一个水果分类器 <span
class="math display">\[f_{\theta_1^*}, \theta_1^\]</span>
是训练得到的最优权重。这个步骤只用到单独一个 Task的数据,
所以被称为"任务内学习"Within-Task Learning。</p></li>
<li><p>再将Task 1 中的测试集喂入训练好的模型<span
class="math display">\[f_{\theta_1^*}\]</span>, 计算出在测试集上的损失
<span class="math display">\[l_\]</span> 。</p></li>
<li><p>同理, 将Task 2 中的训练集 (交通工具的图片和标注) 喂入模板 <span
class="math display">\[ F_{\phi}\]</span>, 训练得到一个交通工具分类器
<span class="math display">\[f_{\theta^{2 *}\]</span> , <span
class="math display">\[\theta_2^\]</span> 是训练得到的最优权重。再拿Task
2 中的测试集喂入 <span class="math display">\[f_{\theta^{2 *}\]</span> ,
计算得到测试集的损失 <span class="math display">\[l_\]</span>
。</p></li>
<li><p>假设训练一个批次 (Batch) 有 $$$$ 个任务,
总损失就是所有任务的测试集上的损失之和。这个步骤用到了一个Batch内所有任务的数据,
所以被称为"跨任务学习"（Across-Task Learning）。</p></li>
<li><p><span class="math display">\[L_{\text {meta }}(\phi)=\sum_{n=1}^N
l_n=\sum_{n=1}^N L\left(D_n^{\text {test }} \mid
\theta_n^*\right)\]</span></p></li>
<li><ul>
<li>L是所有任务共用的损失函数</li>
<li><span class="math display">\[l_\]</span> 是第 $$$$
个任务在其测试集上的损失</li>
<li><span class="math display">\[D_n^{\text {test }\]</span> 是第 $$$$
个任务中的测试集（即Query Set）</li>
<li><span class="math display">\[\theta_n^\]</span> 是第 $$$$
个任务训练得到的最优参数</li>
</ul></li>
</ul></li>
<li><figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/(null)-20240116152611540.(null)"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure></li>
<li><p><strong>MAML算法</strong></p>
<ul>
<li><p>Model-Agnostic Meta-Learning (MAML)是一类特殊的元学习,
有两个特点:</p></li>
<li><p>模板配置 <span class="math display">\[\ph\]</span> 仅限于模型参数
<span class="math display">\[\thet\]</span> 的初始值。</p></li>
<li><p>损失函数 <span class="math display">\[L_{\text {meta
}}(\phi\]</span> <strong>对</strong> <span
class="math display">\[\ph\]</span> <strong>可导,</strong> 从而可以通过
SGD的方式求解出最优 <span class="math display">\[\ph\]</span> ,
也就是最优的 <span class="math display">\[\thet\]</span> 初值。</p></li>
<li><p>提出MAML是为了解决"小样本训练"（Few-Shot Learning）的问题,
也就是新任务没有足够多的数据将模型参数从头训练好。MAML的解决思路是:</p></li>
<li><p>通过若干组任务（比如Task 1 是分辨不同水果, Task 2
是分辨不同的交通工具）, 学习出一套高质量的参数初值 <span
class="math display">\[\ph\]</span></p></li>
<li><p>当面对一个新任务（比如分辨不同动物时）时, 由这段高质量的参数初值
<span class="math display">\[\ph\]</span> 出发,
只需要经过少量样本的迭代, 就能达到适合新任务的最优参数 <span
class="math display">\[\theta^\]</span>,
从而解决了新任务样本不足的问题。</p></li>
<li><p>具体解法上, 尽管理论上从初值 <span
class="math display">\[\ph\]</span> 出发,
需要经过多轮训练迭代才能得到最优参数 <span
class="math display">\[\theta^\]</span> 。但是,
从减少训练样本数的实际目标出发, 我们假设初值 <span
class="math display">\[\ph\]</span> 只经过一次梯度下降就得到最优参数
<span class="math display">\[\theta^\]</span>, 如公式所示。</p></li>
<li><p><span class="math display">\[\theta_n^*=\phi-\alpha
\frac{\partial L\left(D_n^{\text {train }} \mid \phi\right)}{\partial
\phi}\]</span></p></li>
<li><p><span class="math display">\[\ph\]</span>
是所有任务共享的参数初值</p></li>
<li><p><span class="math display">\[\theta_n^\]</span> 是第 $<span
class="math display">\[$ 个任务的最优模型参数, 假设由 \]</span>$$
通过一次梯度下降就能得到</p></li>
<li><p>L是所有任务共享的损失函数</p></li>
<li><p><span class="math display">\[L\left(D_n^{\text {train }} \mid
\phi\right\]</span> 是模型以初值 <span
class="math display">\[\ph\]</span> 为参数, 在第 $<span
class="math display">\[$ 个任务的训练集 \]</span>D_n^{$$
上的损失</p></li>
<li><p><span class="math display">\[\alph\]</span> 是迭代步长</p></li>
</ul></li>
<li><p>如何作用于冷启动的推荐系统任务呢？</p>
<ul>
<li><p>我们可以得到将MAML应用于推荐场景所要做的第一个改进,
就是修正其应用范围：</p></li>
<li><p>对于推荐模型的大部分参数, 包括DNN权重和常规特征的Embedding,
新任务（即新用户/新物料）应该直接复用老任务（即老用户/老物料）已经训练好的，这样既能保证参数的质量，又能节省资源。所以,
MAML完全没必要学习这些参数的最优初值。</p></li>
<li><p>每个新任务只有ID Embedding是这个任务独有的, 是无法复用老任务的,
希望能够从一个最优初值出发只经过少量数据就快速迭代至最优状态。而这个最优的User
ID Embedding初值, 或最优的Item ID Embedding的初值,
是唯一需要MAML学习的模板配置。</p></li>
<li><p>优化目标改造</p></li>
<li><p>MAML在推荐场景下的唯一任务就是将最优的ID Embedding初值 <span
class="math display">\[\ph\]</span> 学习出来,
而在冷启的不同阶段发挥着不同作用。以新用户冷启为例:</p></li>
<li><p>第1个阶段是Cold-Start（为了和通篇所指的广义冷启相区别,
我称之为"纯冷启"）：用户生平第一次向本推荐服务发出请求，预测程序在线上服务的模型的Embedding层找不到该用户User
ID对应的 Embedding, 就拿 <span class="math display">\[\ph\]</span>
代替喂进模型进行预测。此时, <span class="math display">\[\ph\]</span>
直接影响了新用户的初体验。</p></li>
<li><p>第2个阶段是Warm-Up（热身）：第1个阶段的用户反馈回传至在线学习
(Online Learning) 程序, 训练程序在Parameter Server中查不到新用户User
ID对应的Embedding, 就拿 <span class="math display">\[\ph\]</span>
当初值, 利用新用户的反馈数据, 通过一次梯度下降就得到了该新用户User ID
Embedding的最新值 <span class="math display">\[\theta^\]</span> 。 <span
class="math display">\[\theta^\]</span> 被打到线上, 作为新的 User ID
Embedding, 为该用户的第"二"次（理想了一点,
假设在线更新足够及时）请求服务。</p></li>
<li></li>
</ul></li>
</ol></li>
<li><p><strong>对比学习(Contrastive Learning)</strong></p>
<ol type="1">
<li><p>对比学习属于<strong>自监督学习的一类</strong></p></li>
<li><p>一个完整的分类模型可以由"特征编码"（Encoding）与"分
(Classification) 两阶段。</p></li>
<li><ul>
<li>特征编码（Encoding）阶段：一张图片可以由一个长度等于 <span
class="math display">\[H \times W \times \]</span> 的大向量表示, 其中
<span class="math display">\[H / W / \]</span>
分别是图片的高/宽/通道个数（比如RGB三色可以理解为 3
个通道）。其中单个维度的信息含量都有限,
而且难免包含噪声。Encoder或是过滤掉原始输入中的噪声,
或是将若干弱信息的原始特征交叉、聚合成一个强信息的特征, 从而将原来 <span
class="math display">\[H \times W \times \]</span> 的原始特征压缩成一个
$<span class="math display">\[$ 维的&quot;有效特征&quot;, 其中
\]</span>K H W $$ 。"有效特征"虽然长度变短了,
但是却保留了原始特征中绝大部分的信息, 是原始特征的"精华"。</li>
<li>分类 (Classification)
阶段：将前一阶段提取出来的"有效特征"，经过简单映射，就得到了最终分类。</li>
</ul></li>
<li><p>常规机器学习中,
"特征编码"与"分类"是由一个模型通过端到端学习来完成的。但是由于现在标注稀疏,
我们只好将"特征编码"与"分类"物理拆分成两个独立的模型。</p></li>
<li><ul>
<li>"特征编码"阶段, 通过"自监督"（Self-Supervised Learning,
SSL）方式来学习。所谓"自监督学习", 是指不依赖人工标注,
通过挖掘未标注样本内部存在的结构、关联,
将"特征编码"这个模块训练出来。传统的降噪自编码器（Denoising
AutoEncoder），Word2Vec和Transformer中通过句子的一部分预测另一部分,
和这里要讲的对比学习, 都属于"自监督学习"的范畴。</li>
<li>"分类"阶段, 还是需要通过"<strong>监督" (Supervised)
方式来学习</strong>。但是由于编码阶段提取出来的"有效特征"的长度已经大大缩短,
所以“分类"模型只需要少量标注数据就能被充分训练,
从而缓解了标注稀疏的问题。</li>
</ul></li>
<li><figure>
<img
src="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTIxZWNhOTQwOWY5Y2NkZGJhMmExZWM5YTI2NmQ2ZGZfVllFZlFtN2tlVlNScjVUZjZVdDdUSk94RkpIMFE1dUlfVG9rZW46SnpER2I1MGc4bzVzZFB4UkZQa2NEODQ4bjdiXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure></li>
<li><ul>
<li>我们有一张原始图片 $<span
class="math display">\[$  尽管我们很容易知道这是一张狼犬的图片, 但是
\]</span><span class="math display">\[
没有被标注。模型并不知道,也无需知道 \]</span>$$ 的类别。</li>
<li>我们通过一些手段, 从原始图片衍生出多张与其相似的图片,
这个过程被称为"数据增强"（Data Augmentation) 。比如中的数据增强,
就是将原始图片 <span class="math display">\[P^{\prime \prime\]</span>
黑白化"得到增强版图片 <span class="math display">\[P_{a u\]</span>
。其他对于图片的数据增强方式还包括：旋转、镜像、剪裁等。</li>
<li>再从全体图片中随机抽取一张图片 <span class="math display">\[P_{r
a\]</span> 。假设候选集足够庞大,
我们不太可能再抽到同一类别的图片,比如中就抽到一张雪鸮的图片。当然模型同样无需知道其类别。</li>
<li>将原始图片 $<span class="math display">\[$ 、增强图片 \]</span>P_{a
u<span class="math display">\[ 和随机图片 \]</span>P_{r a<span
class="math display">\[ , 都喂入Encoder进行提炼压缩,
得到三者的&quot;有效特征&quot;向量 \]</span>V 、 <em>{a u<span
class="math display">\[ 和 \]</span></em>{r a$$ 。</li>
<li>我们计算 <span class="math display">\[\boldsymbol{V\]</span> 与
<span class="math display">\[\mathbf{V}_{a u\]</span> 之间的相似度 <span
class="math display">\[s_{+}=\operatorname{Sim}\left(\mathbf{V},
\mathbf{V}_{a u}\right)\]</span>, 模型的训练目标是最大化 <span
class="math display">\[s_{+}\]</span>, 即原样本与其增强版在向量空间里,
应该越近越好。</li>
<li>我们计算 <span class="math display">\[\mathbf{V\]</span> 与 <span
class="math display">\[\mathbf{V}_{r a\]</span> 之间的相似度 <span
class="math display">\[s_{-}=\operatorname{Sim}\left(\mathbf{V},
\mathbf{V}_{r a}\right)\]</span>, 模型的训练目标是最小化 <span
class="math display">\[s_{-}\]</span>,
即原样本与随机抽取的其他样本在向量空间里, 应该越远越好。</li>
</ul></li>
<li><p>再将训练好的分类器用于小样本学习中</p></li>
<li><figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/(null)-20240116152611886.(null)"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure></li>
<li><p>如何将<strong>对比学习用于推荐系统</strong></p>
<ul>
<li><p>推荐系统中的海量数据标注存在贫富差距的问题，就是所谓的<strong>二八法则</strong>，少数的物料或者用户拥有了大量的标注信息，但是大量的物料或者用户所拥有的标注信息很少</p></li>
<li><p>对比学习在推荐系统的主要作用就是<strong>“纠偏”</strong></p></li>
<li><p>通过"数据增强", 我们从少数用户/物料衍生出更多样本,
放大少数群体在训练样本中的音量。</p></li>
<li><p>对比学习作为辅助任务,
要让模型多见识一些平日里被其忽视的少数人群和小众物料。让平常听惯了"阳春白雪"的模型,
也多多感受一下"下里巴人"。</p></li>
<li><p>因为在训练阶段与少数群体都"亲密接触"过了,
被对比学习调教过的模型线上预测时,
会少一份势利,对小众人群与物料友好一些。</p></li>
<li></li>
<li><p>既然明确了对比学习的目标是为了Debias, 那么训练时,
我们必须注意以下两点</p></li>
<li><p>第一点, 参与对比学习的样本, 和参与主任务的样本,
最好来自不同的样本空间</p>
<ul>
<li>主任务, 需要拟合用户与物料之间的真实互动,
训练数据还是以曝光数据为主, 也就是以老用户、老物料为主。</li>
<li>对比学习, 既然是为了放大少数群体样本的影响力,
其训练样本应该以鲜有曝光机会的少数人群和小众物料为主。比如,
越少曝光的用户或物料, 他们的样本被衍生、增强得应该越多; 反之,
就应该少增强或不增强。</li>
</ul></li>
<li><p>第二点, 主任务与对比学习任务之间, 必须共享参数。</p>
<ul>
<li>近年来给我的感觉, 参数共享、结构共享在推荐算法中,
越来越不受待见。比如, 多任务场景下,流行让同一个特征对不同目标,
拥有不同Embedding; 通篇都在讲参数独立性, 同一个特征与不同特征交叉时,
都要使用不同的Embedding。</li>
<li>但是, 对于对比学习, 参数共享是必须的。否则,
主模型与对比学习辅助模型, 各学各的, 主模型中的Bias依旧存在,
对比学习学了个寂寞。</li>
<li><img
src="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=NTQwYzA5MTAxZTQzYjBkY2ZiZjNjN2QzMTUxMDA2YjlfWThoNmFJN2ROTFp2N0FtSlk1SGlUbE9ISlNhYkNrYmVfVG9rZW46WVdJUWJMNkFQb3k1R0F4VFU2ZGN4YnhCbnFyXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"
title="fig:" alt="img" /></li>
</ul></li>
</ul></li>
<li><p>区分对比学习和向量化召回</p>
<ul>
<li>首先, 向量召回属于<strong>"有监督学习"</strong>。U2|召回中,
用户与其点击过的物料在向量空间是相近的。在 121 召回中,
被同一个用户点击过的物料在向量空间中是相近的。这些正样本都来源于用户反馈（标注）。反之,对比学习属于<strong>"自监督学习",</strong>
不需要用户标注。用户与其增强版本, 物料与其增强版本,
这些正样本都是我们根据一定规则制造出来的。</li>
<li>其次,
向量召回重点<strong>关注的是负样本</strong>。大型推荐系统中的用户反馈源源不断,
正样本从来都不是问题。反之, 对于对比学习,
重点、难点恰恰是如何制造正样本。也就是给定用户或物料,
如何"增强"出与其相似的用户或物料信息。因为推荐模型中的特征,
以类别特征为主,
高维、稀疏且相互关联（比如被一个用户点击过的多个物料之间可能存在时序、因果关系），简单粗暴地"增强"，反而降低了产生的正样本的可信度。因此,
阅读将对比学习应用于推荐场景的文章, 重点是看其"数据增强"方法有何创新,
其他方面如负样本策略、模型结构、损失设计往往都是向量召回中的常规套路，无甚新意。</li>
<li>最后, 向量<strong>化召回是主任务</strong>,
比如替用户找到他喜欢的物料, 对推荐效果负直接责任。反之, 对比学习的目的,
仅仅是为了纠正模型对小众用户、冷门物料这些少数派的偏见。对比学习作为辅助任务,
只存在于训练阶段，并不上线，间接影响推荐效果。</li>
</ul></li>
</ol></li>
</ol>
<h1 id="推荐系统的多任务多场景">推荐系统的多任务多场景</h1>
<h2 id="多任务推荐">多任务推荐</h2>
<p>多任务建模(Multi-Task) ， 有时也被称为多目标建模(Multi-Objective)</p>
<ul>
<li>比如视频推荐场景下，
我们推荐出去的结果，既想让用户点击，点击之后又希望观看的时间尽量长，还想让用户多多评论、转发。因此，需要同时建模点击率、观看时长、评论率和转发率这4个目标。</li>
<li>比如电商场景下，我们推荐出去的商品，既想让用户多多点击，还希望用户多多下单购买(术语叫转化)。因此，我们要同时建模三个目标:一件商品从曝光到点击的概率(点击率，CTR)、从点击到购买的概率(转化率,
CVR)和从曝光到购买的概率(CTCVR)。</li>
</ul>
<p><strong>为什么不为每个目标单独建模?</strong></p>
<p>这么做太浪费资源，大厂的推荐模型本来就对内存、算力消耗巨大。如果每个目标单独建模，需要将内存、算力的消耗都乘上10，这笔预算恐怕很难批得下来。</p>
<p>其次，用户转化是一个链条，比如先点击，再加入购物车，最后购买。在这个链条越靠后的环节，价值越大，但是可用于训练的正样本也就越少，非常有必要将所有环节放在一起联合训练</p>
<p><strong>为什么不直接建模终极目标?</strong></p>
<p>以电商场景为例，用户最终没有购买(即未转化)，并不代表用户就一定不喜欢推荐结果，也很有可能是因为商品价格超出了这名用户的消费能力。如果只以提高CTCVR为唯一目标，APP推荐给这名用户的就都是在他消费能力之内的中低端商品。可能会暂时提高销售额，但是会带来两方面的危害:</p>
<ul>
<li>容易造成用户的审美疲劳，对用户的长期留存不利。</li>
<li>也失去给用户"种草"的机会。万一哪一天，用户狠下心来想剁手，APP却推荐不出来高端商品,</li>
</ul>
<p>也就白白浪费了一次提高销售额的机会。</p>
<h3 id="多任务方法">多任务方法</h3>
<h4 id="并发建模">并发建模</h4>
<p>这种模式下，每个目标独立建模，忽略了不同目标之间的因果关系。</p>
<ol type="1">
<li>Share Bottom共享底层</li>
</ol>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/(null)-20240116152612199.(null)"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ul>
<li>底层结构比如Embedding层和底层的DNN,为所有任务共享的。</li>
<li>每个任务有自己独立的"塔" 结构，Shared
Bottom的输出作为每个塔的输入。</li>
</ul>
<p>这种结构的优点是实现了多任务之间的"知识迁移"。比如，任务A的正样本多，任务B的正样本少。如果任务B单独训练，对"共享底层"的训练不会太充分。而联合任务A与B，数据丰富的任务A能够将"共享底层"训练到一个比较好的状态，让B在此基础上继续训练，事半功倍。</p>
<p>很多时候，不同任务之间的关系，并非我们想像的那般相辅相成。不同任务对底层共享参数的梯度方向存在分歧，虽说还不至于南辕北辙、相互拆台，但也做不到"心往一块想，劲往一处使"。</p>
<ol type="1">
<li>Multi-gate Mixture-of-Experts</li>
</ol>
<p>沿着拆解共享部分的思路，Mixture-of-Experts (MoE)
将"共享底层"拆分成若干小型DNN，<strong>每个DNN称为一个Expert</strong>，再由一个门控网络"
(Gate) 控制每个Expert对某个任务的参与程度。</p>
<figure>
<img
src="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmM4ZTkxYjNjNDBlY2VjOWY5Mzk1ZDBiYjQ4MmI1NmZfTmxzWWpQOU5jckR3MHAyR1pTVjhodlV2dUt2TEJKbkZfVG9rZW46SG92WmJBOHJjb25Qc3V4N0RoRmNQTnNibnBoXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>MoE中第 $$$$ 个目标的预测值, 如下所示。</p>
<p><span class="math display">\[y_k=h_k\left(\sum_{i=1}^n
g(\mathbf{x})_i \operatorname{Expert}_i(\mathbf{x})\right)\]</span></p>
<ul>
<li><span class="math display">\[\mathrm{x\]</span> 是输入的特征向量,
<span class="math display">\[y_\]</span> 是根据计算出的第 <span
class="math display">\[\mathrm{k\]</span> 个目标的预测值。</li>
<li>一共创建了n个Expert, Expert <span class="math display">\[t_\]</span>
代表第 <span class="math display">\[\mathrm{i\]</span>
个Expert的网络模型。</li>
<li><span class="math display">\[\mathrm{g\]</span> 代表门控模型, <span
class="math display">\[g(\mathbf{x}\]</span> 将输入特征映射成一个 $<span
class="math display">\[$ 维长的数组, \]</span>g()_<span
class="math display">\[ 是其中的第 \]</span><span
class="math display">\[ 位, 表示第 \]</span><span
class="math display">\[ 个Expert的权重。具体实现上, \]</span>$$
就是一个普通的多层全链接网络 (MLP), 其最后一层使用Softmax做激活函数,
使各Expert的权重之和等于 1 。</li>
<li><span class="math display">\[h_\]</span> 代表第 $<span
class="math display">\[$ 个任务的Tower结构（图 7-2中的Tower A和Tower B),
喂入 \]</span>h_$$ 的是各个Expert输出的加权和。</li>
</ul>
<p>Multi-gate Mixture-of-Experts (MMoE) 在MoE的基础上, 进一步拆解,
结构如图所示：</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/(null)-20240116152612493.(null)"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ul>
<li>MoE中只有一个Gate, 替所有任务决定各Expert的权重。</li>
<li>MMoE中, 每个任务都有自己的Gate,
衡量各Expert对于本任务的重要性。</li>
</ul>
<ol type="1">
<li>Progressive Layered Extraction</li>
</ol>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/(null)-20240116152612659.(null)"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ul>
<li>首先, 对模型的共享部分继续拆解。在MMoE中,
所有Expert为所有任务所共享。而在PLE中, 将所有
Exper划分为"任务独占"（Task Specific）和"任务共享"（Task
Shared）两大类，前者只参与单一任务，后者参与所有任务。比如图7-5中,
"Experts A"中的所有Experts, 只参与对任务A的建模。而建模任务
A，是由"Experts A"与"Experts Shared"中的所有Experts共同参与的。</li>
<li>其次, MMoE中只有一层Experts,
Experts之间的交互比较弱。而PLE中引入了多层Experts,
Experts之间的交互层层递进、深化。</li>
</ul>
<p>PLE的第 $<span class="math display">\[$ 层要输出 \]</span>N+$$
个向量, 如公式(7-3)所示</p>
<p><span class="math display">\[\left[\mathbf{x}_1^k, \ldots,
\mathbf{x}_N^k, \mathbf{x}_s^k\right]\]</span></p>
<ul>
<li>$$$$ 是所有任务的个数</li>
<li><span class="math display">\[\mathbf{x}_t^k, t \in[1, \ldots,
N\]</span> 表示第 $<span class="math display">\[$ 层对任务 \]</span>$$
的建模结果</li>
<li><span class="math display">\[\mathbf{x}_s^\]</span> 表示第 $$$$
层对共享信息的建模结果</li>
</ul>
<p>在第 <span class="math display">\[\mathrm{k\]</span> 层建模时,
首先将下层的输出喂入本层的各Experts</p>
<p><span class="math display">\[\begin{aligned} &amp; E
O_t^k=\left[E_{t, 1}^k\left(\mathbf{x}_t^{k-1}\right), \ldots, E_{t,
m_t}^k\left(\mathbf{x}_t^{k-1}\right)\right], t \in[1, \ldots, N] \\
&amp; E O_s^k=\left[E_{s, 1}^k\left(\mathbf{x}_s^{k-1}\right), \ldots,
E_{s, m_s}^k\left(\mathbf{x}_s^{k-1}\right)\right]
\end{aligned}\]</span></p>
<ul>
<li><span class="math display">\[\mathrm{x}_t^{k-1\]</span> 是第 <span
class="math display">\[k-\]</span> 层对任务 $$$$ 的建模结果</li>
<li><span class="math display">\[E O_t^\]</span> 表示第 $<span
class="math display">\[$ 层任务 \]</span>$$
独占的那些Experts的输出向量的集合</li>
<li><span class="math display">\[E_{t, i}^\]</span> 代表第 $<span
class="math display">\[$ 层任务 \]</span><span class="math display">\[
独占的第 \]</span>$$ 个Expert</li>
<li><span class="math display">\[m_\]</span> 是任务 $$$$
独占的所有Experts的个数</li>
<li><span class="math display">\[\mathbf{x}_s^{k-1} 、 E O_s^k 、 E_{s,
i}^k 、 m_\]</span> 代表类似含意, 只不过是针对共享信息的</li>
</ul>
<p>最终参与第 $<span class="math display">\[$ 层任务 \]</span><span
class="math display">\[ 建模的是 \]</span>E O_t^<span
class="math display">\[ 和 \]</span>E O_s^<span class="math display">\[
中的所有 \]</span>m_t+m_<span class="math display">\[
个Experts。先计算这些Experts的权重, 如公式 \]</span>(7-5$$ 所示。</p>
<p><span
class="math display">\[\mathbf{C}_t^k=G_t^k\left(\mathbf{x}_t^{k-1}\right)
\in R^{m_t+m_s}\]</span></p>
<ul>
<li><span class="math display">\[G_t^\]</span> 是第 $<span
class="math display">\[$ 层针对任务 \]</span>\mathrm{t$$ 的门控函数</li>
<li><span class="math display">\[\mathbf{C}_t^\]</span> 是一个长度为
<span class="math display">\[m_t+m_\]</span> 的数组, 表示对参与第 $<span
class="math display">\[$ 层任务 \]</span><span class="math display">\[
建模的是 \]</span>E O_t^<span class="math display">\[ 和 \]</span>E
O_s^$$ 中所有Experts的权重。</li>
</ul>
<p>然后, 将权重与Experts的输出加权加和, 得到第 $<span
class="math display">\[$ 层对任务 \]</span>$$ 的建模结果 <span
class="math inline">\(\mathbf{x}_t^k\)</span>, 如公式(7-6)所示,
其中符号"||"表示将两个数组拼接一起。</p>
<p><span class="math display">\[\mathbf{x}_t^k=\sum_{i=1}^{m_t+m_s}
\mathbf{C}_t^k[i] \times\left(E O_t^k \| E O_s^k\right)[i]\]</span></p>
<p>第 $<span class="math display">\[$ 层对共享信息 \]</span>_s^$$
的建模, 与对某个特定目标的建模类似,
只不过要让本层所有Experts参与其中。</p>
<p><span class="math display">\[\begin{aligned} \mathbf{C}_s^k &amp;
=G_s^k\left(\mathbf{x}_s^{k-1}\right) \in R^{T E} \\ \mathbf{x}_s^k
&amp; =\sum_{i=1}^{T E} \mathbf{C}_s^k[i] \times\left(E O_1^k\|\ldots\|
E O_N^k \| E O_s^k\right)[i] \end{aligned}\]</span></p>
<h4 id="串行建模">串行建模</h4>
<p>串行建模主要用于电商场景。如同前面提到的，电商业务需要将三个概率CTR/CVR/CTCVR都预估清楚，在预测时，我们需要对尚未曝光的物料预测包括CVR在内的分数。这样一来，训练数据中的物料与<strong>预测时的物料集合存在明显差异</strong>，导致"样本选择误差"
(Sample Selection Bias, SSB)，严重影响模型效果。</p>
<figure>
<img
src="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2VlZTY1OTEwN2ExYTBjZWQ5NTBkZWIzOGQyN2Y0NTJfWXI0WWQ0V0FpUHk2eHpZQ0hCVGlNaXVHcWVNRDEyeUFfVG9rZW46S1F3b2JBWGZZb2YwRUR4aDN4eWNxcTNWbjliXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ol type="1">
<li><strong>ESMM</strong></li>
</ol>
<p>为了克服以上样本选择偏差，阿里的Entire Space Multi- task Model (ESMM)
的解决思路是:</p>
<ul>
<li>将CVR与CTR、CTCVR一样，都建模在"曝光样本空间"上(理论上，这些任务都应该建模在粗排结果集上，但是实现起来有难度，所以大家都约定俗成建模在"曝光样本"上了，其中的SSB就忽略不计了)。</li>
<li>但是,毕竟"曝光未点击"的样本不符合CVR的定义，因此CVR只能作为隐藏目标，在其他目标被优化的同时，被间接优化。</li>
</ul>
<figure>
<img
src="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=MDdjNjQxOTFlY2ZhMGNjYWExNWI2YjU0MDU2NzY3MGJfMkhoVXFMY0JXcXpjSGhWS3Z0bkRhNWs4SmFwVjkzVGtfVG9rZW46UUgwQ2JGamhybzVVbEt4S002NGNHOWhPbk9kXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ul>
<li>整个模型由"CTR模块"与"CVR模块"组成, 喂入的都是曝光样本</li>
<li>图 7-7中的Embedding Layer、Field-wise
Pooling、MLP都是常规操作。值得注意的是, CTR模块与CVR
模块的底层Embedding是共享的,
有利于正例丰富的CTR任务向正例稀疏的CVR任务进行"知识迁移"。</li>
<li>在分别预测得到"曝光 <span class="math display">\[\rightarro\]</span>
点击"概率 <span class="math inline">\(\mathrm{pCTR}\)</span>, 和"点击
<span class="math display">\[\rightarro\]</span> 购买"概率pCVR后,
ESMM根据条件概率公式, 得到"曝光 <span
class="math display">\[\rightarro\]</span> 购买"概率 <span
class="math display">\[p C T C V R=p C T R \times p C V \]</span>
。</li>
<li>由于
pCTR和pCTCVR都是建立在"曝光样本空间"上的，可以被直接优化，总损失函数如公式(7-9)所示。注意这里CVR没有被直接优化,
而是作为 <span class="math display">\[\mathrm{PCTCVR\]</span>
的组成部分被间接优化。而且CVR也是被全体"曝光数据"训练出来的,
消除了训练与预测两阶段间的"样本选择偏差"。</li>
</ul>
<p><span class="math display">\[\begin{aligned} L\left(\mathbf{W}_{c t
r}, \mathbf{W}_{c v r}\right) &amp; =\sum_{i=1}^N B C E\left(y_i, d n
n_{c t r}\left(\mathbf{x}_i ; \mathbf{W}_{c t r}\right)\right) \\ &amp;
+\sum_{i=1}^N B C E\left(z_i, d n n_{c t r}\left(\mathbf{x}_i ;
\mathbf{W}_{c t r}\right) \times d n n_{c v r}\left(\mathbf{x}_i ;
\mathbf{W}_{c v r}\right)\right) \end{aligned}\]</span></p>
<ul>
<li><span class="math display">\[\mathbf{x}_\]</span> 是第涤样本的特征,
<span class="math display">\[y_\]</span> 代表第 $<span
class="math display">\[$ 条样本是否点击, \]</span>z_<span
class="math display">\[ 代表第 \]</span><span class="math display">\[
条样本是否购买, \]</span>$$ 代表样本总数</li>
<li><span class="math display">\[d n n_{c t r\]</span> 和 <span
class="math display">\[d n n_{c v r\]</span> 分别CTR模块与CVR模块, <span
class="math display">\[\mathbf{W}_{c t r}, \mathbf{W}_{c v r\]</span>
分别代表两模块中要学习的权重</li>
<li>BCE（Binary Cross Entropy）代表二阶交叉熵函数。</li>
</ul>
<ol type="1">
<li><strong>ESM2</strong></li>
</ol>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/(null)-20240116152613215.(null)"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>ESM2要预测 4 个概率, 在图 7-10中从左至右分别是:</p>
<ul>
<li>"曝光 <span class="math display">\[\rightarro\]</span> 点击"的概率,
CTR, 记为 <span class="math display">\[y_1=P(c=1 \mid v=1)\]</span>,
其中 $<span class="math display">\[$ 表示曝光, \]</span>$$
表示点击。</li>
<li>"点击 <span class="math display">\[\rightarro\]</span>
直接行为"的概率, 记为 <span class="math display">\[y_2=P(a=1 \mid
c=1\]</span> 。其中 $$$$ 表示"直接行为" (Direct Action, DAction）,
是指像"加入购物车"、"加入愿望清单"这样与购买强相关的行为。</li>
<li>"直接行为 <span class="math display">\[\rightarro\]</span>
购买"的概率, 记为 <span class="math display">\[y_3=P(b=1 \mid
a=1)\]</span>, 其中 $$$$ 表示购买。</li>
<li>"其他行为 <span class="math display">\[\rightarro\]</span>
购买"的概率, 记为 <span class="math display">\[y_4=P(b=1 \mid
a=0\]</span> 。</li>
</ul>
<p>基于以上 4 个概率, ESM2要优化三个目标。最简单的就是"曝光 <span
class="math display">\[\rightarro\]</span> 点击", 损失函数如公式 <span
class="math display">\[(7-10\]</span> 所示。</p>
<p><span class="math display">\[L o s s_1=\sum_{i=1}^N B C E\left(c_i,
p_i^{c t r}\right)=\sum_{i=1}^N B C E\left(c_i, y_{1
i}\right)\]</span></p>
<ul>
<li><span class="math display">\[c_\]</span> 代表第涤样本是否点击</li>
<li><span class="math display">\[p_i^{c t r}=y_{1 i\]</span>
是模型预测的第 $$$$ 条样本的CTR</li>
<li>$$$$ 是所有样本数量, BCE代表二阶交叉熵损失函数</li>
</ul>
<p>第二个目标是"曝光 <span class="math display">\[\rightarro\]</span>
直接行为", 如公式(7-11)和公式(7-12)所示。</p>
<p><span class="math display">\[\begin{aligned} p_i^{\text {ctavr }}=
&amp; P\left(a_i=1 \mid v_i=1\right) \\ = &amp; P\left(a_i=1 \mid
c_i=1\right) \times P\left(c_i=1 \mid v_i=1\right) \\ = &amp; y_{2 i}
y_{1 i} \\ &amp; \text { Loss }_2=\sum_{i=1}^N B C E\left(a_i,
p_i^{\text {ctavr }}\right) \end{aligned}\]</span></p>
<ul>
<li><span class="math display">\[p_i^{c t a v r\]</span>
代表模型预测出的第 $<span class="math display">\[$ 个样本&quot;曝光
\]</span>$$ 直接行为"的概率</li>
<li><span class="math display">\[a_\]</span> 代表第 $$$$
条样本发生了直接行为</li>
</ul>
<p>第三个目标是"曝光 <span class="math display">\[\rightarro\]</span>
购买"，如公式(7-13) (7-15)所示。</p>
<p><span class="math display">\[\begin{gathered} p_i^{c v
r}=P\left(b_i=1 \mid c_i=1\right) \\ =P\left(b_i=1 \mid a_i=0\right)
\times P\left(a_i=0 \mid c_i=1\right)+P\left(b_i=1 \mid a_i=1\right)
\times P\left(a_i=1 \mid c_i=1\right) \\ =y_{4 i}\left(1-y_{2
i}\right)+y_{3 i} y_{2 i} \\ p_i^{\text {ctcvr }}=p_i^{c t r} \times
p_i^{c v r}=y_{1 i}\left(y_{4 i}\left(1-y_{2 i}\right)+y_{3 i} y_{2
i}\right) \\ \operatorname{Loss}_3=\sum_{i=1}^N B C E\left(b_i, p_i^{c t
c v r}\right) \end{gathered}\]</span></p>
<ul>
<li><span class="math display">\[p_i^{c v r\]</span> 代表模型预测出的第
$<span class="math display">\[$ 条样本&quot;点击 \]</span>$$
购买"的概率</li>
<li><span class="math display">\[p_i^{\text {ctcvr }\]</span>
代表模型预测出的第 $<span class="math display">\[$ 条样本&quot;曝光
\]</span>$$ 购买"的概率</li>
<li><span class="math display">\[b_\]</span> 代表第 $$$$
条样本是否购买</li>
</ul>
<p>最终ESM2要优化的目标是三个目标的损失之和，其中 <span
class="math display">\[w_1 、 w_2 、 w_\]</span>
是三个用于调节损失权重的超参数。和ESMM一样, 这里CVR是作为隐藏目标,
被间接优化。</p>
<p><span class="math display">\[\text { Loss }=w_1 \text { Loss }_1+w_2
\text { Loss }_2+w_3 \text { Loss }_3\]</span></p>
<ol type="1">
<li>除此之外还有例如<strong>ESCM2</strong>、<strong>知识迁移</strong>等等</li>
</ol>
<h2 id="多场景推荐">多场景推荐</h2>
<p>多场景推荐，关注的是指使用推荐服务的用户中，存在着<strong>差异明显的不同消费模式</strong>。</p>
<ul>
<li>同一个视频APP，"单列模式"让用户有"沉浸式"检验，每次只看到当前视频，看不到其他候选视频；而"双列模式"允许用户一次性看到多个候选视频，有更多选择自由。这两种产品模式下的用户行为模式，存在显著差异。</li>
<li>一个提供全球服务的APP,不同国家的用户的消费模式，明显不同。</li>
<li>同一个APP，不同生命周期的用户差异明显，需要推荐系统有不同的应对策略。对低活跃用户，推荐结果要以热门物料为主；</li>
</ul>
<p>注意多场景推荐与几个相关概念的异同:</p>
<ul>
<li><strong>多场景推荐vs.多任务/多目标推荐</strong>。多场景研究的是如何用一个模型将行为模式有明显差异的不同用户群体都服务好，而无论用户来自哪个群体，模型可能都要预测多个目标。所以，多场景与多目标是相互正交的两个维度</li>
<li><strong>多场景推荐vs.
跨场景(跨域)推荐</strong>。一般来说，多场景推荐指的是用一套模型来服务所有用户，
而跨场景推荐需要用不同模型来服务不同用户，而多个模型之间存在知识迁移。比如某公司已经有一款图文APP积累了大批活跃用户，现在该公司新推出了一款视频APP。</li>
</ul>
<h3 id="特征位置">特征位置</h3>
<p>要想模型能够识别出不同场景、不同用户群体并区别对待,
首先要设计出"场景指示" (Scenario Indicator)特征。比如:</p>
<ul>
<li>"APP模式"能够区分用户请求是来自"单列模式"还是"双列模式"。</li>
<li>为了区分不同国家的用户，国籍、语言应当被纳为特征。</li>
<li>为了区分"低活用户"与"高活用户"。"近7天用户活跃天数"、"是否新注册用户"、"用户是否登陆"这些都应该被用作特征。</li>
</ul>
<p>但是仅仅设计出以上特征, 还是远远不够的。如何将这些特征加入模型,
也大有讲究。本书前面曾经反复强调,
"DNN是万能函数模拟器"的神话已经破灭。如果把"场景指示"特征加到DNN底部，让它们的信息"按部就班"层层上传,
恐怕再重要的信息到达顶部时, 也不剩下多少了。另外,
DNN的底层往往由许多Field Embedding拼接而成，
动辄上千维是小意思。这时你再新加入一两个"场景指标"特征,
"泯然众人矣"，恐怕也不会太奇怪。</p>
<p>为解决以上问题,
业界常见的作法是将"场景指示"特征加到离最终目标近一点的地方。</p>
<ul>
<li>"场景指示"特征，通过一个非常浅的网络, 得到logit scene</li>
<li>其他对场景不敏感的特征，按照常规处理，经过比较复杂的网络，得到logit
common</li>
</ul>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/(null)-20240116152613359.(null)"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>这样做, 使"场景指示"特征对最终预测结果的影响直接有力,
避免自DNN底部层层上传带来的信息损失,更有机会将如此重要的先验知识贯彻到"顶"。</p>
<h3 id="模型结构">模型结构</h3>
<p>多场景推荐模型由两大部分组成:</p>
<ul>
<li>场景共享部分: 需要共享结构和参数来建模来建模多场景之间的共性,
让数据丰富的场景将共享参数充分训练, 借此向数据稀少的场景迁移知识。</li>
<li>场景独立部分：各场景也需要独立的结构与参数,
以建模该场景的特殊性。</li>
</ul>
<p>代表算法：</p>
<ol type="1">
<li>Split&amp;Merge：将共享结构和各场景独有的结构串联起来</li>
</ol>
<figure>
<img
src="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=NmE5OTI2NmIwNDkxMDFjMGI3YjBkOWNkNzU5OTY0MjdfYzBJRGZrNzNmU2VrVEN1ZmRNOExKcFlyb2hldWF2amFfVG9rZW46TXRZQmJYOEY1b2dxdlp4Q3FNcmNPYTRKbnRjXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ol type="1">
<li><strong>HMoE</strong></li>
</ol>
<p>在普通"串联"结构的基础上, 阿里于2020年提出了Hybrid
Mixture-of-Experts（HMoE）结构。HMoE的理论假设是, 对某个样本,
除了其所在场景的模型的打分, 其他场景的模型打分也有借鉴意义。所以,
HMoE在"场景独立部分"引入了MoE结构,
每个场景下的模型都相当于一个Expert。一条样本要经过多个Expert打分,
再对各Expert的打分加权相加, 得到最终得分。</p>
<figure>
<img
src="https://hw1g2gf4y6m.feishu.cn/space/api/box/stream/download/asynccode/?code=NTk2YTAwMGY2MGU0ZmU3NmJmNjY5Mzc1ZjdkZmJhZjBfOU9PcnZUTng1TXQxWmVQVFJCV2JnYVo1d2N2NHIzR1NfVG9rZW46RHg4T2JPUGdNb1ZwMHp4ZEwwcWNtTWlYblVoXzE3MDUzODk5NjU6MTcwNTM5MzU2NV9WNA"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ol type="1">
<li><strong>STAR</strong></li>
</ol>
<p>阿里于2021年提出STAR型结构, 突破了传统的串联模式,
将"场景共享部分"与"场景独立部分"更紧密地"交织"在一起。计算过程如公式(7-37)所示,
网络结构如图7-16所示。</p>
<p><span class="math display">\[\begin{aligned} y_p &amp; =D N
N\left(\mathbf{x}_p ; \mathbf{W}_p^*\right) \\ \mathbf{W}_p^* &amp;
=\left[\mathbf{W}_{p, 1}^*, \ldots, \mathbf{W}_{p, K}^*\right] \\
\mathbf{W}_{p, i}^* &amp; =\mathbf{W}_{p, i} \otimes \mathbf{W}_i
\end{aligned}\]</span></p>
<ul>
<li>第 $<span class="math display">\[$ 个场景的输入 $\mathbf{x}_p$,
经过一个DNN结构, 得到第 \]</span><span class="math display">\[
个场景的输出 \]</span>y_<span class="math display">\[ 。这个DNN的参数是
\]</span>_p^$$ 。</li>
<li><span class="math display">\[\mathbf{W}_p^*=\left[\mathbf{W}_{p,
1}^*, \ldots, \mathbf{W}_{p, K}^*\right\]</span> 是长度为 $<span
class="math display">\[$ 的数组, \]</span>_{p, i}^<span
class="math display">\[ 是DNN第 \]</span><span class="math display">\[
层的权重, \]</span>$$ 是DNN的总层数。</li>
<li><span class="math display">\[\mathbf{W}_{p, i}^\]</span> 是由第
$<span class="math display">\[$ 个场景独有结构的第 \]</span><span
class="math display">\[ 层权重 \]</span><em>{p, i}<span
class="math display">\[, 与共享结构的 \]</span><span
class="math display">\[ 层权重 \]</span></em>{i}<span
class="math display">\[，通过按位相乘 (用 \]</span>$$ 表示)得到。</li>
</ul>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/(null)-20240116152613918.(null)"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="模型参数">模型参数</h3>
<p>动态权重法</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/(null)-20240116152614074.(null)"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ul>
<li>把"场景指示"（Scenario Indicator）特征 <span
class="math display">\[\boldsymbol{z\]</span>，喂进"权重生成器"（Weight
Generator, WG，生成动态权重向量 <span class="math display">\[\mathbf{D
W}=W G(\mathbf{z}\]</span> 。</li>
<li>再将 <span class="math display">\[\boldsymbol{D}
\boldsymbol{W\]</span> 变形（Reshape）成一个合适形状的DNN, 记为 <span
class="math display">\[F_{\mathrm{DW}\]</span> 或 <span
class="math display">\[F_{W G(\mathbf{z})\]</span>。比如, 假设 <span
class="math display">\[\boldsymbol{D} \boldsymbol{W\]</span>
的长度是<span class="math display">\[640=32 \times 16+16 \times
8\]</span>, 所以 <span class="math display">\[\boldsymbol{D}
\boldsymbol{W\]</span> 可以变形为一个三层的MLP，每层的神经元个数分别为
<span class="math display">\[[32,16,8\]</span>。</li>
<li>将这个根据"场景指示"特征动态生成的网络<span
class="math display">\[F_{W
G(\mathbf{z})}\]</span>，应用于在整个推荐模型的关键位置。</li>
</ul>
<p>大型推荐系统经常要同时解决<strong>"多场景+多目标"</strong>的推荐问题,
即不仅一个模型要应对多个场景,
而且在每个场景下还要同时预测多个目标。阿里于2022年提出M2M（Multi-scenario
Multi-task）结构，运用"动态权重"模式解决这一问题。</p>
<p>M2M整体上还是遵循了经典的MMoE结构, 只不过在两个关键位置, "评估多个
Expert的重要性的Gate"与"各任务独有的Tower",
采用了根据"场景指示"特征动态生成的权重, 以更好地适应不同场景的特点。</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/(null)-20240116152614240.(null)"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>【基础工具】Anaconda命令集</title>
    <url>/2023/10/22/conda_list/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>
<h2 id="conda安装">Conda安装</h2>
<h3 id="直接安装">直接安装</h3>
<p>安装网址https://www.anaconda.com/，但是下载速度很慢</p>
<h3 id="镜像安装">镜像安装</h3>
<p>清华源网址https://mirrors.tuna.tsinghua.edu.cn/anaconda/</p>
<p>下载速度会比较快</p>
<p>如果觉得anacodna的包非常大，可以选择安装miniconda
https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/</p>
<h2 id="conda-常用命令">Conda 常用命令</h2>
<h3 id="查看conda版本">查看conda版本</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">conda --version/ conda -V<br></code></pre></td></tr></table></figure>
<h3 id="查看已有环境">查看已有环境</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">conda info --envs<br>conda env <span class="hljs-built_in">list</span><br>conda info -e<br></code></pre></td></tr></table></figure>
<h3 id="进退环境">进退环境</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">conda activate  [name]<span class="hljs-comment"># 重新进入虚拟环境</span><br>conda deactivate  <span class="hljs-comment"># 退出虚拟环境</span><br></code></pre></td></tr></table></figure>
<h3 id="创建新的环境">创建新的环境</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">conda create -n *** python=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<h3 id="删除环境">删除环境</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">conda remove -n old_name --<span class="hljs-built_in">all</span> <span class="hljs-comment"># 删除环境old_name</span><br></code></pre></td></tr></table></figure>
<h3 id="激活环境">激活环境</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">conda activate xxxx <span class="hljs-comment"># 激活xxxx环境</span><br></code></pre></td></tr></table></figure>
<h3 id="关闭环境">关闭环境</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">conda deactivate <span class="hljs-comment"># 关闭环境</span><br></code></pre></td></tr></table></figure>
<h3 id="克隆环境">克隆环境</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">conda create -n [new_name] --clone [old_name]<br></code></pre></td></tr></table></figure>
<h3 id="升级版本">升级版本</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">conda update -n base conda <span class="hljs-comment">#update最新版本的conda；</span><br>conda update --<span class="hljs-built_in">all</span> <span class="hljs-comment">#更新所有包</span><br></code></pre></td></tr></table></figure>
<h3 id="pip管理的常用包">Pip管理的常用包</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">pip search package_name <br>pip show package_name <br>pip uninstall｜｜package_name<br>pip <span class="hljs-built_in">list</span><br></code></pre></td></tr></table></figure>
<h3 id="删除环境中的包">删除环境中的包</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">conda remove package <span class="hljs-comment">#删除当前环境中的包</span><br>conda remove -- name env_name package <span class="hljs-comment">#删除指定环境中的包</span><br></code></pre></td></tr></table></figure>
<h3 id="指定环境中安装包">指定环境中安装包</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">conda install --name env_name package_name <br></code></pre></td></tr></table></figure>
<h3 id="生成conda环境依赖包的版本">生成Conda环境依赖包的版本</h3>
<p>在做实验的过程中，需要输出一个关于当前环境的版本依赖文件，可以选择使用下面的方法进行输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pip list --format=freeze&gt; requirements.txt<br></code></pre></td></tr></table></figure>
<h3 id="conda环境的python版本非指定">Conda环境的python版本非指定</h3>
<p>指定虚拟环境x的python版本是3.8，base环境是3.11；conda
activate激活x之后python版本仍为3.11。</p>
<p><strong>原因：</strong>在base环境中修改了.zshrc文件中的python只定路径，让每次虚拟环境中的python找到的python都只能按照指定的python路径进行寻找，从而导致conda环境中的python版本不能制定。</p>
<p><strong>修改方式：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">vim .zshrc<br></code></pre></td></tr></table></figure>
<p>进入
.zshrc环境中进行修改，如果发现一类诸如其他python版本指定的路径的话，需要进行删除，只需要保留最原始的关于anaconda的命令初始化，完成之后输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.zshrc<br></code></pre></td></tr></table></figure>
<p>解决问题</p>
<h3 id="镜像源安装">镜像源安装</h3>
<p>在conda环境中改变默认的下载镜像源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pip config <span class="hljs-built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple <br></code></pre></td></tr></table></figure>
<p>加上这句话之后就会出现以下的写文件</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino">Writing to /home/user/.config/pip/pip.conf<br></code></pre></td></tr></table></figure>
<p><strong>下载使用清华源加上： -i
https://pypi.tuna.tsinghua.edu.cn/simple</strong></p>
<blockquote>
<p><strong>清华：<code>https://pypi.tuna.tsinghua.edu.cn/simple/</code></strong></p>
<p><strong>阿里云：<code>http://mirrors.aliyun.com/pypi/simple/</code></strong></p>
<p><strong>中国科技大学
：<code>https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/</code></strong></p>
<p><strong>豆瓣：<code>http://pypi.doubanio.com/simple/</code></strong></p>
</blockquote>
<p>如果是给conda添加镜像：清华源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">conda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/win-64/<br></code></pre></td></tr></table></figure>
<p>添加阿里源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">conda config --add channels https://mirrors.aliyun.com/pypi/simple/<br></code></pre></td></tr></table></figure>
<p>查看已经添加的镜像源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">conda config --show channels<br></code></pre></td></tr></table></figure>
<p>移除其中的指定的镜像源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">conda config --remove channels + 镜像的名称<br></code></pre></td></tr></table></figure>
<h3 id="conda无法自动更新">Conda无法自动更新</h3>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231206113335958.png"
alt="image-20231206113335958" />
<figcaption aria-hidden="true">image-20231206113335958</figcaption>
</figure>
<p>原因：<a
href="https://so.csdn.net/so/search?q=conda&amp;spm=1001.2101.3001.7020">conda</a>和pip等相关包的版本太低，自动更新不能用，解决方案：在命令行中输入以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">conda clean --all<br>conda update --all<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>基础工具</category>
      </categories>
      <tags>
        <tag>基础工具</tag>
      </tags>
  </entry>
  <entry>
    <title>【深度学习】图神经网络</title>
    <url>/2024/01/12/gnn/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>
<h1 id="图神经网络">图神经网络</h1>
<p>GNN全称----图神经网络，它是一种直接作用于图结构上的神经网络。我们可以把图中的每一个节点
<span class="math inline">\(V\)</span> 当作个体对象，而每一条边 <span
class="math inline">\(E\)</span>
当作个体与个体间的某种联系，所有节点组成的关系网就是最后的图 <span
class="math inline">\(U\)</span></p>
<p>GNN的输入一般是每个节点的起始特征向量和表示节点间关系的邻接矩阵，有了这两个输入信息，接下来就是聚合操作了。所谓的聚合，其实就是将周边与节点
V i ViVi 有关联的节点{V a , V b , . . . Va,Vb,...Va,Vb,...}加权到V i
ViVi上，当作一次特征更新。同理，对图中的每个节点进行聚合操作，更新所有图节点的特征。</p>
<p>GNN本质就是更新每个节点的特征，输入是特征，输出是特征，邻接矩阵不会变</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
</search>
