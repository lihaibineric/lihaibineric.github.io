

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/galaxy.png">
  <link rel="icon" href="/img/galaxy.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Haibin Li">
  <meta name="keywords" content="">
  
    <meta name="description" content="语言细节 vector的长度：  C++：nums.size() Python：len(nums) GO：len(nums)  初始化数组：  C++：array[n]&#x3D;{0} 让所有元素都是0  构造vector:  C++：vector result(长度，元素) Python：res &#x3D; [float(&#39;inf&#39;)] * len(nums) GO：&#x3D;make([]int，n)  for循环">
<meta property="og:type" content="article">
<meta property="og:title" content="【算法题】LeetCode算法汇总">
<meta property="og:url" content="https://lihaibineric.github.io/2024/01/01/leetcode/index.html">
<meta property="og:site_name" content="LIHAIBIN&#39;S BLOG">
<meta property="og:description" content="语言细节 vector的长度：  C++：nums.size() Python：len(nums) GO：len(nums)  初始化数组：  C++：array[n]&#x3D;{0} 让所有元素都是0  构造vector:  C++：vector result(长度，元素) Python：res &#x3D; [float(&#39;inf&#39;)] * len(nums) GO：&#x3D;make([]int，n)  for循环">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240111141316267.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240111153940915.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240111155904466.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240603224752141.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240606214825990.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240606220937391.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240609215431024.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240522221019585.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240629200640705.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240118151406885.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240118152000575.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240119195217619.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240119200331204.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240513211326213.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240129144103735.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240609223041348.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240701205600757.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240629213345117.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240119211247536.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240122123926323.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240701204812907.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240128142408271.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240128143004648.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240310153527352.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240310153733207.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240310155051578.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240310155150041.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240310190137229.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240310191703835.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240206140055727.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240129130942760.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240224222001801.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240224230446459.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240224230907817.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240225115054788.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240225120135322.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240225120230954.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240225121723461.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240225123025333.png">
<meta property="og:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240225123828659.png">
<meta property="article:published_time" content="2024-01-01T13:15:17.000Z">
<meta property="article:modified_time" content="2024-07-01T14:39:27.968Z">
<meta property="article:author" content="Haibin Li">
<meta property="article:tag" content="算法题">
<meta property="article:tag" content="leetcode">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240111141316267.png">
  
  
  
  <title>【算法题】LeetCode算法汇总 - LIHAIBIN&#39;S BLOG</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"lihaibineric.github.io","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":50,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 36vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>LIHAIBIN&#39;S HOMEPAGE</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" false
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="【算法题】LeetCode算法汇总"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-01-01 21:15" pubdate>
          January 1, 2024 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          129k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          1077 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">【算法题】LeetCode算法汇总</h1>
            
              <p class="note note-info">
                
                  
                    Last updated on July 1, 2024 pm
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <meta name="referrer" content="no-referrer"/>
<h1 id="语言细节">语言细节</h1>
<p>vector的长度：</p>
<ul>
<li>C++：nums.size()</li>
<li>Python：len(nums)</li>
<li>GO：len(nums)</li>
</ul>
<p>初始化数组：</p>
<ul>
<li>C++：array[n]={0} 让所有元素都是0</li>
</ul>
<p>构造vector:</p>
<ul>
<li>C++：vector result(长度，元素)</li>
<li>Python：res = [float('inf')] * len(nums)</li>
<li>GO：=make([]int，n)</li>
</ul>
<p>for循环：</p>
<ul>
<li>C++：条件小括号+循环体中括号</li>
<li>Python：冒号且不需要小括号包条件</li>
<li>GO：循环体中括号，条件按照C++写但是不需要小括号</li>
</ul>
<h1 id="数组">数组</h1>
<h3 id="二分查找">二分查找</h3>
<p><strong>题目描述</strong></p>
<p>链接：<a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/description/">https://leetcode.cn/problems/binary-search/description/</a></p>
<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target
，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回
-1。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="hljs-section">输出: 4</span><br><span class="hljs-section">解释: 9 出现在 nums 中并且下标为 4</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="hljs-section">输出: -1</span><br><span class="hljs-section">解释: 2 不存在 nums 中因此返回 -1</span><br></code></pre></td></tr></table></figure>
<p><strong>思路</strong></p>
<p>题目表示的是有序数组，而且题目没有重复元素。在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是<strong>循环不变量</strong>规则</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>  <span class="hljs-comment"># 定义target在左闭右闭的区间里，[left, right]</span><br><br>        <span class="hljs-keyword">while</span> left &lt;= right:<br>            middle = left + (right - left) // <span class="hljs-number">2</span><br>            <br>            <span class="hljs-keyword">if</span> nums[middle] &gt; target:<br>                right = middle - <span class="hljs-number">1</span>  <span class="hljs-comment"># target在左区间，所以[left, middle - 1]</span><br>            <span class="hljs-keyword">elif</span> nums[middle] &lt; target:<br>                left = middle + <span class="hljs-number">1</span>  <span class="hljs-comment"># target在右区间，所以[middle + 1, right]</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> middle  <span class="hljs-comment"># 数组中找到目标值，直接返回下标</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>  <span class="hljs-comment"># 未找到目标值</span><br></code></pre></td></tr></table></figure>
<p>注意这里给出的题解法：当
<code>left &lt;= right</code>的时候，以下的条件中全部都不取到等号
<code>nums[middle] &gt; target nums[middle] &lt; target</code></p>
<p>需要注意的是：<code>right=nums.size()-1</code></p>
<p>C++版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)<br>        &#123;<br>            <span class="hljs-comment">// int middle = (left+right)/2; 这样写会溢出</span><br>            <span class="hljs-type">int</span> middle = left + ((right - left) / <span class="hljs-number">2</span>);<br>            <span class="hljs-keyword">if</span>(nums[middle]&gt;target)<br>            &#123;<br>                right = middle<span class="hljs-number">-1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[middle]&lt;target)<br>            &#123;<br>                left = middle+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> middle;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>Go版本</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    right:=<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span><br>    left:=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> left&lt;=right&#123;<br>        middle:= left+(right-left)/<span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[middle]&lt;target&#123;<br>            left = middle+<span class="hljs-number">1</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[middle]&gt;target&#123;<br>            right = middle<span class="hljs-number">-1</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> middle<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="丢失的数字">丢失的数字</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/missing-number/description/?envType=study-plan-v2&amp;envId=2024-spring-sprint-100">https://leetcode.cn/problems/missing-number/description/?envType=study-plan-v2&amp;envId=2024-spring-sprint-100</a></p>
<p>给定一个包含 <code>[0, n]</code> 中 <code>n</code> 个数的数组
<code>nums</code> ，找出 <code>[0, n]</code>
这个范围内没有出现在数组中的那个数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,0,1]</span><br>输出：2<br>解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 <span class="hljs-comment">[0,3]</span> 内。2 是丢失的数字，因为它没有出现在 nums 中。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[0,1]</span><br>输出：2<br>解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 <span class="hljs-comment">[0,2]</span> 内。2 是丢失的数字，因为它没有出现在 nums 中。<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>1、排序，然后逐个比较nums[i]==i来判断哪个数字不在数组中</p>
<p>2、先求和然后用n(n-1)/2减去当前的和就是不在数组中的元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]!=i)&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="移除元素">移除元素</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/description/">https://leetcode.cn/problems/remove-element/description/</a></p>
<p><strong>题目描述</strong></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,2,3]</span>, val = 3<br>输出：2, nums = <span class="hljs-comment">[2,2]</span><br>解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = <span class="hljs-comment">[2,2,3,3]</span> 或 nums = <span class="hljs-comment">[2,2,0,0]</span>，也会被视作正确答案。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">0,1,2,2</span>,<span class="hljs-number">3,0,4,2</span>], val = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">5</span>, nums = [<span class="hljs-number">0,1,3,0</span>,<span class="hljs-number">4</span>]<br>解释：函数应该返回新的长度 <span class="hljs-number">5</span>, 并且 nums 中的前五个元素为 <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。<br></code></pre></td></tr></table></figure>
<p><strong>思路</strong></p>
<p>双指针法（快慢指针法）：
<strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p>
<p>定义快慢指针</p>
<ul>
<li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li>
<li>慢指针：指向更新 新数组下标的位置</li>
</ul>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240111141316267.png" srcset="/img/loading.gif" lazyload alt="双指针题解" style="zoom:67%;" /></p>
<p>C++版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-type">int</span> slowindex=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fastindex = <span class="hljs-number">0</span>; fastindex&lt;nums.<span class="hljs-built_in">size</span>();fastindex++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(val!=nums[fastindex])&#123;<br>                nums[slowindex] = nums[fastindex];<br>                slowindex++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slowindex;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>python版本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeElement</span>(<span class="hljs-params">self, nums, val</span>):<br>        slowindex=<span class="hljs-number">0</span><br>        fastindex=<span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> fastindex&lt;<span class="hljs-built_in">len</span>(nums):<br>            <span class="hljs-keyword">if</span> val!=nums[fastindex]:<br>                nums[slowindex]=nums[fastindex]<br>                slowindex = slowindex+<span class="hljs-number">1</span><br>            fastindex+=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> slowindex        <br></code></pre></td></tr></table></figure>
<p>GO版本：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, val <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    slow:=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;<br>        <span class="hljs-keyword">if</span> nums[i]!=val&#123;<br>            nums[slow]=nums[i]<br>            slow++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="有序数组的平方">有序数组的平方</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/">https://leetcode.cn/problems/squares-of-a-sorted-array/</a></p>
<p><strong>题目描述</strong></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [-<span class="hljs-number">4</span>,-<span class="hljs-number">1,0,3,10</span>]<br>输出：[<span class="hljs-number">0,1,9,16</span>,<span class="hljs-number">100</span>]<br>解释：平方后，数组变为 [<span class="hljs-number">16,1,0,9</span>,<span class="hljs-number">100</span>]<br>排序后，数组变为 [<span class="hljs-number">0,1,9,16</span>,<span class="hljs-number">100</span>]<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [-<span class="hljs-number">7</span>,-<span class="hljs-number">3,2,3,11</span>]<br>输出：[<span class="hljs-number">4,9,9,49</span>,<span class="hljs-number">121</span>]<br></code></pre></td></tr></table></figure>
<p><strong>思路</strong></p>
<p>双指针法，首尾遍历比较并存储</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240111144022821.png" srcset="/img/loading.gif" lazyload
alt="双指针遍历存储" />
<figcaption aria-hidden="true">双指针遍历存储</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(nums.size(),<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> j = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> k =j;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ;i&lt;=j;)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i]*nums[i]&gt;nums[j]*nums[j])&#123;<br>                result[k--]= nums[i]*nums[i];<br>                i++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                result[k--]= nums[j]*nums[j];<br>                j--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>Python:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sortedSquares</span>(<span class="hljs-params">self, nums</span>):<br>        l, r, i = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span><br>        res = [<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)] * <span class="hljs-built_in">len</span>(nums) <span class="hljs-comment"># 需要提前定义列表，存放结果</span><br>        <span class="hljs-keyword">while</span> l&lt;=r :<br>            <span class="hljs-keyword">if</span> nums[l]*nums[l] &lt; nums[r]*nums[r] :<br>                res[i--]=nums[r]*nums[r]<br>                r--<br>            <span class="hljs-keyword">else</span>:<br>                res[i--]=nums[l]*nums[l]<br>                l++<br>        <span class="hljs-keyword">return</span> <br></code></pre></td></tr></table></figure>
<p>GO:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortedSquares</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>	n := <span class="hljs-built_in">len</span>(nums)<br>	i, j, k := <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>, n<span class="hljs-number">-1</span><br>	ans := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>	<span class="hljs-keyword">for</span> i &lt;= j &#123;<br>		lm, rm := nums[i]*nums[i], nums[j]*nums[j]<br>		<span class="hljs-keyword">if</span> lm &gt; rm &#123;<br>			ans[k] = lm<br>			i++<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			ans[k] = rm<br>			j--<br>		&#125;<br>		k--<br>	&#125;<br>	<span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="长度最小的子数组">长度最小的子数组</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">https://leetcode.cn/problems/minimum-size-subarray-sum/description/</a></p>
<p><strong>题目描述</strong></p>
<p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数
<code>target</code> <strong>。</strong></p>
<p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的
<strong>连续子数组</strong>
<code>[numsl, numsl+1, ..., numsr-1, numsr]</code>
，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回
<code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：target = 7, nums = <span class="hljs-comment">[2,3,1,2,4,3]</span><br>输出：2<br>解释：子数组 <span class="hljs-comment">[4,3]</span> 是该条件下的长度最小的子数组。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：<span class="hljs-keyword">target</span> = <span class="hljs-number">4</span>, nums = [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：target = <span class="hljs-number">11</span>, nums = [<span class="hljs-number">1,1,1,1</span>,<span class="hljs-number">1,1,1,1</span>]<br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p><strong>思路</strong></p>
<p>滑动窗口法</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240111153940915.png" srcset="/img/loading.gif" lazyload alt="滑动窗口法" style="zoom:67%;" /></p>
<p>滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动本题中实现滑动窗口，主要确定如下三点：</p>
<ul>
<li>窗口内是什么？</li>
<li>如何移动窗口的起始位置？</li>
<li>如何移动窗口的结束位置？</li>
</ul>
<p>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> s, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = INT32_MAX;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口数值之和</span><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口起始位置</span><br>        <span class="hljs-type">int</span> subLength = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口的长度</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j++) &#123;<br>            sum += nums[j];<br>            <span class="hljs-comment">// 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件</span><br>            <span class="hljs-keyword">while</span> (sum &gt;= s) &#123;<br>                subLength = (j - i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 取子序列的长度</span><br>                result = result &lt; subLength ? result : subLength;<br>                sum -= nums[i++]; <span class="hljs-comment">// 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span><br>        <span class="hljs-keyword">return</span> result == INT32_MAX ? <span class="hljs-number">0</span> : result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="螺旋矩阵">螺旋矩阵</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix-ii/">https://leetcode.cn/problems/spiral-matrix-ii/</a></p>
<p><strong>题目描述</strong></p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240111155904466.png" srcset="/img/loading.gif" lazyload alt="螺旋矩阵" style="zoom:67%;" /></p>
<p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到
<code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的
<code>n x n</code> 正方形矩阵 <code>matrix</code></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">[[1,2,3],[8,9,4],[7,6,5]]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure>
<p>思路：大模拟循环遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generateMatrix</span>(<span class="hljs-type">int</span> n) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">result</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>));<br>        <span class="hljs-type">int</span> is=<span class="hljs-number">0</span>,ie=n<span class="hljs-number">-1</span>,js=<span class="hljs-number">0</span>,je=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(is&lt;=ie&amp;&amp;js&lt;=je)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=js;j&lt;=je;j++)<br>            &#123;<br>                result[is][j] = k++;<br>            &#125;<br>            is++;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =is;i&lt;=ie;i++)<br>            &#123;<br>                result[i][je] = k++;<br>            &#125;<br>            je--;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=je;j&gt;=js;j--)<br>            &#123;<br>                result[ie][j] = k++;<br>            &#125;<br>            ie--;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=ie;i&gt;=is;i--)<br>            &#123;<br>                result[i][js] = k++;<br>            &#125;<br>            js++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="螺旋矩阵2">螺旋矩阵2</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix/description/?envType=study-plan-v2&amp;envId=2024-spring-sprint-100">https://leetcode.cn/problems/spiral-matrix/description/?envType=study-plan-v2&amp;envId=2024-spring-sprint-100</a></p>
<p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵
<code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong>
，返回矩阵中的所有元素。</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240603224752141.png" srcset="/img/loading.gif" lazyload alt="螺旋矩阵2" style="zoom:50%;" /></p>
<p>思路：</p>
<p>主要的解题方法就是模拟，但是需要注意的是每次改变is/ie/js/je之后都需要进行一次判断一旦不满足循环的条件立马退出不进行模拟</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>(), n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> is = <span class="hljs-number">0</span>, js = <span class="hljs-number">0</span>, ie = m<span class="hljs-number">-1</span>, je = n<span class="hljs-number">-1</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt;res;<br>        <span class="hljs-keyword">while</span>(is&lt;=ie &amp;&amp; js&lt;=je)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=js;j&lt;=je;j++)&#123;<br>                res.<span class="hljs-built_in">push_back</span>(matrix[is][j]);<br>            &#125;<br>            is++;<br>            <span class="hljs-keyword">if</span>(is&gt;ie || js&gt;je) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = is;i&lt;=ie;i++)&#123;<br>                res.<span class="hljs-built_in">push_back</span>(matrix[i][je]);<br>            &#125;<br>            je--;<br>            <span class="hljs-keyword">if</span>(is&gt;ie || js&gt;je) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=je;j&gt;=js;j--)&#123;<br>                res.<span class="hljs-built_in">push_back</span>(matrix[ie][j]);<br>            &#125;<br>            ie--;<br>            <span class="hljs-keyword">if</span>(is&gt;ie || js&gt;je) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =ie;i&gt;=is;i--)&#123;<br>                res.<span class="hljs-built_in">push_back</span>(matrix[i][js]);<br>            &#125;<br>            js++;<br>            <span class="hljs-keyword">if</span>(is&gt;ie || js&gt;je) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="生命游戏">生命游戏</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/game-of-life/description/?envType=study-plan-v2&amp;envId=2024-spring-sprint-100">https://leetcode.cn/problems/game-of-life/description/?envType=study-plan-v2&amp;envId=2024-spring-sprint-100</a></p>
<p>根据 <a
target="_blank" rel="noopener" href="https://baike.baidu.com/item/生命游戏/2926434?fr=aladdin">百度百科</a>
， <strong>生命游戏</strong> ，简称为 <strong>生命</strong>
，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。</p>
<p>给定一个包含 <code>m × n</code>
个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：
<code>1</code> 即为 <strong>活细胞</strong> （live），或 <code>0</code>
即为 <strong>死细胞</strong>
（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</p>
<ol type="1">
<li>如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；</li>
<li>如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；</li>
<li>如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；</li>
<li>如果死细胞周围正好有三个活细胞，则该位置死细胞复活；</li>
</ol>
<p>下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。给你
<code>m x n</code> 网格面板 <code>board</code>
的当前状态，返回下一个状态。</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240606214825990.png" srcset="/img/loading.gif" lazyload alt="image-20240606214825990" style="zoom:50%;" /></p>
<p>思路：</p>
<ol type="1">
<li>给出8个方位的计算公式，-1，0，1横纵两个方向来调整</li>
<li>复制一份相同的地图保证不会每次调整的时候更换初始的值</li>
<li>模拟操作即可，注意每次考虑边界条件</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gameOfLife</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-type">int</span> step[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">origin_board</span>(board.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(),<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;board.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();j++)&#123;<br>                origin_board[i][j] = board[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;r&lt;board.<span class="hljs-built_in">size</span>();r++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c = <span class="hljs-number">0</span>;c&lt;board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();c++)&#123;<br>                <span class="hljs-comment">//计算周围的活细胞数量</span><br>                <span class="hljs-type">int</span> alive_cell = <span class="hljs-number">0</span>;<br><br>                <span class="hljs-comment">//遍历8个方向</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">3</span>;j++)&#123;<br>                        <span class="hljs-keyword">if</span>(!(step[i]==<span class="hljs-number">0</span> &amp;&amp; step[j]==<span class="hljs-number">0</span>))&#123; <span class="hljs-comment">//表示不同时为0的情况</span><br>                            <span class="hljs-keyword">if</span>(((r+step[i]&gt;=<span class="hljs-number">0</span>)&amp;&amp;(r+step[i]&lt;board.<span class="hljs-built_in">size</span>()))&amp;&amp;((c+step[j]&gt;=<span class="hljs-number">0</span>)&amp;&amp;(c+step[j]&lt;board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()))&amp;&amp;(origin_board[r+step[i]][c+step[j]]==<span class="hljs-number">1</span>))&#123;<br>                                alive_cell++;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span>(origin_board[r][c]==<span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">if</span> ((alive_cell&lt;<span class="hljs-number">2</span>)||(alive_cell&gt;<span class="hljs-number">3</span>))&#123;<br>                        board[r][c]=<span class="hljs-number">0</span>;<br>                    &#125;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">if</span>(alive_cell==<span class="hljs-number">3</span>)&#123;<br>                        board[r][c]=<span class="hljs-number">1</span>;<br>                    &#125;<br>                &#125;<br>        &#125;<br>    &#125;<br>    &#125;    <br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="旋转矩阵">旋转矩阵</h3>
<p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code>
表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>你必须在<strong><a
target="_blank" rel="noopener" href="https://baike.baidu.com/item/原地算法">原地</a></strong>
旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong>
使用另一个矩阵来旋转图像。</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240606220937391.png" srcset="/img/loading.gif" lazyload alt="旋转矩阵示意图" style="zoom:50%;" /></p>
<p>思路：</p>
<ol type="1">
<li>顺时针旋转的思路先水平方向翻转</li>
<li>再中心对称反转即可</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-comment">//先水平翻转</span><br>        <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;n/<span class="hljs-number">2</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-built_in">swap</span>(matrix[i][j], matrix[n-i<span class="hljs-number">-1</span>][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//中心对称反转</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br>                <span class="hljs-built_in">swap</span>(matrix[i][j], matrix[j][i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="矩阵置零">矩阵置零</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/set-matrix-zeroes/description/?envType=study-plan-v2&amp;envId=2024-spring-sprint-100">https://leetcode.cn/problems/set-matrix-zeroes/description/?envType=study-plan-v2&amp;envId=2024-spring-sprint-100</a></p>
<p>给定一个 <code>*m* x *n*</code> 的矩阵，如果一个元素为
<strong>0</strong> ，则将其所在行和列的所有元素都设为 <strong>0</strong>
。请使用 <strong><a
target="_blank" rel="noopener" href="http://baike.baidu.com/item/原地算法">原地</a></strong>
算法<strong>。</strong></p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240609215431024.png" srcset="/img/loading.gif" lazyload alt="矩阵置零的示意图" style="zoom:50%;" /></p>
<p>思路：</p>
<p>分别记录下哪一行那一列要设置成0，然后最后再遍历改变一下即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; r0;<br>        vector&lt;<span class="hljs-type">int</span>&gt; c0;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;matrix.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); j++)&#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][j]==<span class="hljs-number">0</span>)&#123;<br>                    r0.<span class="hljs-built_in">push_back</span>(i);<br>                    c0.<span class="hljs-built_in">push_back</span>(j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;r0.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();j++)&#123;<br>                matrix[r0[i]][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;c0.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;matrix.<span class="hljs-built_in">size</span>();j++)&#123;<br>                matrix[j][c0[i]] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="快速排序">快速排序</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">part</span><span class="hljs-params">(<span class="hljs-type">int</span>* r, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> hight)</span>  <span class="hljs-comment">//划分函数</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> i = low, j = hight, pivot = r[low]; <span class="hljs-comment">//基准元素</span><br>	<span class="hljs-keyword">while</span> (i &lt; j)<br>	&#123;<br>		<span class="hljs-keyword">while</span> (i&lt;j &amp;&amp; r[j]&gt;pivot) <span class="hljs-comment">//从右向左开始找一个 小于等于 pivot的数值</span><br>		&#123;<br>			j--;<br>		&#125;<br>		<span class="hljs-keyword">if</span> (i &lt; j)<br>		&#123;<br>			<span class="hljs-built_in">swap</span>(r[i++], r[j]);  <span class="hljs-comment">//r[i]和r[j]交换后 i 向右移动一位</span><br>		&#125;<br>		<span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; r[i] &lt;= pivot) <span class="hljs-comment">//从左向右开始找一个 大于 pivot的数值</span><br>		&#123;<br>			i++;<br>		&#125;<br>		<span class="hljs-keyword">if</span> (i &lt; j)<br>		&#123;<br>			<span class="hljs-built_in">swap</span>(r[i], r[j--]);  <span class="hljs-comment">//r[i]和r[j]交换后 i 向左移动一位</span><br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> i;  <span class="hljs-comment">//返回最终划分完成后基准元素所在的位置</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Quicksort</span><span class="hljs-params">(<span class="hljs-type">int</span>* r, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> hight)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> mid;<br>	<span class="hljs-keyword">if</span> (low &lt; hight)<br>	&#123;<br>		mid = <span class="hljs-built_in">part</span>(r, low, hight);  <span class="hljs-comment">// 返回基准元素位置</span><br>		<span class="hljs-built_in">Quicksort</span>(r, low, mid - <span class="hljs-number">1</span>); <span class="hljs-comment">// 左区间递归快速排序</span><br>		<span class="hljs-built_in">Quicksort</span>(r, mid+<span class="hljs-number">1</span>, hight); <span class="hljs-comment">// 右区间递归快速排序</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="数组中的第k大元素">数组中的第K大元素</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/xx4gT2/description/">https://leetcode.cn/problems/xx4gT2/description/</a></p>
<p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第
<code>**k**</code> 个最大的元素。</p>
<p>请注意，你需要找的是数组排序后的第 <code>k</code>
个最大的元素，而不是第 <code>k</code> 个不同的元素。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [3,2,1,5,6,4] 和 k = 2</span><br><span class="hljs-section">输出: 5</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: [<span class="hljs-number">3,2,3,1</span>,<span class="hljs-number">2,4,5,5</span>,<span class="hljs-number">6</span>] 和 k = <span class="hljs-number">4</span><br>输出: <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>
<p><strong>重点快速排序</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span>&#123;<br>        <span class="hljs-type">int</span> key = nums[low];<br>        <span class="hljs-keyword">while</span>(low&lt; high)&#123;<br>            <span class="hljs-keyword">while</span>(low&lt;high &amp;&amp; nums[high]&gt;= key) high--;<br>            nums[low] = nums[high];<br>            <span class="hljs-keyword">while</span>(low&lt;high&amp;&amp; nums[low]&lt;=key) low++;<br>            nums[high] = nums[low];<br>        &#125;<br>        nums[low] = key;<br>        <span class="hljs-keyword">return</span> low;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(low&gt;=high) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> mid = <span class="hljs-built_in">partition</span>(nums, low, high);<br>        <span class="hljs-built_in">quicksort</span>(nums, low, mid<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">quicksort</span>(nums, mid+<span class="hljs-number">1</span>, high);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">quicksort</span>(nums, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> nums[n-k];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><strong>堆排序算法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BuildHeap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-type">int</span> p = i, c=<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(c&lt;=n)&#123;<br>            <span class="hljs-keyword">if</span>(c&lt;n &amp;&amp; arr[c]&gt;arr[c+<span class="hljs-number">1</span>]) c++;<br>            <span class="hljs-keyword">if</span>(arr[p]&gt;arr[c])&#123;<br>                <span class="hljs-built_in">swap</span>(arr[p], arr[c]);<br>                p = c;<br>            &#125;<br>            c = <span class="hljs-number">2</span>*c+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Heapsort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span></span>&#123;<br>        <span class="hljs-comment">//建立一个堆</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=arr.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span><span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-built_in">BuildHeap</span>(arr, i,arr.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=arr.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; i&gt;<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-built_in">swap</span>(arr[<span class="hljs-number">0</span>], arr[i]);<br>            <span class="hljs-built_in">BuildHeap</span>(arr,<span class="hljs-number">0</span>,i<span class="hljs-number">-1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">Heapsort</span>(nums);<br>        <span class="hljs-keyword">return</span> nums[k<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="和为k的子数组">和为K的子数组</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&amp;envId=top-100-liked">https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&amp;envId=top-100-liked</a></p>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code>
，请你统计并返回 <em>该数组中和为 <code>k</code> 的子数组的个数</em>
。</p>
<p>子数组是数组中元素的连续非空序列</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1,1,1], k = 2</span><br><span class="hljs-string">输出：2</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1,2,3], k = 3</span><br><span class="hljs-string">输出：2</span><br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>这道题用前缀和+哈希表来解决</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240522221019585.png" srcset="/img/loading.gif" lazyload alt="和为K的子数组" style="zoom:50%;" /></p>
<p>主要的思路是，首先维护一个map数组来存每个元素的前缀和，以及出现的次数，当每次到一个位置的时候来判断当前的map中是否有pre-k的元素以及对应的值，如果有那么就可以将个数加上，这个map对应的键是加和的元素，值是出现的个数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;pre;<br>        pre[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            p+=nums[i];<br>            <span class="hljs-keyword">if</span>(pre.<span class="hljs-built_in">find</span>(p-k)!=pre.<span class="hljs-built_in">end</span>())&#123;<br>                res+=pre[p-k];<br>            &#125;<br>            pre[p]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="哈希表">哈希表</h1>
<p><strong>一般哈希表都是用来快速判断一个元素是否出现集合里</strong></p>
<p>只需要初始化把所有元素都存在哈希表里，在查询的时候通过索引直接就可以知道元素在不在这哈希表里了</p>
<p>建立索引：哈希函数</p>
<h3 id="有效的字母异位词">有效的字母异位词</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-anagram/description/">https://leetcode.cn/problems/valid-anagram/description/</a></p>
<p><strong>题目描述</strong></p>
<p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s
的字母异位词。</p>
<p>示例 1: 输入: s = "anagram", t = "nagaram" 输出: true</p>
<p>示例 2: 输入: s = "rat", t = "car" 输出: false</p>
<p><strong>思路</strong></p>
<p>暴力的方法可能时间复杂度会很高</p>
<p>判断有没有异位词的本质就是查看当前的字母是不是有出现过，那么思路就是选择
<strong>哈希表</strong></p>
<p>定义一个数组叫做record用来上记录字符串s里字符出现的次数。</p>
<p>需要把字符映射到数组也就是哈希表的索引下标上，<strong>因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。</strong></p>
<p>再遍历 字符串s的时候，<strong>只需要将 s[i] - ‘a’ 所在的元素做+1
操作即可，并不需要记住字符a的ASCII，只要求出一个相对数值就可以了。</strong>
这样就将字符串s中字符出现的次数，统计出来了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> record[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">// 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了</span><br>            record[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; t.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            record[t[i] - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (record[i] != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// record数组所有元素都为零0，说明字符串s和t是字母异位词</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="两个数组的交集">两个数组的交集</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-arrays/description/">https://leetcode.cn/problems/intersection-of-two-arrays/description/</a></p>
<p>题目描述</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1,2,2,1]</span>, nums2 = <span class="hljs-comment">[2,2]</span><br>输出：<span class="hljs-comment">[2]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[4,9,5]</span>, nums2 = <span class="hljs-comment">[9,4,9,8,4]</span><br>输出：<span class="hljs-comment">[9,4]</span><br>解释：<span class="hljs-comment">[4,9]</span> 也是可通过的<br></code></pre></td></tr></table></figure>
<p>思路</p>
<p>使用哈希表存储，但是用<code>set(unordered_set)</code></p>
<p>std::set和std::multiset底层实现都是红黑树，std::unordered_set的底层实现是哈希表，
使用unordered_set
读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; result_set; <span class="hljs-comment">// 存放结果，之所以用set是为了给结果集去重</span><br>        <span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums_set</span><span class="hljs-params">(nums1.begin(), nums1.end())</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums2) &#123;<br>            <span class="hljs-comment">// 发现nums2的元素 在nums_set里又出现过</span><br>            <span class="hljs-keyword">if</span> (nums_set.<span class="hljs-built_in">find</span>(num) != nums_set.<span class="hljs-built_in">end</span>()) &#123;<br>                result_set.<span class="hljs-built_in">insert</span>(num);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(result_set.<span class="hljs-built_in">begin</span>(), result_set.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findRepeatedDnaSequences</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector&lt;string&gt;ans;<br>        <span class="hljs-type">int</span> L =<span class="hljs-number">10</span>;<br>        unordered_map&lt;string, <span class="hljs-type">int</span>&gt; cnt;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;= n-L;i++)&#123;<br>            string sub = s.<span class="hljs-built_in">substr</span>(i,L);<br>            <span class="hljs-keyword">if</span>(++cnt[sub]==<span class="hljs-number">2</span>)&#123;<br>                ans.<span class="hljs-built_in">push_back</span>(sub);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="快乐数">快乐数</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/happy-number/description/">https://leetcode.cn/problems/happy-number/description/</a></p>
<p>题目描述</p>
<p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p>
<p><strong>「快乐数」</strong> 定义为：</p>
<ul>
<li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li>
<li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong>
但始终变不到 1。</li>
<li>如果这个过程 <strong>结果为</strong> 1，那么这个数就是快乐数。</li>
</ul>
<p>如果 <code>n</code> 是 <em>快乐数</em> 就返回 <code>true</code>
；不是，则返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">输入：n = 19<br>输出：<span class="hljs-literal">true</span><br>解释：<br>1*<span class="hljs-number">*2</span> + 9*<span class="hljs-number">*2</span> = 82<br>8*<span class="hljs-number">*2</span> + 2*<span class="hljs-number">*2</span> = 68<br>6*<span class="hljs-number">*2</span> + 8*<span class="hljs-number">*2</span> = 100<br>1*<span class="hljs-number">*2</span> + 0*<span class="hljs-number">*2</span> + 0*<span class="hljs-number">*2</span> = 1<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>注意，题目中提到一个点是
<strong>无限循环</strong>，说明计算的结果<strong>sum是有限</strong>的只需要在哈希表中将这部分的结果存储进去，并每次比较是不是<strong>出现1</strong>
如果是那么就是快乐数，否则就不是快乐数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n)&#123;<br>            sum+=(n%<span class="hljs-number">10</span>)*(n%<span class="hljs-number">10</span>);<br>            n/=<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">//首先建立哈希表来存储是不是出现了无限循环的结果</span><br>        unordered_set&lt;<span class="hljs-type">int</span>&gt;sum_set;<br>        <span class="hljs-comment">//无限循环 直到出现1或者无限循环且不是快乐数</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            n=<span class="hljs-built_in">getSum</span>(n);<br>            <span class="hljs-keyword">if</span>(sum_set.<span class="hljs-built_in">find</span>(n)!=sum_set.<span class="hljs-built_in">end</span>())&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                sum_set.<span class="hljs-built_in">insert</span>(n);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="两数之和">两数之和</h3>
<p>题目描述</p>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/submissions/495021134/">https://leetcode.cn/problems/two-sum/submissions/495021134/</a></p>
<p>给定一个整数数组 <code>nums</code> 和一个整数目标值
<code>target</code>，请你在该数组中找出 <strong>和为目标值</strong>
<em><code>target</code></em> 的那 <strong>两个</strong>
整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，<strong>数组中同一个元素在答案里不能重复出现</strong>。</p>
<p>你可以按任意顺序返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br>解释：因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> == 9 ，返回 <span class="hljs-comment">[0, 1]</span> 。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,4]</span>, target = 6<br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,3]</span>, target = 6<br>输出：<span class="hljs-comment">[0,1]</span><br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>构建一个哈希表，然后遍历一遍就行了在哈希表中找n-a的值是否存在，但是最大的问题是<strong>数组中同一个元素在答案里不能重复出现</strong>，所以不能简单考虑unordered_set</p>
<p>这里提供一种新的思路，就是用unordered_map来存储数组中的数据内容和下标的数值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        std::unordered_map &lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">// 遍历当前元素，并在map中寻找是否有匹配的key</span><br>            <span class="hljs-keyword">auto</span> iter = map.<span class="hljs-built_in">find</span>(target - nums[i]); <br>            <span class="hljs-keyword">if</span>(iter != map.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-keyword">return</span> &#123;iter-&gt;second, i&#125;;<br>            &#125;<br>            <span class="hljs-comment">// 如果没找到匹配对，就把访问过的元素和下标加入到map中</span><br>            map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(nums[i], i)); <br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="四数相加">四数相加</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum-ii/description/">https://leetcode.cn/problems/4sum-ii/description/</a></p>
<p>给你四个整数数组
<code>nums1</code>、<code>nums2</code>、<code>nums3</code> 和
<code>nums4</code> ，数组长度都是 <code>n</code> ，请你计算有多少个元组
<code>(i, j, k, l)</code> 能满足：</p>
<ul>
<li><code>0 &lt;= i, j, k, l &lt; n</code></li>
<li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>], <span class="hljs-symbol">nums3</span> = [<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>], <span class="hljs-symbol">nums4</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">2</span><br>解释：<br>两个元组如下：<br><span class="hljs-number">1.</span> <span class="hljs-comment">(0, 0, 0, 1)</span> -&gt; <span class="hljs-symbol">nums1</span>[<span class="hljs-number">0</span>] + <span class="hljs-symbol">nums2</span>[<span class="hljs-number">0</span>] + <span class="hljs-symbol">nums3</span>[<span class="hljs-number">0</span>] + <span class="hljs-symbol">nums4</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span> + <span class="hljs-comment">(-2)</span> + <span class="hljs-comment">(-1)</span> + <span class="hljs-number">2</span> = <span class="hljs-number">0</span><br><span class="hljs-number">2.</span> <span class="hljs-comment">(1, 1, 0, 0)</span> -&gt; <span class="hljs-symbol">nums1</span>[<span class="hljs-number">1</span>] + <span class="hljs-symbol">nums2</span>[<span class="hljs-number">1</span>] + <span class="hljs-symbol">nums3</span>[<span class="hljs-number">0</span>] + <span class="hljs-symbol">nums4</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span> + <span class="hljs-comment">(-1)</span> + <span class="hljs-comment">(-1)</span> + <span class="hljs-number">0</span> = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">0</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">0</span>], <span class="hljs-symbol">nums3</span> = [<span class="hljs-number">0</span>], <span class="hljs-symbol">nums4</span> = [<span class="hljs-number">0</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p>思路</p>
<ol type="1">
<li>首先定义 一个unordered_map，key放a和b两数之和，value
放a和b两数之和<strong>出现的次数</strong>。</li>
<li>遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。</li>
<li>定义int变量count，用来统计 a+b+c+d = 0 出现的次数。</li>
<li>在遍历大C和大D数组，找到如果 0-(c+d)
在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。</li>
<li>最后返回统计值 count 就可以了</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums3, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums4)</span> </span>&#123;<br>        std::unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;nm;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums1.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;nums2.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-type">int</span> s = nums1[i]+nums2[j];<br>                nm[s]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums3.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;nums4.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(nm.<span class="hljs-built_in">find</span>(<span class="hljs-number">0</span>-nums3[i]-nums4[j])!=nm.<span class="hljs-built_in">end</span>())&#123;<br>                    res+=nm[<span class="hljs-number">0</span>-(nums3[i]+nums4[j])];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="赎金信">赎金信</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/ransom-note/description/">https://leetcode.cn/problems/ransom-note/description/</a></p>
<p>给你两个字符串：<code>ransomNote</code> 和 <code>magazine</code>
，判断 <code>ransomNote</code> 能不能由 <code>magazine</code>
里面的字符构成。</p>
<p>如果可以，返回 <code>true</code> ；否则返回 <code>false</code> 。</p>
<p><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code>
中使用一次。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">ransomNote</span> = <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-attr">magazine</span> = <span class="hljs-string">&quot;b&quot;</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">ransomNote</span> = <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-attr">magazine</span> = <span class="hljs-string">&quot;ab&quot;</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>用哈希表unordered_map来存储次数，对于ransomNote来减去次数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canConstruct</span><span class="hljs-params">(string ransomNote, string magazine)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;umap;<br>        <span class="hljs-keyword">if</span>(ransomNote.<span class="hljs-built_in">size</span>()&gt;magazine.<span class="hljs-built_in">size</span>())&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;magazine.<span class="hljs-built_in">size</span>();i++)&#123;<br>            umap[magazine[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;ransomNote.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(umap.<span class="hljs-built_in">find</span>(ransomNote[i]-<span class="hljs-string">&#x27;a&#x27;</span>)!=umap.<span class="hljs-built_in">end</span>())&#123;<br>                umap[ransomNote[i]-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br>                <span class="hljs-keyword">if</span>(umap[ransomNote[i]-<span class="hljs-string">&#x27;a&#x27;</span>]&lt;<span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="三数之和">三数之和</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/description/">https://leetcode.cn/problems/3sum/description/</a></p>
<p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组
<code>[nums[i], nums[j], nums[k]]</code> 满足
<code>i != j</code>、<code>i != k</code> 且 <code>j != k</code>
，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p>
<p>你返回所有和为 <code>0</code> 且不重复的三元组。</p>
<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[-1,0,1,2,-1,-4]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[-1,-1,2]</span>,<span class="hljs-comment">[-1,0,1]</span>]</span><br>解释：<br>nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> + nums<span class="hljs-comment">[2]</span> = (-1) + 0 + 1 = 0 。<br>nums<span class="hljs-comment">[1]</span> + nums<span class="hljs-comment">[2]</span> + nums<span class="hljs-comment">[4]</span> = 0 + 1 + (-1) = 0 。<br>nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[3]</span> + nums<span class="hljs-comment">[4]</span> = (-1) + 2 + (-1) = 0 。<br>不同的三元组是 <span class="hljs-comment">[-1,0,1]</span> 和 <span class="hljs-comment">[-1,-1,2]</span> 。<br></code></pre></td></tr></table></figure>
<p>思路</p>
<p><strong>其实这道题目使用哈希法并不十分合适</strong>，因为在去重的操作中有很多细节需要注意，在面试中很难直接写出没有bug的代码，而且使用哈希法
在使用两层for循环的时候，能做的剪枝操作很有限，虽然时间复杂度是O(n^2)</p>
<p>这道题可以用双指针法求解</p>
<p>拿这个nums数组来举例，首先将数组排序，然后有一层for循环，<strong>i从下标0的地方开始，同时定一个下标left
定义在i+1的位置上，定义下标right 在数组结尾的位置上</strong>。</p>
<p>依然还是在数组中找到 abc 使得a + b +c =0，我们这里相当于 a =
nums[i]，b = nums[left]，c = nums[right]。</p>
<p>接下来如何移动left 和right呢， 如果nums[i] + nums[left] + nums[right]
&gt; 0 就说明
<strong>此时三数之和大了</strong>，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。</p>
<p>如果 nums[i] + nums[left] + nums[right] &lt; 0 说明 此时
三数之和小了，<strong>left
就向右移动，才能让三数之和大一些，直到left与right相遇为止</strong>。</p>
<p>还有一个难度就是不能有重复的结果，需要做一次去重的操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-comment">// 找出a + b + c = 0</span><br>        <span class="hljs-comment">// a = nums[i], b = nums[left], c = nums[right]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">// 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span><br>            <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br>          <span class="hljs-comment">// 正确去重a方法</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> left = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (right &gt; left) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="hljs-number">0</span>) right--;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="hljs-number">0</span>) left++;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    result.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);<br>                    <span class="hljs-comment">// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span><br>                    <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) right--;<br>                    <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) left++;<br>                  <span class="hljs-comment">// 找到答案时，双指针同时收缩</span><br>                    right--;<br>                    left++;<br>                &#125;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="section"></h3>
<h3 id="字母异位词分组">字母异位词分组</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/group-anagrams/description/?envType=study-plan-v2&amp;envId=top-100-liked">https://leetcode.cn/problems/group-anagrams/description/?envType=study-plan-v2&amp;envId=top-100-liked</a></p>
<p>给你一个字符串数组，请你将 <strong>字母异位词</strong>
组合在一起。可以按任意顺序返回结果列表。</p>
<p><strong>字母异位词</strong>
是由重新排列源单词的所有字母得到的一个新单词。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: strs = [<span class="hljs-string">&quot;eat&quot;</span>, <span class="hljs-string">&quot;tea&quot;</span>, <span class="hljs-string">&quot;tan&quot;</span>, <span class="hljs-string">&quot;ate&quot;</span>, <span class="hljs-string">&quot;nat&quot;</span>, <span class="hljs-string">&quot;bat&quot;</span>]<br>输出: [[<span class="hljs-string">&quot;bat&quot;</span>],[<span class="hljs-string">&quot;nat&quot;</span>,<span class="hljs-string">&quot;tan&quot;</span>],[<span class="hljs-string">&quot;ate&quot;</span>,<span class="hljs-string">&quot;eat&quot;</span>,<span class="hljs-string">&quot;tea&quot;</span>]]<br></code></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: strs = [<span class="hljs-string">&quot;&quot;</span>]<br>输出: <span class="hljs-string">[[&quot;&quot;]]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: strs = [<span class="hljs-string">&quot;a&quot;</span>]<br>输出: <span class="hljs-string">[[&quot;a&quot;]]</span><br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>对每个字符串进行计数，将每个字符串中出现的字母和数字进行排序作为key存储，利用map数据结构来进行存储上述的内容，value的值就存每个字符串</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;<br>        unordered_map&lt;string, vector&lt;string&gt;&gt; map;<br>        <span class="hljs-keyword">for</span>(string str: strs)&#123;<br>            <span class="hljs-type">int</span> count_letter[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c: str)&#123;<br>                count_letter[c-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            &#125;<br>            string key = <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;i++)&#123;<br>                <span class="hljs-keyword">if</span>(count_letter[i]&gt;<span class="hljs-number">0</span>)&#123;<br>                    key.<span class="hljs-built_in">push_back</span>(i-<span class="hljs-string">&#x27;a&#x27;</span>);<br>                    key.<span class="hljs-built_in">push_back</span>(count_letter[i]);<br>                &#125;<br>            &#125;<br>            map[key].<span class="hljs-built_in">push_back</span>(str);<br>        &#125;<br>        vector&lt;vector&lt;string&gt;&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; p:map) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(p.second);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="最长连续序列">最长连续序列</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-consecutive-sequence/submissions/531637826/?envType=study-plan-v2&amp;envId=top-100-liked">https://leetcode.cn/problems/longest-consecutive-sequence/submissions/531637826/?envType=study-plan-v2&amp;envId=top-100-liked</a></p>
<p>题目描述：</p>
<p>给定一个未排序的整数数组 <code>nums</code>
，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。请你设计并实现时间复杂度为
<code>O(n)</code> 的算法解决此问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[100,4,200,1,3,2]</span><br>输出：<span class="hljs-number">4</span><br>解释：最长数字连续序列是 <span class="hljs-string">[1, 2, 3, 4]</span>。它的长度为 <span class="hljs-number">4</span>。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">0,3,7,2</span>,<span class="hljs-number">5,8,4,6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>用哈希集合来存储上述的数，本质上还是需要比较是否存在下一个数x+1，但是可以在条件判断上进行约束，如果x-1这个数不存在集合中那么说明可以从x开始遍历
<code>!num_set.count(num - 1))&#123; //count用来计数是否存在数在集合中</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; num_set;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num : nums)&#123;<br>            num_set.<span class="hljs-built_in">insert</span>(num);<br>        &#125;<br>        <span class="hljs-type">int</span> maxlong = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num: num_set)&#123;<br>            <span class="hljs-keyword">if</span> (!num_set.<span class="hljs-built_in">count</span>(num - <span class="hljs-number">1</span>))&#123; <span class="hljs-comment">//count用来计数是否存在数在集合中</span><br>                <span class="hljs-type">int</span> curnum = num;<br>                <span class="hljs-type">int</span> curlong = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span>(num_set.<span class="hljs-built_in">count</span>(curnum+<span class="hljs-number">1</span>))&#123;<br>                    curnum+=<span class="hljs-number">1</span>;<br>                    curlong+=<span class="hljs-number">1</span>;<br>                &#125;<br>                maxlong = <span class="hljs-built_in">max</span>(maxlong, curlong);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxlong;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="双指针">双指针</h1>
<h3 id="移除元素-1">移除元素</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/description/">https://leetcode.cn/problems/remove-element/description/</a></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,2,3]</span>, val = 3<br>输出：2, nums = <span class="hljs-comment">[2,2]</span><br>解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = <span class="hljs-comment">[2,2,3,3]</span> 或 nums = <span class="hljs-comment">[2,2,0,0]</span>，也会被视作正确答案。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">0,1,2,2</span>,<span class="hljs-number">3,0,4,2</span>], val = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">5</span>, nums = [<span class="hljs-number">0,1,3,0</span>,<span class="hljs-number">4</span>]<br>解释：函数应该返回新的长度 <span class="hljs-number">5</span>, 并且 nums 中的前五个元素为 <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>使用快慢指针来实现两个指针之间的移动，对于找到了和val数值一样的就进行替换</p>
<h3 id="移动零">移动零</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/move-zeroes/description/?envType=study-plan-v2&amp;envId=top-100-liked">https://leetcode.cn/problems/move-zeroes/description/?envType=study-plan-v2&amp;envId=top-100-liked</a></p>
<p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code>
移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p><strong>请注意</strong>
，必须在不复制数组的情况下原地对数组进行操作。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入: nums = <span class="hljs-string">[0,1,0,3,12]</span><br>输出: <span class="hljs-string">[1,3,12,0,0]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: nums = <span class="hljs-comment">[0]</span><br>输出: <span class="hljs-comment">[0]</span><br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>使用双指针，向后遍历的过程中一旦遇到非0的元素就将其与左边指针互换并左边下标+1，凡事遇到需要交换位置的这类方法都建议能使用双指针来实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right = <span class="hljs-number">0</span>; right&lt;nums.<span class="hljs-built_in">size</span>();right++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[right])&#123;<br>                <span class="hljs-built_in">swap</span>(nums[left],nums[right]);<br>                left++;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="合并两个有序数组">合并两个有序数组</h3>
<p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组
<code>nums1</code> 和 <code>nums2</code>，另有两个整数 <code>m</code> 和
<code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code>
中的元素数目。</p>
<p>请你 <strong>合并</strong> <code>nums2</code> 到 <code>nums1</code>
中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。</p>
<p><strong>注意：</strong>最终，合并后数组不应由函数返回，而是存储在数组
<code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为
<code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后
<code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code>
的长度为 <code>n</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1,2,3,0,0,0]</span>, m = 3, nums2 = <span class="hljs-comment">[2,5,6]</span>, n = 3<br>输出：<span class="hljs-comment">[1,2,2,3,5,6]</span><br>解释：需要合并 <span class="hljs-comment">[1,2,3]</span> 和 <span class="hljs-comment">[2,5,6]</span> 。<br>合并结果是 <span class="hljs-comment">[1,2,2,3,5,6]</span> ，其中斜体加粗标注的为 nums1 中的元素。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1]</span>, m = 1, nums2 = <span class="hljs-comment">[]</span>, n = 0<br>输出：<span class="hljs-comment">[1]</span><br>解释：需要合并 <span class="hljs-comment">[1]</span> 和 <span class="hljs-comment">[]</span> 。<br>合并结果是 <span class="hljs-comment">[1]</span> 。<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, <span class="hljs-type">int</span> m, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            nums1[m+i] = nums2[i];<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(nums1.<span class="hljs-built_in">begin</span>(), nums1.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="轮转数组">轮转数组</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-array/description/?envType=study-plan-v2&amp;envId=2024-spring-sprint-100">https://leetcode.cn/problems/rotate-array/description/?envType=study-plan-v2&amp;envId=2024-spring-sprint-100</a></p>
<p>给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转
<code>k</code> 个位置，其中 <code>k</code> 是非负数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">输入</span><span class="hljs-punctuation">:</span> <span class="hljs-string">nums = [1,2,3,4,5,6,7], k = 3</span><br><span class="hljs-attribute">输出</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[5,6,7,1,2,3,4]</span><br><span class="hljs-attribute">解释</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">向右轮转 1 步</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[7,1,2,3,4,5,6]</span><br><span class="hljs-attribute">向右轮转 2 步</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[6,7,1,2,3,4,5]</span><br><span class="hljs-attribute">向右轮转 3 步</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[5,6,7,1,2,3,4]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-1</span>,<span class="hljs-string">-100</span>,3,99], k = 2<br>输出：[3,99,<span class="hljs-string">-1</span>,<span class="hljs-string">-100</span>]<br>解释: <br>向右轮转 1 步: [99,<span class="hljs-string">-1</span>,<span class="hljs-string">-100</span>,3]<br>向右轮转 2 步: [3,99,<span class="hljs-string">-1</span>,<span class="hljs-string">-100</span>]<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>如何才能原地轮转数组，就是不引入额外的空间存储，这里考虑的就是用取模和最大公约数的方式进行运算，而每次while结束的终点是s==cur，简单来说就是当1-&gt;3-&gt;5之后还会到1那么这个时候就结束</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240629200640705.png" srcset="/img/loading.gif" lazyload alt="轮转数组思路" style="zoom:50%;" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        k = k % n;<br>        <span class="hljs-type">int</span> count = <span class="hljs-built_in">gcd</span>(k, n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s = <span class="hljs-number">0</span>; s&lt;count; s++)&#123;<br>            <span class="hljs-type">int</span> cur = s;<br>            <span class="hljs-type">int</span> pre = nums[s];<br>            <span class="hljs-keyword">do</span>&#123;<br>                <span class="hljs-type">int</span> next = (cur + k)%n;<br>                <span class="hljs-built_in">swap</span>(nums[next], pre);<br>                cur = next;<br>            &#125;<span class="hljs-keyword">while</span>(s!=cur);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="验证回文串">验证回文串</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-palindrome/description/?envType=study-plan-v2&amp;envId=2024-spring-sprint-100">https://leetcode.cn/problems/valid-palindrome/description/?envType=study-plan-v2&amp;envId=2024-spring-sprint-100</a></p>
<p>如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个
<strong>回文串</strong> 。字母和数字都属于字母数字字符。给你一个字符串
<code>s</code>，如果它是 <strong>回文串</strong> ，返回
<code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;A man, a plan, a canal: Panama&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：<span class="hljs-string">&quot;amanaplanacanalpanama&quot;</span> 是回文串。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;race a car&quot;</span><br>输出：<span class="hljs-literal">false</span><br>解释：<span class="hljs-string">&quot;raceacar&quot;</span> 不是回文串。<br></code></pre></td></tr></table></figure>
<p>思路：需要先用<code>isalnum()</code>来验证当前的字符串是不是字母，再用<code>tolower</code>来转成小写字母</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        string ss;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isalnum</span>(s[i]))&#123;<br>                ss+=<span class="hljs-built_in">tolower</span>(s[i]);<br>            &#125;<br>        &#125;<br>        string sss = ss;<br>        std::<span class="hljs-built_in">reverse</span>(ss.<span class="hljs-built_in">begin</span>(), ss.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> sss==ss? <span class="hljs-literal">true</span>: <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="比较版本号">比较版本号</h3>
<p>给你两个 <strong>版本号字符串</strong> <code>version1</code> 和
<code>version2</code> ，请你比较它们。版本号由被点 <code>'.'</code>
分开的修订号组成。<strong>修订号的值</strong> 是它
<strong>转换为整数</strong> 并忽略前导零。</p>
<p>比较版本号时，请按 <strong>从左到右的顺序</strong>
依次比较它们的修订号。如果其中一个版本字符串的修订号较少，则将缺失的修订号视为
<code>0</code>。</p>
<p>返回规则如下：</p>
<ul>
<li>如果 <code>*version1* &lt; *version2*</code> 返回
<code>-1</code>，</li>
<li>如果 <code>*version1* &gt; *version2*</code> 返回
<code>1</code>，</li>
<li>除此之外返回 <code>0</code>。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>version1 = "1.2", version2 = "1.10"</p>
<p><strong>输出：</strong>-1</p>
<p><strong>解释：</strong>version1 的第二个修订号为 "2"，version2
的第二个修订号为 "10"：2 &lt; 10，所以 version1 &lt; version2。</p>
<p>思路：用模拟的方式将字符串的内容转化成数字来存储并最终进行比较，注意点号的细节和用大数存储</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compareVersion</span><span class="hljs-params">(string version1, string version2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = version1.<span class="hljs-built_in">length</span>(), m = version2.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; n || j &lt; m) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> x = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (; i &lt; n &amp;&amp; version1[i] != <span class="hljs-string">&#x27;.&#x27;</span>; ++i) &#123;<br>                x = x * <span class="hljs-number">10</span> + version1[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            ++i; <span class="hljs-comment">// 跳过点号</span><br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> y = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (; j &lt; m &amp;&amp; version2[j] != <span class="hljs-string">&#x27;.&#x27;</span>; ++j) &#123;<br>                y = y * <span class="hljs-number">10</span> + version2[j] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            ++j; <span class="hljs-comment">// 跳过点号</span><br>            <span class="hljs-keyword">if</span> (x != y) &#123;<br>                <span class="hljs-keyword">return</span> x &gt; y ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h3 id="下一个排列">下一个排列</h3>
<p>整数数组的一个 <strong>排列</strong>
就是将其所有成员以序列或线性顺序排列。</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作
<code>arr</code>
的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code>
。</li>
</ul>
<p>整数数组的 <strong>下一个排列</strong>
是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的
<strong>下一个排列</strong>
就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code>
。</li>
<li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是
<code>[3,1,2]</code> 。</li>
<li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code>
，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。</li>
</ul>
<p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code>
的下一个排列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[1,3,2]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,1]</span><br>输出：<span class="hljs-comment">[1,2,3]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1,5]</span><br>输出：<span class="hljs-comment">[1,5,1]</span><br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>注意到下一个排列总是比当前排列要大，除非该排列已经是最大的排列。我们希望找到一种方法，能够找到一个大于当前序列的新序列，且变大的幅度尽可能小。</p>
<p>具体地，我们这样描述该算法，对于长度为 n的排列 a：</p>
<p>首先从后向前查找第一个顺序对 (i,i+1)，满足
a[i]&lt;a[i+1]。这样「较小数」即为 a[i]。此时
[i+1,n)必然是下降序列。如果找到了顺序对，那么在区间 [i+1,n)
中从后向前查找第一个元素 j满足 a[i]&lt;a[j]。这样「较大数」即为
a[j]。交换 a[i] 与 a[j]，此时可以证明区间
[i+1,n)必为降序。我们可以直接使用双指针反转区间
[i+1,n)使其变为升序，而无需对该区间进行排序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span>;<br>        <span class="hljs-comment">// 找到第一个比后一位要小的元素</span><br>        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span> &amp;&amp; nums[i]&gt;=nums[i+<span class="hljs-number">1</span>])&#123;<br>            i--;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> j =nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span>(j&gt;=<span class="hljs-number">0</span> &amp;&amp; nums[i]&gt;=nums[j])&#123;<br>                j--;<br>            &#125;<br>            <span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>()+i+<span class="hljs-number">1</span>, nums.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="删除有序数组中的重复元素">删除有序数组中的重复元素</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/?envType=study-plan-v2&amp;envId=2024-spring-sprint-100">https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/?envType=study-plan-v2&amp;envId=2024-spring-sprint-100</a></p>
<p>给你一个 <strong>非严格递增排列</strong> 的数组 <code>nums</code>
，请你<strong><a
target="_blank" rel="noopener" href="http://baike.baidu.com/item/原地算法">原地</a></strong>
删除重复出现的元素，使每个元素 <strong>只出现一次</strong>
，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持
<strong>一致</strong> 。然后返回 <code>nums</code>
中唯一元素的个数。</p>
<p>考虑 <code>nums</code> 的唯一元素的数量为 <code>k</code>
，你需要做以下事情确保你的题解可以被通过：</p>
<ul>
<li>更改数组 <code>nums</code> ，使 <code>nums</code> 的前
<code>k</code> 个元素包含唯一元素，并按照它们最初在 <code>nums</code>
中出现的顺序排列。<code>nums</code> 的其余元素与 <code>nums</code>
的大小不重要。</li>
<li>返回 <code>k</code> 。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1,2]</span><br>输出：2, nums = <span class="hljs-comment">[1,2,_]</span><br>解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">0,0,1,1</span>,<span class="hljs-number">1,2,2,3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">5</span>, nums = [<span class="hljs-number">0,1,2,3</span>,<span class="hljs-number">4</span>]<br>解释：函数应该返回新的长度 <span class="hljs-number">5</span> ， 并且原数组 nums 的前五个元素被修改为 <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> 。不需要考虑数组中超出新长度后面的元素。<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>这道题技巧在于抓住有序的数组，可以用<strong>双指针来对数组进行遍历</strong>，定义两个指针
fast 和
slow分别为快指针和慢指针，快指针表示遍历数组到达的下标位置，慢指针表示下一个不同元素要填入的下标位置，初始时两个指针都指向下标
1。</p>
<p>假设数组 nums的长度为 n。将快指针 fast 依次遍历从 1到
n−1的每个位置，对于每个位置，如果 nums[fast]≠nums[fast−1]，说明
nums[fast]和之前的元素都不同，因此将 nums[fast]的值复制到
nums[slow]，然后将 slow的值加 1，即指向下一个位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> slow = <span class="hljs-number">1</span>, fast = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(fast&lt;n)&#123;<br>            <span class="hljs-keyword">if</span>(nums[fast]!=nums[fast<span class="hljs-number">-1</span>])&#123;<br>                nums[slow] = nums[fast];<br>                slow++;<br>            &#125;<br>            fast++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="反转字符串">反转字符串</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string/description/">https://leetcode.cn/problems/reverse-string/description/</a></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = [<span class="hljs-string">&quot;h&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;o&quot;</span>]<br>输出：[<span class="hljs-string">&quot;o&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;h&quot;</span>]<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = [<span class="hljs-string">&quot;H&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;h&quot;</span>]<br>输出：[<span class="hljs-string">&quot;h&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;H&quot;</span>]<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>采用两个指针之间互相交换，首尾交换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; s)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, b = s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;a&lt;b;)&#123;<br>            <span class="hljs-type">char</span> tmp;<br>            tmp=s[a];<br>            s[a]=s[b];<br>            s[b]=tmp;<br>            a++;<br>            b--;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="反转字符串中的单词">反转字符串中的单词</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-words-in-a-string/description/">https://leetcode.cn/problems/reverse-words-in-a-string/description/</a></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;the sky is blue&quot;</span><br>输出：<span class="hljs-string">&quot;blue is sky the&quot;</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;  hello world  &quot;</span><br>输出：<span class="hljs-string">&quot;world hello&quot;</span><br>解释：反转后的字符串中不能存在前导空格和尾随空格。<br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a good   example&quot;</span><br>输出：<span class="hljs-string">&quot;example good a&quot;</span><br>解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>首先对字符串中额外的空格进行删除</p>
<p>字符串进行全局的逆序</p>
<p>再根据空格作为一个单独字母的节点进行分格分别进行逆序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(s[i]==s[i<span class="hljs-number">-1</span>]&amp;&amp;s[i]==<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>()+i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">0</span>&amp;&amp;s[s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>            s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>()+s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">0</span>&amp;&amp;s[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>            s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>());<br>        &#125;<br><br>        <span class="hljs-comment">//完成全局的交换</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j=s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&lt;j;i++,j--)&#123;<br>            <span class="hljs-type">char</span> tmp;<br>            tmp = s[i];<br>            s[i] = s[j];<br>            s[j] = tmp;<br>        &#125;<br>        cout&lt;&lt;s;<br>        <span class="hljs-comment">//进行局部的交换</span><br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(j&lt;=s.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">if</span>(s[j]==<span class="hljs-string">&#x27; &#x27;</span>||j==s.<span class="hljs-built_in">size</span>())&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k =i, q =j<span class="hljs-number">-1</span>;k&lt;q;k++,q--)&#123;<br>                    <span class="hljs-type">char</span> tmp;<br>                    tmp = s[k];<br>                    s[k] = s[q];<br>                    s[q] = tmp;<br>                &#125;<br>                i=j+<span class="hljs-number">1</span>;<br>                j=i+<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                j++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="反转链表">反转链表</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/description/">https://leetcode.cn/problems/reverse-linked-list/description/</a></p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240118151406885.png" srcset="/img/loading.gif" lazyload alt="image-20240118151406885" style="zoom:67%;" /></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span><br>输出：<span class="hljs-string">[5,4,3,2,1]</span><br></code></pre></td></tr></table></figure>
<p>思路：本质上就是利用了两个链表指针实现对元素的转向</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* temp;<br>        ListNode* cur = head;<br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            temp = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="删除链表的倒数第n个结点">删除链表的倒数第N个结点</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/</a></p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240118152000575.png" srcset="/img/loading.gif" lazyload alt="image-20240118152000575" style="zoom:67%;" /></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5</span>], n = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">1,2,3,5</span>]<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1]</span>, n = 1<br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>遍历，用两个指针分别来记录</p>
<p>如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummyHead-&gt;next = head;<br>        ListNode* slow = dummyHead;<br>        ListNode* fast = dummyHead;<br>        <span class="hljs-keyword">while</span>(n-- &amp;&amp; fast != <span class="hljs-literal">NULL</span>) &#123;<br>            fast = fast-&gt;next;<br>        &#125;<br>        fast = fast-&gt;next; <span class="hljs-comment">// fast再提前走一步，因为需要让slow指向删除节点的上一个节点</span><br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">NULL</span>) &#123;<br>            fast = fast-&gt;next;<br>            slow = slow-&gt;next;<br>        &#125;<br>        slow-&gt;next = slow-&gt;next-&gt;next; <br>        <br>        <span class="hljs-comment">// ListNode *tmp = slow-&gt;next;  C++释放内存的逻辑</span><br>        <span class="hljs-comment">// slow-&gt;next = tmp-&gt;next;</span><br>        <span class="hljs-comment">// delete nth;</span><br>        <br>        <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="链表相交">链表相交</h3>
<p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code>
，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回
<code>null</code> 。</p>
<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>
<p><strong>注意</strong>，函数返回结果后，链表必须
<strong>保持其原始结构</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240119195217619.png" srcset="/img/loading.gif" lazyload alt="链表相交图" style="zoom:80%;" /></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：intersectVal = <span class="hljs-number">8</span>, listA = [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>], listB = [<span class="hljs-number">5,0,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">2</span>, skipB = <span class="hljs-number">3</span><br>输出：Intersected at &#x27;<span class="hljs-number">8</span>&#x27;<br>解释：相交节点的值为 <span class="hljs-number">8</span> （注意，如果两个链表相交则不能为 <span class="hljs-number">0</span>）。<br>从各自的表头开始算起，链表 <span class="hljs-keyword">A</span> 为 [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>]，链表 B 为 [<span class="hljs-number">5,0,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]。<br>在 <span class="hljs-keyword">A</span> 中，相交节点前有 <span class="hljs-number">2</span> 个节点；在 B 中，相交节点前有 <span class="hljs-number">3</span> 个节点。<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>简单来说，就是求两个链表交点节点的<strong>指针</strong>，注意返回的是结点的指针，不是对应的数值，同时注意这里比较的是<strong>相同的指针不是数值相同</strong>，因此直接比较指针是不是相同就可以了</p>
<p>由于题目说的相交的结构如图所示，如果存在相交的指针位置，只可能出现在后面只需要考虑利用双指针从相差的数值位开始遍历</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode* curA = headA;<br>        ListNode* curB = headB;<br>        <span class="hljs-type">int</span> lenA = <span class="hljs-number">0</span>, lenB = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(curA != <span class="hljs-literal">NULL</span>)&#123;<br>            lenA++;<br>            curA = curA -&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(curB != <span class="hljs-literal">NULL</span>)&#123;<br>            lenB++;<br>            curB = curB -&gt;next;<br>        &#125;<br>        curA = headA;<br>        curB = headB;<br>        <span class="hljs-keyword">if</span>(lenB&gt; lenA)&#123;<br>            <span class="hljs-built_in">swap</span>(lenA,lenB);<br>            <span class="hljs-built_in">swap</span>(curA, curB);<br>        &#125;<br><br>        <span class="hljs-type">int</span> gap = lenA - lenB;<br>        <span class="hljs-keyword">while</span>(gap--)&#123;<br>            curA =  curA-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(curA!=<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">if</span>(curA == curB)&#123;<br>                <span class="hljs-keyword">return</span> curA;<br>            &#125;<br>            curA = curA-&gt;next;<br>            curB = curB-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="环形链表">环形链表</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">https://leetcode.cn/problems/linked-list-cycle-ii/description/</a></p>
<p>判断是否是有还存在，如果有那么返回开始入环的第一个节点的下标</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240119200331204.png" srcset="/img/loading.gif" lazyload alt="环形链表" style="zoom:50%;" /></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [3,2,0,-4], pos = 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>这道题用快慢指针的思路，就是慢指针每次只走一步，快指针每次走两步，如果在到达null之前出现快慢指针指向了同一个地方，说明这个<strong>链表有环存在</strong>，那么怎么判断下标的位置呢？</p>
<p>具体的证明过程：</p>
<figure>
<img
src="../../../../../Library/Application%20Support/typora-user-images/image-20240119200838486.png" srcset="/img/loading.gif" lazyload
alt="环形链表" />
<figcaption aria-hidden="true">环形链表</figcaption>
</figure>
<p>相遇时slow指针走过的节点数为: <code>x + y</code>，
fast指针走过的节点数：<code>x + y + n (y + z)</code>，n为fast指针在环内走了n圈才遇到slow指针，
（y+z）为 一圈内节点的个数A。</p>
<p>因为fast指针是一步走两个节点，slow指针一步走一个节点， 所以
fast指针走过的节点数 = slow指针走过的节点数 * 2：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">(<span class="hljs-name">x</span> + y) * <span class="hljs-number">2</span> = x + y + n (<span class="hljs-name">y</span> + z)<br></code></pre></td></tr></table></figure>
<p>两边消掉一个（x+y）: <code>x + y = n (y + z)</code></p>
<p>因为要找环形的入口，那么要求的是x，因为x表示 头结点到
环形入口节点的的距离。</p>
<p>所以要求x ，将x单独放在左面：<code>x = n (y + z) - y</code> ,</p>
<p>再从n(y+z)中提出一个
（y+z）来，整理公式之后为如下公式：<code>x = (n - 1) (y + z) + z</code>
注意这里n一定是大于等于1的，因为
fast指针至少要多走一圈才能相遇slow指针</p>
<p>所以可以得到的规律是：<strong>从头结点出发一个指针，从相遇节点
也出发一个指针，这两个指针每次只走一个节点，
那么当这两个指针相遇的时候就是 环形入口的节点</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode* fast = head;<br>        ListNode* slow = head;<br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">NULL</span>&amp;&amp; fast-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>            <span class="hljs-comment">//说明找到了</span><br>            <span class="hljs-keyword">if</span>(slow==fast)&#123;<br>                ListNode* index1 = fast;<br>                ListNode* index2 = head;<br>                <span class="hljs-keyword">while</span>(index1!=index2)&#123;<br>                    index1 = index1-&gt;next;<br>                    index2 = index2 -&gt;next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> index2;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="section-1"></h3>
<h3 id="找到字符串中所有字幕的异位词">找到字符串中所有字幕的异位词</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/?envType=study-plan-v2&amp;envId=top-100-liked">https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/?envType=study-plan-v2&amp;envId=top-100-liked</a></p>
<p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code>
中所有 <code>p</code> 的 <strong>异位词</strong>
的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>
<p><strong>异位词</strong>
指由相同字母重排列形成的字符串（包括相同的字符串）。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入: s = <span class="hljs-string">&quot;cbaebabacd&quot;</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出: <span class="hljs-selector-attr">[0,6]</span><br>解释:<br>起始索引等于 <span class="hljs-number">0</span> 的子串是 <span class="hljs-string">&quot;cba&quot;</span>, 它是 <span class="hljs-string">&quot;abc&quot;</span> 的异位词。<br>起始索引等于 <span class="hljs-number">6</span> 的子串是 <span class="hljs-string">&quot;bac&quot;</span>, 它是 <span class="hljs-string">&quot;abc&quot;</span> 的异位词。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入: s = <span class="hljs-string">&quot;abab&quot;</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-string">&quot;ab&quot;</span><br>输出: <span class="hljs-selector-attr">[0,1,2]</span><br>解释:<br>起始索引等于 <span class="hljs-number">0</span> 的子串是 <span class="hljs-string">&quot;ab&quot;</span>, 它是 <span class="hljs-string">&quot;ab&quot;</span> 的异位词。<br>起始索引等于 <span class="hljs-number">1</span> 的子串是 <span class="hljs-string">&quot;ba&quot;</span>, 它是 <span class="hljs-string">&quot;ab&quot;</span> 的异位词。<br>起始索引等于 <span class="hljs-number">2</span> 的子串是 <span class="hljs-string">&quot;ab&quot;</span>, 它是 <span class="hljs-string">&quot;ab&quot;</span> 的异位词。<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>这道题可以考虑用滑动窗口的方法来考虑，对于不同位置但是组成一样的一对字符串可以用哈希表来记录，这个地方就用哈希数组来存储，每次按照一定的顺序进行滑动</p>
<p>所以我们可以在字符串 s 中构造一个长度为与字符串 p
的长度相同的滑动窗口，并在滑动中维护窗口中每种字母的数量；当窗口中每种字母的数量与字符串
p 中每种字母的数量相同时，则说明当前窗口为字符串 p的异位词</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = s.<span class="hljs-built_in">size</span>(), n = p.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(m&lt;n)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;();<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">scount</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pcount</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            scount[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            pcount[p[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(scount == pcount)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m-n;i++)&#123;<br>            scount[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            scount[s[i+n]-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            <span class="hljs-keyword">if</span>(scount==pcount)&#123;<br>                res.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="盛最多水的容器">盛最多水的容器</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/container-with-most-water/?envType=study-plan-v2&amp;envId=top-100-liked">https://leetcode.cn/problems/container-with-most-water/?envType=study-plan-v2&amp;envId=top-100-liked</a></p>
<p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有
<code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是
<code>(i, 0)</code> 和 <code>(i, height[i])</code>
。找出其中的两条线，使得它们与 <code>x</code>
轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。<strong>说明：</strong>你不能倾斜容器。</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240513211326213.png" srcset="/img/loading.gif" lazyload alt="最多水的容器" style="zoom:50%;" /></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：[<span class="hljs-number">1,8,6,2</span>,<span class="hljs-number">5,4,8,3</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-number">49</span> <br>解释：图中垂直线代表输入数组 [<span class="hljs-number">1,8,6,2</span>,<span class="hljs-number">5,4,8,3</span>,<span class="hljs-number">7</span>]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 <span class="hljs-number">49</span>。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">输入：height = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>双指针来解决这个题，主要的思路就是首尾都放一个指针，然后依次向中间移动，向中间移动意味着x轴的长度变短那么需要高度要长，因此需要舍弃掉短的那边--或者++来滑动</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = height.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> maxa = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-type">int</span> water = <span class="hljs-built_in">min</span>(height[r], height[l]) * (r-l);<br>            <span class="hljs-keyword">if</span>(water&gt;maxa)&#123;<br>                maxa = water;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(height[l]&lt;height[r])&#123;<br>                l++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                r--;<br>            &#125;<br>        &#125; <br>        <span class="hljs-keyword">return</span> maxa;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="接雨水">接雨水</h3>
<p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code>
的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><strong>示例 1：</strong></p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/rainwatertrap.png" srcset="/img/loading.gif" lazyload
alt="接雨水" />
<figcaption aria-hidden="true">接雨水</figcaption>
</figure>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：height = [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>]<br>输出：<span class="hljs-number">6</span><br>解释：上面是由数组 [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>] 表示的高度图，在这种情况下，可以接 <span class="hljs-number">6</span> 个单位的雨水（蓝色部分表示雨水）。 <br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：height = <span class="hljs-string">[4,2,0,3,2,5]</span><br>输出：<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>找到最大的左边和最大的右边并相减</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(height.<span class="hljs-built_in">size</span>()&lt;=<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxLeft</span><span class="hljs-params">(height.size(), <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxRight</span><span class="hljs-params">(height.size(), <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> size = maxRight.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">//记录每个柱子左边柱子的最大高度</span><br>        maxLeft[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;size;i++)&#123;<br>            maxLeft[i] = <span class="hljs-built_in">max</span>(height[i],maxLeft[i<span class="hljs-number">-1</span>]);<br>        &#125;<br>        <span class="hljs-comment">//记录每个柱子右边柱子的最大高度</span><br>        maxRight[size<span class="hljs-number">-1</span>] = height[size<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=size<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            maxRight[i] = <span class="hljs-built_in">max</span>(height[i],maxRight[i+<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>            <span class="hljs-type">int</span> count = <span class="hljs-built_in">min</span>(maxLeft[i], maxRight[i])-height[i];<br>            <span class="hljs-keyword">if</span>(count &gt; <span class="hljs-number">0</span>) sum+=count;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="柱形图中的最大矩形">柱形图中的最大矩形</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram/description/">https://leetcode.cn/problems/largest-rectangle-in-histogram/description/</a></p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240129144103735.png" srcset="/img/loading.gif" lazyload alt="最大矩形问题" style="zoom:67%;" /></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：heights = <span class="hljs-string">[2,1,5,6,2,3]</span><br>输出：<span class="hljs-number">10</span><br>解释：最大的矩形为图中红色区域，面积为 <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minLeft</span><span class="hljs-params">(heights.size())</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minRight</span><span class="hljs-params">(heights.size())</span></span>;<br>        <span class="hljs-type">int</span> size = heights.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-comment">//记录每个柱子左边第一个小于该柱子的下标</span><br>        minLeft[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;size;i++)&#123;<br>            <span class="hljs-type">int</span> t= i<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span>(t&gt;=<span class="hljs-number">0</span>&amp;&amp;heights[t]&gt;=heights[i]) t=minLeft[t];<br>            minLeft[i]=t;<br>        &#125;<br>        <span class="hljs-comment">//记录每个柱右边第一个小于该柱子的下标</span><br>        minRight[size<span class="hljs-number">-1</span>]=size;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=size <span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-type">int</span> t=i+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(t&lt;size&amp;&amp;heights[t]&gt;=heights[i]) t=minRight[t];<br>            minRight[i]=t;<br>        &#125;<br><br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>            <span class="hljs-type">int</span> sum=heights[i]*(minRight[i]-minLeft[i]<span class="hljs-number">-1</span>);<br>            res = <span class="hljs-built_in">max</span>(sum,res);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="滑动窗口">滑动窗口</h1>
<h3 id="存在重复的元素ii">存在重复的元素II</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/contains-duplicate-ii/description/?envType=study-plan-v2&amp;envId=2024-spring-sprint-100">https://leetcode.cn/problems/contains-duplicate-ii/description/?envType=study-plan-v2&amp;envId=2024-spring-sprint-100</a></p>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code>
，判断数组中是否存在两个 <strong>不同的索引</strong> <code>i</code> 和
<code>j</code> ，满足 <code>nums[i] == nums[j]</code> 且
<code>abs(i - j) &lt;= k</code> 。如果存在，返回 <code>true</code>
；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>], <span class="hljs-attr">k</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>], <span class="hljs-attr">k</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-attr">k</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>滑动窗口，每次内层循环只需要选择一定的长度进行循环，同时保证不能超过数组的最大长度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsNearbyDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">bool</span> res = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i+<span class="hljs-number">1</span>;j&lt;=i+k&amp;&amp; j&lt;nums.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i]==nums[j])&#123;<br>                    res = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="链表">链表</h1>
<h3 id="两数相加">两数相加</h3>
<p>给你两个 <strong>非空</strong>
的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong>
的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240609223041348.png" srcset="/img/loading.gif" lazyload alt="两数相加示意图" style="zoom:50%;" /></p>
<p>思路：</p>
<p>模拟相加和进位过程，注意链表的初始化和更新迭代</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* res = <span class="hljs-literal">nullptr</span>, *tail = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> plus = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l1 || l2)&#123;<br>            <span class="hljs-type">int</span> n1 = l1? l1-&gt;val: <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> n2 = l2? l2-&gt;val: <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> val = n1+n2+plus&gt;=<span class="hljs-number">10</span>? (n1+n2+plus)%<span class="hljs-number">10</span> : n1+n2+plus;<br>            plus = (n1+n2+plus)/<span class="hljs-number">10</span>;<br><br>            <span class="hljs-keyword">if</span> (!res) &#123;<br>                res = tail = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(val);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                tail-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(val);<br>                tail = tail-&gt;next;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(l1)&#123;<br>                l1 = l1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(l2)&#123;<br>                l2 = l2-&gt;next;<br>            &#125; <br>        &#125;<br>        <span class="hljs-keyword">if</span> (plus &gt; <span class="hljs-number">0</span>) &#123;<br>            tail-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(plus);<br>            &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="相交链表">相交链表</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists/description/?envType=study-plan-v2&amp;envId=2024-spring-sprint-100">https://leetcode.cn/problems/intersection-of-two-linked-lists/description/?envType=study-plan-v2&amp;envId=2024-spring-sprint-100</a></p>
<p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code>
，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回
<code>null</code> 。图示两个链表在节点 <code>c1</code>
开始相交<strong>：</strong></p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240701205600757.png" srcset="/img/loading.gif" lazyload alt="链表相交的示意图" style="zoom:50%;" /></p>
<p>题目数据 <strong>保证</strong>
整个链式结构中不存在环。注意<strong>，函数返回结果后，链表必须
</strong>保持其原始结构** 。</p>
<p>思路：</p>
<p>假设链式中存在相交，那么可以考虑交叉互换的思路让两条链子变成环，那么问题就变成了一个追赶问题，如果刚好遇到有相同的，那么就会输出，否者就会输出nullptr</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(headA == <span class="hljs-literal">nullptr</span> || headB == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        ListNode *pa = headA, *pb = headB;<br>        <span class="hljs-keyword">while</span>(pa!=pb)&#123;<br>            <span class="hljs-keyword">if</span>(pa!=<span class="hljs-literal">nullptr</span>)&#123;<br>                pa = pa-&gt;next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                pa = headB;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(pb!=<span class="hljs-literal">nullptr</span>)&#123;<br>                pb = pb-&gt;next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                pb = headA;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pa;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="旋转链表">旋转链表</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-list/description/?envType=study-plan-v2&amp;envId=2024-spring-sprint-100">https://leetcode.cn/problems/rotate-list/description/?envType=study-plan-v2&amp;envId=2024-spring-sprint-100</a></p>
<p>给你一个链表的头节点 <code>head</code>
，旋转链表，将链表每个节点向右移动 <code>k</code> 个位置。</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-string">[4,5,1,2,3]</span><br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>闭合为环，记给定链表的长度为 n，注意到当向右移动的次数 k≥n
时，我们仅需要向右移动 kmodn 次即可。因为每 n
次移动都会让链表变为原状。这样我们可以知道，新链表的最后一个节点为原链表的第
(n−1)−(kmodn) 个节点（从 0 开始计数）。</p>
<p>这样，我们可以先将给定的链表连接成环，然后将指定位置断开。</p>
<p>具体代码中，我们首先计算出链表的长度
n，并找到该链表的末尾节点，将其与头节点相连。这样就得到了闭合为环的链表。然后我们找到新链表的最后一个节点（即原链表的第
(n−1)−(kmodn)
个节点），将当前闭合为环的链表断开，即可得到我们所需要的结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">rotateRight</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>||head ==<span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-comment">// 计算出总共的节点个数</span><br>        <span class="hljs-type">int</span> n = <span class="hljs-number">1</span>;<br>        ListNode* iter = head;<br>        <span class="hljs-keyword">while</span>(iter-&gt;next!=<span class="hljs-literal">nullptr</span>)&#123;<br>            iter = iter-&gt;next;<br>            n++;<br>        &#125;<br>        <span class="hljs-comment">// 如果旋转的次数刚好回归到原始的位置那么就结束</span><br>        <span class="hljs-type">int</span> add = n-k%n;<br>        <span class="hljs-keyword">if</span>(add == n)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        iter-&gt;next = head;<br>        <span class="hljs-keyword">while</span>(add--)&#123;<br>            iter = iter-&gt;next;<br>        &#125;<br>        ListNode* res = iter-&gt;next;<br>        iter-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="反转链表ii">反转链表II</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list-ii/description/?envType=study-plan-v2&amp;envId=2024-spring-sprint-100">https://leetcode.cn/problems/reverse-linked-list-ii/description/?envType=study-plan-v2&amp;envId=2024-spring-sprint-100</a></p>
<p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和
<code>right</code> ，其中 <code>left &lt;= right</code> 。请你反转从位置
<code>left</code> 到位置 <code>right</code> 的链表节点，返回
<strong>反转后的链表</strong> 。</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240629213345117.png" srcset="/img/loading.gif" lazyload alt="反转链表2" style="zoom:50%;" /></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：head = <span class="hljs-selector-attr">[1,2,3,4,5]</span>, <span class="hljs-attribute">left</span> = <span class="hljs-number">2</span>, right = <span class="hljs-number">4</span><br>输出：<span class="hljs-selector-attr">[1,4,3,2,5]</span><br></code></pre></td></tr></table></figure>
<p>思路：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure>
<h1 id="二叉树">二叉树</h1>
<h3 id="相同的树">相同的树</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/same-tree/description/?envType=study-plan-v2&amp;envId=2024-spring-sprint-100">https://leetcode.cn/problems/same-tree/description/?envType=study-plan-v2&amp;envId=2024-spring-sprint-100</a></p>
<p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code>
，编写一个函数来检验这两棵树是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：<span class="hljs-selector-tag">p</span> = <span class="hljs-selector-attr">[1,2,3]</span>, <span class="hljs-selector-tag">q</span> = <span class="hljs-selector-attr">[1,2,3]</span><br>输出：true<br></code></pre></td></tr></table></figure>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：<span class="hljs-selector-tag">p</span> = <span class="hljs-selector-attr">[1,2]</span>, <span class="hljs-selector-tag">q</span> = <span class="hljs-selector-attr">[1,null,2]</span><br>输出：false<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p><strong>深度优先搜索算法</strong>，递归判断是否相同</p>
<p>如果两个二叉树都为空，则两个二叉树相同。如果两个二叉树中有且只有一个为空，则两个二叉树一定不相同。如果两个二叉树都不为空，那么首先判断它们的根节点的值是否相同，若不相同则两个二叉树一定不同，若相同，再分别判断两个二叉树的左子树是否相同以及右子树是否相同。这是一个递归的过程，因此可以使用深度优先搜索，递归地判断两个二叉树是否相同。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">nullptr</span> &amp;&amp; q==<span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">nullptr</span>||q==<span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p-&gt;val!=q-&gt;val)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSameTree</span>(p-&gt;left, q-&gt;left) &amp;&amp; <span class="hljs-built_in">isSameTree</span>(p-&gt;right, q-&gt;right);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="翻转二叉树">翻转二叉树</h3>
<p>给你一棵二叉树的根节点 <code>root</code>
，翻转这棵二叉树，并返回其根节点。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：root = <span class="hljs-string">[4,2,7,1,3,6,9]</span><br>输出：<span class="hljs-string">[4,7,2,9,6,3,1]</span><br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>可以发现想要翻转它，其实就把每一个节点的左右孩子交换一下就可以了。<strong>注意只要把每一个节点的左右孩子翻转一下，就可以达到整体翻转的效果</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-built_in">swap</span>(root-&gt;left, root-&gt;right);<br>        <span class="hljs-built_in">invertTree</span>(root-&gt;left);<br>        <span class="hljs-built_in">invertTree</span>(root-&gt;right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="二叉树的中序遍历">二叉树的中序遍历</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/?envType=study-plan-v2&amp;envId=top-100-liked">https://leetcode.cn/problems/binary-tree-inorder-traversal/description/?envType=study-plan-v2&amp;envId=top-100-liked</a></p>
<p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的
<strong>中序</strong> 遍历</em> 。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,null,2,3]</span><br>输出：<span class="hljs-comment">[1,3,2]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1]</span><br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>用递归分别对二叉树的左右子树和根结点进行遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt;&amp; res)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">inorder</span>(root-&gt;left, res);<br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">inorder</span>(root-&gt;right,res);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt;res;<br>        <span class="hljs-built_in">inorder</span>(root, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="二叉树的最大深度">二叉树的最大深度</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/?envType=study-plan-v2&amp;envId=top-100-liked">https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/?envType=study-plan-v2&amp;envId=top-100-liked</a></p>
<p>给定一个二叉树 <code>root</code> ，返回其最大深度。</p>
<p>二叉树的 <strong>最大深度</strong>
是指从根节点到最远叶子节点的最长路径上的节点数。</p>
<p>思路：</p>
<p>利用递归和深度优先搜索来求解</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxDepth</span>(root-&gt;left), <span class="hljs-built_in">maxDepth</span>(root-&gt;right))+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="构建二叉搜索树并中序遍历">构建二叉搜索树并中序遍历</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span>&#123;<br>  <span class="hljs-type">int</span> val;<br>  TreeNode* left;<br>  TreeNode* right;<br>  <span class="hljs-built_in">TreeNode</span>(): <span class="hljs-built_in">val</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>  <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> val): <span class="hljs-built_in">val</span>(val), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>)()<br>&#125;;<br><br><span class="hljs-function">TreeNode* <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; nums)</span></span>&#123;<br>  TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[<span class="hljs-number">0</span>]);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>    TreeNode* n = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[i]);<br>    TreeNode* cur = root;<br>    <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)&#123;<br>      <span class="hljs-keyword">if</span>(nums[i]&lt;cur-&gt;val)&#123;<br>        <span class="hljs-keyword">if</span>(cur-&gt;left==<span class="hljs-literal">nullptr</span>)&#123;cur-&gt;left = n; <span class="hljs-keyword">break</span>;&#125;<br>        <span class="hljs-keyword">else</span>(cur = cur-&gt;left;)<br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(cur-&gt;right==<span class="hljs-literal">nullptr</span>)&#123;cur-&gt;right = n; <span class="hljs-keyword">break</span>;&#125;<br>        <span class="hljs-keyword">else</span>(cur = cur-&gt;right;)<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-built_in">inorder</span>(root-&gt;left);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,root-&gt;val);<br>  <span class="hljs-built_in">inorder</span>(root-&gt;right);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  vector&lt;<span class="hljs-type">int</span>&gt; nums=(&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;);<br>  TreeNode* st = <span class="hljs-built_in">search</span>(nums);<br>  <span class="hljs-built_in">inorder</span>(root);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="验证二叉搜索树">验证二叉搜索树</h3>
<p>思路：对这个树进行中序遍历放进一个数组中如果是从大到小的顺序，那么就认为是二叉搜索树</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; nums;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">inorder</span>(root-&gt;left);<br>        nums.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">inorder</span>(root-&gt;right);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">inorder</span>(root);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &lt;= nums[i - <span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="二叉搜索树中第k小的元素">二叉搜索树中第K小的元素</h3>
<p>思路：一样的思路，将二叉搜索树进行存储进一个一维的数组中，然后输出第k-1个元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; nums;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">inorder</span>(root-&gt;left);<br>        nums.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">inorder</span>(root-&gt;right);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">inorder</span>(root);<br>        <span class="hljs-keyword">return</span> nums[k<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="从前序和中序遍历构造二叉树">从前序和中序遍历构造二叉树</h3>
<p>本质上就是利用中序找到每个子串的内容</p>
<p>利用前序放入对应的元素，每次都从中取出一个第一个放进结果序列中</p>
<p>对于 <strong>后序列+中序</strong>的思路也是一样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">//内部实现</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, <span class="hljs-type">int</span> ps, <span class="hljs-type">int</span> pe, <span class="hljs-type">int</span> is, <span class="hljs-type">int</span> ie)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(ps &gt;= pe || is &gt;= ie)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>      <span class="hljs-comment">//找到第一个元素就是前序遍历的第一个元素</span><br>        TreeNode* r = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[ps]);<br>       <span class="hljs-comment">//find inorder partition</span><br>      <span class="hljs-comment">//找到中序遍历中的处于位置中间的那个元素</span><br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">for</span>(i = is; i &lt; ie; i++)&#123;<br>            <span class="hljs-keyword">if</span>(inorder[i] == preorder[ps])&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        r-&gt;left = <span class="hljs-built_in">build</span>(preorder, inorder, ps + <span class="hljs-number">1</span>, ps + <span class="hljs-number">1</span> + (i - is), is, i);<br>        r-&gt;right = <span class="hljs-built_in">build</span>(preorder, inorder, ps + <span class="hljs-number">1</span> + i - is, pe, i + <span class="hljs-number">1</span>, ie);<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>  <span class="hljs-comment">//最外层的调用</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(preorder, inorder, <span class="hljs-number">0</span>, preorder.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>, inorder.<span class="hljs-built_in">size</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="深搜回溯">深搜回溯</h1>
<p><strong>深度优先搜索的三部曲：</strong></p>
<ol type="1">
<li>确定搜索函数的返回值以及搜索函数的参数分别是什么</li>
<li>确定每次找到叶子结点的终止条件</li>
<li>确定for单层搜索的逻辑，包含push,backtracking,pop</li>
</ol>
<p>别忘了最开始的初始化步骤</p>
<h3 id="组合问题">组合问题</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/description/">https://leetcode.cn/problems/combinations/description/</a></p>
<p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围
<code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p>
<p>你可以按 <strong>任何顺序</strong> 返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：n = 4, k = 2<br>输出：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,4]</span>,</span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">1</span>, k = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure>
<p>思路，使用深度优先搜索算法进行处理</p>
<ul>
<li>首先要区分private和public这两个部分分别做的内容，private主要就是写出回溯的函数主体并且可能需要的数据结构</li>
<li>public中就对函数进行跳用以及数据结构的使用</li>
<li>第一步就是确定函数的类型和返回，这里用了一个 <code>startindex</code>
用来存储下一次进行选择的位置点这样能够避免重复</li>
<li>同时函数的返回类型是二位的向量结构</li>
<li>同时定义终止条件和单层循环的内容</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt;path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> startindex)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>()==k)&#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startindex;i&lt;=n;i++)&#123;<br>            path.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">backtracking</span>(n,k,i+<span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)&#123;<br>        <span class="hljs-built_in">backtracking</span>(n,k,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="组合问题iii">组合问题III</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iii/submissions/496823507/">https://leetcode.cn/problems/combination-sum-iii/submissions/496823507/</a></p>
<p>找出所有相加之和为 <code>n</code> 的 <code>k</code>
个数的组合，且满足下列条件：</p>
<ul>
<li>只使用数字1到9</li>
<li>每个数字 <strong>最多使用一次</strong></li>
</ul>
<p>返回 <em>所有可能的有效组合的列表</em>
。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p>
<p><strong>示例:</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: k = <span class="hljs-number">3</span>, n = <span class="hljs-number">7</span><br>输出: <span class="hljs-string">[[1,2,4]]</span><br>解释:<br><span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">4</span> = <span class="hljs-number">7</span><br>没有其他符合的组合了。<br></code></pre></td></tr></table></figure>
<p>思路：简单的深度优先搜索，但需要注意的是可以适当采用<strong>减枝操作和必要的时候添加sum变量进行记录</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtacking</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n,<span class="hljs-type">int</span> startindex, <span class="hljs-type">int</span> sum)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>()==k)&#123;<br>            <span class="hljs-keyword">if</span>(sum == n) result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i= startindex;i&lt;=<span class="hljs-number">9</span>;i++)&#123;<br>            sum+=i;<br>            path.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">backtacking</span>(k,n,i+<span class="hljs-number">1</span>,sum);<br>            sum-=i;<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum3</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-built_in">backtacking</span>(k,n,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>为了优化可以做一个剪枝操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (sum &gt; targetSum) &#123; <span class="hljs-comment">// 剪枝操作</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="电话号码组合问题">电话号码组合问题</h3>
<p>给定一个仅包含数字 <code>2-9</code>
的字符串，返回所有它能表示的字母组合。答案可以按
<strong>任意顺序</strong> 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1
不对应任何字母。</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240119211247536.png" srcset="/img/loading.gif" lazyload alt="电话号码的按键" style="zoom:50%;" /></p>
<p><strong>示例 ：</strong></p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入：<span class="hljs-keyword">digits</span> = <span class="hljs-string">&quot;23&quot;</span><br>输出：[<span class="hljs-string">&quot;ad&quot;</span>,<span class="hljs-string">&quot;ae&quot;</span>,<span class="hljs-string">&quot;af&quot;</span>,<span class="hljs-string">&quot;bd&quot;</span>,<span class="hljs-string">&quot;be&quot;</span>,<span class="hljs-string">&quot;bf&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>,<span class="hljs-string">&quot;ce&quot;</span>,<span class="hljs-string">&quot;cf&quot;</span>]<br></code></pre></td></tr></table></figure>
<p>这道题需要注意的地方是，首先第一步做好map字符的映射</p>
<p>第二步最关键是要写清楚回溯函数的参数可能包含index，就是第几位置的字符，同时需要区分backtracking函数的for循环的内容是相当于横向的遍历，而函数体内部的实现是纵向的遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">const</span> string letterMap[<span class="hljs-number">10</span>] = &#123;<br>        <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// 0</span><br>        <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// 1</span><br>        <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-comment">// 2</span><br>        <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-comment">// 3</span><br>        <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-comment">// 4</span><br>        <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-comment">// 5</span><br>        <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-comment">// 6</span><br>        <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-comment">// 7</span><br>        <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-comment">// 8</span><br>        <span class="hljs-string">&quot;wxyz&quot;</span>, <span class="hljs-comment">// 9</span><br>    &#125;;<br>    vector&lt;string&gt; result;<br>    string s;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">const</span> string digits,<span class="hljs-type">int</span> index, string s)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(digits.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(index==digits.<span class="hljs-built_in">size</span>())&#123;<br>            result.<span class="hljs-built_in">push_back</span>(s);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> digit = digits[index]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>        string letters = letterMap[digit];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i= <span class="hljs-number">0</span>;i&lt;letters.<span class="hljs-built_in">size</span>();i++)&#123;<br>            s.<span class="hljs-built_in">push_back</span>(letters[i]);<br>            <span class="hljs-built_in">backtracking</span>(digits, index+<span class="hljs-number">1</span>, s);<br>            s.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>&#123;<br>        <span class="hljs-built_in">backtracking</span>(digits,<span class="hljs-number">0</span>,<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="组合总和">组合总和</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/">https://leetcode.cn/problems/combination-sum/</a></p>
<p>给你一个 <strong>无重复元素</strong> 的整数数组
<code>candidates</code> 和一个目标整数 <code>target</code> ，找出
<code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的
所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按
<strong>任意顺序</strong> 返回这些组合。</p>
<p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以
<strong>无限制重复被选取</strong>
。如果至少一个数字的被选数量不同，则两种组合是不同的。</p>
<p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于
<code>150</code> 个。</p>
<p><strong>示例 ：</strong></p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：candidates = [2,3,6,7], target = 7<br>输出：[[2,2,3],[7]]<br>解释：<br>2 和<span class="hljs-number"> 3 </span>可以形成一组候选，2 +<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 7 </span>。注意<span class="hljs-number"> 2 </span>可以使用多次。<br>7 也是一个候选，<span class="hljs-number"> 7 </span>=<span class="hljs-number"> 7 </span>。<br>仅有这两种组合。<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>题目最关键的点在于能重复使用元素但是不能<strong>重复元素的组合不能被重复输出</strong></p>
<p>因此需要调整startindex的开始的位置是在<code>backtracking(candidates,target,sum,i);</code>注意，这个时候从i开始保证还能用到自己的元素重复使用，还有<strong>最重要的
<code>sort(candidates.begin(), candidates.end()); // 需要排序</code></strong></p>
<p>排序之后能够很好的进行剪枝，将一些加了之后元素大于目标的删掉直接跳过</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startindex)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(sum==target)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=startindex;i&lt;candidates.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(sum&gt;target)&#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            sum+=candidates[i];<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            <span class="hljs-built_in">backtracking</span>(candidates,target,sum,i);<br>            sum-=candidates[i];<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 需要排序</span><br>        <span class="hljs-built_in">backtracking</span>(candidates, target, <span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="组合总和ii">组合总和II</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-ii/description/">https://leetcode.cn/problems/combination-sum-ii/description/</a></p>
<p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数
<code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为
<code>target</code> 的组合。</p>
<p><code>candidates</code>
中的每个数字在每个组合中<strong>只能使用</strong> <strong>一次</strong>
。</p>
<p><strong>注意：</strong>解集不能包含重复的组合。</p>
<p><strong>示例 :</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: candidates = <span class="hljs-comment">[10,1,2,7,6,1,5]</span>, target = 8,<br>输出:<br><span class="hljs-comment">[</span><br><span class="hljs-comment"><span class="hljs-comment">[1,1,6]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[1,2,5]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[1,7]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[2,6]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>这个地方最大的困难在于每个数字在每个组合中只能使用一次，同时集合中的元素存在重复的元素，那么这个时候有一个问题是如何才能<strong>对元素进行去重处理</strong>呢，就是让每个元素只能被使用一次</p>
<p>去重的操作就在于
<code>vector&lt;bool&gt; used(candidates.size(),false);         sort(candidates.begin(), candidates.end());</code></p>
<p>首先需要在
<code>backtracking</code>中定一个continue，这个地方是为了筛选不是重复的部分，那么如何区分开是否是同一个数组中重复的元素而不是重复利用的元素呢？</p>
<ul>
<li><code>i&gt;0&amp;&amp;candidates[i]==candidates[i-1]</code>这个地方表明了对元素相邻之间进行比较</li>
<li><code>used[i-1]==false</code>如果这个地方是false，那么说明这个元素是同一层的元素(同一个数组中的元素)</li>
<li>注意
<code>i&lt;candidates.size()&amp;&amp;sum + candidates[i] &lt;= target</code>为了避免出现超出时间限制的情况</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startindex, vector&lt;<span class="hljs-type">bool</span>&gt;used)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(sum==target)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i= startindex;i&lt;candidates.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;candidates[i]==candidates[i<span class="hljs-number">-1</span>]&amp;&amp;used[i<span class="hljs-number">-1</span>]==<span class="hljs-literal">false</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            sum+=candidates[i];<br>            used[i]=<span class="hljs-literal">true</span>;<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            <span class="hljs-built_in">backtracking</span>(candidates, target, sum, i+<span class="hljs-number">1</span>, used);<br>            used[i]=<span class="hljs-literal">false</span>;<br>            path.<span class="hljs-built_in">pop_back</span>();<br>            sum-=candidates[i];<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum2</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(candidates.size(),<span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">backtracking</span>(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, used);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="分割回文串">分割回文串</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-partitioning/description/">https://leetcode.cn/problems/palindrome-partitioning/description/</a></p>
<p>给你一个字符串 <code>s</code>，请你将 <code>s</code>
分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回
<code>s</code> 所有可能的分割方案。</p>
<p><strong>回文串</strong> 是正着读和反着读都一样的字符串。</p>
<p><strong>示例：</strong></p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;aab&quot;</span><br>输出：[[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>],[<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>]]<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<ul>
<li>首先给出回文字符的判断方法：首尾指针来回比较</li>
<li>回溯算法中最关键的点在于<code>startindex</code>的使用，利用这个来移动
<code>s.substr(startindex, i-startindex+1)</code>来截取并筛选出相应的字符串的值进行回文比较</li>
<li>回溯的终止条件是
<code>startindex&gt;=s.size()</code>如果超出了范围那么久说明到终点了</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; res;<br>    vector&lt;string&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ishuiwen</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start,j = end;i&lt;j;i++,j--)&#123;<br>            <span class="hljs-keyword">if</span>(s[i]!=s[j])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> startindex)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(startindex&gt;=s.<span class="hljs-built_in">size</span>())&#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=startindex;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">ishuiwen</span>(s,startindex,i))&#123;<br>                string str = s.<span class="hljs-built_in">substr</span>(startindex, i-startindex+<span class="hljs-number">1</span>);<br>                path.<span class="hljs-built_in">push_back</span>(str);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-built_in">backtracking</span>(s,i+<span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) &#123;<br>        <span class="hljs-built_in">backtracking</span>(s,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="复原ip地址">复原IP地址</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/restore-ip-addresses/description/">https://leetcode.cn/problems/restore-ip-addresses/description/</a></p>
<p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于
<code>0</code> 到 <code>255</code> 之间组成，且不能含有前导
<code>0</code>），整数之间用 <code>'.'</code> 分隔。</p>
<ul>
<li>例如：<code>"0.1.2.201"</code> 和<code>"192.168.1.1"</code> 是
<strong>有效</strong> IP 地址，但是
<code>"0.011.255.245"</code>、<code>"192.168.1.312"</code> 和
<code>"192.168@1.1"</code> 是 <strong>无效</strong> IP 地址。</li>
</ul>
<p>给定一个只包含数字的字符串 <code>s</code> ，用以表示一个 IP
地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在
<code>s</code> 中插入 <code>'.'</code> 来形成。你 <strong>不能</strong>
重新排序或删除 <code>s</code> 中的任何数字。你可以按
<strong>任何</strong> 顺序返回答案。</p>
<p><strong>示例 ：</strong></p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;25525511135&quot;</span><br>输出：[<span class="hljs-string">&quot;255.255.11.135&quot;</span>,<span class="hljs-string">&quot;255.255.111.35&quot;</span>]<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<ul>
<li>回溯三部曲第一步：如何确定函数的类型以及参数呢？首先参数肯定包含了s、开始的位置(因为要一直往后移动并选择)、以及一个标记用于是否已经有三个点</li>
<li>写好判断是否合法的函数，这里比较多的陷阱需要注意</li>
<li>注意，当放进去3个点之后别忘了判断最后一位是否满足合法性的要求，容易忽略最后一位的情况</li>
<li>注意字符串的插入 <code>s.inset(n,'.')</code> 和删除
<code>s.erase(n)</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; res;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isvalid</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(start&gt;end)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s[start]==<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;start!=end)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;=end;i++)&#123;<br>            <span class="hljs-keyword">if</span> (s[i] &gt; <span class="hljs-string">&#x27;9&#x27;</span> || s[i] &lt; <span class="hljs-string">&#x27;0&#x27;</span>) &#123; <span class="hljs-comment">// 遇到非数字字符不合法</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            num=num*<span class="hljs-number">10</span>+(s[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>            <span class="hljs-keyword">if</span>(num&gt;<span class="hljs-number">255</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> startindex, <span class="hljs-type">int</span> pointnum)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(pointnum==<span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isvalid</span>(s, startindex, s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)) &#123;<br>                res.<span class="hljs-built_in">push_back</span>(s);<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=startindex;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isvalid</span>(s,startindex,i))&#123;<br>                s.<span class="hljs-built_in">insert</span>(s.<span class="hljs-built_in">begin</span>()+i+<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;.&#x27;</span>);<br>                pointnum++;<br>                <span class="hljs-built_in">backtracking</span>(s,i+<span class="hljs-number">2</span>,pointnum);<br>                pointnum--;<br>                s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>()+i+<span class="hljs-number">1</span>);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-built_in">backtracking</span>(s,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="子集">子集</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/description/">https://leetcode.cn/problems/subsets/description/</a></p>
<p>给你一个整数数组 <code>nums</code> ，数组中的元素
<strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。你可以按
<strong>任意顺序</strong> 返回解集。</p>
<p><strong>示例：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[]</span>,<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[2]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[1,2,3]</span>]</span><br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>这道题比较简单，就是简单的遍历就可以了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> startindex)</span></span>&#123;<br>        res.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=startindex;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtracking</span>(nums,i+<span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">backtracking</span>(nums,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="子集ii">子集II</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets-ii/description/">https://leetcode.cn/problems/subsets-ii/description/</a></p>
<p>给你一个整数数组 <code>nums</code>
，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按
<strong>任意顺序</strong> 排列。</p>
<p><strong>示例：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,2]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[]</span>,<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[1,2,2]</span>,<span class="hljs-comment">[2]</span>,<span class="hljs-comment">[2,2]</span>]</span><br></code></pre></td></tr></table></figure>
<p>注意：</p>
<p>凡是涉及到去重的操作，都需要优先进行排序操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; nums, <span class="hljs-type">int</span> startindex, vector&lt;<span class="hljs-type">bool</span>&gt; used)</span></span>&#123;<br>        res.<span class="hljs-built_in">push_back</span>(path);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=startindex;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i]==nums[i<span class="hljs-number">-1</span>]&amp;&amp;used[i<span class="hljs-number">-1</span>]==<span class="hljs-literal">false</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            used[i]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">backtracking</span>(nums,i+<span class="hljs-number">1</span>,used);<br>            used[i]=<span class="hljs-literal">false</span>;<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsetsWithDup</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(nums.size(),<span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 去重需要排序</span><br>        <span class="hljs-built_in">backtracking</span>(nums,<span class="hljs-number">0</span>,used);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="非递减子序列">非递减子序列</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-decreasing-subsequences/description/">https://leetcode.cn/problems/non-decreasing-subsequences/description/</a></p>
<p>给你一个整数数组 <code>nums</code>
，找出并返回所有该数组中不同的递增子序列，递增子序列中
<strong>至少有两个元素</strong> 。你可以按 <strong>任意顺序</strong>
返回答案。数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[4,6,7,7]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[4,6]</span>,<span class="hljs-comment">[4,6,7]</span>,<span class="hljs-comment">[4,6,7,7]</span>,<span class="hljs-comment">[4,7]</span>,<span class="hljs-comment">[4,7,7]</span>,<span class="hljs-comment">[6,7]</span>,<span class="hljs-comment">[6,7,7]</span>,<span class="hljs-comment">[7,7]</span>]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[4,4]]</span><br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>首先这道题不需要去重同时也不需要提前进行排序</p>
<p>但是需要对同一层的元素进行去重操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> startindex)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>        &#125;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; uset;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =startindex;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span> ((!path.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &lt; path.<span class="hljs-built_in">back</span>())<br>                    || uset.<span class="hljs-built_in">find</span>(nums[i]) != uset.<span class="hljs-built_in">end</span>()) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            uset.<span class="hljs-built_in">insert</span>(nums[i]);<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtracking</span>(nums,i+<span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">findSubsequences</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">backtracking</span>(nums,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="全排列">全排列</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/description/">https://leetcode.cn/problems/permutations/description/</a></p>
<p>给定一个不含重复数字的数组 <code>nums</code> ，返回其
<em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong>
返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[0,1],[1,0]]</span><br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>要求解全排列，因此回溯退出的条件是当<strong>path的长度和nums的长度一样</strong>的时候就达到了退出的条件</p>
<p>因为这道题<strong>没有重复</strong>的元素，求解全排列需要每次都从0开始选择，因此难点在于<strong>如何标记出已经选择过</strong>的元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>()==nums.<span class="hljs-built_in">size</span>())&#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(used[i]==<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            used[i]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">backtracking</span>(nums,used);<br>            used[i]=<span class="hljs-literal">false</span>;<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(nums.size(),<span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">backtracking</span>(nums,used);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="全排列ii">全排列II</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations-ii/">https://leetcode.cn/problems/permutations-ii/</a></p>
<p>给定一个可包含重复数字的序列 <code>nums</code>
，<strong><em>按任意顺序</em></strong> 返回所有不重复的全排列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1,2]</span><br>输出：<br><span class="hljs-comment">[<span class="hljs-comment">[1,1,2]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[1,2,1]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[2,1,1]</span>]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>首先这个全排列有重复的元素，因此需要有去重的操作，既然涉及到去重那需要重新排序，同时需要跳过重复的元素</p>
<p>第二步，既然是全排列，那么需要标记重复选择的元素并选择跳过</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>()==nums.<span class="hljs-built_in">size</span>())&#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i]==nums[i<span class="hljs-number">-1</span>]&amp;&amp;used[i<span class="hljs-number">-1</span>]==<span class="hljs-literal">false</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(used[i]==<span class="hljs-literal">false</span>)&#123;<br>                used[i]=<span class="hljs-literal">true</span>;<br>                path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                <span class="hljs-built_in">backtracking</span>(nums, used);<br>                path.<span class="hljs-built_in">pop_back</span>();<br>                used[i]=<span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permuteUnique</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(nums.size(),<span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">backtracking</span>(nums,used);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="重新安排行程">重新安排行程</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/reconstruct-itinerary/description/">https://leetcode.cn/problems/reconstruct-itinerary/description/</a></p>
<p>给你一份航线列表 <code>tickets</code> ，其中
<code>tickets[i] = [fromi, toi]</code>
表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。所有这些机票都属于一个从
<code>JFK</code>（肯尼迪国际机场）出发的先生，所以该行程必须从
<code>JFK</code>
开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。</p>
<ul>
<li>例如，行程 <code>["JFK", "LGA"]</code> 与
<code>["JFK", "LGB"]</code> 相比就更小，排序更靠前。</li>
</ul>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240122123926323.png" srcset="/img/loading.gif" lazyload alt="安排行程" style="zoom: 67%;" /></p>
<p>思路：</p>
<p>【困难】</p>
<ul>
<li><p>首先第一步：确定终止条件，遇到的机场个数，如果达到了（航班数量+1）</p></li>
<li><p>记录航班的数量，使用<code>unordered_map&lt;string, map&lt;string, int&gt;&gt; targets;</code>
来记录航班的映射关系，我定义为全局变量。</p>
<p>当然把参数放进函数里传进去也是可以的，我是尽量控制函数里参数的长度。参数里还需要ticketNum，表示有多少个航班</p></li>
<li><p>回溯的过程中，如何遍历一个机场所对应的所有机场呢？</p>
<p>这里刚刚说过，在选择映射函数的时候，不能选择<code>unordered_map&lt;string, multiset&lt;string&gt;&gt; targets</code>，
因为一旦有元素增删multiset的迭代器就会失效，当然可能有牛逼的容器删除元素迭代器不会失效，这里就不在讨论了。</p>
<p><strong>可以说本题既要找到一个对数据进行排序的容器，而且还要容易增删元素，迭代器还不能失效</strong>。</p>
<p>所以我选择了<code>unordered_map&lt;string, map&lt;string, int&gt;&gt; targets</code>
来做机场之间的映射</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; res;<br>    unordered_map&lt;string, map&lt;string, <span class="hljs-type">int</span>&gt;&gt; targets;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> ticketnum, vector&lt;string&gt;&amp; res)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>()==ticketnum+<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(pair&lt;<span class="hljs-type">const</span> string, <span class="hljs-type">int</span>&gt;&amp; target: targets[res[res.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>]])&#123;<br>            <span class="hljs-keyword">if</span>(target.second&gt;<span class="hljs-number">0</span>)&#123;<br>                res.<span class="hljs-built_in">push_back</span>(target.first);<br>                target.second--;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">backtracking</span>(ticketnum, res)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                res.<span class="hljs-built_in">pop_back</span>();<br>                target.second++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findItinerary</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> vector&lt;string&gt;&amp; vec: tickets)&#123;<br>            targets[vec[<span class="hljs-number">0</span>]][vec[<span class="hljs-number">1</span>]]++;<br>        &#125;<br>        res.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;JFK&quot;</span>);<br>        <span class="hljs-built_in">backtracking</span>(tickets.<span class="hljs-built_in">size</span>(), res);<br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="n皇后">N皇后</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-queens/description/">https://leetcode.cn/problems/n-queens/description/</a></p>
<p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code>
个皇后放置在 <code>n×n</code>
的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n
皇后问题</strong> 的解决方案。</p>
<p>每一种解法包含一个不同的 <strong>n 皇后问题</strong>
的棋子放置方案，该方案中 <code>'Q'</code> 和 <code>'.'</code>
分别代表了皇后和空位。</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：n = <span class="hljs-number">4</span><br>输出：[[<span class="hljs-string">&quot;.Q..&quot;</span>,<span class="hljs-string">&quot;...Q&quot;</span>,<span class="hljs-string">&quot;Q...&quot;</span>,<span class="hljs-string">&quot;..Q.&quot;</span>],[<span class="hljs-string">&quot;..Q.&quot;</span>,<span class="hljs-string">&quot;Q...&quot;</span>,<span class="hljs-string">&quot;...Q&quot;</span>,<span class="hljs-string">&quot;.Q..&quot;</span>]]<br>解释：如上图所示，<span class="hljs-number">4</span> 皇后问题存在两个不同的解法。<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>这道题关键在于<strong>用好数据结构</strong>和写好<strong>合法性的判断</strong></p>
<p>关键在于定义好<code>chessboard</code>第二步是把合法性位置判断写好</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; res;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isvalid</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, vector&lt;string&gt;&amp; chessboard,<span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-comment">//检查列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(chessboard[row][j]==<span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//检查行</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(chessboard[i][col]==<span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//检查对角线45</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>; i &gt;=<span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i--, j--) &#123;<br>        <span class="hljs-keyword">if</span> (chessboard[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//检查对角线135</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = row<span class="hljs-number">-1</span>,j=col+<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>&amp;&amp;j&lt;n;i--,j++)&#123;<br>            <span class="hljs-keyword">if</span>(chessboard[i][j]==<span class="hljs-string">&#x27;Q&#x27;</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;string&gt;&amp; chessboard, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(row==n)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(chessboard);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> col = <span class="hljs-number">0</span>;col&lt;n;col++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isvalid</span>(row,col,chessboard,n))&#123;<br>                chessboard[row][col]=<span class="hljs-string">&#x27;Q&#x27;</span>;<br>                <span class="hljs-built_in">backtracking</span>(chessboard,row+<span class="hljs-number">1</span>,n);<br>                chessboard[row][col]=<span class="hljs-string">&#x27;.&#x27;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">chessboard</span><span class="hljs-params">(n, std::string(n, <span class="hljs-string">&#x27;.&#x27;</span>))</span></span>;<br>        <span class="hljs-built_in">backtracking</span>(chessboard,<span class="hljs-number">0</span>,n);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="解数独">解数独</h3>
<p>编写一个程序，通过填充空格来解决数独问题。</p>
<p>数独的解法需 <strong>遵循如下规则</strong>：</p>
<ol type="1">
<li>数字 <code>1-9</code> 在每一行只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一列只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code>
宫内只能出现一次。（请参考示例图）</li>
</ol>
<p>数独部分空格内已填入了数字，空白格用 <code>'.'</code> 表示。</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>],[<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],[<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>]]<br>输出：[[<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>],[<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>],[<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>],[<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],[<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>],[<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>],[<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>],[<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>]]<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>深度优先搜索，加上<strong>合法性判断</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isvalid</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">char</span> a)</span></span>&#123;<br>        <span class="hljs-comment">//行遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">9</span>;j++)&#123;<br>            <span class="hljs-keyword">if</span>(board[row][j]==a) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//列遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(board[i][col]==a) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//方框内判断：关键找到起始的方框对角</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i= (row/<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>;i&lt;(row/<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>+<span class="hljs-number">3</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=(col/<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>; j&lt;(col/<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>+<span class="hljs-number">3</span>;j++)&#123;<br>                <span class="hljs-keyword">if</span>(board[i][j]==a) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;board.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(board[i][j]==<span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> a=<span class="hljs-string">&#x27;1&#x27;</span>;a&lt;=<span class="hljs-string">&#x27;9&#x27;</span>;a++)&#123;<br>                        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isvalid</span>(board,i,j,a))&#123;<br>                            board[i][j]=a;<br>                            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">backtracking</span>(board)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                            board[i][j]=<span class="hljs-string">&#x27;.&#x27;</span>;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-built_in">backtracking</span>(board);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="贪心算法">贪心算法</h1>
<h3 id="分发饼干">分发饼干</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/assign-cookies/description/">https://leetcode.cn/problems/assign-cookies/description/</a></p>
<p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子
<code>i</code>，都有一个胃口值
<code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干
<code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果
<code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code>
分配给孩子 <code>i</code>
，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<p><strong>示例 :</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: g = [1,2,3], s = [1,1]</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: </span><br>你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。<br>虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。<br>所以你应该输出1。<br></code></pre></td></tr></table></figure>
<p><strong>示例 :</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: g = [1,2], s = [1,2,3]</span><br><span class="hljs-section">输出: 2</span><br><span class="hljs-section">解释: </span><br>你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。<br>你拥有的饼干数量和尺寸都足以让所有孩子满足。<br>所以你应该输出2.<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p><strong>这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩</strong>。</p>
<p>可以尝试使用贪心策略，先将饼干数组和小孩数组排序。</p>
<p>然后从后向前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足小孩数量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; g, vector&lt;<span class="hljs-type">int</span>&gt;&amp; s)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(),s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(g.<span class="hljs-built_in">begin</span>(),g.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> index=s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> num= <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=g.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(index&gt;=<span class="hljs-number">0</span>&amp;&amp;s[index]&gt;=g[i])&#123;<br>                num++;<br>                index--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="最长回文串">最长回文串</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindrome/description/?envType=study-plan-v2&amp;envId=2024-spring-sprint-100">https://leetcode.cn/problems/longest-palindrome/description/?envType=study-plan-v2&amp;envId=2024-spring-sprint-100</a></p>
<p>给定一个包含大写字母和小写字母的字符串 <code>s</code> ，返回
*通过这些字母构造成的
<strong>最长的回文串</strong>的长度。在构造过程中，请注意
<strong>区分大小写</strong> 。比如 <code>"Aa"</code>
不能当做一个回文字符串。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入:s = &quot;abccccdd&quot;</span><br><span class="hljs-section">输出:7</span><br><span class="hljs-section">解释:</span><br>我们可以构造的最长的回文串是<span class="hljs-string">&quot;dccaccd&quot;</span>, 它的长度是 7。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir">输入<span class="hljs-symbol">:s</span> = <span class="hljs-string">&quot;a&quot;</span><br>输出<span class="hljs-symbol">:</span><span class="hljs-number">1</span><br>解释：可以构造的最长回文串是<span class="hljs-string">&quot;a&quot;</span>，它的长度是 <span class="hljs-number">1</span>。<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>这道题用贪心来解，需要输出的内容是一个回文字符串的最长的长度，那么首先用一个哈希map来记录下每个字符串出现的次数，然后对这个map进行遍历，每个元素都需要v/2*2，最多能加入这么多，如果某个元素的个数是奇数个，只需要判断当前长度是否为偶数，如果为偶数就能加入一个字符（放中间）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; count;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c:s)&#123;<br>            count[c]++;<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p: count)&#123;<br>            <span class="hljs-type">int</span> v = p.second;<br>            ans+= v/<span class="hljs-number">2</span>*<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(v%<span class="hljs-number">2</span>==<span class="hljs-number">1</span> &amp;&amp; ans%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="摆动序列">摆动序列</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/wiggle-subsequence/description/">https://leetcode.cn/problems/wiggle-subsequence/description/</a></p>
<p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为
<strong>摆动序列
。</strong>第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p>
<ul>
<li>例如， <code>[1, 7, 4, 9, 2, 5]</code> 是一个
<strong>摆动序列</strong> ，因为差值 <code>(6, -3, 5, -7, 3)</code>
是正负交替出现的。</li>
</ul>
<p>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 中作为
<strong>摆动序列</strong> 的 <strong>最长子序列的长度</strong></p>
<p><strong>示例 ：</strong></p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,7,4,9,2,5]<br>输出：6<br>解释：整个序列均为摆动序列，各元素之间的差值为 (6, <span class="hljs-string">-3</span>, 5, <span class="hljs-string">-7</span>, 3) <br></code></pre></td></tr></table></figure>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,17,5,10,13,15,10,5,16,8]<br>输出：7<br>解释：这个序列包含几个长度为 7 摆动序列。<br>其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, <span class="hljs-string">-7</span>, 3, <span class="hljs-string">-3</span>, 6, <span class="hljs-string">-8</span>) <br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p><strong>本题异常情况的本质，就是要考虑平坡</strong>，
平坡分两种，一个是 上下中间有平坡，一个是单调有平坡，如图</p>
<p>同时需要注意的是在判断条件语句的时候，<strong>不能简单的用判断相乘法小于0作为判断，因为存在平坡的情况</strong></p>
<figure>
<img
src="../../../../../Library/Application%20Support/typora-user-images/image-20240123150641735.png" srcset="/img/loading.gif" lazyload
alt="异常情况需要考虑" />
<figcaption aria-hidden="true">异常情况需要考虑</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()&lt;=<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>        &#125;<br>        <span class="hljs-type">int</span> num=<span class="hljs-number">1</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; differ;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            differ.<span class="hljs-built_in">push_back</span>(nums[i]-nums[i<span class="hljs-number">-1</span>]);<br>        &#125;<br>        <span class="hljs-type">int</span> preDiff=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;differ.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>((preDiff&lt;=<span class="hljs-number">0</span>&amp;&amp; differ[i]&gt;<span class="hljs-number">0</span>)||(differ[i]&lt;<span class="hljs-number">0</span>&amp;&amp;preDiff&gt;=<span class="hljs-number">0</span>))&#123;<br>                num++;<br>                preDiff = differ[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="最大子数组和">最大子数组和</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/description/">https://leetcode.cn/problems/maximum-subarray/description/</a></p>
<p>给你一个整数数组 <code>nums</code>
，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>子数组</strong> 是数组中的一个连续部分。</p>
<p><strong>示例：</strong></p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]<br>输出：6<br>解释：连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6 。<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>这道题使用的是局部的最优贪心的思路，如果遇到让总的值小于0，那么久立刻让总的值变成0，那么下一轮就从头开始记了，同时max会每一轮进行判断是否有比当前的最大值大，如果有那么就进行替换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = INT32_MIN;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            count+=nums[i];<br>            <span class="hljs-keyword">if</span>(count&gt;res)&#123;<br>                res = count;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(count&lt;=<span class="hljs-number">0</span>) count = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="买卖股票的最佳时机">买卖股票的最佳时机</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/</a></p>
<p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code>
表示某支股票第 <code>i</code>
天的价格。在每一天，你可以决定是否购买和/或出售股票。你在任何时候
<strong>最多</strong> 只能持有 <strong>一股</strong>
股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p>
<p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：prices = [7,1,5,3,6,4]<br>输出：7<br>解释：在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 3 </span>天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 =<span class="hljs-number"> 5 </span>-<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 4 </span>。<br>     随后，在第<span class="hljs-number"> 4 </span>天（股票价格 = 3）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 =<span class="hljs-number"> 6 </span>-<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 3 </span>。<br>     总利润为<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 7 </span>。<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p><strong>把利润分解为每天为单位的维度，而不是从 0 天到第 3
天整体去考虑！</strong></p>
<p>那么根据 prices
可以得到每天的利润序列：<code>(prices[i] - prices[i - 1]).....(prices[1] - prices[0])</code></p>
<p>相当于是每天的利润之差和0的比较，只选择为正的值，负数的情况直接忽略</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;prices.<span class="hljs-built_in">size</span>();i++)&#123;<br>            res+=<span class="hljs-built_in">max</span>(prices[i]-prices[i<span class="hljs-number">-1</span>],<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="动态规划">动态规划</h1>
<p>状态转移公式（递推公式）是很重要，但动规不仅仅只有递推公式。</p>
<p><strong>对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！</strong></p>
<ol type="1">
<li>确定dp数组（dp table）以及下标的含义</li>
<li>确定递推公式</li>
<li>dp数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ol>
<p><strong>注意：动态规划的问题一般只会输出最后的一个结果，不会输出比如中间的路径等相关的值</strong></p>
<h3 id="斐波那契数列">斐波那契数列</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/fibonacci-number/">https://leetcode.cn/problems/fibonacci-number/</a></p>
<p><strong>斐波那契数</strong> （通常用 <code>F(n)</code>
表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由
<code>0</code> 和 <code>1</code>
开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span> = <span class="hljs-number">0</span>，<span class="hljs-built_in">F</span>(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-title">F</span><span class="hljs-params">(n)</span></span> = <span class="hljs-built_in">F</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">F</span>(n - <span class="hljs-number">2</span>)，其中 n &gt; <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p>给定 <code>n</code> ，请计算 <code>F(n)</code> 。</p>
<p><strong>示例：</strong></p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl">输入：<span class="hljs-variable">n</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">1</span><br>解释：<span class="hljs-function"><span class="hljs-title">F</span>(<span class="hljs-number">2</span>) = <span class="hljs-title">F</span>(<span class="hljs-number">1</span>) + <span class="hljs-title">F</span>(<span class="hljs-number">0</span>) = <span class="hljs-number">1</span> + <span class="hljs-number">0</span> = <span class="hljs-number">1</span></span><br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>因为这道题给出了递推公式：<code>F(n) = F(n - 1) + F(n - 2)</code></p>
<p>动规五部曲：</p>
<p>这里我们要用一个一维dp数组来保存递归的结果</p>
<ol type="1">
<li><p>确定dp数组以及下标的含义：dp[i]的定义为：第i个数的斐波那契数值是dp[i]</p></li>
<li><p>确定递推公式<code>F(n) = F(n - 1) + F(n - 2)</code></p></li>
<li><p>dp数组如何初始化</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">dp[0] = 0;<br>dp[1] = 1;<br></code></pre></td></tr></table></figure></li>
<li><p>确定遍历顺序</p>
<p>从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i
- 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的</p></li>
<li><p>举例推导dp数组</p></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">dp</span>(n+<span class="hljs-number">1</span>);<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>            dp[i]=dp[i<span class="hljs-number">-1</span>]+dp[i<span class="hljs-number">-2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="爬楼梯">爬楼梯</h3>
<p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。每次你可以爬
<code>1</code> 或 <code>2</code>
个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 2<br>输出：2<br>解释：有两种方法可以爬到楼顶。<br>1.<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶<br>2.<span class="hljs-number"> 2 </span>阶<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>动态规划简单题，递推公式：<code>dp[i] = dp[i-2]+dp[i-1];</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>]=<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=n;i++)&#123;<br>            dp[i] = dp[i<span class="hljs-number">-2</span>]+dp[i<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="杨辉三角">杨辉三角</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/pascals-triangle/description/?envType=study-plan-v2&amp;envId=2024-spring-sprint-100">https://leetcode.cn/problems/pascals-triangle/description/?envType=study-plan-v2&amp;envId=2024-spring-sprint-100</a></p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240701204812907.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" /></p>
<p><strong>示例 1:</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: numRows = 5<br>输出: <span class="hljs-comment">[<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[1,1]</span>,<span class="hljs-comment">[1,2,1]</span>,<span class="hljs-comment">[1,3,3,1]</span>,<span class="hljs-comment">[1,4,6,4,1]</span>]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: numRows = <span class="hljs-number">1</span><br>输出: <span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>给出基础的条件为：[[1],[1,1]]</p>
<p>然后每行遍历的递归方程式为第i个有i-1个元素需要设置，元素设置的方法通过上一行来确定</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generate</span>(<span class="hljs-type">int</span> numRows) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(numRows==<span class="hljs-number">1</span>)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;<span class="hljs-number">1</span>&#125;);<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        res = &#123;&#123;<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-keyword">if</span>(numRows ==<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">2</span>;i&lt;numRows;i++)&#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; tmp_res = &#123;<span class="hljs-number">1</span>&#125;;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;i<span class="hljs-number">-1</span>;j++)&#123;<br>                <span class="hljs-type">int</span> ans = res[i<span class="hljs-number">-1</span>][j]+res[i<span class="hljs-number">-1</span>][j+<span class="hljs-number">1</span>];<br>                tmp_res.<span class="hljs-built_in">push_back</span>(ans);<br>            &#125;<br>            tmp_res.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>            res.<span class="hljs-built_in">push_back</span>(tmp_res);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="最小费用爬楼梯">最小费用爬楼梯</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-climbing-stairs/description/">https://leetcode.cn/problems/min-cost-climbing-stairs/description/</a></p>
<p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code>
是从楼梯第 <code>i</code>
个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。你可以选择从下标为
<code>0</code> 或下标为 <code>1</code>
的台阶开始爬楼梯。请你计算并返回达到楼梯顶部的最低花费。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：cost = [10,15,20]<br>输出：15<br>解释：你将从下标为<span class="hljs-number"> 1 </span>的台阶开始。<br>- 支付<span class="hljs-number"> 15 </span>，向上爬两个台阶，到达楼梯顶部。<br>总花费为<span class="hljs-number"> 15 </span>。<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>动态规划<strong>可以有两个途径得到dp[i]，一个是dp[i-1]
一个是dp[i-2]</strong>。</p>
<p>dp[i - 1] 跳到 dp[i] 需要花费
<code>dp[i - 1] + cost[i - 1]</code>。</p>
<p>dp[i - 2] 跳到 dp[i] 需要花费
<code>dp[i - 2] + cost[i - 2]</code>。</p>
<p>那么究竟是选从dp[i - 1]跳还是从dp[i - 2]跳呢？</p>
<p>一定是选最小的，所以<code>dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])</code>;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = cost.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>]= <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>            dp[i]=<span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>]+cost[i<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-2</span>]+cost[i<span class="hljs-number">-2</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="不同路径">不同路径</h3>
<p>一个机器人位于一个 <code>m x n</code> 网格的左上角
（起始点在下图中标记为 “Start”
）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为
“Finish” ）。问总共有多少条不同的路径？</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240128142408271.png" srcset="/img/loading.gif" lazyload alt="机器人路径问题" style="zoom:67%;" /></p>
<p>思路：</p>
<p>简单的动态规划问题，只需要保证每次迭代都从上面和左边进行叠加</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            dp[<span class="hljs-number">0</span>][i]=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;n;j++)&#123;<br>                dp[i][j]=dp[i<span class="hljs-number">-1</span>][j]+dp[i][j<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="不同路径ii">不同路径II</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths-ii/description/">https://leetcode.cn/problems/unique-paths-ii/description/</a></p>
<p>一个机器人位于一个 <code>m x n</code> 网格的左上角
（起始点在下图中标记为 “Start”
）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为
“Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用
<code>1</code> 和 <code>0</code> 来表示。</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240128143004648.png" srcset="/img/loading.gif" lazyload alt="障碍物的机器人路径" style="zoom: 50%;" /></p>
<p>思路：</p>
<p>和上一题的思路一样，都是需要遍历路径就行，但是这里加入了一个新的数组用来存储有障碍物的位置，因此需要额外进行标记
<code>&amp;&amp;obstacleGrid[i][0]==0</code>的信息，同时遇到障碍物就不改变对应的值，直接
<code>continue</code>就好</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">dp</span>(obstacleGrid.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;obstacleGrid.<span class="hljs-built_in">size</span>()&amp;&amp;obstacleGrid[i][<span class="hljs-number">0</span>]==<span class="hljs-number">0</span>;i++) dp[i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()&amp;&amp;obstacleGrid[<span class="hljs-number">0</span>][i]==<span class="hljs-number">0</span>;i++) dp[<span class="hljs-number">0</span>][i]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;obstacleGrid.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(obstacleGrid[i][j]==<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>                dp[i][j]=dp[i<span class="hljs-number">-1</span>][j]+dp[i][j<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[obstacleGrid.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>][obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="整数拆分">整数拆分</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/integer-break/description/">https://leetcode.cn/problems/integer-break/description/</a></p>
<p>给定一个正整数 <code>n</code> ，将其拆分为 <code>k</code> 个
<strong>正整数</strong> 的和（ <code>k &gt;= 2</code>
），并使这些整数的乘积最大化。返回 <em>你可以获得的最大乘积</em> 。</p>
<p><strong>示例 :</strong></p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: n = 2<br>输出: 1<br>解释:<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 1 </span>+ 1,<span class="hljs-number"> 1 </span>×<span class="hljs-number"> 1 </span>= 1。<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>给出递推公式一个是<code>j * (i - j)</code>
直接相乘。一个是<code>j * dp[i - j]</code>，相当于是拆分<code>(i - j)</code>，在遍历j的过程中其实都计算过了。那么从1遍历j，比较<code>(i - j) * j和dp[i - j] * j</code>
取最大的。递推公式：<code>dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j))</code>；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n ; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i / <span class="hljs-number">2</span>; j++) &#123;<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i], <span class="hljs-built_in">max</span>((i - j) * j, dp[i - j] * j));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h3 id="香槟塔问题">香槟塔问题</h3>
<p>我们把玻璃杯摆成金字塔的形状，其中 <strong>第一层</strong> 有
<code>1</code> 个玻璃杯， <strong>第二层</strong> 有 <code>2</code>
个，依次类推到第 100 层，每个玻璃杯 (250ml) 将盛有香槟。</p>
<p>从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上）</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240310153527352.png" srcset="/img/loading.gif" lazyload alt="香槟塔问题" style="zoom:50%;" /></p>
<figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">示例 1</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">输入</span><span class="hljs-punctuation">:</span> <span class="hljs-string">poured(倾倒香槟总杯数) = 1, query_glass(杯子的位置数) = 1, query_row(行数) = 1</span><br><span class="hljs-attribute">输出</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0.00000</span><br><span class="hljs-attribute">解释</span><span class="hljs-punctuation">:</span> <span class="hljs-string">我们在顶层（下标是（0，0））倒了一杯香槟后，没有溢出，因此所有在顶层以下的玻璃杯都是空的。</span><br><br><span class="hljs-attribute">示例 2</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">输入</span><span class="hljs-punctuation">:</span> <span class="hljs-string">poured(倾倒香槟总杯数) = 2, query_glass(杯子的位置数) = 1, query_row(行数) = 1</span><br><span class="hljs-attribute">输出</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0.50000</span><br><span class="hljs-attribute">解释</span><span class="hljs-punctuation">:</span> <span class="hljs-string">我们在顶层（下标是（0，0）倒了两杯香槟后，有一杯量的香槟将从顶层溢出，位于（1，0）的玻璃杯和（1，1）的玻璃杯平分了这一杯香槟，所以每个玻璃杯有一半的香槟。</span><br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>线性DP，令 <code>poured</code> 为
<code>k</code>，<code>query_row</code> 和 <code>query_glass</code>
分别为 <em>n</em> 和 <em>m</em></p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240310153733207.png" srcset="/img/loading.gif" lazyload alt="思路题解" style="zoom:50%;" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">champagneTower</span><span class="hljs-params">(<span class="hljs-type">int</span> poured, <span class="hljs-type">int</span> query_row, <span class="hljs-type">int</span> query_glass)</span> </span>&#123;<br>        <span class="hljs-type">double</span> dp[<span class="hljs-number">110</span>][<span class="hljs-number">110</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]= (<span class="hljs-type">double</span>) poured;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;=query_row;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;=i;j++)&#123;<br>                <span class="hljs-keyword">if</span>(dp[i][j]&gt;<span class="hljs-number">1</span>)&#123;<br>                    dp[i+<span class="hljs-number">1</span>][j]+=(dp[i][j]<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;<br>                    dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]+=(dp[i][j]<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;<br>                    dp[i][j] = <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[query_row][query_glass];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="最大正方形">最大正方形</h3>
<p>在一个由 <code>'0'</code> 和 <code>'1'</code>
组成的二维矩阵内，找到只包含 <code>'1'</code>
的最大正方形，并返回其面积。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240310155051578.png" srcset="/img/loading.gif" lazyload alt="image-20240310155051578" style="zoom:50%;" /></p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：matrix = [[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>]]<br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：matrix = [[<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>]]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>难点在于不是矩形而是正方形</p>
<p>动态规划的思路是分别去比较和左侧左上方格中的元素的比值选择出最大的</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240310155150041.png" srcset="/img/loading.gif" lazyload alt="动态规划思路" style="zoom:50%;" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximalSquare</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(matrix.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>||matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>        <span class="hljs-type">int</span> maxsize = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> rows = matrix.<span class="hljs-built_in">size</span>(), colums = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(rows, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(colums));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i= <span class="hljs-number">0</span>;i&lt;rows;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;colums;j++)&#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][j]==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>||j==<span class="hljs-number">0</span>)&#123;dp[i][j]=<span class="hljs-number">1</span>;&#125;<br>                    <span class="hljs-keyword">else</span>&#123;<br>                        dp[i][j] = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]),dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])+<span class="hljs-number">1</span>;<br>                    &#125;<br>                    maxsize = <span class="hljs-built_in">max</span>(maxsize, dp[i][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxsize* maxsize;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="戳气球">戳气球</h3>
<p>有 <code>n</code> 个气球，编号为<code>0</code> 到
<code>n - 1</code>，每个气球上都标有一个数字，这些数字存在数组
<code>nums</code> 中。</p>
<p>现在要求你戳破所有的气球。戳破第 <code>i</code> 个气球，你可以获得
<code>nums[i - 1] * nums[i] * nums[i + 1]</code> 枚硬币。 这里的
<code>i - 1</code> 和 <code>i + 1</code> 代表和 <code>i</code>
相邻的两个气球的序号。如果 <code>i - 1</code>或 <code>i + 1</code>
超出了数组的边界，那么就当它是一个数字为 <code>1</code> 的气球。</p>
<p>求所能获得硬币的最大数量。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">输入：nums = [3,1,5,8]<br>输出：167<br>解释：<br>nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []<br>coins =  3<span class="hljs-number">*1</span><span class="hljs-number">*5</span>    +   3<span class="hljs-number">*5</span><span class="hljs-number">*8</span>   +  1<span class="hljs-number">*3</span><span class="hljs-number">*8</span>  + 1<span class="hljs-number">*8</span><span class="hljs-number">*1</span> = 167<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>这道题是一个区间DP的题目，下面的解题思路</p>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/burst-balloons/solutions/337630/zhe-ge-cai-pu-zi-ji-zai-jia-ye-neng-zuo-guan-jian-/?envType=featured-list&amp;envId=2cktkvj%3FenvType%3Dfeatured-list&amp;envId=2cktkvj">https://leetcode.cn/problems/burst-balloons/solutions/337630/zhe-ge-cai-pu-zi-ji-zai-jia-ye-neng-zuo-guan-jian-/?envType=featured-list&amp;envId=2cktkvj%3FenvType%3Dfeatured-list&amp;envId=2cktkvj</a></p>
<p>关键点在于</p>
<p>DP的状态转移方程只和i和j位置的数字相关，分治的思想，分别划分为两个区间进行遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; rec;<br>    vector&lt;<span class="hljs-type">int</span>&gt; val;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(left&gt;=right<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(rec[left][right]!=<span class="hljs-number">-1</span>)&#123;<span class="hljs-keyword">return</span> rec[left][right];&#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=left+<span class="hljs-number">1</span>;i&lt;right;i++)&#123;<br>            <span class="hljs-type">int</span> sum = val[left]*val[i]* val[right];<br>            sum+=<span class="hljs-built_in">solve</span>(left,i)+<span class="hljs-built_in">solve</span>(i, right);<br>            rec[left][right] = <span class="hljs-built_in">max</span>(rec[left][right], sum);<br>        &#125;<br>        <span class="hljs-keyword">return</span> rec[left][right];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxCoins</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        n = nums.<span class="hljs-built_in">size</span>();<br>        val.<span class="hljs-built_in">resize</span>(n+<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            val[i] = nums[i<span class="hljs-number">-1</span>];<br>        &#125;<br>        val[<span class="hljs-number">0</span>] = val[n+<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        rec.<span class="hljs-built_in">resize</span>(n+<span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">2</span>, <span class="hljs-number">-1</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">solve</span>(<span class="hljs-number">0</span>, n+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="背包问题解题框架">背包问题解题框架</h3>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240129124938997.png" srcset="/img/loading.gif" lazyload
alt="背包问题的基本分类关系" />
<figcaption aria-hidden="true">背包问题的基本分类关系</figcaption>
</figure>
<h4 id="背包">0-1背包</h4>
<p><code>dp[j]</code>为
容量为<code>j</code>的背包所背的最大价值，那么如何推导<code>dp[j]</code>呢？<code>dp[j]</code>可以通过<code>dp[j - weight[i]]</code>推导出来，<code>dp[j - weight[i]]</code>表示容量为<code>j - weight[i]</code>的背包所背的最大价值。</p>
<p><code>dp[j - weight[i]] + value[i]</code> 表示 容量为 <code>j</code>
- 物品i重量 的背包 加上
物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）</p>
<p>此时dp[j]有两个选择，一个是取自己<code>dp[j]</code> 相当于
二维dp数组中的<code>dp[i-1][j]</code>，即不放物品i，一个是取<code>dp[j - weight[i]] + value[i]</code>，即放物品i，指定是取最大的，毕竟是求最大价值，</p>
<p><strong>递推公式：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br></code></pre></td></tr></table></figure>
<p><strong>初始化：</strong></p>
<p>全部初始化为0</p>
<p><strong>遍历顺序：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>整体的代码结构是</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_1_wei_bag_problem</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; weight = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>    vector&lt;<span class="hljs-type">int</span>&gt; value = &#123;<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br>    <span class="hljs-type">int</span> bagWeight = <span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(bagWeight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="完全背包问题">完全背包问题</h4>
<p>有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i]
。<strong>每件物品都有无限个（也就是可以放入背包多次）</strong>，求解将哪些物品装入背包里物品价值总和最大。</p>
<p><strong>完全背包和01背包问题唯一不同的地方就是，每种物品有无限件</strong>。</p>
<p>在代码层面的区别在于背包遍历的时候是从头开始到尾遍历，<code>int j = weight[i]; j &lt;= bagWeight; j++</code>，因为所有的背包内部都是无限的</p>
<p>1、先遍历物品再遍历背包</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_CompletePack</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; weight = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>    vector&lt;<span class="hljs-type">int</span>&gt; value = &#123;<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br>    <span class="hljs-type">int</span> bagWeight = <span class="hljs-number">4</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(bagWeight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = weight[i]; j &lt;= bagWeight; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>2、先遍历背包再遍历物品</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagWeight; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">if</span> (j - weight[i] &gt;= <span class="hljs-number">0</span>) dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="分割等和子集">分割等和子集</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/description/">https://leetcode.cn/problems/partition-equal-subset-sum/description/</a></p>
<p>给你一个<strong>只包含正整数</strong>的<strong>非空</strong> 数组
<code>nums</code>
。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等<strong>示例：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,5,11,5]</span><br>输出：true<br>解释：数组可以分割成 <span class="hljs-comment">[1, 5, 5]</span> 和 <span class="hljs-comment">[11]</span> <br></code></pre></td></tr></table></figure>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>]<br>输出：<span class="hljs-literal">false</span><br>解释：数组不能分割成两个元素和相等的子集。<br></code></pre></td></tr></table></figure>
<p>思路：因为这个地方只需要写出是否能够划分，而不是具体的划分结果，因此可以考虑利用动态规划的方法来进行写，可以利用背包法来进行求解，具体步骤：</p>
<ol type="1">
<li>首先判断数组的和是否为偶数，是的话那么背包的大小就是总和取一半，不是的话就直接返回false</li>
<li>0-1背包问题，大小是总和的一半，每个物品的价值是数的大小</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum =<span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">10001</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            sum+=nums[i];<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(sum%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> target = sum/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=target; j&gt;=nums[i];j--)&#123;<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j],dp[j-nums[i]]+nums[i]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(dp[target]==target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="最后一块石头的重量">最后一块石头的重量</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/last-stone-weight-ii/description/">https://leetcode.cn/problems/last-stone-weight-ii/description/</a></p>
<p>有一堆石头，用整数数组 <code>stones</code> 表示。其中
<code>stones[i]</code> 表示第 <code>i</code>
块石头的重量。每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为
<code>x</code> 和 <code>y</code>，且
<code>x &lt;= y</code>。那么粉碎的可能结果如下：</p>
<ul>
<li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li>
<li>如果 <code>x != y</code>，那么重量为 <code>x</code>
的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为
<code>y-x</code>。</li>
</ul>
<p>最后，<strong>最多只会剩下一块</strong> 石头。返回此石头
<strong>最小的可能重量</strong> 。如果没有石头剩下，就返回
<code>0</code>。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：stones = <span class="hljs-comment">[2,7,4,1,8,1]</span><br>输出：1<br>解释：<br>组合 2 和 4，得到 2，所以数组转化为 <span class="hljs-comment">[2,7,1,8,1]</span>，<br>组合 7 和 8，得到 1，所以数组转化为 <span class="hljs-comment">[2,1,1,1]</span>，<br>组合 2 和 1，得到 1，所以数组转化为 <span class="hljs-comment">[1,1,1]</span>，<br>组合 1 和 1，得到 0，所以数组转化为 <span class="hljs-comment">[1]</span>，这就是最优值。<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>本题其实就是尽量让石头分成重量相同的两堆，相撞之后剩下的石头最小，<strong>这样就化解成01背包问题了</strong>本题物品的重量为stones[i]，物品的价值也为stones[i]。对应着01背包里的物品重量weight[i]和
物品价值value[i]。</p>
<p>这道题的关键在于如何将这堆石头<strong>尽可能平均的划分成两堆</strong>（只有这样才能让剩下的石头的重量最小），大小就是总和除以2</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lastStoneWeightII</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; stones)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">15001</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>; i&lt;stones.<span class="hljs-built_in">size</span>();i++)&#123;<br>            sum+=stones[i];<br>        &#125;<br>        <span class="hljs-type">int</span> target = sum/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;stones.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j= target;j&gt;=stones[i];j--)&#123;<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-stones[i]]+stones[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum - dp[target]- dp[target];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="目标和">目标和</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/target-sum/description/">https://leetcode.cn/problems/target-sum/description/</a></p>
<p>给你一个非负整数数组 <code>nums</code> 和一个整数 <code>target</code>
。</p>
<p>向数组中的每个整数前添加 <code>'+'</code> 或 <code>'-'</code>
，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p>
<ul>
<li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加
<code>'+'</code> ，在 <code>1</code> 之前添加 <code>'-'</code>
，然后串联起来得到表达式 <code>"+2-1"</code> 。</li>
</ul>
<p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同
<strong>表达式</strong> 的数目。</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,1,1,1,1], target = 3<br>输出：5<br>解释：一共有<span class="hljs-number"> 5 </span>种方法让最终目标和为<span class="hljs-number"> 3 </span>。<br>-1 +<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3<br>+1 -<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3<br>+1 +<span class="hljs-number"> 1 </span>-<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3<br>+1 +<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>-<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3<br>+1 +<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>-<span class="hljs-number"> 1 </span>= 3<br></code></pre></td></tr></table></figure>
<p>假设加法的总和为x，那么减法对应的总和就是sum - x。</p>
<p>所以我们要求的是 x - (sum - x) = target</p>
<p>x = (target + sum) / 2</p>
<p><strong>此时问题就转化为，装满容量为x的背包，有几种方法</strong>。</p>
<p>这里的x，就是bagSize，也就是我们后面要求的背包容量。</p>
<p>大家看到(target + sum) / 2 应该担心计算的过程中向下取整有没有影响</p>
<p>动态规划：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++) sum+=nums[i];<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(target)&gt;sum) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>((target+sum)%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> bagsize = (target+sum)/<span class="hljs-number">2</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(bagsize+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=bagsize;j&gt;=nums[i];j--)&#123;<br>                dp[j]+=dp[j-nums[i]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[bagsize];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="一和零">一和零</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/ones-and-zeroes/description/">https://leetcode.cn/problems/ones-and-zeroes/description/</a></p>
<p>给你一个二进制字符串数组 <code>strs</code> 和两个整数 <code>m</code>
和 <code>n</code> 。</p>
<p>请你找出并返回 <code>strs</code> 的最大子集的长度，该子集中
<strong>最多</strong> 有 <code>m</code> 个 <code>0</code> 和
<code>n</code> 个 <code>1</code> 。</p>
<p>如果 <code>x</code> 的所有元素也是 <code>y</code> 的元素，集合
<code>x</code> 是集合 <code>y</code> 的 <strong>子集</strong> 。</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：strs = [<span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-string">&quot;0001&quot;</span>, <span class="hljs-string">&quot;111001&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>], m = <span class="hljs-number">5</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">4</span><br>解释：最多有 <span class="hljs-number">5</span> 个 <span class="hljs-number">0</span> 和 <span class="hljs-number">3</span> 个 <span class="hljs-number">1</span> 的最大子集是 &#123;<span class="hljs-string">&quot;10&quot;</span>,<span class="hljs-string">&quot;0001&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>&#125; ，因此答案是 <span class="hljs-number">4</span> 。<br>其他满足题意但较小的子集包括 &#123;<span class="hljs-string">&quot;0001&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>&#125; 和 &#123;<span class="hljs-string">&quot;10&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>&#125; 。&#123;<span class="hljs-string">&quot;111001&quot;</span>&#125; 不满足题意，因为它含 <span class="hljs-number">4</span> 个 <span class="hljs-number">1</span> ，大于 <span class="hljs-built_in">n</span> 的值 <span class="hljs-number">3</span> <br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMaxForm</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(string str: strs)&#123;<br>            <span class="hljs-type">int</span> onenum=<span class="hljs-number">0</span>, zeronum=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c :str)&#123;<br>                <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;0&#x27;</span>)zeronum++;<br>                <span class="hljs-keyword">else</span> onenum++;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=m;i&gt;=zeronum;i--)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=n; j&gt;=onenum; j--)&#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i-zeronum][j- onenum]+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="零钱兑换ii">零钱兑换II</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change-ii/description/">https://leetcode.cn/problems/coin-change-ii/description/</a></p>
<p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数
<code>amount</code> 表示总金额。</p>
<p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回
<code>0</code> 。</p>
<p>假设每一种面额的硬币有无限个。</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：amount = 5, coins = [1, 2, 5]<br>输出：4<br>解释：有四种方式可以凑成总金额：<br>5=5<br>5=2<span class="hljs-string">+2</span><span class="hljs-string">+1</span><br>5=2<span class="hljs-string">+1</span><span class="hljs-string">+1</span><span class="hljs-string">+1</span><br>5=1<span class="hljs-string">+1</span><span class="hljs-string">+1</span><span class="hljs-string">+1</span><span class="hljs-string">+1</span><br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>完全背包问题</p>
<p>注意在用完全背包问题的时候，遍历背包这个地方是从++开始，就是从coins[i]开始遍历</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;coins.<span class="hljs-built_in">size</span>();i++)&#123;<span class="hljs-comment">//遍历物品</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = coins[i];j&lt;=amount;j++)&#123; <span class="hljs-comment">//遍历背包</span><br>                dp[j]+=dp[j-coins[i]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="组合总结iv">组合总结IV</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iv/description/">https://leetcode.cn/problems/combination-sum-iv/description/</a></p>
<p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code>
，和一个目标整数 <code>target</code> 。请你从 <code>nums</code>
中找出并返回总和为 <code>target</code> 的元素组合的个数。</p>
<p>题目数据保证答案符合 32 位整数范围。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">4</span><br>输出：<span class="hljs-number">7</span><br>解释：<br>所有可能的组合为：<br>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)<br>请注意，顺序不同的序列被视作不同的组合。<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>题目中说这个问题每个元素可以被用好多次，因此想到完全背包问题</p>
<p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p>
<p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p>
<p>本题中的结果是需要考虑到不同数字之间的排列顺序的，所以这个地方要用到排列，先背包再物品</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">combinationSum4</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(target+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=target;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;nums.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(i-nums[j]&gt;=<span class="hljs-number">0</span> &amp;&amp; dp[i]&lt;INT_MAX-dp[i-nums[j]])&#123;<br>                    dp[i]+=dp[i-nums[j]];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="零钱兑换">零钱兑换</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/description/">https://leetcode.cn/problems/coin-change/description/</a></p>
<p>给你一个整数数组 <code>coins</code>
，表示不同面额的硬币；以及一个整数 <code>amount</code>
，表示总金额。计算并返回可以凑成总金额所需的
<strong>最少的硬币个数</strong>
如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code></p>
<p>你可以认为每种硬币的数量是无限的。</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：coins = [1, 2, 5], amount = 11<br>输出：3 <br>解释：11 =<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 5 </span>+ 1<br></code></pre></td></tr></table></figure>
<p>确定dp数组以及下标的含义，<strong>dp[j]：凑足总额为j所需钱币的最少个数为dp[j]</strong></p>
<p>确定递推公式，凑足总额为<code>j - coins[i]</code>的最少个数为<code>dp[j - coins[i]]</code>，那么只需要加上一个钱币<code>coins[i]</code>即<code>dp[j - coins[i]] + 1</code>就是<code>dp[j]</code>（考虑coins[i]）</p>
<p>所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的。</p>
<p>递推公式：<code>dp[j] = min(dp[j - coins[i]] + 1, dp[j]);</code></p>
<p>完全背包问题，且不是排列问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, INT_MAX)</span></span>;<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;coins.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j =coins[i];j&lt; amount;j++)&#123;<br>                <span class="hljs-keyword">if</span>(dp[j-coins[i]]!=INT_MAX)&#123;<br>                    dp[j] = <span class="hljs-built_in">min</span>(dp[j], dp[j-coins[i]]+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(dp[amount]==INT_MAX) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="完全平方数">完全平方数</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/perfect-squares/">https://leetcode.cn/problems/perfect-squares/</a></p>
<p>给你一个整数 <code>n</code> ，返回 <em>和为 <code>n</code>
的完全平方数的最少数量</em> 。</p>
<p><strong>完全平方数</strong>
是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code>
和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code>
不是。</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 12<br>输出：3 <br>解释：12 =<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 4 </span>+ 4<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>完全背包问题，注意这个地方求解的是最小数量，因此初始化的时候是用INT_MAX来进行初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>, INT_MAX)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i*i&lt;=n;i++)&#123; <br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i*i; j&lt;=n; j++)&#123;<br>                dp[j]= <span class="hljs-built_in">min</span>(dp[j], dp[j-i*i]+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="打家劫舍">打家劫舍</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/description/">https://leetcode.cn/problems/house-robber/description/</a></p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你
<strong>不触动警报装置的情况下</strong>
，一夜之内能够偷窃到的最高金额。</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[1,2,3,1]<br>输出：4<br>解释：偷窃<span class="hljs-number"> 1 </span>号房屋 (金额 = 1) ，然后偷窃<span class="hljs-number"> 3 </span>号房屋 (金额 = 3)。<br>     偷窃到的最高金额 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 4 </span>。<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>当前房屋偷与不偷取决于 前一个房屋和前两个房屋是否被偷了。</p>
<p>递推公式为：dp[i]取最大值，即dp[i] = max(dp[i - 2] + nums[i], dp[i -
1]);</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size())</span></span>;<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">1</span>],nums[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            dp[i]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-2</span>]+nums[i], dp[i<span class="hljs-number">-1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="打家劫舍ii">打家劫舍II</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-ii/description/">https://leetcode.cn/problems/house-robber-ii/description/</a></p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都
<strong>围成一圈</strong>
，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>
。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你
<strong>在不触动警报装置的情况下</strong>
，今晚能够偷窃到的最高金额。</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2,3,2]<br>输出：3<br>解释：你不能先偷窃<span class="hljs-number"> 1 </span>号房屋（金额 = 2），然后偷窃<span class="hljs-number"> 3 </span>号房屋（金额 = 2）, 因为他们是相邻的。<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>如果是一个环的情况，那么需要考虑的是如何转换，既然是首尾相连的情况，那么注意的是分成两种情况，第一种是指考虑开头和倒数第二个，第二种是指考虑第二个到最后一个</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> res1 = <span class="hljs-built_in">robrange</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span>);<br>        <span class="hljs-type">int</span> res2 = <span class="hljs-built_in">robrange</span>(nums, <span class="hljs-number">1</span>, nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(res1, res2);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">robrange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(end==start) <span class="hljs-keyword">return</span> nums[start];<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size())</span></span>;<br>        dp[start] = nums[start];<br>        dp[start+<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[start], nums[start+<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =start+<span class="hljs-number">2</span>;i&lt;=end;i++)&#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-2</span>]+nums[i], dp[i<span class="hljs-number">-1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[end];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="买卖股票的最佳时机-1">买卖股票的最佳时机</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/</a></p>
<p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素
<code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>
<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在
<strong>未来的某一个不同的日子</strong>
卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回
<code>0</code> 。</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出，最大利润 = 6-1 =<span class="hljs-number"> 5 </span>。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>贪心</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    	<span class="hljs-type">int</span> low = INT_MAX;<br>    	<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;prices.<span class="hljs-built_in">size</span>(); i++)&#123;<br>    		low = <span class="hljs-built_in">min</span>(low, prices[i]);<br>    		res = <span class="hljs-built_in">max</span>(res, prices[i]-low);<br>    	&#125;<br>    	<span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>动态规划</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure>
<h3 id="乘积最大子数组">乘积最大子数组</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-product-subarray/description/">https://leetcode.cn/problems/maximum-product-subarray/description/</a></p>
<p>给你一个整数数组 <code>nums</code>
，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p>测试用例的答案是一个 <strong>32-位</strong> 整数。</p>
<p><strong>子数组</strong> 是数组的连续子序列。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [2,3,-2,4]</span><br><span class="hljs-section">输出: 6</span><br><span class="hljs-section">解释: 子数组 [2,3] 有最大乘积 6。</span><br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>因为是乘积的问题，所以会存在如果某个值特别小或者是特别大再负负得正之后仍然会出现最大的情况，因此我们在用动态规划记录的时候不仅要记录最大值还需要记录最小值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxp</span><span class="hljs-params">(nums)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minp</span><span class="hljs-params">(nums)</span></span>;<br>        <span class="hljs-type">int</span> res = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            maxp[i]=<span class="hljs-built_in">max</span>(maxp[i<span class="hljs-number">-1</span>]*nums[i], <span class="hljs-built_in">max</span>(nums[i], minp[i<span class="hljs-number">-1</span>]*nums[i]));<br>            res = <span class="hljs-built_in">max</span>(maxp[i], res);<br>            minp[i]=<span class="hljs-built_in">min</span>(minp[i<span class="hljs-number">-1</span>]*nums[i], <span class="hljs-built_in">min</span>(nums[i], maxp[i<span class="hljs-number">-1</span>]*nums[i]));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="最长有效括号">最长有效括号</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-valid-parentheses/description/">https://leetcode.cn/problems/longest-valid-parentheses/description/</a></p>
<p>给你一个只包含 <code>'('</code> 和 <code>')'</code>
的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(()&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：最长有效括号子串是 <span class="hljs-string">&quot;()&quot;</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;)()())&quot;</span><br>输出：<span class="hljs-number">4</span><br>解释：最长有效括号子串是 <span class="hljs-string">&quot;()()&quot;</span><br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>动态规划，分两类进行讨论，分别考虑最后结尾的元素是不是')'
再分成两类进行讨论</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240310163130082.png" srcset="/img/loading.gif" lazyload
alt="image-20240310163130082" />
<figcaption aria-hidden="true">image-20240310163130082</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> maxans = <span class="hljs-number">0</span>, n = s.<span class="hljs-built_in">length</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">dp</span>(n,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(s[i<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                    dp[i] = (i &gt;= <span class="hljs-number">2</span> ? dp[i - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>) + <span class="hljs-number">2</span>;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i-dp[i<span class="hljs-number">-1</span>]&gt;<span class="hljs-number">0</span> &amp;&amp; s[i-dp[i<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                    dp[i] = dp[i<span class="hljs-number">-1</span>]+((i-dp[i<span class="hljs-number">-1</span>])&gt;=<span class="hljs-number">2</span>?dp[i-dp[i<span class="hljs-number">-1</span>]<span class="hljs-number">-2</span>]:<span class="hljs-number">0</span>)+<span class="hljs-number">2</span>;<br>                &#125;<br>                maxans = <span class="hljs-built_in">max</span>(maxans, dp[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="最长连续递增序列">最长连续递增序列</h3>
<p>https://leetcode.cn/problems/longest-continuous-increasing-subsequence/</p>
<p>给定一个未经排序的整数数组，找到最长且
<strong>连续递增的子序列</strong>，并返回该序列的长度。</p>
<p><strong>连续递增的子序列</strong> 可以由两个下标 <code>l</code> 和
<code>r</code>（<code>l &lt; r</code>）确定，如果对于每个
<code>l &lt;= i &lt; r</code>，都有
<code>nums[i] &lt; nums[i + 1]</code> ，那么子序列
<code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code>
就是连续递增子序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,3,5,4,7]</span><br>输出：3<br>解释：最长连续递增序列是 <span class="hljs-comment">[1,3,5]</span>, 长度为3。<br>尽管 <span class="hljs-comment">[1,3,5,7]</span> 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 <br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,2,2,2,2]</span><br>输出：1<br>解释：最长连续递增序列是 <span class="hljs-comment">[2]</span>, 长度为1。<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>简单的遍历模拟并用dp数组来存储到目前为止的最长递增序列的长度，本质上也是一种贪心</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLengthOfLCIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(),<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">int</span> s =<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">1</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i<span class="hljs-number">-1</span>]&lt;nums[i])&#123;dp[i] = dp[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;&#125;<br>            s = <span class="hljs-built_in">max</span>(s,dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="无重复字符的最长子串">无重复字符的最长子串</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/</a></p>
<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的
<strong>最长子串</strong>的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>滑动窗口法，用一个left来记录对应的左侧没有出现重复的元素，一直进行erase()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">size</span>();<br>        std::unordered_set&lt;<span class="hljs-type">char</span>&gt; lookup;<br>        <span class="hljs-type">int</span> maxstr = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">while</span>(lookup.<span class="hljs-built_in">find</span>(s[i])!=lookup.<span class="hljs-built_in">end</span>())&#123;<br>                lookup.<span class="hljs-built_in">erase</span>(s[left]);<br>                left++;<br>            &#125;<br>            maxstr = <span class="hljs-built_in">max</span>(maxstr, i-left+<span class="hljs-number">1</span>);<br>            lookup.<span class="hljs-built_in">insert</span>(s[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxstr;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="最长递增子序列">最长递增子序列</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">https://leetcode.cn/problems/longest-increasing-subsequence/description/</a></p>
<p>给你一个整数数组 <code>nums</code>
，找到其中最长严格递增子序列的长度。</p>
<p><strong>子序列</strong>
是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code>
是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">10,9,2,5</span>,<span class="hljs-number">3,7,101,18</span>]<br>输出：<span class="hljs-number">4</span><br>解释：最长递增子序列是 [<span class="hljs-number">2,3,7,101</span>]，因此长度为 <span class="hljs-number">4</span> 。<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>既然涉及到非连续的子序列，那么在处理的时候就需要用两个指针来标记两个位置遍历</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> lengthOfLIS(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-built_in">int</span>&gt; dp(nums.<span class="hljs-built_in">size</span>(),<span class="hljs-number">0</span>);<br>        for(<span class="hljs-built_in">int</span> i =<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            dp[i]=<span class="hljs-number">1</span>;<br>            for(<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[j]&lt;nums[i])&#123;<br>                    dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j]+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *max_element(dp.begin(), dp.<span class="hljs-keyword">end</span>());;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="最长重复子数组">最长重复子数组</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/">https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/</a></p>
<p>给两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，返回
<em>两个数组中 <strong>公共的</strong> 、长度最长的子数组的长度</em>
。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1,2,3,2,1]</span>, nums2 = <span class="hljs-comment">[3,2,1,4,7]</span><br>输出：3<br>解释：长度最长的公共子数组是 <span class="hljs-comment">[3,2,1]</span> 。<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>在比较i，j对的时候，当然希望能够利用到前面的i-1和j-1的结果，因此用二维的动态规划来提示</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(nums1.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(nums2.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i= nums1.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j= nums2.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br>                dp[i][j] = nums1[i]==nums2[j]?dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>                ans = <span class="hljs-built_in">max</span>(ans, dp[i][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="回文子串">回文子串</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindromic-substrings/description/">https://leetcode.cn/problems/palindromic-substrings/description/</a></p>
<p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中
<strong>回文子串</strong> 的数目。</p>
<p><strong>回文字符串</strong> 是正着读和倒过来读一样的字符串。</p>
<p><strong>子字符串</strong> 是字符串中的由连续字符组成的一个序列。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：三个回文子串: <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;aaa&quot;</span><br>输出：<span class="hljs-number">6</span><br>解释：<span class="hljs-number">6</span>个回文子串: <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;aaa&quot;</span><br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>计算有多少个回文子串的最朴素方法就是枚举出所有的回文子串，而枚举出所有的回文字串又有两种思路，分别是：</p>
<ul>
<li><p>枚举出所有的子串，然后再判断这些子串是否是回文；</p></li>
<li><p>枚举每一个可能的回文中心，然后用两个指针分别向左右两边拓展，当两个指针指向的元素相同的时候就拓展，否则停止拓展。</p></li>
</ul>
<p>因此我们这里可以用中心拓展法来解决这个问题</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240310190137229.png" srcset="/img/loading.gif" lazyload alt="中心拓展问题" style="zoom:50%;" /></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>(), ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>;i++)&#123;<br>            <span class="hljs-type">int</span> l = i/<span class="hljs-number">2</span>, r=i/<span class="hljs-number">2</span>+i%<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">while</span>(l&gt;=<span class="hljs-number">0</span> &amp;&amp; r&lt;n &amp;&amp; s[l]==s[r])&#123;<br>                --l;<br>                ++r;<br>                ++ans;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="最长公共子序列">最长公共子序列</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/">https://leetcode.cn/problems/longest-common-subsequence/</a></p>
<p>给定两个字符串 <code>text1</code> 和
<code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong>
的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code>
。一个字符串的 <strong>子序列</strong>
是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">text1</span> = <span class="hljs-string">&quot;abcde&quot;</span>, <span class="hljs-attr">text2</span> = <span class="hljs-string">&quot;ace&quot;</span> <br>输出：<span class="hljs-number">3</span>  <br>解释：最长公共子序列是 <span class="hljs-string">&quot;ace&quot;</span> ，它的长度为 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">text1</span> = <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-attr">text2</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：最长公共子序列是 <span class="hljs-string">&quot;abc&quot;</span> ，它的长度为 <span class="hljs-number">3</span> <br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>使用动态规划进行求解，其中dp的<strong>二维数组</strong>中记录的元素是:i和:j范围内的最大的公共子序列</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = text1.<span class="hljs-built_in">length</span>(), n = text2.<span class="hljs-built_in">length</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            <span class="hljs-type">char</span> c1 = text1.<span class="hljs-built_in">at</span>(i<span class="hljs-number">-1</span>);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; j++)&#123;<br>                <span class="hljs-type">char</span> c2 = text2.<span class="hljs-built_in">at</span>(j<span class="hljs-number">-1</span>);<br>                <span class="hljs-keyword">if</span>(c1==c2)&#123;<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="编辑距离">编辑距离</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/description/">https://leetcode.cn/problems/edit-distance/description/</a></p>
<p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将
<code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em>
。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xl">输入：word1 = <span class="hljs-string">&quot;horse&quot;</span>, word2 = <span class="hljs-string">&quot;ros&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：<br><span class="hljs-function"><span class="hljs-title">horse</span> -&gt;</span> rorse (将 <span class="hljs-string">&#x27;h&#x27;</span> 替换为 <span class="hljs-string">&#x27;r&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">rorse</span> -&gt;</span> rose (删除 <span class="hljs-string">&#x27;r&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">rose</span> -&gt;</span> ros (删除 <span class="hljs-string">&#x27;e&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>题目给定了两个单词，设为 A 和 B，这样我们就能够六种操作方法。</p>
<p>但我们可以发现，如果我们有单词 A 和单词 B：</p>
<p>对单词 A 删除一个字符和对单词 B 插入一个字符是等价的。例如当单词 A 为
doge，单词 B 为 dog 时，我们既可以删除单词 A 的最后一个字符
e，得到相同的 dog，也可以在单词 B 末尾添加一个字符 e，得到相同的
doge；</p>
<p>同理，对单词 B 删除一个字符和对单词 A 插入一个字符也是等价的；</p>
<p>对单词 A 替换一个字符和对单词 B 替换一个字符是等价的。例如当单词 A 为
bat，单词 B 为 cat 时，我们修改单词 A 的第一个字母 b -&gt; c，和修改单词
B 的第一个字母 c -&gt; b 是等价的。</p>
<p>这样以来，本质不同的操作实际上只有三种：</p>
<p>在单词 A 中插入一个字符；</p>
<p>在单词 B 中插入一个字符；</p>
<p>修改单词 A 的一个字符。</p>
<p>我们用 <code>D[i][j]</code> 表示 <code>A</code> 的前 <code>i</code>
个字母和 <code>B</code> 的前 <code>j</code> 个字母之间的编辑距离。</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240310191703835.png" srcset="/img/loading.gif" lazyload alt="编辑距离题解" style="zoom:50%;" /></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = word1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> m = word2.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-comment">//其中有一个子字符串为空字符串</span><br>        <span class="hljs-keyword">if</span> (n*m==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> n+m;<br><br>        <span class="hljs-comment">//DP数组</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m+<span class="hljs-number">1</span>));<br><br>        <span class="hljs-comment">//边界状态初始化</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;n+<span class="hljs-number">1</span>;i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j =<span class="hljs-number">0</span>;j&lt;m+<span class="hljs-number">1</span>;j++)&#123;<br>            dp[<span class="hljs-number">0</span>][j] = j;<br>        &#125;<br><br>        <span class="hljs-comment">//循环计算DP</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n+<span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;m+<span class="hljs-number">1</span>; j++)&#123;<br>                <span class="hljs-type">int</span> left = dp[i<span class="hljs-number">-1</span>][j]+<span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> down = dp[i][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> left_down = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>                <span class="hljs-keyword">if</span>(word1[i<span class="hljs-number">-1</span>]!=word2[j<span class="hljs-number">-1</span>]) left_down +=<span class="hljs-number">1</span>;<br>                dp[i][j] = <span class="hljs-built_in">min</span>(left, <span class="hljs-built_in">min</span>(down, left_down));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][m];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="正则表达式匹配">正则表达式匹配</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/regular-expression-matching/description/">https://leetcode.cn/problems/regular-expression-matching/description/</a></p>
<p>给你一个字符串 <code>s</code> 和一个字符规律
<code>p</code>，请你来实现一个支持 <code>'.'</code> 和 <code>'*'</code>
的正则表达式匹配。</p>
<ul>
<li><code>'.'</code> 匹配任意单个字符</li>
<li><code>'*'</code> 匹配零个或多个前面的那一个元素</li>
</ul>
<p>所谓匹配，是要涵盖 <strong>整个</strong> 字符串
<code>s</code>的，而不是部分字符串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-attr">p</span> = <span class="hljs-string">&quot;a&quot;</span><br>输出：<span class="hljs-literal">false</span><br>解释：<span class="hljs-string">&quot;a&quot;</span> 无法匹配 <span class="hljs-string">&quot;aa&quot;</span> 整个字符串。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：s = <span class="hljs-string">&quot;aa&quot;</span>, p = <span class="hljs-string">&quot;a*&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：因为 <span class="hljs-string">&#x27;*&#x27;</span> 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 <span class="hljs-string">&#x27;a&#x27;</span>。因此，字符串 <span class="hljs-string">&quot;aa&quot;</span> 可被视为 <span class="hljs-string">&#x27;a&#x27;</span> 重复了一次。<br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：s = <span class="hljs-string">&quot;ab&quot;</span>, p = <span class="hljs-string">&quot;.*&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：<span class="hljs-string">&quot;.*&quot;</span> 表示可匹配零个或多个（<span class="hljs-string">&#x27;*&#x27;</span>）任意字符（<span class="hljs-string">&#x27;.&#x27;</span>）。<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<ol type="1">
<li><strong>定义状态：</strong> 创建一个二维数组 <code>dp</code>，其中
<code>dp[i][j]</code> 表示 <code>s</code> 的前 <code>i</code> 个字符与
<code>p</code> 的前 <code>j</code> 个字符是否匹配。</li>
<li><strong>初始化：</strong>
<ol type="1">
<li><code>dp[0][0]</code> 为
<code>true</code>，因为两个空字符串是匹配的。</li>
<li>初始化 <code>dp[0][j]</code>，处理模式 <code>p</code> 的前
<code>j</code> 个字符与空字符串 <code>s</code> 的匹配情况。这通常依赖于
<code>'*'</code> 字符，因为 <code>'*'</code> 可以表示重复前面的字符 0
次。</li>
</ol></li>
<li><strong>状态转移方程：</strong>
<ol type="1">
<li>当 <code>s[i-1] == p[j-1]</code> 或 <code>p[j-1] == '.'</code>
时，<code>dp[i][j] = dp[i-1][j-1]</code>。</li>
<li>当 <code>p[j-1] == '*'</code> 时，需要分两种情况考虑：
<ul>
<li>如果 <code>p[j-2]</code> 不匹配 <code>s[i-1]</code>，则
<code>'*'</code> 表示它前面的字符出现 0
次，<code>dp[i][j] = dp[i][j-2]</code>。</li>
<li>如果 <code>p[j-2]</code> 匹配
<code>s[i-1]</code>，则存在多种可能性（<code>'*'</code>
表示前面的字符出现 0 次、1
次或多次），<code>dp[i][j] = dp[i][j-2] || dp[i][j-1] || dp[i-1][j]</code>。</li>
</ul></li>
</ol></li>
<li><strong>循环顺序：</strong> 从左到右，从上到下遍历 <code>dp</code>
数组。</li>
<li><strong>返回结果：</strong> <code>dp[len(s)][len(p)]</code> 表示整个
<code>s</code> 和 <code>p</code> 是否匹配</li>
</ol>
<h1 id="栈队列单调栈">栈&amp;队列&amp;单调栈</h1>
<h3 id="有效括号">有效括号</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/description/">https://leetcode.cn/problems/valid-parentheses/description/</a></p>
<p>给定一个只包括
<code>'('</code>，<code>')'</code>，<code>'&#123;'</code>，<code>'&#125;'</code>，<code>'['</code>，<code>']'</code>
的字符串 <code>s</code> ，判断字符串是否有效。</p>
<ol type="1">
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>每个右括号都有一个对应的相同类型的左括号。</li>
</ol>
<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;()&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>
<p>思路：简单的判断栈</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ismatch</span><span class="hljs-params">(<span class="hljs-type">char</span> a, <span class="hljs-type">char</span> b)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>((a==<span class="hljs-string">&#x27;)&#x27;</span>&amp;&amp;b==<span class="hljs-string">&#x27;(&#x27;</span>)||(a==<span class="hljs-string">&#x27;&#125;&#x27;</span>&amp;&amp;b==<span class="hljs-string">&#x27;&#123;&#x27;</span>)||(a==<span class="hljs-string">&#x27;]&#x27;</span>&amp;&amp;b==<span class="hljs-string">&#x27;[&#x27;</span>))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">char</span>&gt;st;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;)&#x27;</span>||s[i]==<span class="hljs-string">&#x27;&#125;&#x27;</span>||s[i]==<span class="hljs-string">&#x27;]&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(!st.<span class="hljs-built_in">empty</span>()&amp;&amp;<span class="hljs-built_in">ismatch</span>(s[i],st.<span class="hljs-built_in">top</span>()))&#123;<br>                    st.<span class="hljs-built_in">pop</span>();<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                st.<span class="hljs-built_in">push</span>(s[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="移掉k位数字">移掉K位数字</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-k-digits/description/?envType=study-plan-v2&amp;envId=2024-spring-sprint-100">https://leetcode.cn/problems/remove-k-digits/description/?envType=study-plan-v2&amp;envId=2024-spring-sprint-100</a></p>
<p>给你一个以字符串表示的非负整数 <code>num</code> 和一个整数
<code>k</code> ，移除这个数中的 <code>k</code>
位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。</p>
<p><strong>示例 1 ：</strong></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">输入：<span class="hljs-built_in">num</span> = <span class="hljs-string">&quot;1432219&quot;</span>, k = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">&quot;1219&quot;</span><br>解释：移除掉三个数字 <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, 和 <span class="hljs-number">2</span> 形成一个新的最小的数字 <span class="hljs-number">1219</span> 。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2 ：</strong></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">输入：<span class="hljs-built_in">num</span> = <span class="hljs-string">&quot;10200&quot;</span>, k = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">&quot;200&quot;</span><br>解释：移掉首位的 <span class="hljs-number">1</span> 剩下的数字为 <span class="hljs-number">200.</span> 注意输出不能有任何前导零。<br></code></pre></td></tr></table></figure>
<p><strong>示例 3 ：</strong></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">输入：<span class="hljs-built_in">num</span> = <span class="hljs-string">&quot;10&quot;</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-string">&quot;0&quot;</span><br>解释：从原数字移除所有的数字，剩余为空就是 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>移除的思想就是贪心，简单来说就是对字符串从左到右进行遍历，来寻找递减的数字组合，如果出现了43这样的组合，那么移除的方法就是将4移除留下3</p>
<p>因此在实现上可以考虑用单调栈来实现，对数组进行依次遍历，对于每个数字，如果该数字小于栈顶元素，我们就不断地弹出栈顶元素，直到</p>
<ul>
<li>栈为空</li>
<li>或者新的栈顶元素不大于当前数字</li>
<li>或者我们已经删除了 <em>k</em> 位数字</li>
</ul>
<p>当完成以上的步骤之后如果k的值还不为0，那么意味着前面的数是一致单调的且是从左到右依次变大的，那么只需要删除最右侧的数字即栈顶的<strong>剩余k</strong>的元素个数即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeKdigits</span><span class="hljs-params">(string num, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">char</span>&gt; st;<br>        <span class="hljs-comment">// 这个地方就用到单调栈的方式来存储</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;num.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">while</span>(st.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">0</span> &amp;&amp; st.<span class="hljs-built_in">back</span>()&gt; num[i] &amp;&amp; k)&#123;<br>                st.<span class="hljs-built_in">pop_back</span>();<br>                k-=<span class="hljs-number">1</span>;<br>            &#125;<br>            st.<span class="hljs-built_in">push_back</span>(num[i]);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(k)&#123;<br>            st.<span class="hljs-built_in">pop_back</span>();<br>            k--;<br>        &#125;<br>        string ans = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span>(st.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">0</span>)&#123;<br>                ans += st.<span class="hljs-built_in">back</span>();<br>                st.<span class="hljs-built_in">pop_back</span>(); <br>        &#125;<br>        std::<span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;ans.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(ans[i]==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            s = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        ans.<span class="hljs-built_in">erase</span>(<span class="hljs-number">0</span>, s<span class="hljs-number">-0</span>);<br>        <span class="hljs-keyword">if</span>(ans[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>            ans = <span class="hljs-string">&quot;0&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans == <span class="hljs-string">&quot;&quot;</span> ? <span class="hljs-string">&quot;0&quot;</span>:ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="去除重复字母">去除重复字母</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicate-letters/description/?envType=study-plan-v2&amp;envId=2024-spring-sprint-100">https://leetcode.cn/problems/remove-duplicate-letters/description/?envType=study-plan-v2&amp;envId=2024-spring-sprint-100</a></p>
<p>给你一个字符串 <code>s</code>
，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证
<strong>返回结果的字典序最小</strong>（要求不能打乱其他字符的相对位置）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;bcabc&quot;</span><br>输出：<span class="hljs-string">&quot;abc&quot;</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cbacdcbc&quot;</span><br>输出：<span class="hljs-string">&quot;acdb&quot;</span><br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>主要解决的思路就是贪心+单调栈。</p>
<p>具体来说，我们的目标是需要一个队列来记录每个字符串的使用次数和是否有剩余，如果有剩余那么就继续执行单调栈的操作，关键点在于如果<strong>当前栈顶部的元素比遍历的数组中元素字典序列要大，那么理论上要拿出来前提是后续还有该元素</strong></p>
<p>按照上述的思路执行循环，每次放元素之前进行条件的判断最后得到结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeDuplicateLetters</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span>, <span class="hljs-title">num</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            num[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        vector&lt;<span class="hljs-type">char</span>&gt; st;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>; i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(!vis[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>])&#123;<br>                <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; st.<span class="hljs-built_in">back</span>()&gt;s[i])&#123;<br>                    <span class="hljs-keyword">if</span>(num[st.<span class="hljs-built_in">back</span>()-<span class="hljs-string">&#x27;a&#x27;</span>]&gt;<span class="hljs-number">0</span>)&#123;<br>                        vis[st.<span class="hljs-built_in">back</span>()-<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-number">0</span>;<br>                        st.<span class="hljs-built_in">pop_back</span>();<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                vis[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]=<span class="hljs-number">1</span>;<br>                st.<span class="hljs-built_in">push_back</span>(s[i]);<br>            &#125;<br>            num[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        &#125;<br>        string ans;<br>        <span class="hljs-keyword">while</span>(st.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">0</span>)&#123;<br>            ans+=st.<span class="hljs-built_in">back</span>();<br>            st.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        std::<span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="删除相邻重复">删除相邻重复</h3>
<p><strong>示例：</strong></p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：<span class="hljs-string">&quot;abbaca&quot;</span><br>输出：<span class="hljs-string">&quot;ca&quot;</span><br>解释：<br>例如，在 <span class="hljs-string">&quot;abbaca&quot;</span> 中，我们可以删除 <span class="hljs-string">&quot;bb&quot;</span> 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 <span class="hljs-string">&quot;aaca&quot;</span>，其中又只有 <span class="hljs-string">&quot;aa&quot;</span> 可以执行重复项删除操作，所以最后的字符串为 <span class="hljs-string">&quot;ca&quot;</span>。<br></code></pre></td></tr></table></figure>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/">https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">char</span>&gt;st;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c:s)&#123;<br>            <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">empty</span>()||c!=st.<span class="hljs-built_in">top</span>())&#123;<br>                st.<span class="hljs-built_in">push</span>(c);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        string res=<span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>())&#123;<br>            res+=st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">//注意这个地方需要反转一下字符串</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="逆波兰表达式求值">逆波兰表达式求值</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/">https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/</a></p>
<p>给你一个字符串数组 <code>tokens</code> ，表示一个根据 <a
target="_blank" rel="noopener" href="https://baike.baidu.com/item/逆波兰式/128437">逆波兰表示法</a>
表示的算术表达式。请你计算该表达式。返回一个表示表达式值的整数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">输入：<span class="hljs-built_in">tokens</span> = [<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;+&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;*&quot;</span>]<br>输出：<span class="hljs-number">9</span><br>解释：该算式转化为常见的中缀算术表达式为：((<span class="hljs-number">2</span> + <span class="hljs-number">1</span>) * <span class="hljs-number">3</span>) = <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">输入：<span class="hljs-built_in">tokens</span> = [<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;13&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;/&quot;</span>,<span class="hljs-string">&quot;+&quot;</span>]<br>输出：<span class="hljs-number">6</span><br>解释：该算式转化为常见的中缀算术表达式为：(<span class="hljs-number">4</span> + (<span class="hljs-number">13</span> / <span class="hljs-number">5</span>)) = <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>利用栈的思想模拟运算的过程，按照tokens的顺序将数字放进栈中，遇到运算符那么就拿出栈中的数字，运算结束之后再放进栈中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt;st;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;tokens.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(tokens[i]!=<span class="hljs-string">&quot;/&quot;</span>&amp;&amp;tokens[i]!=<span class="hljs-string">&quot;+&quot;</span>&amp;&amp;tokens[i]!=<span class="hljs-string">&quot;-&quot;</span>&amp;&amp;tokens[i]!=<span class="hljs-string">&quot;*&quot;</span>)&#123;<br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">stoi</span>(tokens[i]));<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-type">int</span> num1 = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-type">int</span> num2 = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (tokens[i] == <span class="hljs-string">&quot;+&quot;</span>) st.<span class="hljs-built_in">push</span>(num2 + num1);<br>                <span class="hljs-keyword">if</span> (tokens[i] == <span class="hljs-string">&quot;-&quot;</span>) st.<span class="hljs-built_in">push</span>(num2 - num1);<br>                <span class="hljs-keyword">if</span> (tokens[i] == <span class="hljs-string">&quot;*&quot;</span>) st.<span class="hljs-built_in">push</span>(num2 * num1);<br>                <span class="hljs-keyword">if</span> (tokens[i] == <span class="hljs-string">&quot;/&quot;</span>) st.<span class="hljs-built_in">push</span>(num2 / num1);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> result = st.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="前k个高频元素">前K个高频元素</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/description/">https://leetcode.cn/problems/top-k-frequent-elements/description/</a></p>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code>
，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按
<strong>任意顺序</strong> 返回答案。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: nums = <span class="hljs-comment">[1,1,1,2,2,3]</span>, k = 2<br>输出: <span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240206140055727.png" srcset="/img/loading.gif" lazyload alt="前k个高频元素的思路图" style="zoom:50%;" /></p>
<p>这道题目主要涉及到如下三块内容：</p>
<ol type="1">
<li>要统计元素出现频率</li>
<li>对频率排序</li>
<li>找出前K个高频元素</li>
</ol>
<p>首先统计元素出现的频率，这一类的问题可以使用map来进行统计。</p>
<p>然后是对频率进行排序，这里我们可以使用一种
容器适配器就是<strong>优先级队列</strong></p>
<p>优先级队列内部元素是自动依照元素的权值排列。那么它是如何有序排列的呢？</p>
<p>缺省情况下priority_queue利用max-heap（大顶堆）完成对元素的排序，这个大顶堆是以vector为表现形式的complete
binary tree（完全二叉树）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">mycomparison</span>&#123;<br>        <span class="hljs-keyword">public</span>:<br>            <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; rhs)</span></span>&#123;<br>                <span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br>            &#125;<br>    &#125;;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">//统计元素出现的频率</span><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            map[nums[i]]++;<br>        &#125;<br><br>        <span class="hljs-comment">//对频率进行排序</span><br>        <span class="hljs-comment">//定义一个小顶堆，大小为k</span><br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, mycomparison&gt; pri_que;<br><br>        <span class="hljs-comment">//用固定大小为k的小顶堆，扫面所有频率的数值</span><br>        <span class="hljs-keyword">for</span>(unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator it=map.<span class="hljs-built_in">begin</span>(); it!=map.<span class="hljs-built_in">end</span>(); it++)&#123;<br>            pri_que.<span class="hljs-built_in">push</span>(*it);<br>            <span class="hljs-keyword">if</span>(pri_que.<span class="hljs-built_in">size</span>()&gt;k)&#123;<br>                pri_que.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//找出前面k个高频元素，因为小顶堆先弹出的是最小的，所以倒序输出到数组</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(k)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=k<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            res[i]=pri_que.<span class="hljs-built_in">top</span>().first;<br>            pri_que.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="每日温度">每日温度</h3>
<p>给定一个整数数组 <code>temperatures</code>
，表示每天的温度，返回一个数组 <code>answer</code> ，其中
<code>answer[i]</code> 是指对于第 <code>i</code>
天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用
<code>0</code> 来代替。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: temperatures = [<span class="hljs-number">73,74,75,71</span>,<span class="hljs-number">69,72,76,73</span>]<br>输出: [<span class="hljs-number">1,1,4,2</span>,<span class="hljs-number">1,1,0,0</span>]<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>可以选择使用<strong>单调栈的方法</strong>来求解，具体的思路是设置一个栈，遍历数组的时候和栈顶元素进行比较，小于栈顶元素的时候就需要将当前元素放入栈中</p>
<p>首先这道题必须有一个向量数组来存储对应位置的元素的值，<code>vector&lt;int&gt; res(temperatures.size(),0)</code>方便修改对应的元素</p>
<p>如果大于当前的栈顶元素的值，那么就要进行比较<code>while</code>循环，只要还是大于当前栈顶的元素都需要对栈顶的元素进行<code>pop()</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; temperatures)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(temperatures.size(),<span class="hljs-number">0</span>)</span></span>;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;temperatures.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(temperatures[i]&lt;=temperatures[st.<span class="hljs-built_in">top</span>()])&#123;<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()&amp;&amp; temperatures[i]&gt;temperatures[st.<span class="hljs-built_in">top</span>()])&#123;<br>                    res[st.<span class="hljs-built_in">top</span>()]=i-st.<span class="hljs-built_in">top</span>();<br>                    st.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="图论">图论</h1>
<h3 id="深度优先搜索理论">深度优先搜索理论</h3>
<p>深度优先搜索和回溯的思路大体上是一样的</p>
<ul>
<li>搜索方向，是认准一个方向搜，直到碰壁之后再换方向</li>
<li>换方向是撤销原路径，改为节点链接的下一个路径，回溯的过程。</li>
</ul>
<p>就地递归函数的下面，例如如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(参数)</span> </span>&#123;<br>    处理节点<br>    <span class="hljs-built_in">dfs</span>(图，选择的节点); <span class="hljs-comment">// 递归</span><br>    回溯，撤销处理结果<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到回溯操作就在递归函数的下面，递归和回溯是相辅相成的</p>
<p>深度优先搜索的三部曲：</p>
<ol type="1">
<li><p><strong>确认递归函数，参数</strong></p>
<p>深搜需要
二维数组数组结构保存所有路径，需要一维数组保存单一路径，这种保存结果的数组，我们可以定义一个全局变量，避免让我们的函数参数过多。</p></li>
<li><p><strong>确认终止条件</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (终止条件) &#123;<br>    存放结果;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>终止添加不仅是结束本层递归，同时也是我们收获结果的时候。</p></li>
<li><p><strong>处理目前搜索节点出发的路径</strong></p></li>
</ol>
<p>一般这里就是一个for循环的操作，去遍历 目前搜索节点
所能到的所有节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (选择：本节点所连接的其他节点) &#123;<br>    处理节点;<br>    <span class="hljs-built_in">dfs</span>(图，选择的节点); <span class="hljs-comment">// 递归</span><br>    回溯，撤销处理结果<br>&#125;<br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240224164602244.png" srcset="/img/loading.gif" lazyload
alt="回溯，撤销处理的结果" />
<figcaption aria-hidden="true">回溯，撤销处理的结果</figcaption>
</figure>
<h3 id="广度优先搜索理论">广度优先搜索理论</h3>
<p>广搜的搜索方式就适合于解决两个点之间的最短路径问题。</p>
<p>因为广搜是从起点出发，以起始点为中心一圈一圈进行搜索，一旦遇到终点，记录之前走过的节点就是一条最短路。</p>
<p>广度优先搜索代码模版：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>  <span class="hljs-comment">// 定义队列</span><br>  queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;que;<br>  que.<span class="hljs-built_in">push</span>(&#123;x,y&#125;);<br>  visited[x][y] = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>    pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cur = que.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">//选择队列中第一个元素</span><br>    que.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 从队列中取出元素</span><br>    <span class="hljs-type">int</span> curx = cur.first;<br>    <span class="hljs-type">int</span> cury = cur.second;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>      <span class="hljs-type">int</span> nextx = curx+dir[i][<span class="hljs-number">0</span>];<br>      <span class="hljs-type">int</span> nexty = cury+dir[i][<span class="hljs-number">1</span>];<br>      <span class="hljs-keyword">if</span>(nextx&lt;<span class="hljs-number">0</span> || nextx&gt;=grid.<span class="hljs-built_in">size</span>() ||nexty&lt;<span class="hljs-number">0</span>||nexty&gt;=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;<br>      <span class="hljs-keyword">if</span>(!visited[nextx][nexty])&#123;<br>        que.<span class="hljs-built_in">push</span>(&#123;nextx,nexty&#125;);<br>        visited[nextx][nexty] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//立刻标记，避免重复访问</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="所有可能的路径">所有可能的路径</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/all-paths-from-source-to-target/description/">https://leetcode.cn/problems/all-paths-from-source-to-target/description/</a></p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240129130942760.png" srcset="/img/loading.gif" lazyload alt="图路径遍历" style="zoom:50%;" /></p>
<p>给你一个有 <code>n</code> 个节点的
<strong>有向无环图（DAG）</strong>，请你找出所有从节点 <code>0</code>
到节点 <code>n-1</code>
的路径并输出（<strong>不要求按特定顺序</strong>） <code>graph[i]</code>
是一个从节点 <code>i</code> 可以访问的所有节点的列表（即从节点
<code>i</code> 到节点 <code>graph[i][j]</code>存在一条有向边）。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：graph = <span class="hljs-string">[[1,2],[3],[3],[]]</span><br>输出：<span class="hljs-string">[[0,1,3],[0,2,3]]</span><br>解释：有两条路径 <span class="hljs-number">0</span> -&gt; <span class="hljs-number">1</span> -&gt; <span class="hljs-number">3</span> 和 <span class="hljs-number">0</span> -&gt; <span class="hljs-number">2</span> -&gt; <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>深度优先搜索</p>
<p>注意在用dfs做题的时候需要初始化<code>path.push_back(0)</code>每一次都需要初始化输入这个数值起点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> x)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(x == graph.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;graph[x].<span class="hljs-built_in">size</span>();i++)&#123;<br>            path.<span class="hljs-built_in">push_back</span>(graph[x][i]);<br>            <span class="hljs-built_in">dfs</span>(graph,graph[x][i]);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">allPathsSourceTarget</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph) &#123;<br>        path.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">dfs</span>(graph, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="岛屿数量">岛屿数量</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-islands/description/">https://leetcode.cn/problems/number-of-islands/description/</a></p>
<p>给你一个由 <code>'1'</code>（陆地）和
<code>'0'</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p><strong>示例 ：</strong></p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：grid = [<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>]<br>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p>深度优先搜索版本：</p>
<p>思路在于利用dfs来对岛屿中的数量进行标记是否能visited，必须是联通的才能继续标记为<code>res++</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] =&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<span class="hljs-comment">//四个方向</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>        <span class="hljs-type">int</span> nextx = x +dir[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> nexty = y +dir[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(nextx&lt;<span class="hljs-number">0</span>||nexty&gt;grid.<span class="hljs-built_in">size</span>()||nexty&lt;<span class="hljs-number">0</span>||nexty&gt;grid[<span class="hljs-number">0</span>].size) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty]==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>          visited[nextx][nexty] = <span class="hljs-literal">true</span>;<br>          <span class="hljs-built_in">dfs</span>(grid, visited, nextx, nexty);<br>        &#125;<br>      &#125;<br>    &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span></span>&#123;<br>    <span class="hljs-type">int</span> n = grid.<span class="hljs-built_in">size</span>(), m = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; visited = vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt; n;i++)&#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>        <span class="hljs-keyword">if</span>(!visited[i][j]&amp;&amp;grid[i][j]==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>          visited[i][j]=<span class="hljs-literal">true</span>;<br>          res++;<br>          <span class="hljs-built_in">dfs</span>(grid, visited, i, j);<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>广度优先搜索版本</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  	<span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>      queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;que;<br>      que.<span class="hljs-built_in">push</span>(&#123;x,y&#125;);<br>      visited[x][y] = <span class="hljs-literal">true</span>;<br>      <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>        pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cur = que.<span class="hljs-built_in">front</span>();<br>        que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> curx = cur.first;<br>        <span class="hljs-type">int</span> cury = cur.second;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>          <span class="hljs-type">int</span> nextx = curx+dir[i][<span class="hljs-number">0</span>];<br>          <span class="hljs-type">int</span> nexty = cury+dir[i][<span class="hljs-number">1</span>];<br>          <span class="hljs-keyword">if</span>(nextx&lt;<span class="hljs-number">0</span>||nextx&gt;grid.<span class="hljs-built_in">size</span>()||nexty&lt;<span class="hljs-number">0</span>||nextt&gt;grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;<br>          <span class="hljs-keyword">if</span>(!visited[nextx][nexty]&amp;&amp;grid[nextx][nexty]==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>            que.<span class="hljs-built_in">push</span>(&#123;nextx,nexty&#125;);<br>            visited[nextx][nexty] = <span class="hljs-literal">true</span>;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = grid.<span class="hljs-built_in">size</span>(), m = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>      	vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; visited = vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br>      	<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>          <span class="hljs-keyword">if</span>(!visited[i][j]&amp;&amp;gird[i][j]==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>            res++;<br>            <span class="hljs-built_in">bfs</span>(grid, visited, i, j);<br>          &#125;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="岛屿的最大面积">岛屿的最大面积</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/max-area-of-island/description/">https://leetcode.cn/problems/max-area-of-island/description/</a></p>
<p>给你一个大小为 <code>m x n</code> 的二进制矩阵 <code>grid</code>
。</p>
<p><strong>岛屿</strong> 是由一些相邻的 <code>1</code> (代表土地)
构成的组合，这里的「相邻」要求两个 <code>1</code> 必须在
<strong>水平或者竖直的四个方向上</strong> 相邻。你可以假设
<code>grid</code> 的四个边缘都被 <code>0</code>（代表水）包围着。</p>
<p>岛屿的面积是岛上值为 <code>1</code> 的单元格的数目。</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240224172315611.png" srcset="/img/loading.gif" lazyload
alt="岛屿的最大数量" />
<figcaption aria-hidden="true">岛屿的最大数量</figcaption>
</figure>
<p>深度优先搜索算法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> count;<br>    <span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>            <span class="hljs-type">int</span> nextx = x+dir[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> nexty = y+dir[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(nextx&lt;<span class="hljs-number">0</span>||nextx&gt;=grid.<span class="hljs-built_in">size</span>()||nexty&lt;<span class="hljs-number">0</span>||nexty&gt;=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(!visited[nextx][nexty]&amp;&amp; grid[nextx][nexty]==<span class="hljs-number">1</span>)&#123;<br>                visited[nextx][nexty]=<span class="hljs-literal">true</span>;<br>                count++;<br>                <span class="hljs-built_in">dfs</span>(grid, visited, nextx, nexty);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = grid.<span class="hljs-built_in">size</span>(), m=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; visited = vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>                <span class="hljs-keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    count = <span class="hljs-number">1</span>;<br>                    visited[i][j] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-built_in">dfs</span>(grid, visited, i, j);<br>                    res = <span class="hljs-built_in">max</span>(res, count);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>广度优先搜索</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>        queue&lt;<span class="hljs-type">int</span>&gt; que;<br>        que.<span class="hljs-built_in">push</span>(x);<br>        que.<span class="hljs-built_in">push</span>(y);<br>        visited[x][y]=<span class="hljs-literal">true</span>;<br>        count++;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> xx = que.<span class="hljs-built_in">front</span>();que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> yy = que.<span class="hljs-built_in">front</span>();que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>                <span class="hljs-type">int</span> nextx = xx+dir[i][<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> nexty = yy+dir[i][<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(nextx&lt;<span class="hljs-number">0</span>||nextx&gt;=grid.<span class="hljs-built_in">size</span>()||nexty&lt;<span class="hljs-number">0</span>||nexty&gt;=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(!visited[nextx][nexty]&amp;&amp; grid[nextx][nexty]==<span class="hljs-number">1</span>)&#123;<br>                    count++;<br>                    visited[nextx][nexty]=<span class="hljs-literal">true</span>;<br>                    que.<span class="hljs-built_in">push</span>(nextx);<br>                    que.<span class="hljs-built_in">push</span>(nexty);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n= grid.<span class="hljs-built_in">size</span>(), m=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;visited = vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>                <span class="hljs-keyword">if</span>(!visited[i][j]&amp;&amp;grid[i][j]==<span class="hljs-number">1</span>)&#123;<br>                    count =<span class="hljs-number">0</span>;<br>                    <span class="hljs-built_in">bfs</span>(grid, visited, i, j);<br>                    res = <span class="hljs-built_in">max</span>(res , count);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="飞地的数量">飞地的数量</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-enclaves/description/">https://leetcode.cn/problems/number-of-enclaves/description/</a></p>
<p>给你一个大小为 <code>m x n</code> 的二进制矩阵 <code>grid</code>
，其中 <code>0</code> 表示一个海洋单元格、<code>1</code>
表示一个陆地单元格。一次 <strong>移动</strong>
是指从一个陆地单元格走到另一个相邻（<strong>上、下、左、右</strong>）的陆地单元格或跨过
<code>grid</code> 的边界。返回网格中 <strong>无法</strong>
在任意次数的移动中离开网格边界的陆地单元格的数量。</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240224222001801.png" srcset="/img/loading.gif" lazyload alt="飞地的数量" style="zoom:67%;" /></p>
<p>思路：</p>
<p>利用dfs或者是bfs的方法先把边界周围的岛屿全部去除为0</p>
<p>然后再对剩下的进行计数，每出现一块地就增加一个计数单位</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-type">int</span> count;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>        grid[x][y] =<span class="hljs-number">0</span>;<br>        count++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i= <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>            <span class="hljs-type">int</span> nextx = x +dir[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> nexty = y +dir[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(nextx&lt;<span class="hljs-number">0</span>||nextx&gt;=grid.<span class="hljs-built_in">size</span>()||nexty&lt;<span class="hljs-number">0</span>||nexty&gt;=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(grid[nextx][nexty]==<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-built_in">dfs</span>(grid, nextx, nexty);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numEnclaves</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = grid.<span class="hljs-built_in">size</span>(), m=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(grid[i][<span class="hljs-number">0</span>]==<span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(grid, i, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span>(grid[i][m<span class="hljs-number">-1</span>]==<span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(grid, i, m<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            <span class="hljs-keyword">if</span>(grid[<span class="hljs-number">0</span>][j]==<span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(grid, <span class="hljs-number">0</span>, j);<br>            <span class="hljs-keyword">if</span>(grid[n<span class="hljs-number">-1</span>][j]==<span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(grid, n<span class="hljs-number">-1</span>, j);<br>        &#125;<br><br>        count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(grid, i, j);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="被围绕的区域">被围绕的区域</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/surrounded-regions/description/">https://leetcode.cn/problems/surrounded-regions/description/</a></p>
<p>给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符
<code>'X'</code> 和 <code>'O'</code> ，找到所有被 <code>'X'</code>
围绕的区域，并将这些区域里所有的 <code>'O'</code> 用 <code>'X'</code>
填充。</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240224230446459.png" srcset="/img/loading.gif" lazyload alt="被围绕的区域" style="zoom: 50%;" /></p>
<p>思路：</p>
<p>利用深度优先搜索的方法先将边界的联通区域全部设置为A，中间的部分不动，完全设置完成之后再进行逐一的赋值调整</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240224230638690.png" srcset="/img/loading.gif" lazyload
alt="基本的思路调整" />
<figcaption aria-hidden="true">基本的思路调整</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>        board[x][y]=<span class="hljs-string">&#x27;A&#x27;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>            <span class="hljs-type">int</span> nextx = x+dir[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> nexty = y+dir[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(nextx&lt;<span class="hljs-number">0</span>||nextx&gt;=board.<span class="hljs-built_in">size</span>()||nexty&lt;<span class="hljs-number">0</span>||nexty&gt;=board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(board[nextx][nexty]==<span class="hljs-string">&#x27;X&#x27;</span>||board[nextx][nexty]==<span class="hljs-string">&#x27;A&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">dfs</span>(board, nextx, nexty);<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n= board.<span class="hljs-built_in">size</span>(), m=board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(board[i][<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;O&#x27;</span>) <span class="hljs-built_in">dfs</span>(board, i,<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span>(board[i][m<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;O&#x27;</span>) <span class="hljs-built_in">dfs</span>(board, i, m<span class="hljs-number">-1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            <span class="hljs-keyword">if</span>(board[<span class="hljs-number">0</span>][j]==<span class="hljs-string">&#x27;O&#x27;</span>) <span class="hljs-built_in">dfs</span>(board, <span class="hljs-number">0</span>, j);<br>            <span class="hljs-keyword">if</span>(board[n<span class="hljs-number">-1</span>][j]==<span class="hljs-string">&#x27;O&#x27;</span>) <span class="hljs-built_in">dfs</span>(board, n<span class="hljs-number">-1</span>, j);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>; i&lt;n ;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>                <span class="hljs-keyword">if</span>(board[i][j]==<span class="hljs-string">&#x27;O&#x27;</span>) board[i][j]=<span class="hljs-string">&#x27;X&#x27;</span>;;<br>                <span class="hljs-keyword">if</span>(board[i][j]==<span class="hljs-string">&#x27;A&#x27;</span>) board[i][j]=<span class="hljs-string">&#x27;O&#x27;</span>;<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="太平洋大西洋水流问题">太平洋大西洋水流问题</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/pacific-atlantic-water-flow/description/">https://leetcode.cn/problems/pacific-atlantic-water-flow/description/</a></p>
<p>有一个 <code>m × n</code> 的矩形岛屿，与 <strong>太平洋</strong> 和
<strong>大西洋</strong> 相邻。 <strong>“太平洋”</strong>
处于大陆的左边界和上边界，而 <strong>“大西洋”</strong>
处于大陆的右边界和下边界。</p>
<p>这个岛被分割成一个由若干方形单元格组成的网格。给定一个
<code>m x n</code> 的整数矩阵 <code>heights</code> ，
<code>heights[r][c]</code> 表示坐标 <code>(r, c)</code> 上单元格
<strong>高于海平面的高度</strong> 。</p>
<p>岛上雨水较多，如果相邻单元格的高度 <strong>小于或等于</strong>
当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。</p>
<p>返回网格坐标 <code>result</code> 的 <strong>2D 列表</strong> ，其中
<code>result[i] = [ri, ci]</code> 表示雨水从单元格 <code>(ri, ci)</code>
流动 <strong>既可流向太平洋也可流向大西洋</strong> 。</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240224230907817.png" srcset="/img/loading.gif" lazyload alt="太平洋大西洋水流问题" style="zoom:50%;" /></p>
<p>思路：</p>
<p>这道题本质上是在考虑连通图能不能到太平洋和大西洋，给出两个函数，dfs是对每一个点能够到的位置进行标记，isResult是遍历每一个节点是不是能够通过联通到达太平洋和大西洋</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; heights, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (visited[x][y]) <span class="hljs-keyword">return</span>;<br>        visited[x][y] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>            <span class="hljs-type">int</span> nextx = x+dir[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> nexty = y+dir[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(nextx&lt;<span class="hljs-number">0</span>||nextx&gt;=heights.<span class="hljs-built_in">size</span>()||nexty&lt;<span class="hljs-number">0</span>||nexty&gt;=heights[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (heights[x][y] &lt; heights[nextx][nexty]) <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-built_in">dfs</span>(heights, visited, nextx, nexty);<br><br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isResult</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; heights, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; visited =vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;(heights.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(heights[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>));<br>        <span class="hljs-comment">// dfs选择当前这个点能到达的全部点</span><br>        <span class="hljs-built_in">dfs</span>(heights, visited, x, y);<br>        <span class="hljs-type">bool</span> isPacific = <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">bool</span> isAtlantic = <span class="hljs-literal">false</span>; <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;heights[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();j++)&#123;<br>            <span class="hljs-keyword">if</span>(visited[<span class="hljs-number">0</span>][j])&#123;<br>                isPacific = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;heights.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(visited[i][<span class="hljs-number">0</span>])&#123;<br>                isPacific = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;heights[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();j++)&#123;<br>            <span class="hljs-keyword">if</span>(visited[heights.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>][j])&#123;<br>                isAtlantic = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;heights.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(visited[i][heights[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>])&#123;<br>                isAtlantic = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (isAtlantic &amp;&amp; isPacific) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pacificAtlantic</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; heights) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-comment">// 遍历每一个点，看是否能同时到达太平洋和大西洋 </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; heights.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; heights[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isResult</span>(heights, i, j)) result.<span class="hljs-built_in">push_back</span>(&#123;i, j&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="最大人工岛">最大人工岛</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/making-a-large-island/description/">https://leetcode.cn/problems/making-a-large-island/description/</a></p>
<p>给你一个大小为 <code>n x n</code> 二进制矩阵 <code>grid</code>
。<strong>最多</strong> 只能将一格 <code>0</code> 变成 <code>1</code>
。</p>
<p>返回执行此操作后，<code>grid</code> 中最大的岛屿面积是多少？</p>
<p><strong>岛屿</strong> 由一组上、下、左、右四个方向相连的
<code>1</code> 形成。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: grid = <span class="hljs-string">[[1, 0], [0, 1]]</span><br>输出: <span class="hljs-number">3</span><br>解释: 将一格<span class="hljs-number">0</span>变成<span class="hljs-number">1</span>，最终连通两个小岛得到面积为 <span class="hljs-number">3</span> 的岛屿。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: grid = <span class="hljs-string">[[1, 1], [1, 0]]</span><br>输出: <span class="hljs-number">4</span><br>解释: 将一格<span class="hljs-number">0</span>变成<span class="hljs-number">1</span>，岛屿的面积扩大为 <span class="hljs-number">4</span>。<br></code></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: grid = <span class="hljs-string">[[1, 1], [1, 1]]</span><br>输出: <span class="hljs-number">4</span><br>解释: 没有<span class="hljs-number">0</span>可以让我们变成<span class="hljs-number">1</span>，面积依然为 <span class="hljs-number">4</span>。<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240225105223461.png" srcset="/img/loading.gif" lazyload
alt="最大人工岛编号" />
<figcaption aria-hidden="true">最大人工岛编号</figcaption>
</figure>
<p>当完成编号之后，第二步骤就是对每个没有编号的节点进行相邻岛屿的面积遍历增加</p>
<p>注意这一步完成之后要对每个不同岛屿的面积数量进行记录，这个地方<strong>可以用map来进行记录</strong></p>
<figure>
<img
src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240225105326511.png" srcset="/img/loading.gif" lazyload
alt="最大人工岛第二步遍历节点" />
<figcaption aria-hidden="true">最大人工岛第二步遍历节点</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> count;<br>    <span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-comment">//第一步dfs对地图已经有的岛屿数量进行标记</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp;grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> mark)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(visited[x][y]||grid[x][y]==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        visited[x][y]=<span class="hljs-literal">true</span>;<br>        grid[x][y] = mark;<br>        count++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>            <span class="hljs-type">int</span> nextx = x+dir[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> nexty = y + dir[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(nextx&lt;<span class="hljs-number">0</span>||nextx&gt;=grid.<span class="hljs-built_in">size</span>()||nexty&lt;<span class="hljs-number">0</span>||nexty&gt;=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">dfs</span>(grid, visited, nextx, nexty, mark);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n =grid.<span class="hljs-built_in">size</span>(), m=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; visited = vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;gridNum;<br>        <span class="hljs-type">int</span> mark = <span class="hljs-number">2</span>; <span class="hljs-comment">//对每个岛屿进行编号</span><br>        <span class="hljs-type">bool</span> isALLgrid = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">0</span>) isALLgrid = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">if</span>(!visited[i][j]&amp;&amp;grid[i][j]==<span class="hljs-number">1</span>)&#123;<br>                    count = <span class="hljs-number">0</span>;<br>                    <span class="hljs-built_in">dfs</span>(grid, visited, i, j, mark);<br>                    gridNum[mark] = count; <span class="hljs-comment">//利用map来对所有岛屿的信息进行编号并记录</span><br>                    mark++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (isALLgrid) <span class="hljs-keyword">return</span> n*m; <span class="hljs-comment">// 如果全部是岛屿的情况，那么这个时候就不需要增加新的面积</span><br><br>        <span class="hljs-comment">//以下的逻辑是对需要增添岛屿的情况进行记录</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; visitedGrid; <span class="hljs-comment">//标记访问过的岛屿</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>                <span class="hljs-type">int</span> count =<span class="hljs-number">1</span>;<br>                visitedGrid.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">//每次都需要将这个已经访问过的岛屿进行清除</span><br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;k++)&#123;<br>                        <span class="hljs-type">int</span> neari = i+dir[k][<span class="hljs-number">0</span>];<br>                        <span class="hljs-type">int</span> nearj = j+dir[k][<span class="hljs-number">1</span>];<br>                        <span class="hljs-keyword">if</span>(neari&lt;<span class="hljs-number">0</span>||nearj&lt;<span class="hljs-number">0</span>||neari&gt;=grid.<span class="hljs-built_in">size</span>()||nearj&gt;=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;<br>                        <span class="hljs-keyword">if</span>(visitedGrid.<span class="hljs-built_in">count</span>(grid[neari][nearj])) <span class="hljs-keyword">continue</span>;<br>                        count+=gridNum[grid[neari][nearj]];<br>                        visitedGrid.<span class="hljs-built_in">insert</span>(grid[neari][nearj]);<br>                    &#125;<br>                &#125;<br>                res = <span class="hljs-built_in">max</span>(res, count);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="单词接龙">单词接龙</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-ladder/description/">https://leetcode.cn/problems/word-ladder/description/</a></p>
<p>字典 <code>wordList</code> 中从单词 <code>beginWord</code> 和
<code>endWord</code> 的 <strong>转换序列</strong>
是一个按下述规格形成的序列
<code>beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk</code>：</p>
<ul>
<li>每一对相邻的单词只差一个字母。</li>
<li>对于 <code>1 &lt;= i &lt;= k</code> 时，每个 <code>si</code> 都在
<code>wordList</code> 中。注意， <code>beginWord</code> 不需要在
<code>wordList</code> 中。</li>
<li><code>sk == endWord</code></li>
</ul>
<p>给你两个单词 <code>beginWord</code> 和 <code>endWord</code>
和一个字典 <code>wordList</code> ，返回 <em>从 <code>beginWord</code> 到
<code>endWord</code> 的 <strong>最短转换序列</strong> 中的
<strong>单词数目</strong></em> 。如果不存在这样的转换序列，返回
<code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：beginWord = <span class="hljs-string">&quot;hit&quot;</span>, endWord = <span class="hljs-string">&quot;cog&quot;</span>, wordList = [<span class="hljs-string">&quot;hot&quot;</span>,<span class="hljs-string">&quot;dot&quot;</span>,<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;lot&quot;</span>,<span class="hljs-string">&quot;log&quot;</span>,<span class="hljs-string">&quot;cog&quot;</span>]<br>输出：<span class="hljs-number">5</span><br>解释：一个最短转换序列是 <span class="hljs-string">&quot;hit&quot;</span> -&gt; <span class="hljs-string">&quot;hot&quot;</span> -&gt; <span class="hljs-string">&quot;dot&quot;</span> -&gt; <span class="hljs-string">&quot;dog&quot;</span> -&gt; <span class="hljs-string">&quot;cog&quot;</span>, 返回它的长度 <span class="hljs-number">5</span>。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang">输入：<span class="hljs-keyword">begin</span>Word = <span class="hljs-string">&quot;hit&quot;</span>, <span class="hljs-keyword">end</span>Word = <span class="hljs-string">&quot;cog&quot;</span>, wordList = [<span class="hljs-string">&quot;hot&quot;</span>,<span class="hljs-string">&quot;dot&quot;</span>,<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;lot&quot;</span>,<span class="hljs-string">&quot;log&quot;</span>]<br>输出：<span class="hljs-number">0</span><br>解释：<span class="hljs-keyword">end</span>Word <span class="hljs-string">&quot;cog&quot;</span> 不在字典中，所以无法进行转换。<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>这道题要解决两个问题：</p>
<ul>
<li>图中的线是如何连在一起的</li>
<li>起点和终点的最短路径长度</li>
</ul>
<p>首先题目中并没有给出点与点之间的连线，而是要我们自己去连，条件是字符只能差一个，所以判断点与点之间的关系，要自己判断是不是差一个字符，如果差一个字符，那就是有链接。</p>
<p>然后就是求起点和终点的最短路径长度，<strong>这里无向图求最短路，广搜最为合适，广搜只要搜到了终点，那么一定是最短的路径</strong>。因为广搜就是以起点中心向四周扩散的搜索。</p>
<p><strong>本题如果用深搜，会比较麻烦，要在到达终点的不同路径中选则一条最短路</strong>。
而广搜只要达到终点，一定是最短路。</p>
<p><strong>广度优先搜索一定是能找到最短路径</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ladderLength</span><span class="hljs-params">(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)</span> </span>&#123;<br>        <span class="hljs-comment">//将vector转化成unordered_set提高查询速度</span><br>        <span class="hljs-function">unordered_set&lt;string&gt; <span class="hljs-title">wordSet</span><span class="hljs-params">(wordList.begin(), wordList.end())</span></span>;<br>        <span class="hljs-comment">// 如果endWorld没有在worldSet里面出现，直接返回0</span><br>        <span class="hljs-keyword">if</span>(wordSet.<span class="hljs-built_in">find</span>(endWord)==wordSet.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        unordered_map&lt;string, <span class="hljs-type">int</span>&gt;visitMap;<br>        queue&lt;string&gt; que;<br>        que.<span class="hljs-built_in">push</span>(beginWord);<br>        visitMap.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;string, <span class="hljs-type">int</span>&gt;(beginWord, <span class="hljs-number">1</span>)); <span class="hljs-comment">//map是用于记录路径的长度</span><br><br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>            string word = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> path = visitMap[word]; <span class="hljs-comment">//这个word的路径长度</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;word.<span class="hljs-built_in">size</span>();i++)&#123;<br>                string newWord = word;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">26</span>;j++)&#123;<br>                    newWord[i]=j+<span class="hljs-string">&#x27;a&#x27;</span>;<br>                    <span class="hljs-keyword">if</span>(newWord ==endWord) <span class="hljs-keyword">return</span> path+<span class="hljs-number">1</span>;<br><br>                    <span class="hljs-keyword">if</span>(wordSet.<span class="hljs-built_in">find</span>(newWord)!=wordSet.<span class="hljs-built_in">end</span>()&amp;&amp; visitMap.<span class="hljs-built_in">find</span>(newWord)==visitMap.<span class="hljs-built_in">end</span>())&#123;<br>                        visitMap.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;string, <span class="hljs-type">int</span>&gt;(newWord, path+<span class="hljs-number">1</span>));<br>                        que.<span class="hljs-built_in">push</span>(newWord);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="钥匙和房间">钥匙和房间</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/keys-and-rooms/description/">https://leetcode.cn/problems/keys-and-rooms/description/</a></p>
<p>有 <code>n</code> 个房间，房间按从 <code>0</code> 到
<code>n - 1</code> 编号。最初，除 <code>0</code>
号房间外的其余所有房间都被锁住。你的目标是进入所有的房间。然而，你不能在没有获得钥匙的时候进入锁住的房间。</p>
<p>当你进入一个房间，你可能会在里面找到一套不同的钥匙，每把钥匙上都有对应的房间号，即表示钥匙可以打开的房间。你可以拿上所有钥匙去解锁其他房间。</p>
<p>给你一个数组 <code>rooms</code> 其中 <code>rooms[i]</code> 是你进入
<code>i</code> 号房间可以获得的钥匙集合。如果能进入
<strong>所有</strong> 房间返回 <code>true</code>，否则返回
<code>false</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：rooms = <span class="hljs-string">[[1],[2],[3],[]]</span><br>输出：<span class="hljs-literal">true</span><br>解释：<br>我们从 <span class="hljs-number">0</span> 号房间开始，拿到钥匙 <span class="hljs-number">1</span>。<br>之后我们去 <span class="hljs-number">1</span> 号房间，拿到钥匙 <span class="hljs-number">2</span>。<br>然后我们去 <span class="hljs-number">2</span> 号房间，拿到钥匙 <span class="hljs-number">3</span>。<br>最后我们去了 <span class="hljs-number">3</span> 号房间。<br>由于我们能够进入每个房间，我们返回 <span class="hljs-literal">true</span>。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：rooms = <span class="hljs-string">[[1,3],[3,0,1],[2],[0]]</span><br>输出：<span class="hljs-literal">false</span><br>解释：我们不能进入 <span class="hljs-number">2</span> 号房间。<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>这是在找一个有向图，如果出现有孤立的问题那么就不能开门进入，一定要全部连通，除此之外还需要注意的是这个是一个有向图的问题，还需要注意方向</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240225115054788.png" srcset="/img/loading.gif" lazyload alt="有向量但不连通" style="zoom:50%;" /></p>
<p>因此需要用DFS来求解</p>
<p>其实本质上就是在利用深度优先搜索来进行遍历查找，如果能找到的话那么就进行标记，最后再进行筛选</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; rooms, <span class="hljs-type">int</span> key, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(visited[key]) <span class="hljs-keyword">return</span>;<br>        visited[key] = <span class="hljs-literal">true</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; keys = rooms[key];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> key :keys)&#123;<br>            <span class="hljs-built_in">dfs</span>(rooms, key, visited);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canVisitAllRooms</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; rooms)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(rooms.size(),<span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">dfs</span>(rooms, <span class="hljs-number">0</span>, visited);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:visited)&#123;<br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="岛屿的周长">岛屿的周长</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/island-perimeter/description/">https://leetcode.cn/problems/island-perimeter/description/</a></p>
<p>给定一个 <code>row x col</code> 的二维网格地图 <code>grid</code>
，其中：<code>grid[i][j] = 1</code> 表示陆地，
<code>grid[i][j] = 0</code> 表示水域。网格中的格子
<strong>水平和垂直</strong>
方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p>
<p>岛屿中没有“湖”（“湖”
指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1
的正方形。网格为长方形，且宽度和高度均不超过 100
。计算这个岛屿的周长。</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240225120135322.png" srcset="/img/loading.gif" lazyload alt="岛屿的周长" style="zoom:50%;" /></p>
<p>思路：</p>
<p>遍历每一个空格，遇到岛屿，计算其上下左右的情况，遇到水域或者出界的情况，就可以计算边了。</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240225120230954.png" srcset="/img/loading.gif" lazyload alt="岛屿的周长题解法" style="zoom:50%;" /></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">islandPerimeter</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;grid.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;k++)&#123;<br>                        <span class="hljs-type">int</span> x= i+dir[k][<span class="hljs-number">0</span>];<br>                        <span class="hljs-type">int</span> y = j+dir[k][<span class="hljs-number">1</span>];<br>                        <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>||y&lt;<span class="hljs-number">0</span>||x&gt;=grid.<span class="hljs-built_in">size</span>()||y&gt;=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()||grid[x][y]==<span class="hljs-number">0</span>)&#123;<br>                            res++;<br>                        &#125; <br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="并查集理论基础">并查集理论基础</h3>
<p>并查集常用来解决连通性问题。当我们需要判断两个元素是否在同一个集合里的时候，我们就要想到用并查集，并查集主要有两个功能：</p>
<ul>
<li>将两个元素添加到一个集合中。</li>
<li>判断两个元素在不在同一个集合</li>
</ul>
<h4 id="基础理论知识">基础理论知识</h4>
<p><strong>将两条边加入并查集</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 将v，u 这条边加入并查集</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u); <span class="hljs-comment">// 寻找u的根</span><br>    v = <span class="hljs-built_in">find</span>(v); <span class="hljs-comment">// 寻找v的根</span><br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span><br>    father[v] = u;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>判断两个边是不是在同一个集合中寻根</strong></p>
<p>给出A元素，就可以通过 father[A] = B，father[B] = C，找到根为 C。</p>
<p>给出B元素，就可以通过 father[B] = C，找到根也为为 C，说明 A 和 B
是在同一个集合里。
大家会想第一段代码里find函数是如何实现的呢？其实就是通过数组下标找到数组元素，一层一层寻根过程，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 并查集里寻根的过程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == father[u]) <span class="hljs-keyword">return</span> u; <span class="hljs-comment">// 如果根就是自己，直接返回</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(father[u]); <span class="hljs-comment">// 如果根不是自己，就根据数组下标一层一层向下找</span><br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 并查集初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        father[i] = i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>最后我们如何判断两个元素是否在同一个集合里，如果通过 find函数 找到
两个元素属于同一个根的话，那么这两个元素就是同一个集合，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 判断 u 和 v是否找到同一个根</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">return</span> u == v;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>路径压缩就一行代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 并查集里寻根的过程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == father[u]) <span class="hljs-keyword">return</span> u;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> father[u] = <span class="hljs-built_in">find</span>(father[u]); <span class="hljs-comment">// 路径压缩</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>以上代码在C++中，可以用三元表达式来精简一下，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> u == father[u] ? u : father[u] = <span class="hljs-built_in">find</span>(father[u]);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>join 函数里的这段代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">u = <span class="hljs-built_in">find</span>(u); <span class="hljs-comment">// 寻找u的根</span><br>v = <span class="hljs-built_in">find</span>(v); <span class="hljs-comment">// 寻找v的根</span><br><span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span><br></code></pre></td></tr></table></figure>
<p>与 isSame 函数的实现是不是重复了？ 如果抽象一下呢，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 判断 u 和 v是否找到同一个根</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">return</span> u == v;<br>&#125;<br><br><span class="hljs-comment">// 将v-&gt;u 这条边加入并查集</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (isSame) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span><br>    father[v] = u;<br><br></code></pre></td></tr></table></figure>
<p>这样写可以吗？ 好像看出去没问题，而且代码更精简了。</p>
<p><strong>其实这么写是有问题的</strong>，在join函数中 我们需要寻找 u 和
v 的根，然后再进行连线在一起，而不是直接 用 u 和 v 连线在一起。</p>
<h4 id="整体代码模版"><strong>整体代码模版</strong></h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> n =<span class="hljs-number">1005</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt; father = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>);<br><span class="hljs-comment">// 并查集初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>		father[i]=i;	<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 并查集的寻根过程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>  <span class="hljs-keyword">return</span> u == father[u]? u:father[u]=<span class="hljs-built_in">find</span>(father[u]);<br>&#125;<br><br><span class="hljs-comment">// 判uv是不是同一个根</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span></span>&#123;<br>  u=<span class="hljs-built_in">find</span>(u);<br>  v=<span class="hljs-built_in">find</span>(v);<br>  <span class="hljs-keyword">return</span> u==v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span></span>&#123;<br>  u=<span class="hljs-built_in">find</span>(u);<br>  v=<span class="hljs-built_in">find</span>(v);<br>  <span class="hljs-comment">//如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span><br>  <span class="hljs-keyword">if</span>(u==v) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-comment">//否则就将其中一个当成另一个的父亲节点</span><br>  father[v]=u;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h3 id="寻找图中是否存在路径">寻找图中是否存在路径</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-if-path-exists-in-graph/description/">https://leetcode.cn/problems/find-if-path-exists-in-graph/description/</a></p>
<p>有一个具有 <code>n</code> 个顶点的 <strong>双向</strong>
图，其中每个顶点标记从 <code>0</code> 到 <code>n - 1</code>（包含
<code>0</code> 和 <code>n - 1</code>）。图中的边用一个二维整数数组
<code>edges</code> 表示，其中 <code>edges[i] = [ui, vi]</code> 表示顶点
<code>ui</code> 和顶点 <code>vi</code> 之间的双向边。 每个顶点对由
<strong>最多一条</strong> 边连接，并且没有顶点存在与自身相连的边。</p>
<p>请你确定是否存在从顶点 <code>source</code> 开始，到顶点
<code>destination</code> 结束的 <strong>有效路径</strong> 。给你数组
<code>edges</code> 和整数 <code>n</code>、<code>source</code> 和
<code>destination</code>，如果从 <code>source</code> 到
<code>destination</code> 存在 <strong>有效路径</strong> ，则返回
<code>true</code>，否则返回 <code>false</code> 。</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240225121723461.png" srcset="/img/loading.gif" lazyload alt="寻找有效路径" style="zoom:50%;" /></p>
<p>思路：</p>
<p>简单的并查集实践，一般这种只需要你返回<strong>是否能连通的就可以用并查集来求解</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> n=<span class="hljs-number">200005</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; father = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">//并查集初始化</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            father[i] = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//并查集里面的寻根过程</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(u==father[u]) <span class="hljs-keyword">return</span> u;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> father[u] = <span class="hljs-built_in">find</span>((father[u]));<br>    &#125;<br>    <span class="hljs-comment">//判断是不是在同一个根上</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span></span>&#123;<br>        u = <span class="hljs-built_in">find</span>(u);<br>        v = <span class="hljs-built_in">find</span>(v);<br>        <span class="hljs-keyword">return</span> u==v;<br>    &#125;<br>    <span class="hljs-comment">//将新的内容加入到并查集中</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>        u = <span class="hljs-built_in">find</span>(u); <span class="hljs-comment">// 寻找u的根</span><br>        v = <span class="hljs-built_in">find</span>(v); <span class="hljs-comment">// 寻找v的根</span><br>        <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span><br>        father[v] = u;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">validPath</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges, <span class="hljs-type">int</span> source, <span class="hljs-type">int</span> destination)</span> </span>&#123;<br>        <span class="hljs-built_in">init</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;edges.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-built_in">join</span>(edges[i][<span class="hljs-number">0</span>],edges[i][<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSame</span>(source, destination);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="冗余连接">冗余连接</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/redundant-connection/description/">https://leetcode.cn/problems/redundant-connection/description/</a></p>
<p>树可以看成是一个连通且 <strong>无环</strong> 的 <strong>无向</strong>
图。</p>
<p>给定往一棵 <code>n</code> 个节点 (节点值 <code>1～n</code>)
的树中添加一条边后的图。添加的边的两个顶点包含在 <code>1</code> 到
<code>n</code>
中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为
<code>n</code> 的二维数组 <code>edges</code>
，<code>edges[i] = [ai, bi]</code> 表示图中在 <code>ai</code> 和
<code>bi</code> 之间存在一条边。</p>
<p>请找出一条可以删去的边，删除后可使得剩余部分是一个有着 <code>n</code>
个节点的树。如果有多个答案，则返回数组 <code>edges</code>
中最后出现的那个。</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240225123025333.png" srcset="/img/loading.gif" lazyload alt="冗余连接图解" style="zoom:50%;" /></p>
<p>思路：</p>
<p>那么我们就可以从前向后遍历每一条边（因为优先让前面的边连上），边的两个节点如果不在同一个集合，就加入集合（即：同一个根节点）。</p>
<p>如果边的两个节点已经出现在同一个集合里，说明着边的两个节点已经连在一起了，再加入这条边一定就出现环了</p>
<p>已经判断 节点A 和 节点B 在在同一个集合（同一个根），如果将 节点A 和
节点B 连在一起就一定会出现环。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> n =<span class="hljs-number">1005</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; father = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            father[i]=i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(u==father[u]) <span class="hljs-keyword">return</span> u;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> father[u] = <span class="hljs-built_in">find</span>(father[u]);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span></span>&#123;<br>        u = <span class="hljs-built_in">find</span>(u);<br>        v = <span class="hljs-built_in">find</span>(v);<br>        <span class="hljs-keyword">return</span> u==v;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span></span>&#123;<br>        u = <span class="hljs-built_in">find</span>(u);<br>        v = <span class="hljs-built_in">find</span>(v);<br>        <span class="hljs-keyword">if</span>(u==v) <span class="hljs-keyword">return</span>;<br>        father[v]=u;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findRedundantConnection</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>        <span class="hljs-built_in">init</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;edges.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isSame</span>(edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">1</span>])) <span class="hljs-keyword">return</span> edges[i];<br>            <span class="hljs-keyword">else</span> (<span class="hljs-built_in">join</span>(edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">1</span>]));<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="冗余连接ii">冗余连接II</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/redundant-connection-ii/description/">https://leetcode.cn/problems/redundant-connection-ii/description/</a></p>
<p>在本问题中，有根树指满足以下条件的 <strong>有向</strong>
图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。</p>
<p>输入一个有向图，该图由一个有着 <code>n</code>
个节点（节点值不重复，从 <code>1</code> 到
<code>n</code>）的树及一条附加的有向边构成。附加的边包含在
<code>1</code> 到 <code>n</code>
中的两个不同顶点间，这条附加的边不属于树中已存在的边。</p>
<p>结果图是一个以边组成的二维数组 <code>edges</code> 。 每个元素是一对
<code>[ui, vi]</code>，用以表示 <strong>有向</strong> 图中连接顶点
<code>ui</code> 和顶点 <code>vi</code> 的边，其中 <code>ui</code> 是
<code>vi</code> 的一个父节点。</p>
<p>返回一条能删除的边，使得剩下的图是有 <code>n</code>
个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。</p>
<p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20240225123828659.png" srcset="/img/loading.gif" lazyload alt="冗余连接2的题目解释" style="zoom:50%;" /></p>
<p>思路：</p>
<p>题目中的表述中提到<strong>该图由一个有着N个节点 (节点值不重复1, 2,
..., N)
的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。这说明题目中的图原本是是一棵树，只不过在不增加节点的情况下多加了一条边！</strong></p>
<p>那么可能的情况有：</p>
<ul>
<li>图中的树存在入度为2的节点</li>
<li>图中存在一个环</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">1010</span>;<br>    <span class="hljs-type">int</span> father[N];<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            father[i]=i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(father[u]==u) <span class="hljs-keyword">return</span> u;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> father[u]=<span class="hljs-built_in">find</span>(father[u]);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span></span>&#123;<br>        u = <span class="hljs-built_in">find</span>(u);<br>        v = <span class="hljs-built_in">find</span>(v);<br>        <span class="hljs-keyword">if</span>(u==v) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">else</span> father[v] = u;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span></span>&#123;<br>        u=<span class="hljs-built_in">find</span>(u);<br>        v = <span class="hljs-built_in">find</span>(v);<br>        <span class="hljs-keyword">return</span> u==v;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getRemoveEdge</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span></span>&#123;<br>        <span class="hljs-built_in">init</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">same</span>(edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">1</span>]))&#123; <span class="hljs-comment">//这个表示有环的情况，需要进行删除</span><br>                <span class="hljs-keyword">return</span> edges[i];<br>            &#125;<br>            <span class="hljs-built_in">join</span>(edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>    <span class="hljs-comment">// 删掉一条边之后判断是不是树</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isTree</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges, <span class="hljs-type">int</span> deleteEdges)</span></span>&#123;<br>        <span class="hljs-built_in">init</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i==deleteEdges) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">same</span>(edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">1</span>])) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//出现环了因此不是树</span><br>            <span class="hljs-built_in">join</span>(edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findRedundantDirectedConnection</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>        <span class="hljs-type">int</span> inDegree[N]=&#123;<span class="hljs-number">0</span>&#125;;<br>        n = edges.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            inDegree[edges[i][<span class="hljs-number">1</span>]]++;<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; vec; <span class="hljs-comment">//记录入度为2的边</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(inDegree[edges[i][<span class="hljs-number">1</span>]]==<span class="hljs-number">2</span>)&#123;<br>                vec.<span class="hljs-built_in">push_back</span>(i);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//如果有入度为2的节点，那么就需要删除</span><br>        <span class="hljs-keyword">if</span>(vec.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isTree</span>(edges, vec[<span class="hljs-number">0</span>]))&#123;<br>                <span class="hljs-keyword">return</span> edges[vec[<span class="hljs-number">0</span>]];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> edges[vec[<span class="hljs-number">1</span>]];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getRemoveEdge</span>(edges);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="数学题">数学题</h1>
<h3 id="回文数">回文数</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-number/description/?envType=study-plan-v2&amp;envId=top-interview-150">https://leetcode.cn/problems/palindrome-number/description/?envType=study-plan-v2&amp;envId=top-interview-150</a></p>
<p>给你一个整数 <code>x</code> ，如果 <code>x</code>
是一个回文整数，返回 <code>true</code> ；否则，返回 <code>false</code>
回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，<code>121</code>
是回文，而 <code>123</code> 不是。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">输入：<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">121</span><br>输出：<span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm">输入：<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">-121</span><br>输出：<span class="hljs-keyword">false</span><br>解释：从左向右读<span class="hljs-punctuation">,</span> 为 <span class="hljs-number">-121</span> 。 从右向左读<span class="hljs-punctuation">,</span> 为 <span class="hljs-number">121</span>- 。因此它不是一个回文数。<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>转化成字符串，然后用双指针进行求解，关键是需要对负数以及个位数为0的数进行筛选去除</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>||(x!=<span class="hljs-number">0</span> &amp;&amp; x%<span class="hljs-number">10</span>==<span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        string str = <span class="hljs-built_in">to_string</span>(x);<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = str.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-keyword">if</span>(str[l]!=str[r])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            l++;<br>            r--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="加一">加一</h3>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/plus-one/description/?envType=study-plan-v2&amp;envId=top-interview-150">https://leetcode.cn/problems/plus-one/description/?envType=study-plan-v2&amp;envId=top-interview-150</a></p>
<p>给定一个由 <strong>整数</strong> 组成的 <strong>非空</strong>
数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位，
数组中每个元素只存储<strong>单个</strong>数字。你可以假设除了整数 0
之外，这个整数不会以零开头。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：digits = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[1,2,4]</span><br>解释：输入数组表示数字 123。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：digits = [<span class="hljs-number">4,3,2,1</span>]<br>输出：[<span class="hljs-number">4,3,2,2</span>]<br>解释：输入数组表示数字 <span class="hljs-number">4321</span>。<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>当我们对数组 digits 加一时，我们只需要关注 digits 的末尾出现了多少个
9 即可。我们可以考虑如下的三种情况：</p>
<p>如果 digits 的末尾没有 9，例如
[1,2,3]，那么我们直接将末尾的数加一，得到 [1,2,4] 并返回；</p>
<p>如果 digits 的末尾有若干个 9，例如
[1,2,3,9,9]，那么我们只需要找出从末尾开始的第一个不为 9 的元素，即
3，将该元素加一，得到 [1,2,4,9,9]。随后将末尾的 9 全部置零，得到
[1,2,4,0,0] 并返回。</p>
<p>如果 digits 的所有元素都是 9，例如 [9,9,9,9,9]，那么答案为
[1,0,0,0,0,0]。我们只需要构造一个长度比 digits 多 1
的新数组，将首元素置为 1，其余元素置为 0 即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">plusOne</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; digits)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=digits.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(digits[i]!=<span class="hljs-number">9</span>)&#123;<br>                digits[i]++;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i+<span class="hljs-number">1</span>;j&lt;digits.<span class="hljs-built_in">size</span>();j++)&#123;<br>                    digits[j]=<span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-keyword">return</span> digits;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 所有元素都为9</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(digits.size()+<span class="hljs-number">1</span>)</span></span>;<br>        ans[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/LeetCode%E7%AE%97%E6%B3%95/" class="category-chain-item">LeetCode算法</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%AE%97%E6%B3%95%E9%A2%98/" class="print-no-link">#算法题</a>
      
        <a href="/tags/leetcode/" class="print-no-link">#leetcode</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>【算法题】LeetCode算法汇总</div>
      <div>https://lihaibineric.github.io/2024/01/01/leetcode/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Haibin Li</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>January 1, 2024</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Updated on</div>
          <div>July 1, 2024</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/01/12/dl_gnn/" title="【深度学习】图神经网络">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">【深度学习】图神经网络</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/12/19/develop_goroutine/" title="【后端开发】Golang协程与Channel">
                        <span class="hidden-mobile">【后端开发】Golang协程与Channel</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
