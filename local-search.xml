<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【多智能体强化学习】基于自动分组的价值函数分解</title>
    <link href="/2023/11/22/MARL_%E8%87%AA%E5%8A%A8%E5%88%86%E7%BB%84/"/>
    <url>/2023/11/22/MARL_%E8%87%AA%E5%8A%A8%E5%88%86%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="automatic-grouping-for-marl">Automatic Grouping for MARL</h2><p>论文标题：</p><p><strong>《Vast: Value function factorization with variable agentsub-teams》</strong></p><p><strong>《Automatic Grouping for Efficient Cooperative Multi-AgentReinforcement Learning》</strong></p><p>论文代码：<ahref="https://github.com/zyfsjycc/GoMARL">https://github.com/zyfsjycc/GoMARL</a></p><h2 id="价值函数分解">价值函数分解</h2><p>价值函数的提出是为了缓解在传统的中心化训练和去中心化执行中的Critic网络出现的难以训练的问题，同时传统的合作型多智能体强化学习的方法难以解决信用分配的问题，即如何确定某个智能体<strong>对于全局任务而言的贡献程度</strong>。</p><h4 id="主体研究框架">主体研究框架：</h4><p><span class="math display">\[Q_{tot} (τ,a)≈Ψ([Q_i (τ_i,a_i)]_{i=1}^N)\]</span></p><p>目的就是学习到这样一个分解算子 <spanclass="math inline">\(Ψ\)</span>，能够将局部的价值函数 <spanclass="math inline">\(Q_i\)</span> 拟合成全局的价值函数 <spanclass="math inline">\(Q_{tot}\)</span>，而这样的拟合过程学习到的分解算子<spanclass="math inline">\(Ψ\)</span>应当满足以下的约束条件： <spanclass="math display">\[\underset{\boldsymbol{a}}{\arg \max } Q_{\text {tot}}(\boldsymbol{\tau}, \boldsymbol{a})=\left(\begin{array}{c}\operatorname{argmax}_{a_1} Q_1\left(\tau_1, a_1\right) \\\vdots \\\operatorname{argmax}_{a_N} Q_N\left(\tau_N, a_N\right)\end{array}\right)\]</span>这个公式的本质是希望分解之后的局部和全局的最优动作能够最优一致，才能保证这样的算子分解方法是有效果的。</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122215614627.png"alt="价值函数分解的基本思想" /><figcaption aria-hidden="true">价值函数分解的基本思想</figcaption></figure><h2 id="可变子团队的价值函数分解">可变子团队的价值函数分解</h2><h4 id="研究动机">研究动机：</h4><ol type="1"><li><strong>大部分</strong>价值函数方法对<strong>少量智能体</strong>的任务效果好</li><li><strong>VFF</strong>方法过于扁平，存在性能瓶颈，没有考虑群组之间的一个关系，比较朴素且直接</li><li>忽略智能体之间关系导致智能体训练信息不足</li></ol><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122202659835.png" alt="朴素的价值函数分解方法" style="zoom:60%;" /><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122202712624.png" alt="自动分组之后的价值函数分解方法" style="zoom:60%;" /></p><p>因此，为了能够缓解朴素的价值函数分解方法中的<strong>缺乏群组信息的缺陷</strong>，文中提出能够分组处理多智能体系统的工作VAST，能够动态处理群组划分的算子来给出基于分组的智能体价值函数方法。</p><h4 id="主要贡献">主要贡献：</h4><ol type="1"><li>基于 <span class="math inline">\(K ≤ N = |D|\)</span>的分解子团队值<spanclass="math inline">\(Q_{t,k}^G\)</span>，线性分解每个子团队成员$jG_{t,k}⊆D$ 局部值<span class="math inline">\(Q_j\)</span></li><li>提出了一种分解方式动态并随时间变化，同时保持VFF方法的去中心性执行的特点</li><li>提供了<strong>元梯度</strong>方法来优化子团队分组策略</li></ol><h4 id="实现方法">实现方法：</h4><h5 id="子团队分组策略">子团队分组策略：</h5><p>分组策略的本质是学习一个<strong>概率分布</strong><spanclass="math inline">\(\mathcal{X}(k∣i,τ_(t,i),s_t)\)</span>，概率分布的本质思想是能够通过每个智能体的状态以及历史数据信息给出智能体<span class="math inline">\(i\)</span> 所在的组别 <spanclass="math inline">\(k\)</span></p><h5 id="元梯度的更新方式">元梯度的更新方式：</h5><p><span class="math display">\[𝑔=𝐴 ̂(𝑘,𝑖,𝜏_{𝑡,𝑖},𝑠_𝑡 ) ∇_𝜃 log⁡𝒳_{MetaGrad}  (𝑘∣𝑖,𝜏_{𝑡,𝑖},𝑠_𝑡 )\]</span></p><ul><li>参考借鉴了强化学习的策略梯度更新的方式</li><li>在多智能体强化学习中利用<strong>强化学习</strong>的方法学习一个组别的分组器</li></ul><p><span class="math display">\[𝐴 ̂(𝑘,𝑖,𝜏_{𝑡,𝑖},𝑠_𝑡 )=𝑄 ̂(𝑘,𝑖,𝜏_{𝑡,𝑖},𝑠_𝑡 )−𝑉 ̂(𝑖,𝜏_{𝑡,𝑖},𝑠_𝑡 )\]</span></p><p><span class="math display">\[𝑉 ̂(𝑖,𝜏_{𝑡,𝑖},𝑠_𝑡 )=∑_(𝑎_{𝑡,𝑖}∈𝒜_𝑖) 𝜋_𝑖 (𝑎_{𝑡,𝑖}∣𝜏_{𝑡,𝑖} ) 𝑄_𝑖(𝜏_{𝑡,𝑖},𝑎_{𝑡,𝑖} )\]</span></p><ul><li>策略梯度更新的方式是基于优势函数的方法进行更新分组器</li></ul><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122220849824.png"alt="不同分类器的对比" /><figcaption aria-hidden="true">不同分类器的对比</figcaption></figure><p>这里还采用了不同的分组器方法加入实验的对比</p><h5 id="算法思路">算法思路</h5><ul><li><p>将D 分成<span class="math inline">\(K= ⌈ηN⌉≤ N =|D|\)</span>个子团队<span class="math inline">\(G_{t,k}\)</span>其中比例<span class="math inline">\(η ∈ [1⁄N,1]\)</span>，所有的团队集合 <spanclass="math inline">\(G_t=⟨G_{t,1},…,G_{t,K} ⟩\)</span>，</p></li><li><p>分组：<span class="math inline">\(G_{t,k}⊆D,G_{t,k}∩G_{t,k′}=∅;D=U_{k=1}^K  G_{t,k}\)</span></p></li><li><p>组内联合动作：<span class="math inline">\(a_{t,k}^G=a{t,j}_j∈G_{t,k}\)</span></p></li><li><p>选择<spanclass="math inline">\(Ψ_{VDN}\)</span>算子分解(满足IGM)：</p><p><span class="math display">\[Q_{t,k}^G (τ_{t,k}^G,a_{t,k}^G )=Ψ_{VDN} (⋅)=∑_{j∈G_{t,k}} Q_j(τ_{t,j},a_{t,j})\]</span></p></li><li><p>最终的全局联合价值函数近似：</p></li></ul><p><span class="math display">\[Q_{tot} (τ_t,a_t )=Ψ(Q_{t,1}^G (τ_{t,1}^G,a_{t,1}^G ),…,Q_{t,K}^G(τ_{t,K}^G,a_{t,K}^G ))\]</span><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122221728761.png" alt="可变子团队的伪代码" style="zoom:67%;" /></p><h5 id="igm条件保持">IGM条件保持</h5><p>如果以群组为单位的价值函数分解的方式能够保证IGM条件： <spanclass="math display">\[argmax_(𝑎_{𝑡,𝑘}^𝐺∈𝒜)⁡〖𝑄_{tot}(𝜏_𝑡,𝑎_𝑡)〗=⟨argmax_(⟨𝐚_{𝐭,𝐤}^𝐆 ⟩_(𝐺_{𝑡,𝑘}∈𝒢_𝑡 ))⁡𝑄_{𝑡,𝑘}^𝐺 (𝜏_{𝑡,𝑘}^𝐺,𝑎_{𝑡,𝑘}^𝐺)⟩_(𝐺_{𝑡,𝑘}∈𝒢_𝑡)\]</span> 希望能够满足对于局部智能体到全局价值函数的IGM条件的保持 <spanclass="math display">\[argmax_(𝑎_𝑡∈𝒜)⁡𝑄_{tot}(𝜏_𝑡,𝑎_𝑡 )=⟨argmax_(𝑎_{𝑡,𝑖}∈𝒜_𝑖 )⁡𝑄_𝑖 (𝜏_{𝑡,𝑖},𝑎_{𝑡,𝑖})⟩_(𝑖∈𝒟)\]</span> 推导过程如下： <span class="math display">\[\begin{aligned}&amp; Q_{t, k}^G\left(\tau_{t, k}^G, a_{t, k}^G\right)=\sum_{j \in G_{t,k}} Q_j\left(\tau_{t, j}, a_{t, j}\right) ; \operatorname{argmax}_{a_t\in G_{t, k}} Q_{t, k}^G\left(\tau_{t, k}^G, a_{t,k}^G\right)=\left\langle\operatorname{argmax}_{a_{t, i} \in\mathcal{A}_i} Q_i\left(\tau_{t, i}, a_{t, i}\right)\right\rangle_{i \inG_{t, k}} \\&amp; a_t \stackrel{\Psi}{=}\left\langle a_{t, k}^G\right\rangle_{G_{t,k} \in \mathcal{G}_t} \stackrel{\Psi_{V DN}}{=}\left\langle\left\langle\bar{a}_{t, i}\right\rangle_{i \in G_{t,k}}\right\rangle_{G_{t, k} \in \mathcal{G}_t}\stackrel{\mathcal{D}=G_{t, 1} \cup \cdots \cup G_{t,K}}{=}\left\langle\bar{a}_{t, i}\right\rangle_{i \in \mathcal{D}}\end{aligned}\]</span></p><h2 id="自适应分组的marl">自适应分组的MARL</h2><h4 id="研究动机-1">研究动机</h4><ul><li>通过任务分配实现隐式分组的方法仅解决结构清晰的任务，并且需要领域知识或先验设置</li><li>VAST 研究子团队对价值分解的影响，但需要先验的组数，ROMA的学习依赖于智能体观察的动态角色</li></ul><h4 id="gomarl算法的优势">GoMARL算法的优势</h4><ul><li>算法不依赖先验领域知识</li><li>动态调整：在分组学习过程中根据智能体的表现<strong>逐步调整</strong>分组划分。利用<strong>群体信息</strong>来促进策略专业化和高效的团队合作</li></ul><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122222736852.png" alt="引入群组划分板块的分解方法" style="zoom:67%;" /></p><h4 id="个体与群组关系假设">个体与群组关系假设</h4><ul><li><strong>所有智能体集合：</strong><spanclass="math inline">\(A={a_1,…,a_n }\)</span></li><li><strong>分组集合</strong>: <span class="math inline">\(G={g_1,…,g_m}，1≤m≤n\)</span></li><li>每个<spanclass="math inline">\(g_i\)</span><strong>包含</strong><spanclass="math inline">\(n_j(1≤n_j≤n)\)</span><strong>个不同的智能体，有</strong><spanclass="math inline">\(g_i={a_(j_1 ),…,a_(j_(n_j ))}\)</span>，<strong>且有</strong><spanclass="math inline">\(g_j∩g_k=∅\)</span>，<strong>且有</strong><spanclass="math inline">\(⋃_jg_j =A，j,k∈{1,2,…,m}\)</span></li></ul><h4 id="自动分组实现方法">自动分组实现方法</h4><p>自动分组的基本逻辑是学习<spanclass="math inline">\(f_g:A↦G\)</span>，这样的算子的目标是能够学习到系数权重<span class="math display">\[Q_G^{tot} (s_t,u_t )=E_(s_{t+1:∞},u_{t+1:∞} ) [∑_(k=0)^∞ γ^kr_{t+k}∣s_t,u_t;G]\]</span> 让总体的联合动作价值函数的值最大，分组的价值函数为： <spanclass="math display">\[𝑄^{𝑔_𝑗}=𝑓(𝑄^{𝑗_1} (𝜏^{𝑗_1},𝑢^{𝑗_1}),⋯,𝑄^{𝑗_{𝑛_𝑗}} (𝜏^{𝑗_(𝑛_𝑗)},𝑢^{𝑗_{𝑛_𝑗}};𝑤_1^{𝑔_𝑗})\]</span> 学习到的贡献程度为：<spanclass="math inline">\(𝑤_1^{𝑔_𝑗}\)</span>，训练的目标函数为： <spanclass="math display">\[ℒ_𝑔 (𝜃_{w_1})=𝔼_((𝐳,𝐮,𝑟,𝐳′)∼ℬ∑_𝑖(∥𝑓_(w_1)^𝑖 (𝜏^𝑖 (𝑧^𝑖,𝑢^𝑖 );𝜃_(w_1)^𝑖)∥_{𝑙_1})\]</span>根据每次在分组中的贡献权重来依次调整智能体的分组，当贡献的权重过小的话，就认为智能体不属于分组中，进入下一轮的分组调整中。</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122223325635.png"alt="自动分组的逻辑图" /><figcaption aria-hidden="true">自动分组的逻辑图</figcaption></figure><h4 id="section"></h4><h4 id="agent-network的优化">Agent Network的优化</h4><ul><li><p>智能体内嵌信息网络获取的群组相关信息<spanclass="math inline">\(e_i\)</span></p></li><li><p><strong>Similarity-Diversityobjective</strong>：来自同一组的智能体的信息是相似的，来自不同群体的智能体信息之间保持多样性：<span class="math display">\[\begin{gathered}\mathcal{L}_{SD}\left(\theta_e\right)=\mathbb{E}_{\mathcal{B}}\left(\sum_{i \neq j}I(i, j) \cdot \operatorname{cosine}\left(f_e\left(h^i ; \theta_e\right),f_e\left(h^j ; \theta_e\right)\right)\right) \\\text { where } I(i, j)=\left\{\begin{array}{cc}-1, &amp; a^i, a^j \in g^k \\1, &amp; a^i \in g^k, a^j \in g^l, k \neq l\end{array}\right.\end{gathered}\]</span>很直观的理解，对于合作型的强化学习任务而言，我们希望能够在同一个任务域内强化策略的合作，而不同的任务域内的策略应当保持多样性，能够让多智能体系统探索更多的可能性，防止陷入局部最优的情况。</p></li><li><p><strong>Agent Network特点</strong>：</p><ul><li>多样化的策略，部分共享参数的策略去中心化</li><li>超网络<spanclass="math inline">\(f_d\)</span>将提取的智能体信息e集成到策略梯度中</li></ul></li><li><p>合理性表示： <span class="math display">\[𝜕𝑄^{𝑡𝑜𝑡}/(𝜕𝜃_ℎ )=(𝜕𝑄^{𝑡𝑜𝑡})/(𝜕𝑄^𝑎 )  (𝜕𝑄^𝑎)/(𝜕𝜃_ℎ )=(𝜕𝑄^{𝑡𝑜𝑡})/(𝜕𝑄^𝑎)  (𝜕𝑄^𝑎)/(𝜕𝑣_ℎ^𝑎 )  (𝜕𝑣_ℎ^𝑎)/(𝜕𝜃_ℎ )=𝑓_𝑑 (𝑒^𝑎 )⋅(𝜕𝑄^{𝑡𝑜𝑡})/(𝜕𝑄^𝑎)  (𝜕𝑣_ℎ^𝑎)/(𝜕𝜃_ℎ )\]</span></p></li></ul><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122225119182.png" alt="Agent Network优化方式" style="zoom:67%;" /></p><h4 id="整体的训练框架">整体的训练框架</h4><h6 id="双层混合网络">双层混合网络</h6><ul><li><p>群体状态下的群体行动价值信息，将全局的状态分解成局部的状态信息用于训练，这部分的局部状态信息是基于群组划分之后的状态信息</p></li><li><p><span class="math inline">\(s^{g_j}\)</span> 是分组后<spanclass="math inline">\(e_t^i (a_i∈g_j)\)</span>按组别融合，建立分组器映射</p><p><span class="math display">\[f_{w_2}(s^g )：s^g→w_2^g\]</span></p></li><li><p>集中到策略梯度中，内嵌群组状态信息潜在促进组内合作： <spanclass="math display">\[𝜕𝑄^{𝑡𝑜𝑡}/(𝜕𝜃_ℎ )=(𝜕𝑄^{𝑡𝑜𝑡})/(𝜕𝑄^𝑎 )  (𝜕𝑄^𝑎)/(𝜕𝜃_ℎ )=(𝜕𝑄^{𝑡𝑜𝑡})/(𝜕𝑄^𝑎)  (𝜕𝑄^𝑎)/(𝜕𝑣_ℎ^𝑎 )  (𝜕𝑣_ℎ^𝑎)/(𝜕𝜃_ℎ )=𝑓_𝑑 (𝑒^𝑎 )⋅(𝜕𝑄^{𝑡𝑜𝑡})/(𝜕𝑄^𝑎)  (𝜕𝑣_ℎ^𝑎)/(𝜕𝜃_ℎ )\]</span></p></li><li><p>按照全文的总共方法的总述可以得到全局分解目标： <spanclass="math display">\[ℒ(𝜃)=ℒ_𝑇𝐷 (𝜃)+𝜆_𝑔 ℒ_𝑔 (𝜃_(w_1 ) )+𝜆_𝑆𝐷 ℒ_𝑆𝐷 (𝜃_𝑒 )\]</span></p></li></ul><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122225354328.png"alt="总体训练框架" /><figcaption aria-hidden="true">总体训练框架</figcaption></figure><h4 id="实验结果">实验结果</h4><p>在星际争霸的环境中的训练结果</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122225759954.png"alt="SMAC训练结果" /><figcaption aria-hidden="true">SMAC训练结果</figcaption></figure><p>消融实验</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122225941711.png"alt="消融实验对比" /><figcaption aria-hidden="true">消融实验对比</figcaption></figure><p>谷歌足球的训练结果</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231122225826734.png"alt="GRF的训练结果与可视化" /><figcaption aria-hidden="true">GRF的训练结果与可视化</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>强化学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>深度学习</tag>
      
      <tag>强化学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【基础工具】Git命令集</title>
    <link href="/2023/10/23/git/"/>
    <url>/2023/10/23/git/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>Git是一个版本控制系统，是任何软件开发项目中的主要内容。通常有两个主要用途：代码备份和代码版本控制。使用Git可以逐步处理代码，在需要回滚到备份副本的过程中保存每一步的进度。</p><h2 id="git的安装与配置">Git的安装与配置</h2><h2 id="git的基本控制">Git的基本控制</h2><h3 id="初始化git仓库">初始化Git仓库</h3><p>当完成上述的配置之后，就能开始初始化Git仓库，进入需要创建<strong>工作区</strong>的文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> workspace<br>git init<br></code></pre></td></tr></table></figure><p>创建一个名为 .git的新子目录（该目录为隐藏的），其中包含所有必需的存储库文件（Git存储库框架）；注意区分<strong>工作区</strong>和<strong>暂存区</strong>，在没有add之前我们都是在<strong>工作区</strong></p><p>【Vscode】考虑Git graph插件来可视化git分支目录的全貌</p><h3 id="添加文件和备注">添加文件和备注</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add . <br>git add &lt;file&gt;<br></code></pre></td></tr></table></figure><p>执行上述命令之后将会将当前的file或者是工作区中的所有文件都上传到暂存区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m<span class="hljs-string">&quot;【test】XXX更改信息提示&quot;</span><br><span class="hljs-comment">#如果多次提交想覆盖到同一个提交的备注上执行下面</span><br>git commit --amend<br></code></pre></td></tr></table></figure><p>上述的命令是将本次的提交添加描述，分布式协作的时候能看清</p><h3 id="状态与日志">状态与日志</h3><p>查看默认配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --list<br></code></pre></td></tr></table></figure><p>查看当前所在的分支位置信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git status<br></code></pre></td></tr></table></figure><p>查看当前分支下的更改日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><h3 id="推送与拉取">推送与拉取</h3><p>将本地暂存区中的更改内容推送到远端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push<br>git push -f <span class="hljs-comment">#强行推出</span><br></code></pre></td></tr></table></figure><p>将远端所在的分支内容拉到本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull<br></code></pre></td></tr></table></figure><p>更新所在分支的最新内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch --all <br></code></pre></td></tr></table></figure><h3 id="复制分支">复制分支</h3><p>获取git连接git@ XXX.git之后执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git@ XXX.git<br></code></pre></td></tr></table></figure><p>如果觉得git的内容太大，可以选择内部的分支进行下载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> -b feature/xxx git@ XXX.git<br></code></pre></td></tr></table></figure><p>feature/xxx为具体的分支内容</p><h3 id="分支操作">分支操作</h3><p>查看分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -a <span class="hljs-comment">#查看所有的分支</span><br>git branch -r <span class="hljs-comment">#查看远端的分支</span><br></code></pre></td></tr></table></figure><p>切换不同的分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout [branch] <span class="hljs-comment">#切换到分支</span><br></code></pre></td></tr></table></figure><p>创建新的分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch [branch] <span class="hljs-comment">#创建新的分支</span><br></code></pre></td></tr></table></figure><p>创建新的分支并切换到上面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b [branch] <span class="hljs-comment">#创建并切换新的分支</span><br></code></pre></td></tr></table></figure><h3 id="分支冲突">分支冲突</h3><p><strong>问题描述：</strong>如果当前修改的版本基于旧版，但是远端已经是新版origin/master，<strong>此时修改基于的内容和远端不同不能强行推</strong>。</p><p><strong>解决方法1：</strong>通过换基的方法解决，通过将当前的修改的旧版换到最新的基上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#先将文件提交到暂存区</span><br>git add . <span class="hljs-comment">#保存在暂存区</span><br>git commit -m <span class="hljs-string">&quot;XXX&quot;</span><br><span class="hljs-comment">#进行换基操作</span><br>git rebase -i origin/master<br><span class="hljs-comment">#再次提交</span><br>git add .<br><span class="hljs-comment">#继续换基</span><br>git rebase --<span class="hljs-built_in">continue</span><br><span class="hljs-comment">#换基成功后,只需要一次备注（覆盖）</span><br>git commit --amend<br><span class="hljs-comment">#最后退出</span><br>git push<br>git push -f <span class="hljs-comment">#或者强行推出</span><br></code></pre></td></tr></table></figure><p><strong>解决方法2：</strong> 暴力覆盖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch --all <span class="hljs-comment">#获取远端的全部内容</span><br>git reset --hard origin/master <span class="hljs-comment">#强行将远端的内容覆盖到本地的文件中</span><br>git commit --amend <br>git push -f <span class="hljs-comment">#强行推出</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基础工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【基础工具】Anaconda命令集</title>
    <link href="/2023/10/22/conda_list/"/>
    <url>/2023/10/22/conda_list/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="conda-常用命令">Conda 常用命令</h2><h3 id="查看conda版本">查看conda版本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">conda --version/ conda -V<br></code></pre></td></tr></table></figure><h3 id="查看已有环境">查看已有环境</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">conda info --envs<br>conda env <span class="hljs-built_in">list</span><br>conda info -e<br></code></pre></td></tr></table></figure><h3 id="进退环境">进退环境</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">conda activate  [name]<span class="hljs-comment"># 重新进入虚拟环境</span><br>conda deactivate  <span class="hljs-comment"># 退出虚拟环境</span><br></code></pre></td></tr></table></figure><h3 id="创建新的环境">创建新的环境</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">conda create -n *** python=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="删除环境">删除环境</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">conda remove -n old_name --<span class="hljs-built_in">all</span> <span class="hljs-comment"># 删除环境old_name</span><br></code></pre></td></tr></table></figure><h3 id="激活环境">激活环境</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">conda activate xxxx <span class="hljs-comment"># 激活xxxx环境</span><br></code></pre></td></tr></table></figure><h3 id="关闭环境">关闭环境</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">conda deactivate <span class="hljs-comment"># 关闭环境</span><br></code></pre></td></tr></table></figure><h3 id="克隆环境">克隆环境</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">conda create -n [new_name] --clone [old_name]<br></code></pre></td></tr></table></figure><h3 id="升级版本">升级版本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">conda update -n base conda <span class="hljs-comment">#update最新版本的conda；</span><br>conda update --<span class="hljs-built_in">all</span> <span class="hljs-comment">#更新所有包</span><br></code></pre></td></tr></table></figure><h3 id="pip管理的常用包">Pip管理的常用包</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">pip search package_name <br>pip show package_name <br>pip uninstall｜｜package_name<br>pip <span class="hljs-built_in">list</span><br></code></pre></td></tr></table></figure><h3 id="删除环境中的包">删除环境中的包</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">conda remove package <span class="hljs-comment">#删除当前环境中的包</span><br>conda remove -- name env_name package <span class="hljs-comment">#删除指定环境中的包</span><br></code></pre></td></tr></table></figure><h3 id="指定环境中安装包">指定环境中安装包</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">conda install --name env_name package_name <br></code></pre></td></tr></table></figure><h3 id="conda环境的python版本非指定">Conda环境的python版本非指定</h3><p>指定虚拟环境x的python版本是3.8，base环境是3.11；condaactivate激活x之后python版本仍为3.11。</p><p><strong>原因：</strong>在base环境中修改了.zshrc文件中的python只定路径，让每次虚拟环境中的python找到的python都只能按照指定的python路径进行寻找，从而导致conda环境中的python版本不能制定。</p><p><strong>修改方式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim .zshrc<br></code></pre></td></tr></table></figure><p>进入.zshrc环境中进行修改，如果发现一类诸如其他python版本指定的路径的话，需要进行删除，只需要保留最原始的关于anaconda的命令初始化，完成之后输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.zshrc<br></code></pre></td></tr></table></figure><p>解决问题</p><h3 id="镜像源安装">镜像源安装</h3><p><strong>下载使用清华源加上： -ihttps://pypi.tuna.tsinghua.edu.cn/simple</strong></p><blockquote><p><strong>清华：<code>https://pypi.tuna.tsinghua.edu.cn/simple/</code></strong></p><p><strong>阿里云：<code>http://mirrors.aliyun.com/pypi/simple/</code></strong></p><p><strong>中国科技大学：<code>https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/</code></strong></p><p><strong>豆瓣：<code>http://pypi.doubanio.com/simple/</code></strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>基础工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【基础工具】VScode远程和免密配置</title>
    <link href="/2023/10/22/vscode-remote/"/>
    <url>/2023/10/22/vscode-remote/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="vscode远程连接与免密配置">VSCode远程连接与免密配置</h2><h4 id="vscode远程连接">VSCode远程连接</h4><p>在vscode中安装remote-ssh的插件</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231125164427793.png" alt="添加插件示意图" style="zoom:67%;" /></p><p>加号的位置点击后在右侧框中输入远程服务器的ip地址与名称：==sshubuntu@3.14.15.926==</p><p>而后选择包含.ssh的文件夹位置，需要注意的是在==remote-ssh的配置文件中需要的文件夹位置==<strong>/users/user/.ssh/config</strong></p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231125164542420.png" alt="Remote插件配置设置" style="zoom:67%;" /></p><h4 id="远程连接免密配置">远程连接免密配置</h4><h6 id="电脑端"><strong>电脑端</strong></h6><ol type="1"><li><p>生成本地<strong>私钥id_rsa，公钥id_rsa.pub</strong>文件，输入以下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -b 4096 <br></code></pre></td></tr></table></figure><p>然后一路回车会在电脑用户目录下的.ssh生成上述的文件，并进入复制<strong>id_rsa.pub</strong>中的文件内容</p></li><li><p>如果已经存在，那么只需要进入上述的.ssh文件中复制即可</p></li></ol><h6 id="服务器端">服务器端</h6><ol type="1"><li><p>进入服务器端的用户名路径下的.ssh文件中，如果没有执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> .ssh<br></code></pre></td></tr></table></figure></li><li><p>在.ssh中新建<strong>authorized_keys文件</strong></p></li><li><p>将复制的<strong>id_rsa.pub</strong>中的文件内容黏贴到<strong>authorized_keys文件</strong>中即可完成</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>基础工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【深度学习】PyTorch使用手册</title>
    <link href="/2023/10/22/pytorch/"/>
    <url>/2023/10/22/pytorch/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>本文主要介绍pytorch中的基本使用，包括如何导入数据集，如何搭建并训练网络以及可视化的内容，基本涵盖了深度学习中经典算法的使用以及相关的例子</p><h2 id="basics">Basics</h2><h3 id="计算梯度例子">计算梯度例子</h3><p>引入基本需要用到的包，深度学习中torch处理大部分张量的运算，而torch.nn则是对torch的网络中的一些运算，这些都是必须用到的包。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch <br><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> torchvision.transforms <span class="hljs-keyword">as</span> transforms<br></code></pre></td></tr></table></figure><p>在深度学习中，一般使用张量进行运算，此时会涉及到计算张量的梯度等问题，我们这里给出一个例子来展示如何使用张量来进行梯度计算：</p><p>初始化定义张量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">x = torch.tensor(<span class="hljs-number">1.</span>, requires_grad=<span class="hljs-literal">True</span>)<br>w = torch.tensor(<span class="hljs-number">2.</span>, requires_grad=<span class="hljs-literal">True</span>)<br>b = torch.tensor(<span class="hljs-number">3.</span>, requires_grad=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>建立<strong>计算图 computational graph</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">y = w * x + b    <span class="hljs-comment"># y = 2 * x + 3</span><br></code></pre></td></tr></table></figure><p>计算梯度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">y.backward()<br><span class="hljs-built_in">print</span>(x.grad)    <span class="hljs-comment"># x.grad = 2 </span><br><span class="hljs-built_in">print</span>(w.grad)    <span class="hljs-comment"># w.grad = 1 </span><br><span class="hljs-built_in">print</span>(b.grad)    <span class="hljs-comment"># b.grad = 1 </span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【多智能体强化学习】Pymarl环境配置</title>
    <link href="/2023/10/22/pymarl%E7%8E%AF%E5%A2%83/"/>
    <url>/2023/10/22/pymarl%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>SMAC是基于暴雪星际争霸IIRTS游戏的协作多智能体强化学习领域的研究环境。SMAC利用星际争霸2机器学习API和DeepMind的PySC2为自主代理提供了一个方便的接口。</p><p>本文主要介绍在多智能体强化学习中的验证平台SAMC和Pymarl的配置和安装过程</p><p>环境地址：<ahref="https://github.com/oxwhirl/pymarl">https://github.com/oxwhirl/pymarl</a></p><p>依赖环境：<ahref="https://github.com/oxwhirl/smac">https://github.com/oxwhirl/smac</a></p><p>主要针对Ubuntu下的Pymarl环境的配置（MAC和Windows类似）</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231022145734342.png"alt="SMAC" /><figcaption aria-hidden="true">SMAC</figcaption></figure><h2 id="安装starcraftii">安装StarCraftII</h2><h3 id="windowsmac">Windows/Mac</h3><p>直接在官网下载安装最新版，需要加速器或者更换亚服：<ahref="https://sc2.blizzard.cn/landing">https://sc2.blizzard.cn/landing</a></p><p>安装地图：<ahref="https://link.zhihu.com/?target=https%3A//github.com/oxwhirl/smac/releases/download/v0.1-beta1/SMAC_Maps.zip">https://link.zhihu.com/?target=https%3A//github.com/oxwhirl/smac/releases/download/v0.1-beta1/SMAC_Maps.zip</a></p><p>将地图放在Maps文件夹下</p><h3 id="ubuntu">Ubuntu</h3><p>在Ubuntu系统中，安装需要版本的SCII即可<ahref="https://github.com/Blizzard/s2client-proto#downloads">https://github.com/Blizzard/s2client-proto#downloads</a></p><p>下载压缩包之后安装并解压放到用户名文件夹下：～/StarCraftII/</p><p>如果没有把SCII安装到用户名之下，这个地方的路径可以根据放置的位置来进行更改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim ~/.bashrc<br></code></pre></td></tr></table></figure><p>在最后一行增加环境变量，这里可以更改星际争霸的位置索引到任何想要放置的位置</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">SC2PATH</span>=~/StarCraftII/<br></code></pre></td></tr></table></figure><p>添加完之后更新环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure><p>添加SAMC的地图：Linux系统在下载SCII的时候就自带了地图</p><h2 id="安装smac">安装SMAC</h2><p>创建虚拟环境并安装pytorch</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">conda create -n pymarl python=<span class="hljs-number">3.8</span> -y<br>conda activate pymarl   <br><span class="hljs-comment"># CUDA 10.2 例子具体的的CUDA版本根据自己的服务器来定</span><br>conda install pytorch==<span class="hljs-number">1.10</span><span class="hljs-number">.0</span> torchvision==<span class="hljs-number">0.11</span><span class="hljs-number">.0</span> torchaudio==<span class="hljs-number">0.10</span><span class="hljs-number">.0</span> cudatoolkit=<span class="hljs-number">10.2</span> -c pytorch<br></code></pre></td></tr></table></figure><p>直接利用虚拟环境中的pip来安装</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install git+https://github.com/oxwhirl/smac.git<br></code></pre></td></tr></table></figure><p>或者可以利用git进行安装，先gitclone下载下来然后进入文件夹中进行安装</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">git clone https://github.com/oxwhirl/smac.git<br>pip install -e smac/<br></code></pre></td></tr></table></figure><p>如果pip install安装失败可以考虑升级pip：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install --upgrade pip<br></code></pre></td></tr></table></figure><p>如果安装的内容失败了可以手动安装，比如pymarl运行所依赖的包有以下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install sacred numpy scipy matplotlib seaborn pyyaml pygame pytest probscale imageio snakeviz tensorboard-logger<br><br></code></pre></td></tr></table></figure><p>或者根据<ahref="https://github.com/oxwhirl/pymarl/tree/master/docker">https://github.com/oxwhirl/pymarl/tree/master/docker</a>中的bash脚本中Dockerfile依赖内容进行安装</p><h2 id="pymarl与scii">Pymarl与SCII</h2><h3 id="采用上述安装步骤">采用上述安装步骤</h3><p>对于上述的操作完成操作之后，下载pymarl的环境包并进入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">git clone git@github.com:oxwhirl/pymarl.git<br>cd pymarl<br></code></pre></td></tr></table></figure><p>将上述安装的SCII文件夹复制到pymarl的src的3dparty之下</p><h3 id="如果利用docker安装">如果利用Docker安装</h3><p>或者根据pymarl中的内容对上述环境进行自动配置（需要Docker）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> docker<br>bash build.sh<br></code></pre></td></tr></table></figure><p>同时安装SCII和SMAC</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bash install_sc2.sh<br></code></pre></td></tr></table></figure><h2 id="测试环境">测试环境</h2><h3 id="测试地图信息">测试地图信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">python -m smac.<span class="hljs-built_in">bin</span>.map_list <br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231022153907123.png" alt="Maps show" style="zoom:67%;" /></p><h3 id="测试环境信息">测试环境信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">python -m smac.examples.random_agents<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231022153709693.png" alt="test agents" style="zoom: 50%;" /></p><h3 id="测试pymarl环境">测试Pymarl环境</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">python src/main.py --config=qmix --env-config=sc2 <span class="hljs-keyword">with</span> env_args.map_name=2s3z<br></code></pre></td></tr></table></figure><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231022153651418.png"alt="test pymarl" /><figcaption aria-hidden="true">test pymarl</figcaption></figure><h2 id="额外设置">额外设置</h2><p>在利用pymarl进行实验的过程中可能会出现</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20231022154059365.png"alt="some bug" /><figcaption aria-hidden="true">some bug</figcaption></figure><p>需要进行设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim torch/_tensor.py<br></code></pre></td></tr></table></figure><p>将757行的内容进行修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">-: self.numpy()<br>+: self.cpu().numpy()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>强化学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>深度学习</tag>
      
      <tag>强化学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【自动驾驶】RSS Model for Autonomous Driving</title>
    <link href="/2023/10/21/RSS-Model/"/>
    <url>/2023/10/21/RSS-Model/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="rss-model-for-autonomous-driving"><strong>RSS Model forAutonomous Driving</strong></h2><h4id="论文on-a-formal-model-of-safe-and-scalable-self-driving-cars">论文：《Ona Formal Model of Safe and Scalable Self-driving Cars》</h4><h4 id="contribution"><strong>Contribution：</strong></h4><ul><li>Safety (RSS model) Reasonable care, Responsibility, agile drivingpolicy</li><li>Semantic (Semantic language) :Defined Q function over the Semanticspace</li><li>PAC sensing model：Safety and Comfort of driving ；tied to the Qfunction;</li></ul><h4 id="safety-concept"><strong>1. Safety Concept</strong></h4><p>Functional versus nominal safety 功能安全与名义安全</p><p>Functional Safety，FuSa 是指电子电路中操作的完整性</p><p>名义安全是在假设HW和SW系统运行无差错(即在功能上是安全的)的情况下，AV是否正在做出安全的逻辑决策。</p><p>Sense，Plan，Act 感知 计划 行动</p><h4 id="现有的自动驾驶汽车的决策方案"><strong>2.现有的自动驾驶汽车的决策方案</strong></h4><ul><li>Miles driven ：基于统计的论点，同时需要较大的统计量数据</li><li>disengagements（脱离）：被定义为人类安全驾驶人因为做出不安全的决定而不得不干预AV的运行，从而导致事故的情况。</li><li>simulation：建立虚拟世界模拟器，模拟器和显示世界的差距，无法建模全部的策略</li><li>scenario based testing：枚举现实世界的驾驶场景，过度拟合和泛化的问题</li><li>proprietary approaches</li></ul><h4id="rssresponsibility-sensitive-safety-model-for-multi-agent-safety"><strong>3.RSS(Responsibility-Sensitive-Safety) Model for Multi-agentSafety</strong></h4><ul><li><p>目标：</p><ul><li>做不到绝对安全，需要有Reasonable的响应</li><li>遵循RSS能做到乌托邦Utopia</li><li>敏捷而非防御，不应当过于谨慎而影响其他驾驶</li><li>法律解释的意义</li></ul></li><li><p>形式化的规则：</p><ol type="1"><li>Do not hit someone from behind.</li><li>Do not cut-in recklessly.</li><li><strong>Right-of-way is given, not taken.</strong>道路通行权是给予的而不是占用的</li><li>Be careful of areas with limited visibility小心有限可视化的范围</li><li>If you can avoid an accident without causing another one, you mustdo it.</li></ol></li></ul><h5 id="single-land-road-单向道路的情况"><strong>3.1 Single Land Road单向道路的情况</strong></h5><ul><li><p>不考虑前车倒退的情况，后车撞上前车那么后车负责，后车有责任和前车保持距离</p></li><li><p><span class="math inline">\(c_r\)</span>表示前车，<spanclass="math inline">\(c_f\)</span>表示后车，<spanclass="math inline">\(\rho\)</span>表示的是前车的反应时间，<spanclass="math inline">\(a_{max,break}\)</span>表示的是前车的最大加速度，<spanclass="math inline">\(a_{max,accel}\)</span>表示的是最多的加速制动，<spanclass="math inline">\(a_{min,break}\)</span>表示的是后车的最小制动加速度来保证不会撞到前车</p></li><li><p><strong>同方向行驶</strong>的安全距离</p><p>给出最小的安全纵向距离： <span class="math display">\[d_{min}=max\{v_r\rho+1/2a_{max,accel}\rho^2+((v_r+\rhoa_{max,accel})^2)/2a_{min,break}-v_f^2/2a_{max,break},0\}\]</span></p></li><li><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915172320331.png"alt="Definition 1" /><figcaption aria-hidden="true">Definition 1</figcaption></figure></li><li><p><span class="math inline">\(t_b\)</span> dangerous time；<spanclass="math inline">\([t_b,t_b+\rho]\)</span> 表示一定的反应时间在这个范围之内在给定的加速度范围之内 执行proper response</p></li><li><p>Proper Response：表示我们允许执行的最大加速度的限制，并取最小值约束保证满足所有的约束</p></li><li><p>安全纵向距离和Proper Response取决于参数：<spanclass="math inline">\(\rho,a_{max,sccel},a_{min,brake},a_{max,brake}\)</span>参数保证了对智能体行为的假设，选择适当的参数</p></li><li><p>Utopia is possible如果所有智能体车辆都能够遵循合理的响应，那么能归纳证明可以规避事故的发生</p></li></ul><h5 id="a-lane-based-coordinate-system-基于车道的坐标系"><strong>3.2 ALane-Based Coordinate System 基于车道的坐标系</strong></h5><ul><li><p>车道中心是平面上一条平滑有向的曲线 <spanclass="math inline">\(r\)</span> ,其中所有部分可以表示为 <spanclass="math inline">\(r^{(1)},...,r^{(k)}\)</span>即可以是线性的，也可以是弧形的</p></li><li><p>构造 <span class="math inline">\(R-&gt;R^2\)</span>的变换为 <spanclass="math inline">\(\phi\)</span>就是横纵坐标，从而来保证在逻辑上的前后车辆的关系</p></li><li><p>具体的映射的方式可以表示为如下：</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915172406204.png"alt="道路映射的方式" /><figcaption aria-hidden="true">道路映射的方式</figcaption></figure></li><li><p>横纵速度/加速度的计算就可以通过这样的坐标系定义之下得到的一阶/二阶的导数计算得到</p></li></ul><h5id="longitudinal-safe-distance-and-proper-response-纵向约束"><strong>3.3Longitudinal Safe Distance and Proper Response 纵向约束</strong></h5><ul><li><p>给出安全距离的定义：</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915172437378.png"alt="Definition 2" /><figcaption aria-hidden="true">Definition 2</figcaption></figure><p>安全距离定义的想法是，如果两辆车都能对违反安全距离的行为做出“适当”反应，那么就不会发生碰撞。如果其中一个没有“正确”反应，那么它就应对事故负责。</p></li><li><p>那么我们需要知道危险发生的时间，定义这样一个时刻<strong>DangerousLongitudinal Situation and Danger Threshold</strong></p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915172501683-20231022115917321.png"alt="真正的危险时间" /><figcaption aria-hidden="true">真正的危险时间</figcaption></figure><p>给定一个纵向的危险发生的时间段</p></li><li><p><strong>longitudinal proper response 纵向的适当响应</strong></p><p>blame time责任时间表示的是这个时间能够将驾驶的责任从自动驾驶汽车转移到驾驶员身上，如果接管了那么后续的责任将由驾驶员负责，否则由汽车负责</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915172514045-20231022115917843.png"alt="Definition 4" /><figcaption aria-hidden="true">Definition 4</figcaption></figure><p>给出了对于纵向单向行驶而言的速度和加速的要求，需要在危险到来之前做出合理的响应</p></li></ul><h5id="lateral-safe-distance-and-proper-response-横向的约束"><strong>3.4Lateral Safe Distance and Proper Response 横向的约束</strong></h5><ul><li><p>稳健侧向速度 <spanclass="math inline">\(\mu\)</span>：汽车总是存在横向的一个微小摆动:<span class="math display">\[\mu-lateral-v=(l_{out}-l)/(t_{out}-t)\]</span></p></li><li><p>横向安全距离：</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915172633796.png"alt="Definition 6" /><figcaption aria-hidden="true">Definition 6</figcaption></figure><p>对于双方而言都有一个加速度，同时有一个最小的制动加速度</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915172648760.png"alt="Lemma 4" /><figcaption aria-hidden="true">Lemma 4</figcaption></figure></li><li><p>同样定义横向的危险时间和危险区间时间：</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173056976-20231022115918644.png"alt="Definition 7" /><figcaption aria-hidden="true">Definition 7</figcaption></figure></li><li><p><strong>Lateral Proper response 给出横向的适当反应</strong></p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173119252.png"alt="Definition 8" /><figcaption aria-hidden="true">Definition 8</figcaption></figure><p>首先如果在适当的响应时间范围之内，那么只需要限制两车的加速度在一定的范围之内</p><p>如果超出了适当响应时间，那么对于两车的加速度限制需要更改</p></li></ul><h5id="combining-longitudinal-and-lateral-proper-responses-横向和纵向相结合"><strong>3.5Combining Longitudinal and Lateral Proper Responses横向和纵向相结合</strong></h5><ul><li><p>对于横向和纵向结合的车道，定义危险时间和危险情况</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173150615.png"alt="Defintion 9" /><figcaption aria-hidden="true">Defintion 9</figcaption></figure></li><li><p>危险阈值时间定义为横向和纵向的危险阈值时间的最大值，同样定义了危险时间t</p></li><li><p><strong>Basic Proper response to dangerous situations对于危险情况的正确反应处理</strong></p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173218415.png"alt="Definition 10" /><figcaption aria-hidden="true">Definition 10</figcaption></figure><p>对于危险的阈值速度进行分析，如果分别为纵向的阈值速度和横向的阈值速度，那么分别根据前面所述的Definition4和Definition 8 进行速度的限制</p><p><img src="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173251798-20231022115919728.png" alt="横向纵向情况" style="zoom:50%;" /></p><p>上面的这张图可以说明问题，当横纵的任意一个方向到达危险的阈值情况，分别作出ProperResponse，那么就可以按照合理的方式来规避风险</p></li><li><p><strong>Lemma5 Utopia is possible</strong></p><p>Consider a multi-lane road where all lanes share the same geometry.Suppose that at all times, all cars on the road comply with the basicproper response as given in Definition 10. Then, there will be<strong>no collisions</strong></p><p>归纳证明说明如果在合适的范围之内作出合理的响应，那么能规避碰撞</p></li></ul><h5id="compensating-for-improper-behavior-of-others-他人的不正当行为"><strong>3.6Compensating for improper behavior of others他人的不正当行为</strong></h5><ul><li><p>如果对方没做出合理反应，那么自己应当作出合适反应避免发生事故，同时不引起下一个事故</p></li><li><p>Naive Prediction：根据速度和加速度线性外推</p></li><li><p>EvasiveManoeuvre：给出两个函数来尽量规避出现车祸，就是根据时间来给速度和加速度的变化规划</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173348421.png"alt="Definition 12" /><figcaption aria-hidden="true">Definition 12</figcaption></figure><p>相当于给出两个函数来知道汽车应当在某个时间范围内到达什么样的位置是安全的，那么要达到这样的位置汽车要采取什么样的速度和加速度来实现</p><p><strong>if you can avoid an accident without causing anotheraccident, you must do it</strong></p></li></ul><h5id="proper-response-with-extra-evasive-effort-制动规避的适当反应"><strong>ProperResponse with Extra Evasive Effort 制动规避的适当反应</strong></h5><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173422047-20231022115920481.png"alt="Definition 13" /><figcaption aria-hidden="true">Definition 13</figcaption></figure><h5id="multiple-geometry-and-right-of-way-rules处理几何图形区域的车辆优先权问题"><strong>3.7Multiple Geometry and Right-of-WayRules处理几何图形区域的车辆优先权问题</strong></h5><ul><li><p>如果有存在不同的几何形状的情形会导致响应的冲突</p></li><li><p>定义横向的安全距离对于<strong>不同的几何路径</strong>对于相同的几何路径仍然成立</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173615571.png"alt="Definition14" /><figcaption aria-hidden="true">Definition14</figcaption></figure><p>向位置范围为[x_i,min,x_i,max]，按照不同的加速度行驶，且不能超过指定的加速度制动那么，则c_1和c_2之间的横向安全距离需要满足：<strong>两车之间横向距离的最小值应大于Definition7中定义的横向安全距离</strong></p></li><li><p>那么如何作出适当的反应 Proper response，给出合适的速度约束</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173634068-20231022115921111.png"alt="横向的合适响应" /><figcaption aria-hidden="true">横向的合适响应</figcaption></figure><p>在反应时间之内可以按照加速度范围内进行移动，但是当超过反应时间之后就要对侧向的速度进行制动</p></li><li><p>定义不同几何路况的纵向的顺序</p><ul><li><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173650265-20231022115921291.png"alt="路况优先权问题" /><figcaption aria-hidden="true">路况优先权问题</figcaption></figure><p>如果在同一条路上那么直接有先后顺序</p><p>如果不在同一条路上，那么根据车辆距离两条道路的相交的位置来定</p><p>当存在纵向的安全距离才会用到这个定义，同时应当是明显的前后顺序</p></li></ul></li><li><p>纵向的安全距离（不同的几何路径）</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173703808-20231022115921710.png"alt="Definition 17" /><figcaption aria-hidden="true">Definition 17</figcaption></figure><ol type="1"><li>如果c_i没有路径的优先级，那么将在路口汇入的位置执行加速到减速的过程停在路口</li><li>如果c_1在c_2前面，c_1执行任意动作（最大刹车加速度的意思是保证这个动作的距离下限），c_2执行最大加速-最小减速过程。当两车速度都为0时，c_1仍然在c_2前面（即后车要刹得住，当前车停下时，纵向顺序关系依然能保持）</li><li>如果没有优先级和前后关系，则考虑两车到达路口的时间范围，如果两者时间范围相交，则有碰撞风险，都需要刹车，反之就正常走。</li></ol><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173722252.png"alt="示意图" /><figcaption aria-hidden="true">示意图</figcaption></figure></li><li><p>纵向的安全响应（Proper response）</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173840619.png"alt="Definition18" /><figcaption aria-hidden="true">Definition18</figcaption></figure><ol type="1"><li>longitudinal proper response取决于Danger ThresholdTime前的situation：</li><li>如果17.1满足，则优先车辆正常开，另外一个则需要在反应时间后刹车。</li><li>如果17.2满足，则前面车辆正常开，候车需要在反应时间后刹车。</li><li>如果17.3满足，两车都需要在横向和纵向上刹车（这里又提到了横向，是纵向已经不能完全规避碰撞风险，所以需要引入横向动作）。</li></ol></li><li><p>Traffic Lights</p><ol type="1"><li>不能简单通过红绿灯的情况来将责任分配给不同的车辆，对于例外的路口的车辆</li><li>绿灯的有优先权 但不是有优先权的就对于规则而言没有责任</li><li>The above discussion is a formalism of the common sense rule of<strong>right of way is given, not taken.</strong></li></ol></li></ul><h5 id="unstructured-road-非结构化的道路"><strong>3.8 Unstructured Road非结构化的道路</strong></h5><ol type="1"><li><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173851532-20231022115922491.png"alt="Definition 19" /><figcaption aria-hidden="true">Definition 19</figcaption></figure><p>轨迹这个表示了根据时间而改变的位置状态，ts的定义就表示车辆第一次完全停止的时间</p><p><strong>未来某部分时刻汽车的位置、某个时间车辆的角度</strong></p></li><li><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173902698-20231022115922745.png"alt="Definition20" /><figcaption aria-hidden="true">Definition20</figcaption></figure><p>当两车的轨迹不满足以下条件时，则称会发生碰撞：</p><p>（1）对于两车均停止之前的任意时刻，两车之间距离均大于epsilon。</p><p>（2）在某车停车之前，两车之前距离均大于epsilon，且此时第二辆车的速度矢量指向第一辆车。即当前车停车，后车依然往前车方向开，后车需要与前车保持距离。</p></li><li><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173913570.png"alt="Definition 21" /><figcaption aria-hidden="true">Definition 21</figcaption></figure><p>定义Constrains（C）下的轨迹T(C,c)，刹车/正常向前行驶的轨迹分别表示为T(Cb, c)和T(Cf,c).</p></li><li><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915173936523.png"alt="Definition 22" /><figcaption aria-hidden="true">Definition 22</figcaption></figure><ol type="1"><li>其中一辆车的刹车轨迹和另一辆车的前进轨迹不相交，那么安全（注意保持先后关系对两辆车都适用）</li><li>两辆车都刹车，轨迹没有相交</li></ol></li><li><p>如果不满足安全的要求，那么应当选择Proper Response：</p><ol type="1"><li>如果两辆车都停着，那么其中一辆车应当远离另一辆车选择用Definition20的方法远离</li><li>否则，如果根据safedistance(1)的定义是安全的，一辆车执行刹车，另一辆车在停下来之前就要按照Cf的轨迹正常开，都停下来之后就回到了（1）</li><li>同时选择刹车</li></ol></li></ol><h5 id="pedestrians-行人"><strong>3.9 Pedestrians 行人</strong></h5><ul><li><p>安全距离和合理反应；和汽车相比调整参数且增加非结构化的假设</p></li><li><p>在斑马线或者是人行道上规定行人的行为，行人的合理活动范围是一个以他为圆心的圆</p></li><li><p>遵循互不干扰否则有责任的准则，当汽车进入行人的可能出事的范围那么汽车有责，否则行人有责任</p></li></ul><h5 id="cautiousness-with-respect-to-occlusion-遮挡问题"><strong>3.10Cautiousness with respect to Occlusion 遮挡问题</strong></h5><ul><li><p>Exposure Time 曝光时间：第一次看到这个物体的时间</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915173954765-20231022115923512.png"alt="Definition23" /><figcaption aria-hidden="true">Definition23</figcaption></figure></li><li><p><strong>速度不合理导致的不合理情况</strong>：</p><p>相当于速度的范围不在给定的合理的区间。上述提到的参数和地图上的每个汽车的位置、优先级规则和其他的场景结构等条件相关联</p><ol type="1"><li><p>具有道路优先级的汽车的最大速度优先级较高</p></li><li><p>速度的阈值范围根据具体的道路结构</p></li></ol><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915174217869.png"alt="遮挡示意图" /><figcaption aria-hidden="true">遮挡示意图</figcaption></figure></li></ul><p>相当于对于遮挡问题需要对双方的车辆有速度限制才能保证危险的发生</p><h5 id="不当行为造成的不合理的情况"><strong>3.11不当行为造成的不合理的情况</strong></h5><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915174242726.png"alt="Definition 25" /><figcaption aria-hidden="true">Definition 25</figcaption></figure><p>对于出现遮挡的参与者都要保持合理的行为才能规避事故</p><p><strong>对于有遮挡的正确响应方法</strong>：规避不合理的情况，包括但不限于24-25的</p><h5 id="responsibility"><strong>3.12 Responsibility</strong></h5><ul><li>明确智能体责任</li><li>发生碰撞那么有可能是其中一个智能体没有遵守适当的响应约束，那么需要对事故负责</li></ul><h5 id="utopia">3.13 Utopia</h5><ul><li>Lemma 5证明如果所有汽车都遵循基本的响应规则，那么不会发生碰撞</li><li>Lemma6证明如果对于遮挡的问题都能做出合理的响应规则，那么就不会发生事故（反证法）</li></ul><h4 id="driving-policy-rl"><strong>4. Driving Policy（RL）</strong></h4><ul><li><p>驾驶策略的定义：驾驶策略是从感知状态到驾驶命令的映射</p></li><li><p>构建高效的驾驶策略，拓展到百万级别的策略</p></li><li><p>描述驾驶策略的语言：(利用强化学习的描述方法)</p><ol type="1"><li><p><span class="math inline">\(s_t\)</span>表示某一时刻的状态，<spanclass="math inline">\(\pi\)</span>表示的是策略函数，<spanclass="math inline">\(a_t\)</span>表示的是汽车能够选择的动作，根据策略函数来确定，得到一块序列<span class="math inline">\(&lt;s_t,a_t&gt;\)</span></p></li><li><p><span class="math inline">\(P_{\pi}\)</span>表示的是根据 <spanclass="math inline">\(\pi\)</span> 选择产生的后面不同序列<spanclass="math inline">\(&lt;s_t,a_t&gt;\)</span>的概率</p></li><li><p><span class="math inline">\(E_{s~P_\pi}[\rho(s)]\)</span>用于衡量当前策略的好坏程度，相当于对当下这个策略可能产生的不同奖励值选择期望，同时<spanclass="math inline">\(\rho(s)\)</span>表示的是当前状态下的奖励</p></li><li><p>在实际的实现过程中，<spanclass="math inline">\(a_t\)</span>表示的是本车与其他道路使用者的位置、速度和加速度等问题，<spanclass="math inline">\(s_{t+1}\)</span>表示的是下一时刻的状态，同时取决于当前时刻的动作以及其他智能体的行为，奖励函数<spanclass="math inline">\(\rho(s)\)</span>取决于当前环境中的其他智能体的相对位置速度等信息。</p></li><li><p>价值函数 <spanclass="math inline">\(Q\)</span>表示的是当前智能体执行某一个动作所能造成的长期回报,由此来选择最好的策略函数来保证<span class="math inline">\(\pi(s)=argmaxQ(s,a)\)</span></p></li><li><p><span class="math display">\[Q(s, a)=\max _{(a_t, \ldots, a_{t+T})} \sum_{\tau=t}^T \rho(s_\tau,a_\tau )  \quad  {  s.t. } \quad s_t=s, a_t=a, \forall \tau,s_{\tau+1}=f(s_\tau, a_\tau)\]</span></p><p>定义价值函数的计算方式，根据每个时刻汇总得到的奖励值进行求和得到的总的价值</p></li><li><p>参数 <span class="math inline">\(T\)</span>表示的是“规划时间范围” 控制计算时间和评估质量之间的自然权衡，如果 <spanclass="math inline">\(T\)</span>越大那么说明当前的动作评估效果越好</p></li></ol></li><li><p>计算价值函数挑战：</p><ol type="1"><li>如果将动作空间进行离散，那么需要较大的计算空间，依赖于巨大的计算能力</li><li>采用离线计算，离散化动作域和状态域，然后采用离线的计算方式评估每个<span class="math inline">\(（s,a）\)</span> 的价值</li><li>采用动态规划，计算每个 <spanclass="math inline">\(（s,a）\)</span>的价值函数值 <spanclass="math inline">\(Q（s,a）\)</span> 仍然面临计算空间较大的问题</li><li>利用有限类函数来近似价值函数，但是无法做出良好的近似，同时对于这样的神经网络比较难以学习</li><li>当更新时间较小存在一定的信噪比，导致学习速度及其缓慢，逼近类方法固有的问题</li><li>总结：<strong>资源计算量巨大的方法</strong>和<strong>粗糙近似逼近</strong>会带来不同程度的问题</li></ol></li><li><p><strong>Semantics</strong> to the rescue重新定义自动驾驶语义</p><ul><li><p>在语义动作空间上定义价值函数Q：语义空间较小无语大量计算资源，能够对价值函数Q进行准确的估计</p></li><li><p>语义动作空间：</p><ol type="1"><li><p>主要思想：纵向目标；横向目标；实现目标的积极性程度</p><p>横向：Lateral goals are desired positions in lane coordinate system(e.g., “my goal is to be in the center of lane number 2”).</p><p>纵向： Longitudinal goals are of three types. The first is relativeposition and speed w.r.t. other vehicles (e.g., “my goal is to be behindcar number 3, at its same speed, and at a distance of 2 seconds fromit”).</p><p>速度目标：speed target (e.g., “drive at the allowed speed for thisroad times 110%”).</p><p>速度限制：speed constraint at a certain position (e.g., whenapproaching a junction, “speed of 0 at the stop line”, or when passing asharp curve, “speed of at most 60kmh at a certain position on thecurve”).<strong>速度曲线</strong></p></li><li><p>确定横向目标和纵向目标之间的组合，利用运动学公式来实现目标</p></li><li><p>语义动作空间产生了所有可能的几何曲线的子集，除了特殊的情况</p></li></ol></li></ul></li><li><p><strong>Constructing an evaluation function for semanticactions</strong> 构建<strong>语义动作的评估</strong>函数</p><ul><li>定义语义动作 <spanclass="math inline">\(A^s\)</span>空间，通过当前的状态 <spanclass="math inline">\(s\)</span>,选择最好的动作 <spanclass="math inline">\(a^s\in A^s\)</span>, 根据一些列的几何轨迹 <spanclass="math inline">\((s_1,a_1),...,(s_T,a_T)\)</span>，同时认为新的下一时刻的状态有一个新的函数给出<span class="math inline">\(s_{t+1}=f(s_t,a_t)\)</span>同时继续根据奖励函数的值来评估执行的语义动作的好坏程度 <spanclass="math inline">\(\frac{1}{T}\sum_{t=1}^T\rho(s_t,a_t)\)</span></li><li>利用语义动作来评估能规避信噪比低等问题</li><li>利用机器学习来泛化，在不同类型的道路上进行训练，推广到不同的道路</li><li>语义动作空间：<strong>资源高效利用同时很准确地进行评估</strong></li></ul></li><li><p><strong>The dynamics of the other agents其他智能体的动态</strong></p><ul><li><span class="math inline">\(s_{t+1}=f(s_t,a_t)\)</span>这样的确定性函数与现实不符合，多个智能体之间会相互影响</li><li>通过高频次地重新应用决策，不断调整策略来适应新的环境</li></ul></li></ul><h4 id="sensing-传感"><strong>Sensing 传感</strong></h4><h5 id="传感研究的内容">传感研究的内容：</h5><p>静态对象：(a fence that occludes relevant part of a mergingroad).；</p><p>动态对象：车辆（边界框、速度、加速度）、行人（边界框、速度、加速度）、交通灯、动态道路分隔线（例如建筑区域的锥体）、临时交通标志和警察活动以及道路上的其他障碍物。</p><h5 id="sensing-system"><strong>Sensing system</strong></h5><ol type="1"><li>Let <span class="math inline">\(S\)</span> denote the domain ofsensing state and let X be the domain of raw sensor and mapping data. A传感系统表示的是一个函数 <span class="math inline">\(\hat{s}\)</span> :<span class="math inline">\(X → S.\)</span></li><li>什么时候传感器的值 <span class="math inline">\(\hat{s}\)</span>能够和状态 <span class="math inline">\(s\)</span>近似？<strong>通过近似之后对驾驶策略的总体表现：安全性和舒适性</strong></li><li>传感器系统可能会犯的<strong>错误类型</strong>：<ul><li>False negative: the sensing system misses an object误报：传感器错过了一个物体</li><li>False positive: the sensing system indicates a “ghost” object错误：传感器系统提示存在幽灵物体</li><li>Inaccurate measurements: the sensing system correctly detects anobject but incorrectly estimates its position or speed测量不准确：传感系统正确检测到物体但是错误估计位置和速度</li><li>Inaccurate semantic: the sensing system correctly detects an objectbut misinterpret its semantic meaning, for example, the color of atraffic light语义信息不准确：传感系统正确检测物体，但误解了语义信息，比如交通灯的颜色</li></ul></li></ol><h5 id="comfort"><strong>Comfort</strong></h5><ul><li>相当于利用传感器函数来近似估计 <spanclass="math inline">\(s\)</span> ,如果 <spanclass="math inline">\(\pi(\hat{s}(x))=\pi(s)\)</span> 也就是说<spanclass="math inline">\(\pi(\hat{s}(x))=argmaxQ(\hat{s}(x),a)\)</span>，那么就说明当前这个传感器是可以的，同时允许有一定的误差范围：<span class="math inline">\(Q(\hat{s}(x),a)\geQ(s,\pi(s))-\epsilon\)</span>，这个时候可以说是 <spanclass="math inline">\(\epsilon-\)</span>准确的，同时也允许传感器有小概率发生故障 <spanclass="math inline">\(\delta\)</span></li><li>For example, we can choose three thresholds, $$1 &lt; $<spanclass="math inline">\(2 &lt;\)</span>$3 to represent mild, medium, andgross mistakes，表示传感器的错误程度，轻中重</li></ul><h5 id="pac-sensing-system"><strong>PAC sensing system</strong></h5><ol type="1"><li><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915174341417.png"alt="Definition 28" /><figcaption aria-hidden="true">Definition 28</figcaption></figure><p><strong>Probably-Approximately-Correct (PAC)</strong>X表示的是原始的数据与映射的数据域，从期望的角度给出误差率的平均值：<span class="math display">\[\mathbb{P}_{(x, s) \sim D}\left[Q(s, \pi(\hat{s}(x))) \geq Q(s,\pi(s))-\epsilon_i\right] \geq 1-\delta_i\]</span></p></li><li><p>通过记录许多人类驾驶员的数据来构建此分布，而不是遵循自动驾驶车辆的特定策略（不切实际），由于任何合理策略对D的影响都很小，通过应用简单的数据增强技术，我们可以构建适当的分布，然后在传感系统的每次重大更新后执行离线验证。</p></li><li><p>重点关注经常发生的“测量不准确”类型的错误</p></li><li><p>let <span class="math inline">\(p(o)\)</span>，<spanclass="math inline">\(\hat{p}(o)\)</span> be the positions of o in thecoordinate system of the host vehicle according to <spanclass="math inline">\(s(x)\)</span>, <spanclass="math inline">\(\hat{s}(x)\)</span>respectively.分别表示某个对象的<strong>真实的位置信息</strong>和<strong>传感器的位置信息</strong>。</p><p>目标到主车辆的距离为：<span class="math inline">\(\|p\|\)</span>，加性误差：<spanclass="math inline">\(\|p(o)-\hat{p}(o)\|\)</span>，相对误差为 <spanclass="math inline">\(\frac{\|p(o)-\hat{p}(o)\|}{\|p(o)\|}\)</span></p></li><li><p>对于positions a set of objects <spanclass="math inline">\(O\)</span>表示的是一堆对象，要求 <spanclass="math inline">\(p(o)\)</span> 和 <spanclass="math inline">\(\hat{p}(o)\)</span>之间的相对误差小于一个精确度不妨计作$$ ,但是<span class="math inline">\(\epsilon-ego-accurate\)</span>的传感状态不能保证PAC传感系统能够满足每个合理的价值函数：当相对误差很小的时候，尽管认为合理了，但是对于实际的情况而言会出现不同的价值函数结果。选择制动or继续前进，<strong>横向不能用相对距离</strong></p></li><li><p>表明<span class="math inline">\(\epsilon-ego-accurate\)</span>并不能保证我们的传感系统是PAC。是否还有其他属性足以满足 PAC传感系统的要求</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915174411587-20231022115924657.png"alt="Definition 29" /><figcaption aria-hidden="true">Definition 29</figcaption></figure></li><li><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915174449633.png"alt="Definition 31" /><figcaption aria-hidden="true">Definition 31</figcaption></figure><p>给出价值函数合理的L-语义-<spanclass="math inline">\(Lipschitz\)</span>条件</p></li><li><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915174520766.png"alt="Lemma 7" /><figcaption aria-hidden="true">Lemma 7</figcaption></figure><p>判定为PAC传感系统的终极判定</p></li></ol><h5 id="safety"><strong>Safety</strong></h5><ul><li><p>目标是减少事故发生的概率，存在两类安全情况：</p><ol type="1"><li>传感系统认为危险情况是不危险的；</li><li>传感器系统认为不危险情况是危险的：当安全的时候突然出现紧急刹车会导致危险</li></ol></li><li><p>解决的是如何确保和验证safety-critic sensingmistake足够小，采用的方法是融合多个工程和技术都独立的子系统。多数子系统认为安全才算安全：</p></li><li><p><strong>单侧c-近似独立</strong>的多个子系统</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/pic/image-20230915174623604-20231022115925281.png"alt="Definition 32" /><figcaption aria-hidden="true">Definition 32</figcaption></figure></li><li><p>对于服从单侧-c近似独立的子系统，能够推出：</p><figure><imgsrc="https://gitee.com/lihaibineric/picgo/raw/master/img/image-20230915174653068.png"alt="Corollary 3" /><figcaption aria-hidden="true">Corollary 3</figcaption></figure><p>基于多子系统方案和Corollary 3，为了达到10^-9失效率，对sensing系统的验证不再需要10^9小时的数据，而是分别对每个子系统验证10^5小时就可以了</p></li><li><p>独立假设背后的合理性留给我们去推理。有些传感器对会产生完全不相关的误差；单侧-c近似独立是否成立</p></li><li><p>对于安全幽灵而言，当出现至少有两个传感器认为的情况是危险的，才能认为是危险的</p></li><li><p><strong>Building a scalable sensingsystem可扩展的传感器系统</strong></p><ol type="1"><li>Cameras</li><li>Road Experience Management (REM)，不使用点云，而是一种基于语义的方法approach，利用大量的车端detects semantically meaningful objects in thescene (lane marks, curbs, poles, traffic lights,etc.)，并可以对云端进行更新。以可扩展的方式非常频繁地更新地图。此外，自动驾驶车辆可以通过现有的通信平台（蜂窝网络）接收小型地图数据</li><li>A complementary radar and lidarsystem，能够产生极高的精度；直接测量速度和距离，这进一步提高了乘坐的舒适度</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>智能安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
